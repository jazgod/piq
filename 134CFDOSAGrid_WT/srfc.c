
/**
tasks
*
*==============================================================================

-- ROI
add regions to SLC
remove old rows so it does not grow forever
backup regions
break up runways into 2 based on direction


-- add compression -- show speed at 3 altitude
go to next 2 1000 foot higher points and get altitudes at those points
AAL220
3500  240
4500  280
5500  320

*/


#include < windows.h >
#include <process.h>
#include <fcntl.h>
#include "unzip.h"
#include "tailor.h"
#include "gd.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <time.h>
#include <sys/timeb.h>
#include <errno.h>	/*declares extern errno*/
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <varargs.h>
#include "vo.h"
#include "vo_extern.h"
#include "SSI.h"
#include "ExecUtil.h"
#include "vo_db.h"
#include "TexFont.h"
#include "shapefil.h"
#include "Tracks.h"
#include "nexrad.h"
#include "mgl.h"
#include "resource.h"
#include "srfc.h"
#include "SurfaceC.h"
#include "nr.h"
#include "nrutil.h"
#include "strptime.h"
#include "miniunz.h"
#include "rough.h"
#include "colorconvert.h"
#include "colordefs.h"
#include "servers.h"
#include "imu.h"
#include "pulseserver.h"
#include "clist.h"
#include "Curl.h"
#include "json.h"
#include "lookup3.h"
#include "tracking.h"
#include "vehicle.h"
#include "Gates.h"
#include "hash_map_fns.h"
#include "bitmapfont.h"
#include "ARTCC.h"
#include "Routes.h"
#include "regions.h"
#include "Wingdi.h"
#include "vfw.h"
#include "AVILib.h"
#include "glutil.h"
#include "AcTypes.h"
#include "shares.h"

#pragma message(" Adding library: vfw32.lib")
#pragma comment( lib, "vfw32.lib" )

char builddate[] = "161027";
char version[] = "2.7";
char* subversion = NULL;

//VO *HistoricalTracksVO[MAX_HISTORICAL_TRACKS];
//VO *HistoricalHdrsVO[MAX_HISTORICAL_TRACKS];
//int HistoricalCount = 0;


// put HistAlertsVo into id instance soon
VO *HistAlertsVO;  // keep record of all alerts so we do not duplicate alerts to alertsgrid

MGLGRID *AlertsGrid;  // only one per WT, not needed to be in Instance id
//MGLGRID *SaveGrid;
//MGLGRID *WarningGrid;
//MGLGRID *ConfirmGrid;
//MGLGRID *CriteriaConfirmGrid;

VO *HisVO;
VO *ColorASDEXAircraftVO;
VO *ColorMLATAircraftVO;
VO *ColorGateAircraftVO;
VO *ColorNoiseAircraftVO;
VO *ColorAircraftVO;

VO *BestVO; // stores selected HistoricalTrackVO
int BestVOCount; // index into HistoricalTracksVO

VO *HistROIVO;

VO *IATAAirportsVO;

#ifdef PERFORMANCE_TESTING
#define TIME_TRACE_DBG(msg)\
{\
	SYSTEMTIME t;\
	char s[LINEBUF_SIZE]={0};\
	GetSystemTime(&t);\
	sprintf_s(s, LINEBUF_SIZE, "%s (%d): (0x%X) TRACE-%s (%2d:%2d %2d.%4d)\n", __FILE__, __LINE__, GetCurrentThreadId(), msg, t.wHour, t.wMinute, t.wSecond, t.wMilliseconds);\
	OutputDebugString(s);\
}
#else
#define TIME_TRACE_DBG(msg) 
#endif

#define json_object_object_foreachC_next(obj,iter) \
	iter.entry = iter.entry->next; \
	iter.entry ? (iter.key = (char*)iter.entry->k, iter.val = (struct json_object*)iter.entry->v, iter.entry) : 0;


// Thread Handle Mangement Functions.
// Only use handles returned from _beginthreadex, 
// make sure to call _endthreadex at end of thread func
extern append_lg_buffers(char** dest, int* dest_size, char* src, int src_size);
extern void RegisterThreadHandle(struct InstanceData* id, uintptr_t hThread, const char* strFuncName);	// Saves handle to wait for termination during shutdown
extern void UnregisterThreadHandle(struct InstanceData* id, uintptr_t hThread);	// Removes handle to thread already terminated
extern int ProcessKeydown(struct InstanceData* id, WPARAM wParam, int keystate);
extern void append_rec_buffer(char** dest, int* dest_size, char* src, int src_size);
extern time_t CalcFileTime(struct InstanceData* id, char *url);
extern void __cdecl GetDLLVersion(DWORD* pdwMajor, DWORD* pdwMinor);
extern unsigned _stdcall RecordVideoThread(PVOID pvoid);                  // WT2.3
extern VO* LoadDBFFile(struct InstanceData* id, const char* file);

void DrawGLTextXY(struct InstanceData* id, double x, double y, char *mystr, GLfloat *color, GLuint fontbase, int bRotate);
void LoadAirportGroundAltitude(struct InstanceData* id);
char* FlightToJSON(struct InstanceData* id, AIR *air);
int FindFlightId( struct InstanceData* id, const char *flightnumtext );
void PrintTracks(struct InstanceData* id, AIR *air, int nFeedType);

//void *createairstruct(struct InstanceData* id);
//void *create_MLATaircraftcolors(struct InstanceData* id);
//void *create_Noiseaircraftcolors(struct InstanceData* id);
//void *create_Gateaircraftcolors(struct InstanceData* id);
//void *create_aircraftcolors(struct InstanceData* id);

#define WINX(x)(x)
#define WINY(y)(id->m_nHeight - (y))

wchar_t strCategory[3][30] = {
	L"Active Operational Areas",
	L"Landside/Roadways",
	L"Terminal/Concourses"
};

wchar_t strStatus[4][30] = {
	L"Closed",
	L"Open",
	L"Restricted",
	L"Other"
};


GLfloat ASDTrailColor[3];


// fill in adsb tags every 1 minutes from Passur Planned departures and eta queries
#define FILL_ADSB_TIME 60

// fill in asdex tags every 1 minutes from Passur Planned departures and eta queries
#define FILL_ASDEX_TIME 60

// fill in asd tags every 1 minutes from Passur Planned departures and eta queries
#define FILL_ASD_TIME 60

// fill in PASSUR tags every 1 minutes from Passur Planned departures and eta queries
#define FILL_PASSUR_TIME 60

// Y offset off the top of view port where flight plan info gets printed
// Note: Effects where compression data gets printed since that would be
//       below flight plan text if both on simultaneously.
#define FLIGHTPLAN_Y_OFFSET 19
#define FLIGHTPLAN_X_OFFSET	10

#define NPT 100
#define MA 6
#define SPREAD 0.001

struct timeb animate_start_time, animate_cur_time;

double pvalue[12] = { 5.0, 27.0, 24.0, 21.0, 18.0, 15.0, 12.0, 9.0, 3.0, 1.0, 5.0, 999.0 };

VO *HoldVO;
VO *HoldFixVO;

// MGLGRID *ROIGrid;  // grid for displaying ROI data
// MGLGRID *GridSettingsMenu;  // this is a grid to implement a menu selector for Filters, Sort or Column selector
//MGLGRID *DataAppGrid;   // top level grid for selecting all data grids
//MGLGRID *DataTypeMenuGrid;  // menu for user to select what type of data object he wants, i.e., FDO, ROI,, etc
//MGLGRID *Grid_Report;
//MGLGRID *Grid_List;
//MGLGRID *MainTabGrid;
//MGLGRID *SecondTabGrid;
//MGLGRID *DataAppCreater;
//MGLGRID *GridManager;
//MGLGRID *Gridnames;
//MGLGRID *BuildSummaryGrid;//mtm--For the build summary
// now in DataAppVO "gridptr" field, MGLGRID *FDOGrid;    // grid for Flight Data Object

AIRWAY* g_pAirways;		// Array of AIRWAY
int g_nAirwayCount;		// Count of Airways
int g_bAirwaysLoaded;	// Airway data loaded flag	

NAV* g_pNavs;			// Array for NAVAIDS	
int g_nNavCount;		// Count of NAVS	
int g_bNavLoaded;		// Nav data loaded flag	

STARSID* g_pStarSID;	// Array of StarSID
int g_nStarCount;		// Count of StarSIDs
int g_bStarsLoaded;		// StarSID data loaded flag	

typedef struct vlinks {
	struct vlinks *np;
	double x, y;
} VLL;


typedef struct multisearchstruct {
	char *colnames[6];
	char *searchstrs[6];
	int colcount;
} MSPARMS;


typedef struct blockstruct {
	struct InstanceData* id;
	char ArrDep[12];
	char starttimestr[32];
	char endtimestr[32];
	char flightid[9];
	char ReplayArpt[5];
} BLOCKPARMS;


int GScreenDebug = 0;



char ScreenComment[256];

int ResetGmap;
int xboxmin, xboxmax, yboxmin, yboxmax, xboxsize, yboxsize;
int pc_x_margin = 2;
int pc_y_margin = 2;
int xpiecesize;
int ypiecesize;
int showlatlongs = FALSE;
int measure_y1, measure_x2, measure_y2;

int animatedind = -1;

char FFFltRoute[512];  // flight path for FindFlight aircraft

int hideblue = 1;

// FOR PRINTING DEBUG INFORMATION ON SCREEN
char debugstr1[256];
char debugstr2[256];
char debugstr3[256];
char debugstr4[256];

// use testflt string to put in desired flight to debug
char testflt[10];


polylist *ConstructionPolyList;
GLuint Constructionlist;

#define FILL_ALL 0
#define LAKES_ONLY 1
#define TRAIL_LABEL_WORLD_SIZE 10.0

time_t LastKnownTime;
int RunwaysLoaded;
char *SplashText;
extern char *GSortBy;

int UserIsAvitat;
int UserIsAirCell;
int UserIsAmstat;
int FAABallSize = 12;

char pulse_db_arpt[ORIG_DES_SIZE];  /* pulse db prefix, for etas, i.e. sanb, jfkb, tpa, tpab... */
// char passur_arpt[ORIG_DES_SIZE];  /* used for passur directory for Am data */

char ReplayArpt[5] = { 0 };
char SystemArpt[5] = { 0 };

int gmove = 0;  //count move number

#define OVERLAY_MARGIN 4

GLubyte *Gmapimage;
#define GMAP_TEXTURE_PIXELS 2048

// VO *FilterVO;
// VO *AvailableVO;


int pcount;

int drag_pindex = -1;



/* ******************* local defs for this module  *******************************/

GLubyte *mapimages[4];

poly *editpoly; // polygon that user is creating via mouse clicks
GLuint editlist; // opengl list to draw tesselated polygons, clear out if new poly vertexes added

#define CUSTOM_MAP_IMAGE_SIZE 1024

#define UNITS_SIZE 7

char *GFAAXmlStr;

#define NUM_TEX_MAPS 256

GLuint maptexture[NUM_TEX_MAPS];   /* Storage For Textures */
double lat1[NUM_TEX_MAPS];   /* coordinates for each map texture */
double lat2[NUM_TEX_MAPS];
double lng1[NUM_TEX_MAPS];
double lng2[NUM_TEX_MAPS];
#define N_MAP_LAYERS 5
int num_tex_maps[N_MAP_LAYERS];


// GLubyte mapimage[MAP_IMAGE_SIZE][MAP_IMAGE_SIZE][4];

GLuint smallmaptexture[NUM_SMALL_MAPS];   /* Storage For Textures */
// GLubyte smallmapimage[SMALL_MAP_IMAGE_SIZE][SMALL_MAP_IMAGE_SIZE][4];

int ProcessingBlocks;
int ProcessLoadFlag;

#ifndef MIN
#define MIN(x,y)      ( (x) < (y) ? (x) : (y) )
#endif
#ifndef MAX
#define MAX(x,y)      ( (x) > (y) ? (x) : (y) )
#endif


#define RADS(degs)  ( (degs) * M_PI / 180.0 )
#define DEGS(rads)  ( (rads) * 180.0 / M_PI )

#define GUI_IMAGE_SIZE 32
#define N_GUI_IMAGES 10
#define N_ICONS 24

#define GUI_BORDER_SIZE 24
#define GUI_STRAIGHT_SIZE 22
#define GUI_ICON_HEIGHT 32
#define GUI_TEX_OFFSET 32   // since icons are size 64 but visible area is generally in higher 32 pixels

#define GUI_ICON_IMAGE_SIZE 64
#define GUI_ICON_AVG_WIDTH 32  // default width, but icons widths vary
#define GUI_ICON_ITEM_SPACING 16  // spacing between icons

// margin is the white area below border icons
#define GUI_MARGIN_SIZE 2


#define HOLD_NO     0
#define HOLD_VELOCITY      1
#define HOLD_SEGMENT_WRAP  2
#define HOLD_IN_AREA       3





#define LOGO_ROWS 32
#define LOGO_COLS 181

int outlineSmooth = FALSE;



int tag_margin_size = 3;

typedef struct taglinklist {
	struct taglinklist *np;
	struct taglinklist *lastp;
	int x1, y1, x2, y2;
} taglist;

taglist *gtaglist;


GLuint quadlist; // for circular range rings

#define MAX_X_GRIDS 24
#define MAX_Y_GRIDS 24

char prevASDEXurl[256] = { 0 };
int GUseADSB = 0;

int GUIIconHeight = 0; // not used yet


// for debugging, turns off roigrid and calcregions
static int OpenglGrid = 0;  // this value can stay at zero, xgrid turned on using 'D' key
static int CalcRegionsFlag = 1;


VO *DelayArptsVO;
int ForceRefresh;
int NumGridWindows;

#define NUM_TRIANGLES 445253

typedef struct disktriangles {
	GLfloat vertex[3][2];
} DISKTRIANGLES;


DISKTRIANGLES *alltriangles;  // allocated dynamically

int alltrianglessize = 0, alltrianglescount = 0;

int UseCachedTriangles = TRUE;  // use triangles cached in RAM instead of disk access to triangles.dat, faster and 
// uses less disk reads, but takes up more RAM
int UseBinaryTree = TRUE;   // normal use = TRUE for hi-res maps. Set to FALSE to recreate grids and triangles
int UseTriangleList = FALSE;   // normal = FALSE, making lists of this many triangles is too slow on machines w/o graphics cards

GLubyte guiimage[N_GUI_IMAGES][32][32][4];
GLubyte logoimage[LOGO_ROWS][LOGO_COLS][4];
GLuint icontexture[N_ICONS];

static int ASDtrackcount;
#define ASD_NEXT_TRACK_OK 20
#define ASD_SAME_TRACK_OK 10

GLuint startMapList;  // map lines

int ShowHiResMap = TRUE;
typedef struct mapdatastruct{
	char shapeFilename[256];	// Unique name for each shape file data
	polylist *elemPolyList;		// Loaded Polygon list (may be NULL for Line-only shape files)
	GLuint elemListPolygon;		// Opengl call-list id for Polygons
	GLuint elemListLine;		// Opengl call-list id for Lines
	GLuint elemListPolygonClosed;	// Opengl call-list id for Polygons with Status Closed
	GLuint elemListLineClosed;		// Opengl call-list id for Lines with Status Closed
	HGLRC	   hRC;				// OpenGL Resource Context, for forced re-loading	
	VO* DBFVO;					// VO holding dbf shapefile data
	int    nStatus;				// Short-circuit status, 0 - Ok, 1 - Error
};

#define ASD_UPDATE_INTERVAL  20

time_t StartProgramTime;

typedef struct tagXYZ
{

	double X, Y, Z;
}
XYZ;

typedef struct curvestruct
{
	double ax, ay, vx0, vy0, vxf, vyf, rmserror;
} CURVE;

VO *AirlinesVO;

// starting refresh rate of retrieving passur flight numbers
#define PASSUR_OVERLAP_TIMEOUT_START 2000
// #define PASSUR_OVERLAP_TIMEOUT  20000
// 5aug2009  -- make faster since we get complaints if both ASD and passur show up
#define PASSUR_OVERLAP_TIMEOUT  0
#define PASSUR_OVERLAP_INCREMENT 2000


int MenuFilterCount;
int LayoutCount;
int SaveLocalData = FALSE;


#define LINEBUF_SIZE 1024


time_t delaystartsecs; // used for fast replay
FILE *trianglefile;

int missedASD;
int missedP;

int MaxTagHeight, MaxTagWidth;

GLfloat MapIntensity = 0.0; // inverse, with 1.0 being faded to white

typedef struct ServerData{
	struct InstanceData* id;
	char* pstrUrl;
	char* pstrPostFields;
};

int AddNoiseTrail(struct InstanceData* id, AIR *air, int AI, struct feedstruct *record, int max_tracks);
AIR* AirpFromGateFlights(struct InstanceData* id, const char* flightid);
void CacheLayouts(struct InstanceData* id, struct json_object* jobj);
int CalcSpeed(struct InstanceData* id, AIR **airp, int AI, int startindex );
void CalcTagWidth(int *maxwidth, char *linestr);
time_t CalcPlannedFileTime(struct InstanceData* id, char *url);
void ChangeAlertConfig(struct InstanceData* id, json_object* jObj);
json_object* CreateAlertsJSONObj(struct InstanceData* id);
int FillASDTags(struct InstanceData* id, AIR** airp);
int FillASDEXTags(struct InstanceData* id, AIR** airp);
int FillPASSURTags(struct InstanceData* id, AIR** airp);
void FillDestOrigFix(struct InstanceData* id, int i, AIR** airp);
AIR *GetAir(AIR **airp, int AI);
void GetDivertedDestination(struct InstanceData* id, char* flightid, char* dest);
char *GetLastErrorStr();
void GetPreferredFixes(struct InstanceData* id);
int HavePermission(struct InstanceData* id, const char* strPerm);
extern void LoadCurrentProjectStatus();
void ProcessJSONLayout(struct InstanceData* id, char* p);
void ProcessPermissions(struct InstanceData* id, struct json_object* jobj);
int ResetASDEXTracks(struct InstanceData* id);
int ResetGateTracks(struct InstanceData* id);
int ResetPASSURTracks(struct InstanceData* id);
int ResetASDTracks(struct InstanceData* id);
int ResetNoiseTracks(struct InstanceData* id);
int ResetTracks(struct InstanceData* id, int ClearASD);
int resizeWindow(struct InstanceData* id, int width, int height);
void SetFailedRequest(struct MemoryStruct* chunk);
void Submit2BackgroundServer(struct InstanceData* id, const char* cpstrUrl, const char* cpstrPostFields);
int DrawRoll(struct InstanceData* id, AIR **airp, int AI, int xoffset, int yoffset, int TagColorIndex, int bGreyed);
void DrawRollPanel(struct InstanceData* id, int xpixel, int ypixel, int width, int height, int TailPanel, int TagColorIndex);
double Updplottime(struct InstanceData* id);
float PolarToCompass(float polar);
void UpdateFDOGrid(struct InstanceData* id);
void UpdateSAGrid(struct InstanceData* id);
// DataThread.c
unsigned __stdcall AircraftDataThread(PVOID pvoid);


extern BOOL CALLBACK Message2DlgBlockReplayCB(HWND hdlg, UINT message, WPARAM wParam, LPARAM lparam);
extern BOOL CALLBACK MessageDlgCB(HWND hdlg, UINT message, WPARAM wParam, LPARAM lparam);

int TestFeed = FALSE;   // use feed on matt's desk

int use_prod_server = TRUE;

int BlockSelectedBuffer[MAX_HISTORICAL_TRACKS];


int scene = FALSE; /* Scene toggle            */
GLint Frames = 0;

int timeflag = TRUE;
TexFont *txf;

int gSlices = 50, gRings = 1;
int alphaMode;

FILE *savemapfile;
int tesscount;
int tottesscount; // total number of tesselated polygons
int totlistcount; // one list for every country or color type of polygon
int USEnd, WLDEnd, LKSEnd;

int ShowHolds = FALSE;

HANDLE    hFAAMutex = NULL;
HANDLE    TailMutex;
HANDLE    TailMutexDefault;
HANDLE	  hFDOMutex;
HANDLE	  hSAMutex;

int ASDThreadStarted = FALSE;

int ExtrapolateMaxMSecs = ASD_EXTRAPOLATE_MAX_MSECS;

int PassurThreadStarted = FALSE;

int CkIntrusions = TRUE;

//GLuint quadlist;
// GLuint startList;  // polygons
//GLuint startMapList;  // map lines

//GLuint startTessList;  // pre-tesselated polygons

//GLuint trianglelist;  
//GLuint censuslist, worldlist, highwayslist, runwayslist, runwaylines, lakelist;


GLfloat laplacian[3][3] = {
	{ -0.125, -0.125, -0.125 },
	{ -0.125, 1.0, -0.125 },
	{ -0.125, -0.125, -0.125 }
};


int ARows, ACols;

GLuint fontOffset;

#define FEED_SIZE 20000000

GLfloat *feedBuffer;

int runways_offset, highways_offset, borders_offset, lakes_offset;
int plistcount;  /* gl lists for line objects, one each for borders, highways, runways */

//AIR **SelectedAirP;
//VO *SelectedAirVO;

// Selected Aircraft Type
#define SAT_NONE	0
#define SAT_PASSUR	1
#define SAT_ASDI	2
#define SAT_ASDEX	3
#define SAT_ADSB	4
#define SAT_MLAT	5
#define SAT_NOISE	6
#define SAT_GATE	7
#define SAT_AIRASIA	8
#define SAT_LMG		9

char g_arFeedTypes[][10] = { "NONE", "ADSB", "ASDEX", "PASSUR", "ASDI", "NOISE", "GATE", "MLAT", "AIRASIA", "LMG" };
static poly *prevselectedpoly;
static char prevstatus[32];

//double polyred[ N_GEN_POLY_LISTS ], polygreen[N_GEN_POLY_LISTS], polyblue[N_GEN_POLY_LISTS];
//char polytype[ N_GEN_POLY_LISTS ];

/* default values are for JFK */
// double passur_latitude = 40.666666, passur_longitude = -73.75;
//int passur_zerox = -1391;   /* distance from latlon to zero point */
//int passur_zeroy = -3011;

int tc[4] = { 0, 0, 1, -1 };
int tr[4] = { 1, -1, 0, 0 };

#define NUM_PREV_LOCATIONS 10
double PrevWorldXmax[NUM_PREV_LOCATIONS];
double PrevWorldXmin[NUM_PREV_LOCATIONS];
double PrevWorldYmax[NUM_PREV_LOCATIONS];
double PrevWorldYmin[NUM_PREV_LOCATIONS];

int LastWorldIndex;  // for backspace command to previous screen geometry
int PrevWorldIndex;

int savemapflag;

char *MyScreenMessage;

polylist *AllPolys;


GLfloat trans[3];
// Larry's colors
//  black                 aircraft index 0  -- doesn't have aircraft images, so use plain blue
//  blue 0
GLfloat silver[3];  // aircraft index  1
GLfloat gold[3];    // 2
GLfloat maroon[3]; // 3
GLfloat larry_red[3]; // 4
GLfloat orange[3]; // 5
GLfloat kumquat[3]; //6
GLfloat olive[3]; // 7
GLfloat lime[3]; //8
GLfloat forest[3]; //9
GLfloat teal[3]; // 10
GLfloat lightblue[3]; // 11
GLfloat darkblue[3]; // 12
GLfloat lightpurple[3]; // 13
GLfloat darkpurple[3]; // 14
GLfloat passion[3]; // 15
//Color Pallete
GLfloat backf[3];
GLfloat foref[3];
GLfloat yellow1[3];
GLfloat yellow2[3];
GLfloat yellow3[3];
GLfloat yellow4[3];
GLfloat yellow5[3];


GLfloat red1[3];
GLfloat red2[3];
GLfloat red3[3];
GLfloat red4[3];
GLfloat red5[3];

GLfloat violet1[3];
GLfloat violet2[3];
GLfloat violet3[3];
GLfloat violet4[3];
GLfloat violet5[3];

GLfloat blue1[3];
GLfloat blue2[3];
GLfloat blue3[3];
GLfloat blue4[3];
GLfloat blue5[3];

GLfloat green1[3];
GLfloat green2[3];
GLfloat green3[3];
GLfloat green4[3];
GLfloat green5[3];

//mtm//
GLfloat  Blue_tab[3];
GLfloat  Blue_title[3];
GLfloat  grey_Tab_bg[3];
GLfloat  Blue_fg[3];

///////////////
//Larry new GUI colors
GLfloat Text_yellow[3];
GLfloat Grid_grey1[3];//top/bottom of scrollbar
GLfloat Grid_grey2[3];//background of grids-darker color
GLfloat Grid_grey3[3];//DataAppCreatorGrid fg and bg of two cells
GLfloat Grid_grey4[3];//text in the tab
GLfloat Grid_grey5[3];//Add new bg
GLfloat SubGrid_grey1[3];//Build grid top row
GLfloat SubGrid_grey2[3];//Build grid BG
//mtm icon colors
GLfloat Iconcolor0[3];
GLfloat Iconcolor1[3];
GLfloat Iconcolor2[3];
GLfloat Iconcolor3[3];
GLfloat Iconcolor4[3];
GLfloat Iconcolor5[3];
GLfloat Iconcolor6[3];
GLfloat Iconcolor7[3];
GLfloat Iconcolor8[3];
GLfloat Iconcolor9[3];
GLfloat Iconcolor10[3];
GLfloat Iconcolor11[3];
GLfloat Iconcolor12[3];
GLfloat Iconcolor13[3];
GLfloat Iconcolor14[3];
GLfloat Iconcolor15[3];


//Larry GUI colors
GLfloat GridBg[3];
GLfloat YellowFg[3];

GLfloat buttonblue[3]; // gui button bg

GLfloat FIDSBarColor[3];
GLfloat DarkSlateGray[3];
GLfloat DarkSlateBlue[3];
GLfloat LightWater[3];
GLfloat LightUS[3];
GLfloat LightCM[3];
GLfloat MedWater[3];
GLfloat MedUS[3];
GLfloat MedCM[3];
GLfloat DarkWater[3];
GLfloat DarkUS[3];
GLfloat DarkCM[3];
GLfloat Thistle[3];
GLfloat DarkThistle[3];

GLfloat CMColor[3];



// Tag Color Indices, determines which texture/colors to use when drawing tag panels
#define TCI_PASSUR	0
#define TCI_ASDI	1
#define TCI_ASDEX	2
#define TCI_ADSB	3
#define TCI_MLAT	4
#define TCI_NOISE	5
#define TCI_ALERT	6
#define TCI_GATE	7
#define TCI_AIRASIA	8
#define TCI_LMG		9
#define TCI_OTHER	10


int UseMapColors = 1; // dark is default

GLfloat *TrailLabelColor;
GLfloat frameseconds;
GLfloat fps;


const GLfloat white[3] = { 1.0f, 1.0f, 1.0f };
const GLfloat black[3] = { 0.0f, 0.0f, 0.0f };
const GLfloat red[3] = { 1.0f, 0.0f, 0.0f };
const GLfloat blue[3] = { 0.0f, 0.0f, 1.0f };
const GLfloat grey[3] = { 0.8f, 0.8f, 0.8f };
const GLfloat darkgrey[3] = { 0.6f, 0.6f, 0.6f };

const GLfloat green[3] = { 0.0f, 1.0f, 0.0f };
const GLfloat yellow[3] = { 1.0f, 1.0f, 0.0f };




static int gframecount;
char g_hostname[64];

int UseASDEXFilters = TRUE;
int UseADSBFilters = TRUE;
int UseAirAsiaFilters = TRUE;

char CurrentAirCellServer[132];
char CurrentIMAPServer[132];


// to be indexed by id->m_sUserSettings.TerrainColor
char *TerrainColorPaths[] = {
	"./data/Maps/NaturalGreen/",
	"./data/Maps/DarkGreen/",
	"./data/Maps/DesertBrown/",
	"./data/Maps/SlateGray/"
};

int terrainColorChange = FALSE;

RGBVALUE  terrainBackgroundColors[] = {
	{ 135.0, 169.0, 107.0 },      // natural green
	{ 61.0, 122.0, 58.0 },        // dark green
	{ 114.0, 117.0, 87.0 },       // desert brown
	{ 135.0, 135.0, 135.0 }       // slate gray
};

GLubyte rasters[][13] =
{
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36 },
	{ 0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00 },
	{ 0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18 },
	{ 0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70 },
	{ 0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e },
	{ 0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c },
	{ 0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30 },
	{ 0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00 },
	{ 0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03 },
	{ 0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c },
	{ 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18 },
	{ 0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e },
	{ 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e },
	{ 0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c },
	{ 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff },
	{ 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e },
	{ 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff },
	{ 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e },
	{ 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e },
	{ 0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06 },
	{ 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60 },
	{ 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e },
	{ 0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18 },
	{ 0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe },
	{ 0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e },
	{ 0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc },
	{ 0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff },
	{ 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff },
	{ 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e },
	{ 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3 },
	{ 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e },
	{ 0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06 },
	{ 0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3 },
	{ 0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0 },
	{ 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3 },
	{ 0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3 },
	{ 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e },
	{ 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe },
	{ 0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c },
	{ 0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe },
	{ 0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e },
	{ 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff },
	{ 0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3 },
	{ 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3 },
	{ 0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3 },
	{ 0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3 },
	{ 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3 },
	{ 0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff },
	{ 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c },
	{ 0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60 },
	{ 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18 },
	{ 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70 },
	{ 0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0 },
	{ 0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03 },
	{ 0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e },
	{ 0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0 },
	{ 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00 },
	{ 0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00 },
	{ 0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0 },
	{ 0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78 },
	{ 0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00 },
	{ 0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00 },
	{ 0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00 },
	{ 0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00 },
	{ 0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f },
	{ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 },
	{ 0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00 }
};


int GNPoints;

// Proxy starts

#define ORLANDO_PULS_SRVR_LIST_SZ 3

static char *OrlandoPulseSrvrs[] = {
	"https://www54.passur.com/fcgi/PulseTrack.fcg",
	"https://www50.passur.com/fcgi/PulseTrack.fcg",
	"https://www51.passur.com/fcgi/PulseTrack.fcg"
};

#define MAXSTRNGSZ	512
int g_nOrlandoPulseSrvrCnt;

int OrlandoCrntPulseSrvr = 0;				// Current pulse server index
int g_nOrlandoPulseSrvrCnt;		// Failure count for Pulse Server

time_t g_tOrlandoPulseSvrFailTime;
int g_nOrlandoPulseSvrFailCnt;

char *GetOrlandoPulseSrvr(struct InstanceData* id)
{
	if (g_nOrlandoPulseSrvrCnt){
		D_CONTROL("SERVER_NAMES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Returning: %s\n", GetCurrentThreadId(), OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]));
		return (OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]);
	}

	D_CONTROL("SERVER_NAMES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Returning: %s\n", GetCurrentThreadId(), OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]));
	return (OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]);
}

char* GetNxtOrlandoPulseSrvr(struct InstanceData* id)
{
	time_t now = time(NULL);
	int nTimeOut = GetConfigValueInt(id, "SERVER_TIMEOUT", 300);
	int nCount = GetConfigValueInt(id, "SERVER_TIMEOUT_COUNT", 5);

	if (!g_tOrlandoPulseSvrFailTime || (now - g_tOrlandoPulseSvrFailTime) > nTimeOut){
		g_nOrlandoPulseSvrFailCnt = 1;
		g_tOrlandoPulseSvrFailTime = now;
	}
	else{
		++g_nOrlandoPulseSvrFailCnt;
		if (g_nOrlandoPulseSvrFailCnt > nCount){
			char buffer[STATUSSTRING_SZ] = { 0 };
			g_nOrlandoPulseSvrFailCnt = 1;
			_snprintf_s(buffer, STATUSSTRING_SZ, _TRUNCATE, "Pulse Server failed %d times in %d secs.", nCount, (now - g_tOrlandoPulseSvrFailTime));
			LogToServer(id, LOG_ERR, "NETWORK", buffer);
		}
	}
	if (g_nOrlandoPulseSrvrCnt){
		OrlandoCrntPulseSrvr = OrlandoCrntPulseSrvr < (g_nOrlandoPulseSrvrCnt - 1) ? OrlandoCrntPulseSrvr + 1 : 0;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Set CrntPulseSrvr=%d, Returning: %s\n", GetCurrentThreadId(), OrlandoCrntPulseSrvr, OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]);
		return (OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]);
	}

	OrlandoCrntPulseSrvr = OrlandoCrntPulseSrvr < (ORLANDO_PULS_SRVR_LIST_SZ - 1) ? OrlandoCrntPulseSrvr + 1 : 0;
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Set CrntPulseSrvr=%d, Returning: %s\n", GetCurrentThreadId(), OrlandoCrntPulseSrvr, OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]);
	return (OrlandoPulseSrvrs[OrlandoCrntPulseSrvr]);
}




void SetFailedRequest(struct MemoryStruct* chunk)
{
	const char* strError = "ERR_FAILED_REQUEST";
	clear_chunk_memory(chunk);

	chunk->size = strlen(strError) + 1;
	chunk->memory = (char*)calloc(chunk->size, sizeof(char*));
	strcat_s(chunk->memory, chunk->size, strError);
}


int stripOuterWhitespace(char* szDest, const char* szSrc, int nCount)
{
	int nSuccess = FALSE;
	char* pStart = (char*)szSrc;
	char* pEnd = NULL;
	memset(szDest, 0, nCount * sizeof(char));

	while (' ' == *pStart && 0 != *pStart) pStart++;
	pEnd = pStart + (strlen(pStart) - 1);
	while (' ' == *pEnd) pEnd--;
	pEnd++; // Include last good char in copy.
	if (pEnd - pStart <= nCount){
		nSuccess = !strncpy_s(szDest, nCount, pStart, pEnd - pStart);
	}else{
		// Still copies some, but returns false
		nSuccess = !strncpy_s(szDest, nCount, pStart, _TRUNCATE);
	}
	return nSuccess;
}

void
vo_set_char_value(struct InstanceData* id, VO *vo, int row_ix, char *c_name, char *s_val)
{
	int d_off;
	int size;
	char *n_val;

	d_off = vo_offset(vo, c_name);
	size = vcol_size(vo, c_name);
	//strcpy(((char *)(vo)->row_index[(row_ix)].datap + d_off) , s_val);
	strcpy_s(((char *)((char *)((void *)(vo)->row_index[(row_ix)].datap) + d_off)), size, s_val);
	n_val = VP(vo, row_ix, c_name, char);
	D_CONTROL("VO_DBG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Passed Value, Saved=[%s:%s] \n", GetCurrentThreadId(), s_val, n_val));
}


void
vo_set_int_value(struct InstanceData* id, VO *vo, int row_ix, char *c_name, int i_val)
{
	int d_off;
	int n_val;

	d_off = vo_offset(vo, c_name);
	//*( (int *)(vo)->row_index[(row_ix)].datap + d_off) = i_val;
	*((int *)((char *)((void *)(vo)->row_index[(row_ix)].datap) + d_off)) = i_val;
	n_val = VV(vo, row_ix, c_name, int);
	if (n_val != i_val)
		D_CONTROL("NEW_DBG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Passed, Saved=[%d:%d] \n", GetCurrentThreadId(), i_val, n_val));
}

void
vo_set_double_value(struct InstanceData* id, VO *vo, int row_ix, char *c_name, double d_val)
{
	int d_off;
	double n_val;

	d_off = vo_offset(vo, c_name);
	//*( (double *)(vo)->row_index[(row_ix)].datap + d_off) = d_val;
	*((double *)((char *)((void *)(vo)->row_index[(row_ix)].datap) + d_off)) = d_val;
	n_val = VV(vo, row_ix, c_name, double);
	D_CONTROL("VO_DBG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Passed Value, Saved=[%f:%f] \n", GetCurrentThreadId(), d_val, n_val));
}


struct curlCachedProxyOpt* cachedCurlOpts = NULL;


int use_passur_time = TRUE;

VO *ProjectsVO;

// Prototypes
char *GetNextField(char *recstr, char *tmpstr, int tmpsize);
int CalcFeedXY(struct InstanceData* id, double lon, double lat, int *feedx, int* feedy, int passurindex);
void SetPassurDelaytime(struct InstanceData* id);
void ImgChangeColorAlpha(GLubyte *mapimage, int ncols, int nrows, int r, int g, int b, int alpha,
	int bg_red, int bg_green, int bg_blue);
BOOL OpenGLTrace(char* pstr, ...);

// Call this function to connect callback 
void RegisterSendMessageCallback(struct InstanceData* id, // InstanceData pointer
	char* szTypeName,		// Type name, e.g. "StartPoly"
	CnSendMessageCb pfn);	// Function pointer to callback

// Call this function to connect callback 
void RegisterGetDataCallback(struct InstanceData* id, // InstanceData pointer
	char* szType,		// Type name, e.g. "StartPoly"
	CnGetDataCb pfn);	// Function pointer to callback

// Call this function to callback to javascript (send a "Callback" event)
void Callback2Javascript(struct InstanceData* id, char* s);

// C to C++ Passthru for SimpleCrypto
BOOL Decrypt(LPBYTE pData, LPDWORD dwDataSize,
	BOOL bFinal);
BOOL Encrypt(LPBYTE pData, LPDWORD pdwDataSize,
	DWORD dwBufferSize, BOOL bFinal);
// Proxy ends

// start code here
void RotateScreenPoint(struct InstanceData* id, int nCenterX, int nCenterY, int* pnPointX, int* pnPointY)
{
	// Convert from degrees to radians via multiplication by PI/180
	double dAtan2 = atan2((*pnPointY) - nCenterY, nCenterX - (*pnPointX));
	double dOrgAngle = 180 + (dAtan2)* 180 / PI;
	double fRadius = sqrt(pow(nCenterX - (*pnPointX), 2) + pow(nCenterY - (*pnPointY), 2));
	double dNewAngle = dOrgAngle - id->m_glfRotateAngle;
	double dRadians = dNewAngle * PI / 180.0f;
	int x = (int)(fRadius * cos(dRadians)) + nCenterX;
	int y = (int)(fRadius * -1 * sin(dRadians)) + nCenterY;
	*pnPointX = x;
	*pnPointY = y;
}

void RotatePoint(struct InstanceData* id, GLfloat* pnPointX, GLfloat* pnPointY)
{
    // Convert from degrees to radians via multiplication by PI/180
	double dCenterX = id->m_sCurLayout.m_dWorldXmin + ((id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)/2.0f);
	double dCenterY = id->m_sCurLayout.m_dWorldYmin + ((id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)/2.0f); 
	double dAtan2 = atan2((*pnPointY) - dCenterY, dCenterX - (*pnPointX));
	double dOrgAngle = 180 + (dAtan2)*180/PI;
	double fRadius = sqrt(pow(dCenterX - (*pnPointX),2.0f) + pow(dCenterY - (*pnPointY),2.0f));
	double dNewAngle = dOrgAngle - id->m_glfRotateAngle;
	double dRadians = dNewAngle * PI / 180.0f;
	double x = (fRadius * cos(dRadians)) + dCenterX;
	double y = (fRadius * -1 * sin(dRadians)) + dCenterY;
	*pnPointX = (GLfloat)x;
	*pnPointY = (GLfloat)y;    
}

void RotateView(struct InstanceData* id, double xMax, double xMin, double yMax, double yMin)
{
	GLfloat x = (GLfloat)(xMin + (xMax - xMin) / 2.0f);
	GLfloat y = (GLfloat)(yMin + (yMax - yMin) / 2.0f);
	glTranslatef(x, y, 0);
	glRotatef(id->m_glfRotateAngle, 0, 0, 1.0f);
	glTranslatef(-x, -y, 0);
}

void AddCustomMap(struct InstanceData* id, const char* arpt, int start, int count, int type)
{
	if (arpt && strlen(arpt) && count >= 0)
	{
		// Check if we have any Custom Map Data
		if (!id->m_pCustomMapData){
			// Allocate first Custom Map Data			
			CUSTOM_MAP_DATA* curr = (CUSTOM_MAP_DATA*)calloc(1, sizeof(CUSTOM_MAP_DATA));
			strcpy_s(curr->arpt, ARPTNAME_SZ, arpt);
			curr->start = start;
			curr->count = count;
			curr->type = type;
			id->m_pCustomMapData = curr;
		}else{
			// Check to see if we already have Map data for Airport
			CUSTOM_MAP_DATA* curr = id->m_pCustomMapData;
			CUSTOM_MAP_DATA* prev = NULL;
			while (curr)
			{
				if (!strcmp(curr->arpt, arpt)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to Add Custom Map Data for %s, Map Data already exists!\n", GetCurrentThreadId(), arpt);
					return;
				}
				prev = curr;
				curr = curr->np;
			}

			// Allocate and Add new Map Data
			curr = (CUSTOM_MAP_DATA*)calloc(1, sizeof(CUSTOM_MAP_DATA));
			strcpy_s(curr->arpt, ARPTNAME_SZ, arpt);
			curr->start = start;
			curr->count = count;
			curr->type = type;
			prev->np = curr;
		}
	}
}

int HaveCustomMap(struct InstanceData* id, const char* arpt, int* start, int* count, int* type)
{
	int bReturn = FALSE;

	CUSTOM_MAP_DATA* curr = id->m_pCustomMapData;
	CUSTOM_MAP_DATA* prev = NULL;
	while (curr)
	{
		if (!strcmp(curr->arpt, arpt)){
			*start = curr->start;
			*count = curr->count;
			*type = curr->type;
			bReturn = TRUE;
			break;
		}
		prev = curr;
		curr = curr->np;
	}

	return bReturn;
}

void FreeEditPolys()
{
	points *np, *freep = NULL;

	if (!editpoly){
		return;
	}
	for (np = editpoly->ppoints; np; np = np->np){
		if (freep){
			vp_free(freep);
			freep = NULL;
		}
		freep = np;
	}
	vp_free(editpoly);
	editpoly = NULL;

}


buildRangeRings(struct InstanceData* id)
{
	GLUquadricObj *qobj;
	double CircRadius;

	if (id->m_bBuildRangeRings){
		qobj = gluNewQuadric();
		quadlist = glGenLists(1);
		GL_ASSERT(glEnable(GL_DEPTH_TEST));

		gluQuadricDrawStyle(qobj, GLU_SILHOUETTE);
		gluQuadricNormals(qobj, GLU_NONE);

		GL_ASSERT(glNewList(quadlist, GL_COMPILE));

		/* make circle 10 nautical miles wide */
		/* 1 degree lat = 69.172 mi = 60.10883 nautical miles */
		CircRadius = 10.0 / 60.10883;

		gluDisk(qobj, 0, CircRadius, gSlices, gRings);
		/* gluSphere( qobj, 1.0, 15, 10 ); */
		GL_ASSERT(glEndList());
	}
	id->m_bBuildRangeRings = FALSE;
}

#ifdef USE_OLD_GRID_TYPES
int parseRoiDataType(const char *dataTypeStr)
{
	if (_strnicmp(dataTypeStr, "int", strlen("int")) == 0)
		return (0);

	if (_strnicmp(dataTypeStr, "string", strlen("string")) == 0)
		return (1);

	if (_strnicmp(dataTypeStr, "bool", strlen("bool")) == 0)
		return (2);

	if (_strnicmp(dataTypeStr, "time", strlen("time")) == 0)
		return (3);

	return (-1);
}



int parseRoiAppData(char *appData, GridConfig *roi)
{
	json_object *jObj;
	enum json_tokener_error jError;

	jObj = json_tokener_parse_verbose(appData, &jError);
	if (jObj && jError == json_tokener_success)
	{
		// Extract Outline and Outline_color
		json_object *jOutline = json_object_object_get(jObj, "outline");
		json_object *jColor = json_object_object_get(jObj, "outline_color");
		const char *outlineColor = json_object_get_string(jColor);

		roi->outline = _stricmp(json_object_get_string(jOutline), "on") == 0;

		if (*outlineColor == '#')
			outlineColor++;

		sscanf_s(outlineColor, "%06x", &roi->outline_color, sizeof(roi->outline_color));

		json_object_put(jObj);
		return (TRUE);
	}

	return (FALSE);
}



int parseRoiTableData(char *tableData, GridConfig *roi)
{
	json_object *jObj;
	enum json_tokener_error jError;

	jObj = json_tokener_parse_verbose(tableData, &jError);
	if (jObj && jError == json_tokener_success)
	{
		json_object_put(jObj);
		return (TRUE);
	}
	return (FALSE);
}

int parseRoiFilterData(char *filterData, GridConfig *roi)
{
	json_object *jObj;
	struct json_object_iter	jIter;
	enum json_tokener_error jError;
	int filterCount = 0;

	jObj = json_tokener_parse_verbose(filterData, &jError);
	if (jObj && jError == json_tokener_success)
	{
		json_object_object_foreachC(jObj, jIter)
		{
			json_object *jFilterType = json_object_object_get(jIter.val, "filterType");
			json_object *jFieldName = json_object_object_get(jIter.val, "fieldName");
			json_object *jFieldType = json_object_object_get(jIter.val, "fieldType");
			json_object *jExcludeSelect = json_object_object_get(jIter.val, "excludeSelected");
			json_object *jSelectedValues = json_object_object_get(jIter.val, "selectedValues");
			json_object *jCriteria = json_object_object_get(jIter.val, "criteria");
			json_object *jOp = json_object_object_get(jIter.val, "op");
			json_object *jValues = json_object_object_get(jIter.val, "values");

			if (jFilterType && json_object_get_type(jFilterType) == json_type_string)
				roi->filters[filterCount].filter_type = _stricmp(json_object_get_string(jFilterType), "criteria_view") == 0;

			if (jFieldName && json_object_get_type(jFieldName) == json_type_string)
				strncpy_s(roi->filters[filterCount].field_name, sizeof(roi->filters[filterCount].field_name), json_object_get_string(jFieldName), _TRUNCATE);

			if (jFieldType && json_object_get_type(jFieldType) == json_type_string)
				roi->filters[filterCount].field_type = parseRoiDataType(json_object_get_string(jFieldType));

			roi->filters[filterCount].exclude_selected = json_object_get_boolean(jExcludeSelect);

			if (jSelectedValues && json_type_array == json_object_get_type(jSelectedValues))
			{
				int nValues = json_object_array_length(jSelectedValues);
				int i;

				for (i = 0; i < nValues; i++)
				{
					json_object * jVal = json_object_array_get_idx(jSelectedValues, i);

					if (i == 0)
					{
						strncpy_s(roi->filters[filterCount].select_value, sizeof(roi->filters[filterCount].select_value), json_object_get_string(jVal), _TRUNCATE);
					}
					else
					{
						strncat_s(roi->filters[filterCount].select_value, sizeof(roi->filters[filterCount].select_value), ",", _TRUNCATE);
						strncat_s(roi->filters[filterCount].select_value, sizeof(roi->filters[filterCount].select_value), json_object_get_string(jVal), _TRUNCATE);
					}
				}
			}
			if ( roi->filters[filterCount].op && json_object_get_string(jOp)){
				strncpy_s(roi->filters[filterCount].op, sizeof(roi->filters[filterCount].op), json_object_get_string(jOp), _TRUNCATE);
			}
			if (jValues && json_type_array == json_object_get_type(jValues) && json_object_array_length(jValues) > 0)
			{
				json_object * jVal = json_object_array_get_idx(jValues, 0);

				strncpy_s(roi->filters[filterCount].cmp_value, sizeof(roi->filters[filterCount].cmp_value), json_object_get_string(jVal), _TRUNCATE);
			}

			filterCount++;
			if (filterCount >= 7)
				break;
		}
		roi->nFilters = filterCount;
		json_object_put(jObj);
		return (TRUE);
	}
	return (FALSE);
}

int parseRoiColumnData(char *columnData, GridConfig *roi, int col)
{
	json_object *jObj;
	enum json_tokener_error jError;

	jObj = json_tokener_parse_verbose(columnData, &jError);
	if (jObj && jError == json_tokener_success)
	{
		json_object *jNameObj = json_object_object_get(jObj, "name");
		json_object *jFieldObj = json_object_object_get(jObj, "field");
		json_object *jDataTypeObj = json_object_object_get(jObj, "data_type");
		json_object *jOrderObj = json_object_object_get(jObj, "order");
		json_object *jDisplayObj = json_object_object_get(jObj, "display");
		json_object *jFilterObj = json_object_object_get(jObj, "filter");
		json_object *jSortObj = json_object_object_get(jObj, "sort");

		// Extract column specific data
		if (jNameObj && json_object_get_type(jNameObj) == json_type_string)
			strncpy_s(roi->configcolumns[col].name, sizeof(roi->configcolumns[col].name), json_object_get_string(jNameObj), _TRUNCATE);

		if (jFieldObj && json_object_get_type(jFieldObj) == json_type_string)
			strncpy_s(roi->configcolumns[col].field_name, sizeof(roi->configcolumns[col].field_name), json_object_get_string(jFieldObj), _TRUNCATE);

		if (jDataTypeObj && json_object_get_type(jDataTypeObj) == json_type_string)
		{
			const char * s = json_object_get_string(jDataTypeObj);

			roi->configcolumns[col].data_type = parseRoiDataType(s);
		}

		if (jOrderObj && json_object_get_type(jOrderObj) == json_type_int)
			roi->configcolumns[col].order = json_object_get_int(jOrderObj);

		if (jDisplayObj)
		{
			json_object *jVisObj = json_object_object_get(jDisplayObj, "visible");

			// KLUDGE: because somebody doesn't know how to spell 'visible'
			if (jVisObj == NULL)
				jVisObj = json_object_object_get(jDisplayObj, "visable");

			if (jVisObj && json_object_get_type(jVisObj) == json_type_int)
				roi->configcolumns[col].display = json_object_get_int(jVisObj);
		}

		if (jFilterObj)
		{
			json_object *jEnabledObj = json_object_object_get(jFilterObj, "enabled");
			json_object *jListSrc = json_object_object_get(jFilterObj, "list_src");
			json_object *jValueList = json_object_object_get(jFilterObj, "value_list");

			if (jEnabledObj && json_object_get_type(jEnabledObj) == json_type_int)
				roi->configcolumns[col].filter_enabled = json_object_get_int(jEnabledObj);

			if (jListSrc && json_object_get_type(jListSrc) == json_type_int)
				roi->configcolumns[col].list_src = json_object_get_int(jListSrc);

			if (jValueList && json_object_get_type(jValueList) == json_type_array)
			{
				int nValues = json_object_array_length(jValueList);
				int i;

				for (i = 0; i < nValues; i++)
				{
					json_object * jVal = json_object_array_get_idx(jValueList, i);

					if (i == 0)
					{
						strncpy_s(roi->configcolumns[col].value_list, sizeof(roi->configcolumns[col].value_list), json_object_get_string(jVal), _TRUNCATE);
					}
					else
					{
						strncat_s(roi->configcolumns[col].value_list, sizeof(roi->configcolumns[col].value_list), ",", _TRUNCATE);
						strncat_s(roi->configcolumns[col].value_list, sizeof(roi->configcolumns[col].value_list), json_object_get_string(jVal), _TRUNCATE);
					}
				}
			}
		}

		if (jSortObj)
		{
			json_object *jSortEnabled = json_object_object_get(jSortObj, "enabled");
			json_object *jSortActive = json_object_object_get(jSortObj, "active");
			json_object *jSortOrder = json_object_object_get(jSortObj, "order");
			json_object *jSortType = json_object_object_get(jSortObj, "sort_type");

			if (jSortEnabled && json_object_get_type(jSortEnabled) == json_type_int)
				roi->configcolumns[col].sortConfig.enabled = json_object_get_int(jSortEnabled);

			if (jSortActive && json_object_get_type(jSortActive) == json_type_int)
				roi->configcolumns[col].sortConfig.active = json_object_get_int(jSortActive);

			if (jSortOrder && json_object_get_type(jSortOrder) == json_type_int)
				roi->configcolumns[col].sortConfig.order = json_object_get_int(jSortOrder);

			if (jSortType && json_object_get_type(jSortType) == json_type_string)
			{
				const char *s = json_object_get_string(jSortType);
				roi->configcolumns[col].sortConfig.sort_type = strncmp(s, "desc", strlen("desc")) == 0 ? 1 : 0;
			}
		}

		json_object_put(jObj);
		return (TRUE);
	}
	return (FALSE);
}

// ROI Configuration Routines
void parseRoiConfigObject(char *data, GridConfig *roi)
{
	char *token;
	char *context = NULL;
	char appData[4096];
	char tableData[4096];
	char filterData[4096];
	char columnData[4096];
	int hcpcount;
	int col;

	for (token = strtok_s(data, "&", &context); token != NULL; token = strtok_s(NULL, "&", &context))
	{
		if (_strnicmp(token, "result=", strlen("result=")) == 0)
		{
			token += strlen("result=");
			if (_strnicmp(token, "FAILED", strlen("FAILED")) == 0)
				return;
		}
		else if (_strnicmp(token, "user=", strlen("user=")) == 0)
			;
		else if (_strnicmp(token, "name=", strlen("name=")) == 0)
			;
		else if (_strnicmp(token, "arpt=", strlen("arpt=")) == 0)
			;
		else if (_strnicmp(token, "appdata=", strlen("appdata=")) == 0)
		{
			token += strlen("appdata=");
			strncpy_s(appData, sizeof(appData), token, _TRUNCATE);
			parseRoiAppData(appData, roi);
		}
		else if (_strnicmp(token, "table=", strlen("table=")) == 0)
		{
			token += strlen("table=");
			strncpy_s(tableData, sizeof(tableData), token, _TRUNCATE);
			parseRoiTableData(tableData, roi);
		}
		else if (_strnicmp(token, "filter=", strlen("filter=")) == 0)
		{
			token += strlen("filter=");
			strncpy_s(filterData, sizeof(filterData), token, _TRUNCATE);
			parseRoiFilterData(filterData, roi);
		}
		else if (_strnicmp(token, "hcpcount=", strlen("hcpcount=")) == 0)
		{
			token += strlen("hcpcount=");
			hcpcount = atoi(token);
		}
		else
		{
			char	label[8];

			for (col=0; col < hcpcount; col++)
			{
				sprintf_s(label, sizeof(label), "hcp%d=", col);
				if (_strnicmp(token, label, strlen(label)) == 0)
				{
					token += strlen(label);
					strncpy_s(columnData, sizeof(columnData), token, _TRUNCATE);
					parseRoiColumnData(columnData, roi, col);
				}
			}
		}
	}
	return ;
}




int LoadUserRoiSettings (struct InstanceData *id, char *user, char *arpt, char *configname, GridConfig *roi)
{
	char username[64];
	char tmpstr [ 4096 ];
	struct MemoryStruct chunk;
	struct json_object* jObj = NULL;

	if (user == NULL || strlen(user) == 0)
		return (FALSE);

	if (arpt == NULL || strlen(arpt) == 0)
		return (FALSE);

	if (configname == NULL || strlen(configname) == 0)
		return (FALSE);

	if (roi == NULL)
		return (FALSE);

	strncpy_s( username, sizeof(username), user, _TRUNCATE );
	StrUpper(username);

	chunk.size = 0;
	chunk.memory = NULL;

	_snprintf_s(tmpstr, sizeof(tmpstr), _TRUNCATE, "Action=GetDGTConfig&appname=ROI&user=%s&arpt=%s&name=%s", username, arpt, configname);

	if ( !GetCurlFormPostResults( id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE ))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load ROI Configuration\n", GetCurrentThreadId());
		GetNxtSurfSrvr(id);
	}
	else
	{
		// Check for valid data from server
		if (chunk.memory)
		{
			if (!strstr(chunk.memory, "404 Not Found"))
			{
				char* data = curl_unescape(chunk.memory, strlen(chunk.memory));

				if (data)
				{
					memset(roi, 0, sizeof(GridConfig));
					parseRoiConfigObject(data, roi);
				}

				curl_free(data);
			}
		}
	}

	free_chunk_memory(&chunk);
	return (TRUE);
}

json_object * mkRoiAppDataObj(GridConfig * roi)
{
	json_object *jObj;
	char	outlineColor[8];

	jObj = json_object_new_object();
	if (jObj == NULL)
		return (NULL);

	json_object_object_add(jObj, "outline", json_object_new_string(roi->outline ? "on" : "off"));

	sprintf_s(outlineColor, sizeof(outlineColor), "#%06X", roi->outline_color);
	json_object_object_add(jObj, "outline_color", json_object_new_string(outlineColor));

	return (jObj);
}

json_object * mkRoiTableConf(GridConfig *roi)
{
	json_object *jObj;

	jObj = json_object_new_object();
	if (jObj == NULL)
		return (NULL);

	json_object_object_add(jObj, "header_row_class", json_object_new_string("header_row"));
	json_object_object_add(jObj, "header_cell_class", json_object_new_string("header_cell"));
	json_object_object_add(jObj, "alternate_even_odd_rows", json_object_new_int(1));
	json_object_object_add(jObj, "row_default_class", json_object_new_string("data_row"));
	json_object_object_add(jObj, "row_odd_class", json_object_new_string("data_row_odd"));
	json_object_object_add(jObj, "row_even_class", json_object_new_string("data_row_even"));
	json_object_object_add(jObj, "cell_default_class", json_object_new_string("data_cell"));
	json_object_object_add(jObj, "row_default_color", json_object_new_string("#5A5A5A"));
	json_object_object_add(jObj, "row_default_odd_color", json_object_new_string("#5A5A5A"));
	json_object_object_add(jObj, "row_default_even_color", json_object_new_string("#525252"));
	json_object_object_add(jObj, "row_highlight_color", json_object_new_string("#F7CF54"));
	json_object_object_add(jObj, "display_hr_row", json_object_new_int(0));
	json_object_object_add(jObj, "display_hr_row_class", json_object_new_string("data_row"));
	json_object_object_add(jObj, "display_hr_cell_class", json_object_new_string("data_cell_center"));

	return (jObj);
}

json_object * mkRoiFilter(GridConfig *roi)
{
	int i;
	static const char *filter_field_types[] =
	{
		"int", "string", "bool", "time"
	};
	json_object *	jObj;

	jObj = json_object_new_object();
	if (jObj == NULL)
		return (NULL);

	for (i=0; i < roi->nFilters; i++)
	{
		GridFilterConfig *filter = &roi->filters[i];

		json_object * jFilterObj = json_object_new_object();
		json_object * jValArray = NULL;

		json_object_object_add(jFilterObj, "filterType", json_object_new_string(filter->filter_type ? "criteria_view" : "list_view"));
		json_object_object_add(jFilterObj, "fieldName", json_object_new_string(filter->field_name));
		json_object_object_add(jFilterObj, "fieldType", json_object_new_string(filter_field_types[filter->field_type]));
		json_object_object_add(jFilterObj, "excludeSelected", json_object_new_boolean(filter->exclude_selected));

		jValArray = json_object_new_array();
		if (filter->filter_type == FTYPE_LIST)
		{
			char values[sizeof(filter->select_value)];
			char *token;
			char *context = NULL;

			memset(values, 0, sizeof(values));
			strncpy_s(values, sizeof(values), filter->select_value, _TRUNCATE);

			for (token = strtok_s(values, ",", &context); token != NULL; token = strtok_s(NULL, ",", &context))
			{
				json_object_array_add(jValArray, json_object_new_string(token));
			}
		}
		json_object_object_add(jFilterObj, "selectedValues", jValArray);
		json_object_object_add(jFilterObj, "criteria", json_object_new_object());
		json_object_object_add(jFilterObj, "op", json_object_new_string(filter->op));
		json_object_object_add(jFilterObj, "values", json_object_new_array());

		json_object_object_add(jObj, filter->field_name, jFilterObj);
	}
	return (jObj);
}

json_object *mkArrayObj(char *arrString)
{
	char values[4096];
	char *token;
	char *context = NULL;

	json_object *jObj = json_object_new_array();

	if (strlen(arrString) == 0)
		return (jObj);

	memset(values, 0, sizeof(values));
	strncpy_s(values, sizeof(values), arrString, _TRUNCATE);

	for (token = strtok_s(values, ",", &context); token != NULL; token = strtok_s(NULL, ",", &context))
	{
		json_object_array_add(jObj, json_object_new_string(token));
	}

	return (jObj);
}

void mkRoiColumns(GridConfig *roi, json_object *columns[])
{
	int i;

	static const char *filter_field_types[] =
	{
		"int", "string", "bool", "time"
	};

	for (i=0; i < 7; i++)
	{
		GridColumnConfig *roiColumn = &roi->configcolumns[i];
		json_object *jObj = json_object_new_object();
		json_object *jDisplayObj = NULL;
		json_object *jFilterObj = NULL;
		json_object *jSortObj = NULL;
		json_object *jClassObj = NULL;

		json_object_object_add(jObj, "name", json_object_new_string(roiColumn->name));
		json_object_object_add(jObj, "field", json_object_new_string(roiColumn->field_name));
		json_object_object_add(jObj, "data_type", json_object_new_string(filter_field_types[roiColumn->data_type]));
		json_object_object_add(jObj, "order", json_object_new_int(roiColumn->order));

		// make Display object
		jDisplayObj = json_object_new_object();
		json_object_object_add(jDisplayObj, "visible", json_object_new_int(roiColumn->display));
		json_object_object_add(jDisplayObj, "wrap", json_object_new_int(0));
		json_object_object_add(jObj, "display", jDisplayObj);

		// make Filter object
		jFilterObj = json_object_new_object();
		json_object_object_add(jFilterObj, "enabled", json_object_new_int(roiColumn->filter_enabled));
		json_object_object_add(jFilterObj, "list_src", json_object_new_int(roiColumn->list_src));
		json_object_object_add(jFilterObj, "value_list", mkArrayObj(roiColumn->value_list));
		json_object_object_add(jObj, "filter", jFilterObj);

		// make Sort object
		jSortObj = json_object_new_object();
		json_object_object_add(jSortObj, "enabled", json_object_new_int(roiColumn->sortConfig.enabled));
		json_object_object_add(jSortObj, "active", json_object_new_int(roiColumn->sortConfig.active));
		json_object_object_add(jSortObj, "order", json_object_new_int(roiColumn->sortConfig.order));
		json_object_object_add(jSortObj, "sort_type", json_object_new_string(roiColumn->sortConfig.sort_type ? "desc" : "asc"));
		json_object_object_add(jObj, "sort", jSortObj);

		// make classes object
		jClassObj = json_object_new_object();
		json_object_object_add(jClassObj, "hdrClass", json_object_new_string("header_cell"));
		json_object_object_add(jClassObj, "dataClass", json_object_new_string("data_cell"));
		json_object_object_add(jObj, "classes", jClassObj);

		columns[i] = jObj;
	}
}



arpt = "";

outstr = str_falloc("Table: \"xgridapps\"\n");
sprintf_s( tmpbuf, sizeof(tmpbuf), "AppName: \"%s\"\n", AppName );
outstr = strcat_alloc(outstr, tmpbuf);
sprintf_s( tmpbuf, sizeof(tmpbuf), "username: \"%s\"\n", id->m_strUserName );
outstr = strcat_alloc(outstr, tmpbuf);
sprintf_s( tmpbuf, sizeof(tmpbuf), "arpt: \"%s\"\n", arpt );
outstr = strcat_alloc(outstr, tmpbuf);
sprintf_s( tmpbuf, sizeof(tmpbuf), "datasource: \"%s\"\n", DataSource );
outstr = strcat_alloc(outstr, tmpbuf);


if ( !grid->SortAvailableGrid ) {
	CreateSortPanel(id, grid  );
	FillAvailableColsVO(id, grid );
}

if (	!grid->SortAvailableGrid || !(AvailableVO = grid->SortAvailableGrid->vo)) {
	return( FALSE );
}

sprintf_s( tmpbuf, sizeof(tmpbuf), "Table: \"xgridcolumns\"\n" );
outstr = strcat_alloc(outstr, tmpbuf);
for (col = 0; col < AvailableVO->count; col++ ){

	ColName = VP(AvailableVO, col, "Column", char );
	IsVisible = VV(AvailableVO, col, "Visible", int);
	SortPriority = VV(AvailableVO, col, "SortPriority", int);
	SortVal = VV(AvailableVO, col, "SortVal", int);


	sprintf_s( tmpbuf, sizeof(tmpbuf), "colname: \"%s\"\n", ColName );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "IsVisible: \"%d\"\n", IsVisible );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "SortPriority: \"%d\"\n", SortPriority );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "col_order: \"%d\"\n", col );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "SortType: \"%d\"\n", SortVal );
	outstr = strcat_alloc(outstr, tmpbuf );
}

sprintf_s( tmpbuf, sizeof(tmpbuf), "Table: \"xgridactions\"\n" );
outstr = strcat_alloc(outstr, tmpbuf);
for (action = 0; action < grid->nActions; action++ ){

	ActionName = grid->Actions[action].ActionName;
	ActionType = grid->Actions[action].ActionType;
	IsActive = grid->Actions[action].IsActive;
	row_fg =  grid->Actions[action].row_fg;  // ex:  FF00B7
	row_bg =  grid->Actions[action].row_bg;  // ex:  FF00B7
	soundname =  grid->Actions[action].soundname;

	sprintf_s( tmpbuf, sizeof(tmpbuf), "actionname: \"%s\"\n", ActionName );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "actiontype: \"%d\"\n", ActionType );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "isactive: \"%d\"\n", IsActive );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "row_fg: \"%s\"\n", row_fg );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "row_bg: \"%s\"\n", row_bg );
	outstr = strcat_alloc(outstr, tmpbuf);
	sprintf_s( tmpbuf, sizeof(tmpbuf), "soundname: \"%s\"\n", soundname );
	outstr = strcat_alloc(outstr, tmpbuf);


	// save filter parameters 
	if (grid->Actions[action].gridconfig->nFilters){
		sprintf_s( tmpbuf, sizeof(tmpbuf), "Tablename: \"xgridparameters\"\n" );
		outstr = strcat_alloc(outstr, tmpbuf);
	}
	for (f = 0; f < grid->Actions[action].gridconfig->nFilters; f++){
		// find column in vo that is being filtered
		searchstr = NULL;
		if ( !strlen( (ColName = grid->Actions[action].gridconfig->filters[f].field_name))) continue;
		if ( grid->Actions[action].gridconfig->filters[f].filter_type == FTYPE_LIST ){
			// filter type is a list of values
			if ( (searchvo = grid->Actions[action].gridconfig->filters[f].searchvo) ){ // vo list of values
				// get list valuesd from searchvo
				// create string of each value separated by commas, etc
				for (s = 0 ; s < searchvo->count; s++ ){
					sprintf_s( tmpbuf, sizeof(tmpbuf), "\"%s\",", VP(searchvo, s, "listval", char ));
					searchstr = strcat_alloc(searchstr, tmpbuf );
				}

			}
		} else if ( grid->Actions[action].gridconfig->filters[f].filter_type == FTYPE_OPERATORS ){
			op = grid->Actions[action].gridconfig->filters[f].op;  // op is 2 letter code, ala NE EQ LE
			cmp_value = grid->Actions[action].gridconfig->filters[f].cmp_value;
			// save op, value, and colname in DB
		}
		if (searchstr){
			sprintf_s( tmpbuf, sizeof(tmpbuf), "fieldname: \"%s\"\n" , ColName);
			outstr = strcat_alloc(outstr, tmpbuf);
			sprintf_s( tmpbuf, sizeof(tmpbuf), "select_value: \"%s\"\n" , searchstr);
			outstr = strcat_alloc(outstr, tmpbuf);
		} else {
			sprintf_s( tmpbuf, sizeof(tmpbuf), "fieldname: \"%s\"\n" , ColName);
			outstr = strcat_alloc(outstr, tmpbuf);
			sprintf_s( tmpbuf, sizeof(tmpbuf), "op: \"%s\"\n" , op);
			outstr = strcat_alloc(outstr, tmpbuf);
			sprintf_s( tmpbuf, sizeof(tmpbuf), "cmp_value: \"%s\"\n" , cmp_value);
			outstr = strcat_alloc(outstr, tmpbuf);
			sprintf_s( tmpbuf, sizeof(tmpbuf), "filter_type: \"%d\"\n" , grid->Actions[action].gridconfig->filters[f].filter_type);
			outstr = strcat_alloc(outstr, tmpbuf);
			sprintf_s( tmpbuf, sizeof(tmpbuf), "field_type: \"%d\"" , grid->Actions[action].gridconfig->filters[f].field_type);
			outstr = strcat_alloc(outstr, tmpbuf);
			sprintf_s( tmpbuf, sizeof(tmpbuf), "exclude_selected: \"%d\"\n" , grid->Actions[action].gridconfig->filters[f].exclude_selected);
			outstr = strcat_alloc(outstr, tmpbuf);
		}

	}  // end each filter

} // end each action

// send fcgi here

#endif



void ShowDataViewer(struct InstanceData* id)
{

	//// make the data viewer visible
	
	int i;
	MGLGRID *Grid;
	char *DataSource;
	VO *DataAppVO;	
	static VO *LastGFDO = NULL;

	if (HavePermission(id, "GRIDTOOL")){
		OpenglGrid = 1;
	}


	//Setting void pointers to MGLGRID struct

	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	MGLGRID* DataAppCreater = (MGLGRID*)id->DataAppCreater;
	id->DataAppGrid = DataAppGrid;
	id->DataAppCreater = DataAppCreater;
	if (DataAppGrid && DataAppGrid->parent_w){
		if (DataAppGrid->IsMinimized != 1)
		{
			DataAppGrid->parent_w->visible = TRUE;
			DataAppCreater->parent_w->visible = TRUE;
		}
		// MainTabGrid->parent_w->visible = TRUE;
	}	
	
	
	for (i = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && i < DataAppVO->count-1; i++){
		DataSource = VP(DataAppVO, i, "DataSource", char);
		Grid = VV(DataAppGrid->vo, i, "gridptr", void *);		
		if (Grid && Grid->active_icon==1){
			Grid->active_icon = 2;
			//FillFDOFromGFDO(id, Grid);
		}

	}
	
	DataAppGrid->check_firstopen = 0;
	
	MGLDrawGUI(id);
	

	
}





int multicompareSearch(char **searchstrptr, struct row_index *row_index)
{
	VO *vo;
	char *teststr, *searchstr, *colname;
	MSPARMS *ms;
	int i, tst;

	//struct row_index *row_index1;
	//struct row_index *row_index2;

	//row_index1 = *row_index1ptr;
	//row_index2 = *row_index2ptr;
	ms = (MSPARMS *)searchstrptr;

	// searchstr = *searchstrptr;
	vo = row_index->vo;

	for (i = 0; i < ms->colcount; i++){
		colname = ms->colnames[i];
		searchstr = ms->searchstrs[i];
		teststr = V_DPPTR(vo, row_index->datap, colname, char);
		if ((tst = strcmp(searchstr, teststr))){
			// does not match
			return(tst);
		}
	}
	return(0); //  match found
}






void *vo_multisearch(VO *vo, ...)
{
	va_list args;
	static void *result;
	MSPARMS *msparms;
	char *colname, *searchstr;
	int i, len;


	msparms = malloc(sizeof(MSPARMS));
	va_start(args, vo);
	/* print name of function causing error */
	// vo = (VO *) va_arg(args, VO *);
	msparms->colcount = 0;
	while ((colname = (char *)va_arg(args, char *)) && msparms->colcount < 6){

		len = strlen(colname);
		msparms->colnames[msparms->colcount] = malloc(len + 1);
		strcpy_s(msparms->colnames[msparms->colcount], len + 1, colname);
		searchstr = (char *)va_arg(args, char *);
		len = strlen(searchstr);
		msparms->searchstrs[msparms->colcount] = malloc(len + 1);
		strcpy_s(msparms->searchstrs[msparms->colcount], len + 1, searchstr);
		(msparms->colcount)++;
	}

	//result = (char **) bsearch( (char *) &searchstr,  (char *) &vo->row_index[0], vo->count,
	//                         sizeof(struct row_index), (int (*)(const void*, const void*)) multicompareSearch );

	result = (char **)bsearch((char *)msparms, (char *)&vo->row_index[0], vo->count,
		sizeof(struct row_index), (int(*)(const void*, const void*)) multicompareSearch);


	va_end(args);

	// clean up
	for (i = 0; i < msparms->colcount; i++){
		free(msparms->colnames[i]);
		free(msparms->searchstrs[i]);
	}
	free(msparms);
	return(result);

}





void MergeFDOVOFromAirASDEX(struct InstanceData *id, MGLGRID *FDOGrid)
{
	int i, rownum, ival;
	AIR **airp;
	AIR *air;
	struct row_index *row_index;
	VO *NewFDOVO = NULL;
	char *newstr;
	extern VO *CrFDOVO();

	// add in any addtional data from asdex air struct

	airp = GetASDEXAirP(id);

	for (i = 0; i < N_TRACK_ID; i++){
		if (!(air = airp[i])){
			continue;
		}

		if (!strcmp(air->FltNum, "UNKN")) continue;
		// see if the FDOGrid already has this flight ID, match flightid, origin, destination
		if ((row_index = vo_multisearch(FDOGrid->vo, "FltNum", air->FltNum, "Origin", air->Origin, NULL))){
			rownum = row_index->rownum;
			// the asdex aircraft already has a record, so add in asdex specific values
			if (air->rg_oto || air->rg_oti || air->tt){
				VV(FDOGrid->vo, rownum, "OutToOff", int) = air->rg_oto;
				VV(FDOGrid->vo, rownum, "OnToIn", int) = air->rg_oti;
				VV(FDOGrid->vo, rownum, "TaxiTime", int) = air->tt;
			}
			VV(FDOGrid->vo, rownum, "beacon", int) = air->beacon;
			if (air->td_oto){
				VV(FDOGrid->vo, rownum, "TarmacOTO", int) = air->td_oto;
			}
			if (air->td_oti){
				VV(FDOGrid->vo, rownum, "TarmacOTI", int) = air->td_oti;
			}
		} else {
			// not found, so we need to add a row to the vo
			// to avoid resorting every time we add a row, put new rows in a VO
			if (!NewFDOVO) NewFDOVO = CrFDOVO();

			vo_alloc_rows(NewFDOVO, 1);
			rownum = NewFDOVO->count - 1;
			strncpy_s(VP(NewFDOVO, rownum, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
			VV(NewFDOVO, rownum, "beacon", int) = air->beacon;
			strncpy_s(VP(NewFDOVO, rownum, "Origin", char), ORIG_DES_SIZE, air->Origin, _TRUNCATE);
			strncpy_s(VP(NewFDOVO, rownum, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
			VV(NewFDOVO, rownum, "altitude", int) = air->altitude;
			VV(NewFDOVO, rownum, "eta", int) = air->eta;
			VV(NewFDOVO, rownum, "ata", int) = air->ata;
			VV(NewFDOVO, rownum, "atd", int) = air->atd;
			VV(NewFDOVO, rownum, "speed", int) = air->speed;
			strncpy_s(VP(NewFDOVO, rownum, "actype", char), ACTYPE_SIZE, air->actype, _TRUNCATE);
			VV(NewFDOVO, rownum, "DestDis", double) = air->DestDis;
			strncpy_s(VP(NewFDOVO, rownum, "src_radar", char), 5, air->src_radar, _TRUNCATE);
			if (air->rg_oto || air->rg_oti || air->tt){
				VV(NewFDOVO, rownum, "OutToOff", int) = air->rg_oto;
				VV(NewFDOVO, rownum, "OnToIn", int) = air->rg_oti;
				VV(NewFDOVO, rownum, "TaxiTime", int) = air->tt;
			}
			if (air->td_oto){
				VV(NewFDOVO, rownum, "TarmacOTO", int) = air->td_oto;
			}
			if (air->td_oti){
				VV(NewFDOVO, rownum, "TarmacOTI", int) = air->td_oti;
			}

		}
	}

	// add in rows from prior VO
	for (i = 0; NewFDOVO && i < NewFDOVO->count; i++){
		vo_alloc_rows(FDOGrid->vo, 1);
		rownum = FDOGrid->vo->count - 1;

		newstr = VP(NewFDOVO, i, "FltNum", char);
		strncpy_s(VP(FDOGrid->vo, rownum, "FltNum", char), FLTNUM_SIZE, newstr, _TRUNCATE);
		VV(FDOGrid->vo, rownum, "Beacon", int) = VV(NewFDOVO, i, "Beacon", int);

		newstr = VP(NewFDOVO, i, "Origin", char);
		strncpy_s(VP(FDOGrid->vo, rownum, "Origin", char), FLTNUM_SIZE, newstr, _TRUNCATE);
		newstr = VP(NewFDOVO, i, "Destin", char);
		strncpy_s(VP(FDOGrid->vo, rownum, "Destin", char), FLTNUM_SIZE, newstr, _TRUNCATE);

		VV(FDOGrid->vo, rownum, "altitude", int) = VV(NewFDOVO, i, "altitude", int);
		VV(FDOGrid->vo, rownum, "eta", int) = VV(NewFDOVO, i, "eta", int);
		VV(FDOGrid->vo, rownum, "ata", int) = VV(NewFDOVO, i, "ata", int);
		VV(FDOGrid->vo, rownum, "atd", int) = VV(NewFDOVO, i, "atd", int);
		VV(FDOGrid->vo, rownum, "speed", int) = VV(NewFDOVO, i, "speed", int);
		newstr = VP(NewFDOVO, i, "actype", char);
		strncpy_s(VP(FDOGrid->vo, rownum, "actype", char), ACTYPE_SIZE, newstr, _TRUNCATE);
		VV(FDOGrid->vo, rownum, "DestDis", double) = VV(NewFDOVO, i, "DestDis", double);
		newstr = VP(NewFDOVO, i, "src_radar", char);
		strncpy_s(VP(FDOGrid->vo, rownum, "src_radar", char), 5, newstr, _TRUNCATE);
		if (VV(NewFDOVO, i, "OutToOff", int) || VV(NewFDOVO, i, "OnToIn", int) || VV(NewFDOVO, i, "TaxiTime", int)){
			newstr = VP(NewFDOVO, i, "FltNum", char);  // for debug purposes
			ival = VV(NewFDOVO, i, "OutToOff", int); // for debug purposes
			VV(FDOGrid->vo, rownum, "OutToOff", int) = VV(NewFDOVO, i, "OutToOff", int);
			ival = VV(NewFDOVO, i, "OnToIn", int); // for debug purposes
			VV(FDOGrid->vo, rownum, "OnToIn", int) = VV(NewFDOVO, i, "OnToIn", int);
			ival = VV(NewFDOVO, i, "TaxiTime", int); // for debug purposes
			VV(FDOGrid->vo, rownum, "TaxiTime", int) = VV(NewFDOVO, i, "TaxiTime", int);
		}
		if (VV(NewFDOVO, i, "TarmacOTO", int)){
			VV(FDOGrid->vo, rownum, "TarmacOTO", int) = VV(NewFDOVO, i, "TarmacOTO", int);
		}
		if (VV(NewFDOVO, i, "TarmacOTI", int)){
			VV(FDOGrid->vo, rownum, "TarmacOTI", int) = VV(NewFDOVO, i, "TarmacOTI", int);
		}
		if (!strlen(VP(FDOGrid->vo, rownum, "OriginalDestin", char))){
			// only fill orginal destination if has not been filled before
			strncpy_s(VP(FDOGrid->vo, rownum, "OriginalDestin", char), FLTNUM_SIZE,
				VP(NewFDOVO, i, "Destin", char), _TRUNCATE);
		}
	}

	if (NewFDOVO) vo_free(NewFDOVO);
	vo_order(FDOGrid->vo);
}





void GetDivertedOriginDestination(struct InstanceData* id, char* flightid, char *origin, char* dest){

	struct row_index *row_index;
	VO *DMXVO = NULL;
	static char testflt[9];


	EnterCriticalSection(&id->m_csEta);
	DMXVO = (VO*)id->m_pDMXVO;

	// similar to GetDivertedDestination, but we want the asdi_dest
	if (!strcmp(flightid, testflt) || !strlen(origin)){
		// no origin, so just check for flightid match
		if (DMXVO && (row_index = vo_search(DMXVO, "FltNum", flightid, NULL))){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "found test flight %s\n", flightid);
			strcpy_s(dest, ORIG_DES_SIZE, VP(DMXVO, row_index->rownum, "asdi_dest", char));
			D_CONTROL("DXM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Assigning diverted destination <%s> to flight <%s>\n",
				GetCurrentThreadId(), dest, flightid));
		}
	}

	if (DMXVO && (row_index = vo_multisearch(DMXVO, "FltNum", flightid, "origin", origin, NULL))){
		//  oldway   if ( DMXVO && (row_index = vo_search(DMXVO, "FltNum", flightid, NULL ))){
		strcpy_s(dest, ORIG_DES_SIZE, VP(DMXVO, row_index->rownum, "asdi_dest", char));
		D_CONTROL("DXM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Assigning diverted destination <%s> to flight <%s>\n",
			GetCurrentThreadId(), dest, flightid));
	}
	LeaveCriticalSection(&id->m_csEta);
}



void MergeFDOVOFromDMXVO(struct InstanceData *id, MGLGRID *FDOGrid)
{
	VO *DMXVO;
	int i;
	char *flightid, *origin, *orig_dest, *asdi_dest;
	struct row_index *row_index;

	// load in all of the diverted flights into the FDOVO 
	/*
			for each dmxvo diverted flight
			if already in fdovo, skip
			else add row to fdovo and copy in dmxvo data into fdovo

			*/

	EnterCriticalSection(&id->m_csEta);
	DMXVO = id->m_pDMXVO;
	for (i = 0; DMXVO && i < DMXVO->count - 1; i++){
		flightid = VP(DMXVO, i, "FltNum", char);
		origin = VP(DMXVO, i, "origin", char);

		// FDOGrid->vo must be ordered by FltNum and Origin for search to work
		if ((row_index = vo_multisearch(FDOGrid->vo, "FltNum", flightid, "Origin", origin, NULL))){
			// already ion grid
		} else {
			// add to FDOVO

			orig_dest = VP(DMXVO, i, "orig_dest", char);
			asdi_dest = VP(DMXVO, i, "asdi_dest", char);

			vo_alloc_rows(FDOGrid->vo, 1);
			strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "FltNum", char), FLTNUM_SIZE, flightid, _TRUNCATE);
			strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Origin", char), FLTNUM_SIZE, origin, _TRUNCATE);
			strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "OriginalDestin", char), FLTNUM_SIZE, orig_dest, _TRUNCATE);
			strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Destin", char), FLTNUM_SIZE, asdi_dest, _TRUNCATE);
		}
	}

	LeaveCriticalSection(&id->m_csEta);

	vo_order(FDOGrid->vo);

}



void FillFDOFromGFDO(struct InstanceData *id, MGLGRID *FDOGrid)
{
	int i;
	VO *LFDO;
	char *FltNum;



	if (!FDOGrid){
		return;
	}
	// fill a vo with all the unique values in this columns for all rows
	if (!FDOGrid->vo){
		FDOGrid->vo = CrFDOVO(FDOGrid);
	}
	if (FDOGrid && FDOGrid->vo){
		vo_rm_rows(FDOGrid->vo, 0, FDOGrid->vo->count);
	}



	// get local copy of GFDO
	// while creating the fdo, we disable the thread from overwriting the GFDO
	EnterCriticalSection(&id->m_csEta);
	LFDO = (VO*)id->GFDO;

	if (!LFDO){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "NULL LFDO\n");
		LeaveCriticalSection(&id->m_csEta);
		return;
	}

	for (i = 0; LFDO && i < LFDO->count; i++){

		vo_alloc_rows(FDOGrid->vo, 1);

		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "FltNum", char), FLTNUM_SIZE, VP(LFDO, i, "FltNum", char), _TRUNCATE);
		FltNum = VP(FDOGrid->vo, FDOGrid->vo->count - 1, "FltNum", char);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Origin", char), FLTNUM_SIZE, VP(LFDO, i, "Origin", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Destin", char), FLTNUM_SIZE, VP(LFDO, i, "Destin", char), _TRUNCATE);

		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "eta", int) = VV(LFDO, i, "eta", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "ata", int) = VV(LFDO, i, "ata", int);

		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "std", int) = VV(LFDO, i, "std", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "etd", int) = VV(LFDO, i, "etd", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "atd", int) = VV(LFDO, i, "atd", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "sta", int) = VV(LFDO, i, "sta", int);


		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "actype", char), ACTYPE_SIZE, VP(LFDO, i, "actype", char), _TRUNCATE);

	//	strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "gate", char), GATE_SIZE, VP(LFDO, i, "gate", char), _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "outtime", int) = VV(LFDO, i, "outtime", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "offtime", int) = VV(LFDO, i, "offtime", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "ontime", int) = VV(LFDO, i, "ontime", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "intime", int) = VV(LFDO, i, "intime", int);


	//	VV(FDOGrid->vo, FDOGrid->vo->count - 1, "d_sta", int) = VV(LFDO, i, "d_sta", int);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "d_actype", char), ACTYPE_SIZE, VP(LFDO, i, "d_actype", char), _TRUNCATE);
	//	VV(FDOGrid->vo, FDOGrid->vo->count - 1, "bestarrgmtts", int) = VV(LFDO, i, "bestarrgmtts", int);
		//VV(FDOGrid->vo, FDOGrid->vo->count - 1, "drag_off", int) = VV(LFDO, i, "drag_off", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "psgr_clseout", int) = VV(LFDO, i, "psgr_clseout", int);

		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "intdprtgate", char), GATE_SIZE, VP(LFDO, i, "intdprtgate", char), _TRUNCATE);
		//strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "prevpubdprtgate", char), GATE_SIZE, VP(LFDO, i, "prevpubdprtgate", char), _TRUNCATE);


		//strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "prevpubarrgate", char), GATE_SIZE, VP(LFDO, i, "prevpubarrgate", char), _TRUNCATE);
	//	strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "previntdprtgate", char), GATE_SIZE, VP(LFDO, i, "previntdprtgate", char), _TRUNCATE);
	//	strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "previntarrgate", char), GATE_SIZE, VP(LFDO, i, "previntarrgate", char), _TRUNCATE);
	//	strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "defaultdprtgateind", char), GATE_SIZE, VP(LFDO, i, "defaultdprtgateind", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "int_arr_gate", char), GATE_SIZE, VP(LFDO, i, "int_arr_gate", char), _TRUNCATE);

		//VV(FDOGrid->vo, FDOGrid->vo->count - 1, "arr_gate_time", int) = VV(LFDO, i, "arr_gate_time", int);
		//VV(FDOGrid->vo, FDOGrid->vo->count - 1, "dprt_gate_time", int) = VV(LFDO, i, "dprt_gate_time", int);
	//	strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "default_arr_gate_ind", char), GATE_SIZE, VP(LFDO, i, "default_arr_gate_ind", char), _TRUNCATE);
	//	VV(FDOGrid->vo, FDOGrid->vo->count - 1, "lst_upd_time", int) = VV(LFDO, i, "lst_upd_time", int);

		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "tbfm_offtime", int) = VV(LFDO, i, "tbfm_offtime", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "tbfm_ontime", int) = VV(LFDO, i, "tbfm_ontime", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "tbfm_freezetime", int) = VV(LFDO, i, "tbfm_freezetime", int);

		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "cargo_door_clsd", int) = VV(LFDO, i, "cargo_door_clsd", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "cargo_door_open", int) = VV(LFDO, i, "cargo_door_open", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "pax_door_clsd", int) = VV(LFDO, i, "pax_door_clsd", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "pax_door_open", int) = VV(LFDO, i, "pax_door_open", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "bridge_on_time", int) = VV(LFDO, i, "bridge_on_time", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "crew_out_time", int) = VV(LFDO, i, "crew_out_time", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "brake_released", int) = VV(LFDO, i, "brake_released", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "brake_set", int) = VV(LFDO, i, "brake_set", int);

		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "dep_gate", char), GATE_SIZE, VP(LFDO, i, "dep_gate", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "arr_gate", char), GATE_SIZE, VP(LFDO, i, "arr_gate", char), _TRUNCATE);


		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "acars_init", int) = VV(LFDO, i, "acars_init", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "first_msg", int) = VV(LFDO, i, "first_msg", int);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "old_fid", char), FLTNUM_SIZE, VP(LFDO, i, "old_fid", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "fps", char), FLTNUM_SIZE, VP(LFDO, i, "fps", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "acs", char), FLTNUM_SIZE, VP(LFDO, i, "acs", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "sfzflag", char), FLTNUM_SIZE, VP(LFDO, i, "sfzflag", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "rfzflag", char), FLTNUM_SIZE, VP(LFDO, i, "rfzflag", char), _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "rwy_freeze", int) = VV(LFDO, i, "rwy_freeze", int);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "actype", char),12, VP(LFDO, i, "actype", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "tracon_rwy", char), FLTNUM_SIZE, VP(LFDO, i, "tracon_rwy", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "arr_rwy", char), FLTNUM_SIZE, VP(LFDO, i, "arr_rwy", char), _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "edc_status", char), FLTNUM_SIZE, VP(LFDO, i, "edc_status", char), _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "edc_time", int) = VV(LFDO, i, "edc_time", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "tbfm_etd", int) = VV(LFDO, i, "tbfm_etd", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "sta_at_rwy", int) = VV(LFDO, i, "sta_at_rwy", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "eta_at_rwy", int) = VV(LFDO, i, "eta_at_rwy", int);

		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Assigned Gate Status", char), 32, VP(LFDO, i, "Assigned Gate Status", char), _TRUNCATE);
		
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "estdprtctrlgmtts", int) = VV(LFDO, i, "estdprtctrlgmtts", int);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "estdprtctrlgmttssrc", char), 32, VP(LFDO, i, "estdprtctrlgmttssrc", char), _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "brdngstrtdgmtts", int) = VV(LFDO, i, "brdngstrtdgmtts", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "paxdrclsgmtts", int) = VV(LFDO, i, "paxdrclsgmtts", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "readytodprtgmtts", int) = VV(LFDO, i, "readytodprtgmtts", int);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "onlinetsgmt", int) = VV(LFDO, i, "onlinetsgmt", int);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "draggateid", char), 32, VP(LFDO, i, "draggateid", char), _TRUNCATE);

	}
	vo_order(FDOGrid->vo);

	// merge in addtional data from ASDEX air struct
	///MergeFDOVOFromAirASDEX(id, FDOGrid);
	//MergeFDOVOFromDMXVO(id, FDOGrid);  // merge in diversion that were not already loaded into FDO from AirVO



	LeaveCriticalSection(&id->m_csEta);

}

/*VO *CrSAVO()
{
VO *SAVO;

SAVO = (VO *)vo_create(0, NULL);
vo_set(SAVO, V_NAME, "SAVO", NULL);

VOPropAdd(SAVO, "seqnum", INTBIND, -1, VO_NO_ROW);
VOPropAdd(SAVO, "appname", NTBSTRINGBIND, APPNAME_SIZE, VO_NO_ROW);
VOPropAdd(SAVO, "username", NTBSTRINGBIND, USERNAME_SIZE, VO_NO_ROW);
VOPropAdd(SAVO, "alertname", NTBSTRINGBIND, ALERTNAME_SIZE, VO_NO_ROW);


VOPropAdd(SAVO, "priority", NTBSTRINGBIND, PRIORITY_SIZE, VO_NO_ROW);
VOPropAdd(SAVO, "starttime", INTBIND, -1, VO_NO_ROW);  // in unix time
VOPropAdd(SAVO, "endtime", INTBIND, -1, VO_NO_ROW);
VOPropAdd(SAVO, "comments", NTBSTRINGBIND, COMMENTS_SIZE, VO_NO_ROW); // comments
VOPropAdd(SAVO, "alertsource", NTBSTRINGBIND, ALERTSOURCE_SIZE, VO_NO_ROW);
VOPropAdd(SAVO, "keyvalues", NTBSTRINGBIND, KEYVALUES_SIZE, VO_NO_ROW);

vo_rm_rows(SAVO, 0, SAVO->count);

//vo_set(FDOVO, V_ORDER_COLS, "FltNum", "Origin", NULL, NULL);

return(SAVO);
}*/


void FillSysAlertsFromGSA(struct InstanceData *id, MGLGRID *SysAlertsGrid)
{
	int i;
	VO *LFDO;
	int temp_seq = 0;
	char temp_appname[APPNAME_SIZE];
	char temp_username[USERNAME_SIZE];
	char temp_alertname[ALERTNAME_SIZE];
	char temp_priority[PRIORITY_SIZE];
	int temp_starttime = 0;
	int temp_endtime = 0;
	char temp_comments[COMMENTS_SIZE];
	char temp_alertsource[ALERTSOURCE_SIZE];
	//char temp_keyvalues[KEYVALUES_SIZE];
	extern VO *CrSAVO();


	if (!SysAlertsGrid){
		return;
	}
	// fill a vo with all the unique values in this columns for all rows
	if (!SysAlertsGrid->vo){
		SysAlertsGrid->vo = CrSAVO(SysAlertsGrid);
	}
	if (SysAlertsGrid && SysAlertsGrid->vo){
		vo_rm_rows(SysAlertsGrid->vo, 0, SysAlertsGrid->vo->count);
	}



	// get local copy of GFDO
	// while creating the fdo, we disable the thread from overwriting the GFDO
	EnterCriticalSection(&id->m_csEta);
	LFDO = (VO*)id->GSA;

	if (!LFDO){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "NULL LFDO\n");
		LeaveCriticalSection(&id->m_csEta);
		return;
	}

	for (i = 0; LFDO && i < LFDO->count; i++){

		vo_alloc_rows(SysAlertsGrid->vo, 1);

		VV(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "seqnum", int) = VV(LFDO, i, "seqnum", int);

		temp_seq = VV(LFDO, i, "seqnum", int);
		strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "appname", char), APPNAME_SIZE, VP(LFDO, i, "appname", char), _TRUNCATE);
		strncpy_s(temp_appname, APPNAME_SIZE, VP(LFDO, i, "appname", char), _TRUNCATE);
		strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "username", char), USERNAME_SIZE, VP(LFDO, i, "username", char), _TRUNCATE);
		strncpy_s(temp_username,USERNAME_SIZE, VP(LFDO, i, "username", char), _TRUNCATE);
		strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "alertname", char), ALERTNAME_SIZE, VP(LFDO, i, "alertname", char), _TRUNCATE);
		strncpy_s(temp_alertname, ALERTNAME_SIZE, VP(LFDO, i, "alertname", char), _TRUNCATE);
		strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "priority", char), PRIORITY_SIZE, VP(LFDO, i, "priority", char), _TRUNCATE);
		strncpy_s(temp_priority, PRIORITY_SIZE, VP(LFDO, i, "priority", char), _TRUNCATE);
		

		VV(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "starttime", int) = VV(LFDO, i, "starttime", int);
		temp_starttime= VV(LFDO, i, "starttime", int);
		VV(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "endtime", int) = VV(LFDO, i, "endtime", int);
		temp_endtime = VV(LFDO, i, "endtime", int);

		strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "comments", char), COMMENTS_SIZE, VP(LFDO, i, "comments", char), _TRUNCATE);
		strncpy_s(temp_comments, COMMENTS_SIZE, VP(LFDO, i, "comments", char), _TRUNCATE);
		strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "alertsource", char), ALERTSOURCE_SIZE, VP(LFDO, i, "alertsource", char), _TRUNCATE);
		strncpy_s(temp_alertsource, ALERTSOURCE_SIZE, VP(LFDO, i, "alertsource", char), _TRUNCATE);
		//strncpy_s(VP(SysAlertsGrid->vo, SysAlertsGrid->vo->count - 1, "keyvalues", char), KEYVALUES_SIZE, VP(LFDO, i, "keyvalues", char), _TRUNCATE);
		//strncpy_s(temp_keyvalues, KEYVALUES_SIZE, VP(LFDO, i, "keyvalues", char), _TRUNCATE);
	
	}
	vo_order(SysAlertsGrid->vo);

	LeaveCriticalSection(&id->m_csEta);

}








void FillFDOVOFromAir(struct InstanceData *id, MGLGRID *FDOGrid)
{
	// file the vo from the 4 Air struct data (ASDI, ASDEX, PASSUR)
	int i;
	AIR **airp;
	AIR *air;
	static char testflt[9];
	static int testcode = 0;

	airp = GetASDAirP(id);

	if (FDOGrid && FDOGrid->vo){
		vo_rm_rows(FDOGrid->vo, 0, FDOGrid->vo->count);
	}

	for (i = 0; i < N_TRACK_ID; i++){
		if (!(air = airp[i])){
			continue;
		}
		vo_alloc_rows(FDOGrid->vo, 1);

		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "beacon", int) = air->beacon;
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Origin", char), FLTNUM_SIZE, air->Origin, _TRUNCATE);
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "altitude", int) = air->altitude;
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "eta", int) = air->eta;
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "ata", int) = air->ata;
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "atd", int) = air->atd;
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "speed", int) = air->speed;
		strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "actype", char), ACTYPE_SIZE, air->actype, _TRUNCATE);
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "DestDis", double) = air->DestDis;
		// strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "src_radar", char), 5, air->src_radar, _TRUNCATE);

		//if ( air->FltRoute && strlen( air->FltRoute ) ){
		//  may crash if air pointer changes	VV(FDOGrid->vo, FDOGrid->vo->count - 1, "FltRoute", void *) = (void *) air->FltRoute;
		//}

		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "OutToOff", int) = air->rg_oto;
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "OnToIn", int) = air->rg_oti;
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "TaxiTime", int) = air->tt;
		// tarmac data from tarmac delay module via vg's fcgi
		if (air->td_oto){
			VV(FDOGrid->vo, FDOGrid->vo->count - 1, "TarmacOTO", int) = air->td_oto;
		}
		VV(FDOGrid->vo, FDOGrid->vo->count - 1, "TarmacOTI", int) = air->td_oti;



		if (!strlen(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "OriginalDestin", char))){
			// only fill orginal destination if has not been filled before
			strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "OriginalDestin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
		}

		// ........ must write our own diversion query, we need origin or else legs will get messed up origin and destination
		GetDivertedOriginDestination(id, air->FltNum, air->Origin, air->DivDestin);
		if (strlen(air->DivDestin)){
			// fill in new Destination from DivDestin in Air struct
			strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "Destin", char), FLTNUM_SIZE, air->DivDestin, _TRUNCATE);

			if (!strlen(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "OriginalDestin", char))){
				// we have a diverted destination, but not a destination???
				// fill is divdestination as the destination, NOT a diversion???
				strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "OriginalDestin", char), FLTNUM_SIZE, air->DivDestin, _TRUNCATE);
			}

		}

		// test code below
		if (testcode){
			if (!strcmp(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "FltNum", char), testflt)){
				// found test aircraft
				strncpy_s(VP(FDOGrid->vo, FDOGrid->vo->count - 1, "OriginalDestin", char), FLTNUM_SIZE, "KXYZ", _TRUNCATE);
			}
		}


	}

	vo_order(FDOGrid->vo);


	// merge in addtional data from ASDEX air struct
	MergeFDOVOFromAirASDEX(id, FDOGrid);

	MergeFDOVOFromDMXVO(id, FDOGrid);  // merge in diversion that were not already loaded into FDO from AirVO


}



#ifdef OLDWAY

void FillFDOVO(struct InstanceData* id, MGLGRID *FDOGrid)
{

	// fill a vo with all the unique values in this columns for all rows
	if (!FDOGrid->vo){
		FDOGrid->vo = CrFDOVO(FDOGrid);
	}  else {
		// already created the FDOGrid->vo
		return;
	}

	FillFDOVOFromAir(id, FDOGrid);  // fills from asdi and asdex

}

#endif


#ifdef USE_OLD_GRID
int SaveUserRoiSettings(struct InstanceData *id, char *user, char *arpt, char *configname, GridConfig *roi)
{
	char	tmpstr[32768];
	char	appStr[2048];
	char	tableStr[2048];
	char	filterStr[2048];
	char	colStr[4096];
	int		i;
	const char	*str;
	char	*dataOut;

	struct	MemoryStruct chunk;

	json_object *	jHcpObj[7] = {NULL};
	json_object *	jAppDataObj = NULL;
	json_object *	jTableConfObj = NULL;
	json_object *	jFilterObj = NULL;

	if (user == NULL || strlen(user) == 0)
		return (FALSE);

	if (arpt == NULL || strlen(arpt) == 0)
		return (FALSE);

	if (configname == NULL || strlen(configname) == 0)
		return (FALSE);

	if (roi == NULL)
		return (FALSE);

	jAppDataObj = mkRoiAppDataObj(roi);
	jTableConfObj = mkRoiTableConf(roi);
	jFilterObj = mkRoiFilter(roi);
	mkRoiColumns(roi, jHcpObj);

	memset(tmpstr, 0, sizeof(tmpstr));
	_snprintf_s(tmpstr, sizeof(tmpstr), _TRUNCATE, "Action=SaveDGTConfig&appname=ROI&user=%s&arpt=%s&name=%s", user, arpt, configname);

	// appdata
	str = json_object_to_json_string(jAppDataObj);
	dataOut = curl_escape(str, strlen(str));

	_snprintf_s(appStr, sizeof(appStr), _TRUNCATE, "&appdata=%s", dataOut);
	strncat_s(tmpstr, sizeof(tmpstr), appStr, _TRUNCATE);
	curl_free(dataOut);
	json_object_put(jAppDataObj);

	// table data
	str = json_object_to_json_string(jTableConfObj);
	dataOut = curl_escape(str, strlen(str));

	_snprintf_s(tableStr, sizeof(tableStr), _TRUNCATE, "&table=%s", dataOut);
	strncat_s(tmpstr, sizeof(tmpstr), tableStr, _TRUNCATE);

	curl_free(dataOut);
	json_object_put(jTableConfObj);

	// filter data
	str = json_object_to_json_string(jFilterObj);
	dataOut = curl_escape(str, strlen(str));

	_snprintf_s(filterStr, sizeof(filterStr), _TRUNCATE, "&filter=%s", dataOut);
	strncat_s(tmpstr, sizeof(tmpstr), filterStr, _TRUNCATE);

	curl_free(dataOut);
	json_object_put(jFilterObj);

	strncat_s(tmpstr, sizeof(tmpstr), "&hcpcount=7", _TRUNCATE);

	for (i=0; i<7; i++)
	{
		str = json_object_to_json_string(jHcpObj[i]);
		dataOut = curl_escape(str, strlen(str));

		_snprintf_s(colStr, sizeof(colStr), _TRUNCATE, "&hcp%d=%s", i, dataOut);
		strncat_s(tmpstr, sizeof(tmpstr), colStr, _TRUNCATE);

		curl_free(dataOut);
		json_object_put(jHcpObj[i]);
	}

	chunk.memory = NULL;
	chunk.size = 0;

	if ( !GetCurlFormPostResults( id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE ))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to save ROI Config\n", GetCurrentThreadId());
		GetNxtSurfSrvr(id);
	}
	else
	{
		// Check for valid data from server
		if (chunk.memory)
		{
			if (!strstr(chunk.memory, "404 Not Found"))
			{
				char* data = curl_unescape(chunk.memory, strlen(chunk.memory));

				curl_free(data);
			}
		}
	}

	return (TRUE);
}

VO * parseRoiNamesObject(json_object *jobj)
{
	VO * namesVO = NULL;

	// jNames is an array of strings - configuration names
	struct json_object *jNames = json_object_object_get(jobj, "names");

	if (jNames && json_type_array == json_object_get_type(jNames))
	{
		int nPos, nLen = json_object_array_length(jNames);
		for (nPos = 0; nPos < nLen; nPos++)
		{
			struct json_object* jElem = json_object_array_get_idx(jNames, nPos);

			if ( namesVO == NULL )
			{
				namesVO = (VO *) vo_create( 0, NULL );
				vo_set( namesVO, V_NAME, "GridConfigNamesVO", NULL );
				VOPropAdd( namesVO, "confname", NTBSTRINGBIND, 32, VO_NO_ROW );
				vo_rm_rows( namesVO, 0, namesVO->count );
			}
			vo_alloc_rows( namesVO, 1 );

			strncpy_s( VP(namesVO, namesVO->count - 1, "confname", char), 32, json_object_get_string(jElem), _TRUNCATE );
		}
	}
	return (namesVO);
}

VO * ListUserRoiConfig (struct InstanceData *id, char *user, char *arpt)
{
	VO	* namesVO = NULL;
	char username[64];
	char tmpstr [ 4096 ];
	struct MemoryStruct chunk;
	struct json_object* jobj = NULL;
	enum json_tokener_error jerror;

	if (user == NULL || arpt == NULL)
		return (NULL);

	if (strlen(user) == 0 || strlen(arpt) == 0)
		return (NULL);

	strncpy_s( username, sizeof(username), user, _TRUNCATE );
	StrUpper(username);

	// Query the server to get the list of ROI Configurations for this user/arpt
	chunk.size = 0;
	chunk.memory = NULL;

	_snprintf_s(tmpstr, sizeof(tmpstr), _TRUNCATE, "Action=ListDGTConfig&appname=ROI&user=%s&arpt=%s", username, arpt);

	if ( !GetCurlFormPostResults( id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE ))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to save layout\n", GetCurrentThreadId());
		GetNxtSurfSrvr(id);
	}
	else
	{
		// Check for valid data from server
		if (chunk.memory)
		{
			if (!strstr(chunk.memory, "404 Not Found"))
			{
				char* data = curl_unescape(chunk.memory, strlen(chunk.memory));

				jobj = json_tokener_parse_verbose(data, &jerror);
				if (jobj && jerror == json_tokener_success)
				{
					namesVO = parseRoiNamesObject(jobj);
					json_object_put(jobj);
				}

				curl_free(data);
			}
		}
	}

	free_chunk_memory(&chunk);
	return (namesVO);
}

int DeleteUserRoiConfig(struct InstanceData *id, char *user, char *arpt, char *configname)
{
	char username[64];
	char tmpstr [ 4096 ];
	struct MemoryStruct chunk;
	struct json_object* jobj = NULL;

	if (user == NULL || strlen(user) == 0)
		return (FALSE);

	if (arpt == NULL || strlen(arpt) == 0)
		return (FALSE);

	if (configname == NULL || strlen(configname) == 0)
		return (FALSE);

	strncpy_s( username, sizeof(username), user, _TRUNCATE );
	StrUpper(username);

	chunk.size = 0;
	chunk.memory = NULL;

	_snprintf_s(tmpstr, sizeof(tmpstr), _TRUNCATE, "Action=DeleteDGTConfig&appname=ROI&user=%s&arpt=%s&name=%s", username, arpt, configname);

	if ( !GetCurlFormPostResults( id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE ))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to delete ROI configuration\n", GetCurrentThreadId());
		GetNxtSurfSrvr(id);
	}
	else
	{
		// Check for valid data from server
		if (chunk.memory)
		{
			if (!strstr(chunk.memory, "404 Not Found"))
			{
				char* data = curl_unescape(chunk.memory, strlen(chunk.memory));

				curl_free(data);
			}
		}
	}

	free_chunk_memory(&chunk);

	return (TRUE);
}

#endif

int CalcFeedXY(struct InstanceData* id, double lon, double lat, int *feedx, int* feedy, int passurindex)
{
	/* 0.621371 miles per km, so 8.6 miles * 1/0.621371 * 1000 */
	/* from jfk apdata file lonlat=-73.75,40.666666 of center of passur
	coordinate system */
	int yoffset, xoffset;
	double rads, degree_long, xmiles, ymiles, deltalng,
		realdelta;

	/* calulate lat lon of this point using simple equations for
	lat/lon */
	/* To convert radians into degrees you should multiply by 180/pi.
	To convert degrees into radians you should multiply by pi/180. */

	rads = id->m_dLatitudes[passurindex] * M_PI / 180.0;
	degree_long = 69.172 * cos(rads);

	/* printf("newlat=%g newlng = %g\n", newlat, newlng ); */

	/* project coordinates using square projection method */

	if (projflag){
		deltalng = lon - LngOrig;
		realdelta = deltalng / cos(lat * M_PI / 180.0);
		lon = LngOrig - realdelta;
	}

	/* convert from degrees */
	ymiles = 69.172 * (lat - id->m_dLatitudes[passurindex]);
	xmiles = degree_long * (lon - id->m_dLongitudes[passurindex]);

	/* convert offset in miles into meters */
	/* 1 meter = .00062 miles */
	xoffset = (int)(xmiles / 0.00062);
	yoffset = (int)(ymiles / 0.00062);

	/* offset in meters from origin at center of map */
	*feedy = (int)(yoffset - id->m_dZeroY[passurindex]);
	*feedx = (int)(xoffset - id->m_dZeroX[passurindex]);

	return(SUCCEED);
}

void AdjustADSBTrackId(struct InstanceData* id, struct feedstruct *record)
{
	// We generally will use the beacon code becuase we are not getting Track ID's in ADS-B feed
	// sometimes get duplicate codes, so we need to generate a new Track ID
	AIR **airp;
	AIR *air;
	uint32_t h1 = 0, h2 = 0;

	airp = GetADSBAirP(id);
	if (air = airp[record->TrackID]){
		// Make sure found track icao24 matches
		if (record->icao24 != air->icao24){
			h1 = record->TrackID;
			do
			{
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)Collision Detected: ICAO24:%d, TRACK:%d has ICAO24: %d\n",
					GetCurrentThreadId(), record->icao24, record->TrackID, air->icao24);
				hashlittle2(&record->icao24, 6, &h1, &h2);
				h1 = h1 & hashmask(14);
				h2 = h2 & hashmask(14);

				// Try next hash h1 (TrackID has already been hashed once)
				if (air = airp[h1]){
					if (record->icao24 == air->icao24){
						record->TrackID = h1;
						break;
					}
				}else{
					record->TrackID = h1;
					break;
				}

				// Try next hash h2 
				if (air = airp[h2]){
					if (record->icao24 == air->icao24){
						record->TrackID = h2;
						break;
					}
				}else{
					record->TrackID = h2;
					break;
				}
			} while (TRUE);
		}
	}
}

void AdjustMLATTrackId(struct InstanceData* id, struct feedstruct *record)
{
	// We generally will use the beacon code becuase we are not getting Track ID's in ADS-B feed
	// sometimes get duplicate codes, so we need to generate a new Track ID
	AIR **airp;
	AIR *air;
	uint32_t h1 = 0, h2 = 0;

	airp = GetMLATAirP(id);
	if (air = airp[record->TrackID]){
		// Make sure found track icao24 matches
		if (record->icao24 != air->icao24){
			h1 = record->TrackID;
			do
			{
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)Collision Detected: ICAO24:%d, TRACK:%d has ICAO24: %d\n",
					GetCurrentThreadId(), record->icao24, record->TrackID, air->icao24);
				hashlittle2(&record->icao24, 6, &h1, &h2);
				h1 = h1 & hashmask(14);
				h2 = h2 & hashmask(14);

				// Try next hash h1 (TrackID has already been hashed once)
				if (air = airp[h1]){
					if (record->icao24 == air->icao24){
						record->TrackID = h1;
						break;
					}
				}else{
					record->TrackID = h1;
					break;
				}

				// Try next hash h2 
				if (air = airp[h2]){
					if (record->icao24 == air->icao24){
						record->TrackID = h2;
						break;
					}
				}else{
					record->TrackID = h2;
					break;
				}
			} while (TRUE);
		}
	}
}

void LoadADSBTrackID(struct InstanceData* id, struct feedstruct *record)
{
	AIR **airp;
	AIR *air;
	int i;
	int bFound = FALSE;
	// Check ASDE-X first
	if (id->m_sCurLayout.m_bShowASDEXAircraft){
		airp = GetASDEXAirP(id);
		for (i = 0; i < N_PASSUR_TRACK_ID; i++){
			if (!(air = airp[i])){
				continue;
			}

			if (!strcasecmp(record->FltNum, air->FltNum)){
				bFound = TRUE;
				record->TrackID = i;
			}
		}
	}

	// Check PASSUR Second
	if (!bFound && id->m_sCurLayout.m_bShowPassurAircraft){
		airp = GetAirP(id, 0);
		for (i = 0; i < N_PASSUR_TRACK_ID; i++){
			if (!(air = airp[i])){
				continue;
			}

			if (!strcasecmp(record->FltNum, air->FltNum)){
				bFound = TRUE;
				record->TrackID = i;
			}
		}
	}

	// Check ASDI
	if (!bFound){
		airp = GetASDAirP(id);
		for (i = 0; i < N_TRACK_ID; i++){
			if (!(air = airp[i])){
				continue;
			}
			if (!strcasecmp(record->FltNum, air->FltNum)){
				bFound = TRUE;
				record->TrackID = i;
			}
		}
	}

	//if(!bFound){
	//	// Last option, need something maybe?
	//	record->TrackID = record->beacon;
	//}
}

int IsTailNumber(struct InstanceData* id, const char* fltnum){
	int bTail = FALSE;
	if(strlen(fltnum) && (isdigit(fltnum[0]) || ('N' == fltnum[0] && isdigit(fltnum[1]))))
		bTail = TRUE;
	return bTail;
}

struct feedstruct *RdRecTypeADSB(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char *endstr;
	int len, evnoddc, checksum, quality;
	int bTail = FALSE;
	unsigned uval;
	float flat, flon;
	char tmpstr[NAMESIZE];

	/* format U_TARGET, record #1
	example:
	a97282,1530,CKS207,42.48232,-71.07624,32798,49d82e61,2d

	Field 1 - ICAO in Hex
	Field 2 - Beacon Code
	Field 3 - Flight ID ( none, period)
	Field 4 - Lat / DIVIDE BY 1 MILL
	Field 5 - Long	/ DIVIDE BY 1 MILL
	Field 6 - Altitude
	Field 7 - UNIX time (hex)
	Field 8 - evnoddc
	Field 9 - Tail Number
	Field 10 - Checksum */

	/* recstr pointing at field #1 = ICAO */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s(tmpstr, "%x", &uval);
	record->icao24 = uval;

	recstr = endstr;
	recstr++;  /* recstr pointing at field #2 Beacon Code */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	if (0 == len){
		// Handles empty beacon code field
		len = 4;
		strncpy_s(tmpstr, NAMESIZE, "0000", len);
	}else
		strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	sscanf_s(tmpstr, "%o", &uval);
	if (0 == uval){
		// Bad Beacon code
		//return( NULL );
	}
	record->beacon = uval;

	recstr = endstr;
	recstr++;
	/* recstr pointing at field #3. Flight ID (ex. COA18 means Continental Flight 18)*/
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	bTail = IsTailNumber(id, tmpstr);
	if(!(!strcmp(".", tmpstr) || !strcmp("@@@@@@@", tmpstr) || bTail)){
		strncpy_s(record->FltNum, FLTNUM_SIZE, tmpstr, _TRUNCATE);
	}

	// Use beacon code for TrackID (not sure if this is an issue).	
	record->TrackID = hashlittle(&record->icao24, 6, 0) & hashmask(14);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #4-- latitude */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s(tmpstr, "%f", &flat);
	flat /= 1000000;
	recstr = endstr;
	recstr++;  /* recstr pointing at field #5 - longitude */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s(tmpstr, "%f", &flon);
	flon /= 1000000;
	// Convert fval to feed
	CalcFeedXY(id, flon, flat, &record->feedx, &record->feedy, 0);

	recstr = endstr;
	recstr++; /* recstr pointing at field #6, Altitude*/
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	record->altitude = atoi(tmpstr); /* in 100 ft. */

	recstr = endstr;
	recstr++;  /* recstr pointing at field #7.  THIS IS TIME  -UNIX time */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s(tmpstr, "%x", &uval);

	record->eventtime = (long)uval;

	/* recstr pointing at field #8.  THIS IS evnoddc   */
	recstr = endstr;
	recstr++;
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s(tmpstr, "%x", &uval);
	evnoddc = uval;
	quality = evnoddc / 4 & 0x1F;
	record->evnoddc = evnoddc;
	// Check Quality for Discarding
	if (evnoddc & 0x02){
		// On Surface
		if (quality >= 8){
			D_CONTROL("ADSB_DATA", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)DROPPING SURFACE FLIGHT: %s, TRACK:%d, LAT:%f, LON:%f, XY(%d, %d), ALT(%d), E/O(%d), Q(%d), TIME:%d\n",
				GetCurrentThreadId(), record->FltNum, record->TrackID, flat, flon, record->feedx, record->feedy, record->altitude, evnoddc, quality, record->eventtime));
			return(NULL);
		}
	}else{
		// In Air
		if (quality >= 18){
			D_CONTROL("ADSB_DATA", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)DROPPING FLIGHT: %s, TRACK:%d, LAT:%f, LON:%f, XY(%d, %d), ALT(%d), E/O(%d), Q(%d), TIME:%d\n",
				GetCurrentThreadId(), record->FltNum, record->TrackID, flat, flon, record->feedx, record->feedy, record->altitude, evnoddc, quality, record->eventtime));
			return(NULL);
		}
	}

	recstr = endstr;
	recstr++;
	/* recstr pointing at field #9. Tail Number*/
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	strncpy_s(record->tail, N_TAIL_SIZE, tmpstr, _TRUNCATE);

	/* recstr pointing at field #9.  THIS IS checksum   */
	recstr = endstr;
	recstr++;
	len = strlen(recstr);
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s(tmpstr, "%X", &uval);
	checksum = uval;

	D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT: %s, ICAO24:%X, BEACON(%04o), TAIL: %s, TRACK:%d, LAT:%f, LON:%f, XY(%d, %d), ALT(%d), E/O(%d), Q(%d), TIME:%d\n",
		GetCurrentThreadId(), record->FltNum, record->icao24, record->beacon, record->tail, record->TrackID, flat, flon, record->feedx, record->feedy, record->altitude, evnoddc, quality, record->eventtime));
	return(record);
}

struct feedstruct *RdRecType60(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	float flat = 0.0f, flon = 0.0f;
	int len, evnoddc, quality;
	int bTail = FALSE;
	unsigned uval;
	char tmpstr[NAMESIZE];

	/* format U_TARGET, record #1
	example:
	a97282,1530,CKS207,42.48232,-71.07624,32798,49d82e61,2d

	Field 1 - ICAO in Hex
	Field 2 - Beacon Code
	Field 3 - Flight ID ( none, period)
	Field 4 - NULL
	Field 5 - NULL
	Field 6 - Altitude
	Field 7 - UNIX time (hex)
	Field 8 - evnoddc
	Field 9 - Tail Number
	Field 10 - Checksum */

	/* recstr pointing at field #1 = ICAO */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	sscanf_s(tmpstr, "%x", &uval);
	record->icao24 = uval;

	/* recstr pointing at field #2 Beacon Code */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	len = strlen(tmpstr);
	if (0 == len){
		// Handles empty beacon code field
		len = 4;
		strncpy_s(tmpstr, NAMESIZE, "0000", len);
	tmpstr[len] = '\0';
	}
	sscanf_s( tmpstr, "%o", &uval );
	record->beacon = uval;

	/* recstr pointing at field #3. Flight ID (ex. COA18 means Continental Flight 18)*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	bTail = IsTailNumber(id, tmpstr);
	if(!(!strcmp(".", tmpstr) || !strcmp("@@@@@@@", tmpstr) || bTail)){
		strncpy_s(record->FltNum, FLTNUM_SIZE, tmpstr, _TRUNCATE);
	}

	// Use beacon code for TrackID (not sure if this is an issue).	
	record->TrackID = hashlittle(&record->icao24, 6, 0) & hashmask(14);

	/* recstr pointing at field #4-- latitude */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	if(strlen(tmpstr)){
		sscanf_s( tmpstr, "%f", &flat );
		record->lat = flat /= 1000000;
	}
	/* recstr pointing at field #5 - longitude */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	if(strlen(tmpstr)){
		sscanf_s( tmpstr, "%f", &flon );
		record->lng = flon /= 1000000;
	}
	if( 0.0f != flon && 0.0f != flat){
	// Convert fval to feed
		CalcFeedXY(id, flon, flat, &record->feedx, &record->feedy, 0);
	}else{
		// We currently drop records that do not have lat/lng
		// @@@mct May not need to do this once we change priority of MLAT over ASDEX
		return( NULL );
	}

	/* recstr pointing at field #6, Altitude*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	record->altitude = atoi(tmpstr); /* in 100 ft. */

	/* recstr pointing at field #7.  THIS IS TIME  -UNIX time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	sscanf_s(tmpstr, "%x", &uval);
	record->eventtime = (long)uval;

	/* recstr pointing at field #8.  THIS IS evnoddc   */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return(NULL);
	}
	sscanf_s(tmpstr, "%x", &uval);
	evnoddc = uval;
	record->evnoddc = evnoddc;
	quality = evnoddc / 4 & 0x1F;
	// Check Quality for Discarding
	if (evnoddc & 0x02){
		// On Surface
		if (quality >= 8){
			D_CONTROL("RCTYPE60", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)DROPPING SURFACE FLIGHT: %s, TRACK:%d, XY(%d, %d), ALT(%d), E/O(%d), Q(%d), TIME:%d\n",
				GetCurrentThreadId(), record->FltNum, record->TrackID, record->feedx, record->feedy, record->altitude, evnoddc, quality, record->eventtime));
			return(NULL);
		}
	}else{
		// In Air
		if (quality >= 18){
			D_CONTROL("RCTYPE60", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)DROPPING FLIGHT: %s, TRACK:%d, XY(%d, %d), ALT(%d), E/O(%d), Q(%d), TIME:%d\n",
				GetCurrentThreadId(), record->FltNum, record->TrackID, record->feedx, record->feedy, record->altitude, evnoddc, quality, record->eventtime));
			return(NULL);
		}
	}

	/* recstr pointing at field #9. Tail Number*/
	if ( (recstr = GetNextField( recstr, record->tail, N_TAIL_SIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #9.  THIS IS origin   */
	if(strlen(recstr)){
		recstr = GetNextField( recstr, record->origin, O_D_SIZE );
		if(strlen(recstr))
			recstr = GetNextField( recstr, record->destin, O_D_SIZE );
	}

	D_CONTROL("RCTYPE60", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT: %s, ICAO24:%X, BEACON:%04o, TAIL: %s, ORIG: %s, DEST: %s, TRACK:%d, XY(%d, %d), ALT(%d), E/O(%d), Q(%d), TIME:%d\n", 
		GetCurrentThreadId(), record->FltNum, record->icao24, record->beacon, record->tail, record->origin, record->destin, record->TrackID, record->feedx, record->feedy, record->altitude, evnoddc, quality, record->eventtime));
	return( record );	
}

struct feedstruct *RdRecType70( struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	long lval = 0;
	struct tm t;
	char tmpstr[ NAMESIZE ] = {0};
	char waypoints[ TMPBUF_SIZE ] = {0};
	
	/* FLIGHT PLAN Record
	example:
	KUL,70,9MAJU,AXM168,1445320560,WMKK,ZGNN,A320,1445332200,1445345100,WMKK.RWY-33.PIBOS1F.PIBOS.R208.IGARI.M765.BITOD.M755.PNH.B329.NAH.W1.NOB.R474.LON.LON11A.RWY-23.ZGNN,1445324710

	Field 1 - TAIL
	Field 2 - Flight ID
	Field 3 - record utc
	Field 4 - origin
	Field 5 - destination
	Field 6 - actype
	Field 7 - stod
	Field 8 - stoa
	Field 9 - route 
	Field 10 - processed utc
	Field 11 - waypoints - Waypoints with Lat/Lng*/

	/* recstr pointing at field #1  Tail Number*/
	if ( (recstr = GetNextField( recstr, record->tail, N_TAIL_SIZE )) == NULL ){
		return( NULL );
	}

	// Use Tail for TrackID (not sure if this is an issue).	
	record->TrackID = hashlittle(&record->tail, strlen(record->tail), 0) & hashmask(14);

	/* recstr pointing at field #2. Flight ID*/
	if ( (recstr = GetNextField( recstr, record->FltNum, FLTNUM_SIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #3.  Record TIME  -UNIX time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%ld", &lval );
	record->eventtime = (long) lval;

	/* recstr pointing at field #4  origin*/
	if ( (recstr = GetNextField( recstr, record->origin, O_D_SIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #5  destination*/
	if ( (recstr = GetNextField( recstr, record->destin, O_D_SIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #6 actype*/
	if ( (recstr = GetNextField( recstr, record->actype, ACTYPE_SIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #7.  stod  -UNIX time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%ld", &lval );
	localtime_s(&t, &lval);
	record->etd = (long) _mkgmtime(&t);

	/* recstr pointing at field #8.  stoa  -UNIX time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%ld", &lval );
	localtime_s(&t, &lval);
	record->eta = (long) _mkgmtime(&t);
	
	/* recstr pointing at field #9 route*/
	if ( (recstr = GetNextField( recstr, record->route, MAX_ROUTE_SIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #10.  Process time  -UNIX time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%ld", &lval );

	/* recstr pointing at field #11. Waypoints (detailed route)*/
	if(strlen(recstr)){
		if ( (recstr = GetNextField( recstr, waypoints, TMPBUF_SIZE )) == NULL ){
			return( NULL );
		}
		record->waypoints = _strdup(waypoints);
	}
	
	
	D_CONTROL("RCTYPE70", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT: %s, TAIL: %s, TRACK:%d, ORIG:%s, DEST:%s, ACTYPE(%s), std(%d), stoa(%d), TIME:%d, PTIME:%d\nROUTE=%s\nWAYPOINTS=%s\n\n", 
		GetCurrentThreadId(), record->FltNum, record->tail, record->TrackID, record->origin, record->destin, record->actype, record->etd, record->eta, record->eventtime, lval, record->route, record->waypoints));
	return( record );	
}

struct feedstruct *RdRecType71( struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char *endstr;
	int len;
	int ival;
	long lval;
	char tmpstr[ NAMESIZE ];

	/*  POS Record
	example:
	KUL,71,9MAJT,,1445378701,7.17656,79.88365,47,264,1445385770

	Field 1 - TAIL
	Field 2 - Flight ID
	Field 3 - record utc
	Field 4 - lat
	Field 5 - lng
	Field 6 - Altitude
	Field 7 - fob
	Field 8 - process utc*/

	/* recstr pointing at field #1. Tail */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	strncpy_s(record->tail, N_TAIL_SIZE, tmpstr, _TRUNCATE);

	// Use Tail for TrackID (not sure if this is an issue).	
	record->TrackID = hashlittle(&record->tail, strlen(record->tail), 0) & hashmask(14);

	recstr = endstr;
	recstr++;
	/* recstr pointing at field #2 = Flight Id */
	if ( !(endstr = strchr(recstr, ',') ) ){
		return( NULL );
	}
	len = endstr - recstr;
	strncpy_s( tmpstr, NAMESIZE, recstr, len );
	tmpstr[len] = '\0';
	if(strlen(tmpstr)){
		strncpy_s( record->FltNum, FLTNUM_SIZE, tmpstr, _TRUNCATE );
	}
	recstr = endstr;
	recstr++;  
	
	/* recstr pointing at field #3.  THIS IS TIME  - UNIX time */
	if ( !(endstr = strchr(recstr, ',') ) ){
		return( NULL );
	}
	len = endstr - recstr;
	strncpy_s( tmpstr, NAMESIZE, recstr, len );
	tmpstr[len] = '\0';
	sscanf_s( tmpstr, "%ld", &lval );

	//record->eventtime = lval;
	record->eventtime = time(0);
	recstr = endstr;
	recstr++;  
	/* recstr pointing at field #4-- latitude */
	if ( !(endstr = strchr(recstr, ',') ) ){
		return( NULL );
	}
	len = endstr - recstr;
	strncpy_s( tmpstr, NAMESIZE, recstr, len );
	tmpstr[len] = '\0';
	sscanf_s( tmpstr, "%f", &record->lat );
	//flat /= 1000000;
	recstr = endstr;
	recstr++;  
	
	/* recstr pointing at field #5 - longitude */
	if ( !(endstr = strchr(recstr, ',') ) ){
		return( NULL );
	}
	len = endstr - recstr;
	strncpy_s( tmpstr, NAMESIZE, recstr, len );
	tmpstr[len] = '\0';
	sscanf_s( tmpstr, "%f", &record->lng );
	//flon /= 1000000;
	// Convert fval to feed
	CalcFeedXY(id, record->lng, record->lat, &record->feedx, &record->feedy, 0);

	recstr = endstr;
	recstr++; 
	/* recstr pointing at field #6, Altitude*/
	if ( !(endstr = strchr(recstr, ',') ) ){
		return( NULL );
	}
	len = endstr - recstr;
	strncpy_s( tmpstr, NAMESIZE, recstr, len );
	tmpstr[len] = '\0';
	record->altitude = atoi( tmpstr ); /* in 100 ft. */

	recstr = endstr;
	recstr++; 
	/* recstr pointing at field #7, fob (fuel on board)*/
	if ( !(endstr = strchr(recstr, ',') ) ){
		return( NULL );
	}
	len = endstr - recstr;
	strncpy_s( tmpstr, NAMESIZE, recstr, len );
	tmpstr[len] = '\0';
	ival = atoi( tmpstr );
	if( ival >= 65535 )
		record->fob = 0;
	else
		record->fob = (int)(ival * 45.359237); /* in 100 lbs convert to 100 kgs. */

	recstr = endstr;
	recstr++; 
	/* recstr pointing at field #8.  Process TIME  -UNIX time */
	len = strlen(recstr);
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	sscanf_s( tmpstr, "%ld", &lval );

	D_CONTROL("RCTYPE71", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT: %s, TAIL:%s, TRACK:%d, LAT(%f), LNG(%f), XY(%d, %d), ALT(%d), FOB(%d), TIME:%d, PTIME:%d\n", 
		GetCurrentThreadId(), record->FltNum, record->tail, record->TrackID, record->lat, record->lng, record->feedx, record->feedy, record->altitude, record->fob, record->eventtime, lval));
	return( record );	
}


struct feedstruct *RdRecType76( struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	long lval = 0;
	float fval = 0.0f;
	struct tm local;
	char tmpstr[ NAMESIZE ] = {0};
	char waypoints[ TMPBUF_SIZE ] = {0};
	
	/* LMG VEHICLE Record
	example:
	KMDW,76,2380LAB,46.133945,-122.933505,1447281800,15.0,3d,0.0,254.4,166.149.106.188,00D0129AEE48,1447281800

	Field 1 - Flight ID
	Field 2 - lat
	Field 3 - lng
	Field 4 - utc
	Field 5 - elevation/altitude
	Field 6 - fix (Degree of accuracy for GPS, 2D = 2 Dimensional, 3D = 3 Dimensional)
	Field 7 - speed
	Field 8 - track (angle of vehicle from 0 to 360 degrees to true north)
	Field 9 - ipaddress
	Field 10 - macaddress
	Field 11 - processed utc*/

	record->vehicle = 1;

	/* recstr pointing at field #1  Flight ID*/
	if ( (recstr = GetNextField( recstr, record->FltNum, FLTNUM_SIZE )) == NULL ){
		return( NULL );
	}

	record->icao24 = atoi(record->FltNum);

	// Use Tail for TrackID (not sure if this is an issue).	
	//record->TrackID = hashlittle(&record->tail, strlen(record->tail), 0) & hashmask(14);

	/* recstr pointing at field #2. lat*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%f", &record->lat );
	
	/* recstr pointing at field #3. lng*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%f", &record->lng );
	
	/* recstr pointing at field #4.  Record TIME  - GMT time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%ld", &lval );
	localtime_s(&local, &lval);
	local.tm_isdst = 1;
	record->eventtime = (long) _mkgmtime(&local);

	/* recstr pointing at field #5  elevation*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%f", &fval );
	record->altitude = (int) fval;

	/* recstr pointing at field #6 Fix (not waypoint fix)_*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #7 speed*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%f", &fval );
	record->speed = (int)fval;
	
	/* recstr pointing at field #8.  track ? - track id */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%f", &fval );
	record->heading = fval;

	/* recstr pointing at field #9.  ipaddress */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	
	/* recstr pointing at field #9 macaddress*/
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	
	record->TrackID = hashlittle(&tmpstr, strlen(tmpstr), 0) & hashmask(14);

	/* recstr pointing at field #10.  Process time  -UNIX time */
	if ( (recstr = GetNextField( recstr, tmpstr, NAMESIZE )) == NULL ){
		return( NULL );
	}
	sscanf_s( tmpstr, "%ld", &lval );

	D_CONTROL("RCTYPE76", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT: %s, TRACK:%d, ELE:%d, SPEED:%d, LAT(%f), LNG(%f),TIME:%d\n", 
		GetCurrentThreadId(), record->FltNum, record->TrackID, record->altitude, record->speed, record->lat, record->lng, record->eventtime));
	return(record);
}


double Distance(double lat1, double lng1, double lat2, double lng2)
{
	double tmprads = acos(sin(RADS(lat1)) * sin(RADS(lat2)) + cos(RADS(lat1)) * cos(RADS(lat2)) * cos(RADS(lng2 - lng1)));
	double dis = 60.0 * DEGS(tmprads); // NM
	return dis;
}

int AsdexDistanceCheck(struct InstanceData* id, struct feedstruct *record){
	AIR **airp;
	AIR *air;

	//return TRUE;

	airp = GetASDEXAirP(id);
	air = airp[record->TrackID];
	if (air){
		int t = abs(record->eventtime - air->utc);
		double d1 = 0.0f, d2 = 0.0f;
		int s = 0;
		t = max(1, t);
		s = max(max(record->speed, air->speed), 10);
		// Estimated distance using adjusted speed, time from last track and factor
		d1 = (s * (t / 3600.0)) * 2.0;
		// Actual Distance
		d2 = Distance(air->CurY, air->CurX, record->lat, record->lng);
		if (d2 < d1){
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) + FLIGHT: %s SPEED %d D1(%f) D2(%f)\n",
				GetCurrentThreadId(), air->FltNum, air->speed, d1, d2));
			return TRUE;
		}else{
			D_CONTROL(__FUNCTION__, vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) - FLIGHT: %s SPEED %d, TDIFF(%d secs) D1(%f) D2(%f)\n",
				GetCurrentThreadId(), air->FltNum, air->speed, t, d1, d2));

		}
	}

	return FALSE;
}

struct feedstruct *RdRecTypeASDEX(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	unsigned uval;
	char tmpstr[TMPBUF_SIZE];
	int nTrackId = -1;
	char* temp = NULL;;

	/* format U_TARGET, record #1
	example:
	a97282,1530,CKS207,42.48232,-71.07624,32798,49d82e61,2d

	Field 0 - Record Type "ASDEX"
	Field 1 - Track ID
	Field 2 - Flight ID
	Field 3 - Aircraft Data Type
	Field 4 - Beacon Code
	Field 5 - Time of Day
	Field 6 - Latitude
	Field 7 - Longitude
	Field 8 - Altitude
	Field 9 - Heading
	Field 10 - Speed
	Field 11 - UNIX Time
	Field 12 - icao24    */

	/*field #0 = ASDEX */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	/* IGNORE */

	/*field #1 = Track ID */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->TrackID = atoi(tmpstr);

	/* field 2 flight id */
	if ((recstr = GetNextField(recstr, record->FltNum, FLTNUM_SIZE)) == NULL){
		return(NULL);
	}

	if (!strlen(record->FltNum)){
		strcpy_s(record->FltNum, FLTNUM_SIZE, "UNKN");
	}

	/* field 3 actype */
	if ((recstr = GetNextField(recstr, record->actype, ACTYPE_SIZE)) == NULL){
		return(NULL);
	}

	/* field 4 beacon code */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	sscanf_s(tmpstr, "%o", &uval);
	record->beacon = uval;

	/* field 5 time of day */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	/* TODO: CORRECT, NOT YET USED */

	/* field 6 Latitude */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	sscanf_s(tmpstr, "%f", &record->lat);

	/* field 7 Longitude */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	sscanf_s(tmpstr, "%f", &record->lng);
	// Convert fval to feed
	CalcFeedXY(id, record->lng, record->lat, &record->feedx, &record->feedy, 0);

	/* field 8 Altitude */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->altitude = atoi(tmpstr);

	/* field 9 Heading */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	sscanf_s(tmpstr, "%f", &record->heading);
	/* TODO: CORRECT, NOT YET USED */

	/* field 10 Speed */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	sscanf_s(tmpstr, "%d", &uval);
	record->speed = uval;

	/* field 11 UNIX time */
	temp = recstr;
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		sscanf_s(temp, "%d", &uval);
		record->eventtime = uval - 14400; /* GMT, quick convert to local time_t */
	}else{
		// Handle new field, icao24
		sscanf_s(tmpstr, "%d", &uval);
		record->eventtime = uval - 14400; /* GMT, quick convert to local time_t */

		/* field 12 icao24 */
		sscanf_s(recstr, "%d", &uval);
		record->icao24 = uval;
	}

	if (strcmp(record->FltNum, "ANON") && strcmp(record->FltNum, "UNKN") && strcmp(record->FltNum, "MISC")){
		// Only do this if we have a FltNum for now, may be able to use beacon
		nTrackId = GetIndex(id, id->m_pASDEXIndexMap, record->FltNum, record->icao24, record->beacon, ASDEX);
		if (-1 != nTrackId && nTrackId != record->TrackID){
			int nRecTrackId = record->TrackID;
			record->TrackID = nTrackId;
			/* MCT Removed 7/14/2015 - Causes problems with Gate Out
			if(AsdexDistanceCheck(id, record)){
			D_CONTROL("ASDEX_DATA_CONFLICT", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s TRACK:%d being converted to TRACK:%d\n",
			GetCurrentThreadId(), record->FltNum, nRecTrackId, record->TrackID));
			}
			else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dumping asdex record - FLIGHT:%s TRACK:%d, reason: Distance Check Failed!\n",
			GetCurrentThreadId(), record->FltNum, nRecTrackId);
			return ( NULL );
			}
			*/
		}
	}

	// Determine if this record is for a ground vehicle
	if (record->altitude <= id->m_nArptAlt || record->speed < 10){
		if (IsVehicle(id, record->icao24, record->FltNum, record->TrackID)){
			record->vehicle = 1;
		}else if(!strcmp(record->FltNum, "UNKN")) 
			record->vehicle = 1;
	}

	D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, XY(%d, %d), ALT(%d), TIME:%d, ICAO24:%X\n",
		GetCurrentThreadId(), record->FltNum, record->TrackID, record->lat, record->lng, record->feedx, record->feedy, record->altitude, record->eventtime, record->icao24));

	return(record);
}



struct feedstruct *RdRecType1(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	unsigned uval;
	char tmpstr[NAMESIZE];
	char *stat_ptr;

	/* format U_TARGET, record #1
	example:
	csfA,1,12,1426,119,997972917,41936,26702,392,-107,-225,9759

	Field 1 - Airport Name, csfA is Islip
	Field 2 - Record type = 1
	Field 3 - Track ID
	Field 4 - Beacon Code
	Field 5 - Point number
	Field 6 - UNIX time
	Field 7 - X wrt origin
	Field 8 - Y wrt origin in meters
	Field 9 - Altitude in hundreds of feet
	Field10 - X velocity
	Field11 - Y velocity
	Field12 - crc - correlated reply count */

	/* recstr pointing at field #3 = Track ID */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}record->TrackID = atoi(tmpstr);

	/* recstr pointing at field #4 Beacon Code */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	if (strlen(tmpstr)) {
		sscanf_s(tmpstr, "%o", &uval);
		record->beacon = uval;
	}

	/* recstr pointing at field #5 Point number */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->pointnum = atoi(tmpstr);

	/* recstr pointing at field #6.  THIS IS TIME  -UNIX time */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->eventtime = (long)strtol(tmpstr, &stat_ptr, 10);
	if (*stat_ptr != '\0') {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) RdRecType1, tmpbuf=%s, invalid number\n", GetCurrentThreadId(), tmpstr);
	}

	/* recstr pointing at field #7-- X wrt origin */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->feedx = atoi(tmpstr);

	/* recstr pointing at field #8 - Y wrt origin in meters */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->feedy = atoi(tmpstr);

	/* recstr pointing at field #9, Altitude in 100 ft. */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->altitude = atoi(tmpstr) * 100; /* in 100 ft. */

	/* recstr pointing at field #10 X velocity */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->velocity_x = atoi(tmpstr);

	/* recstr pointing at field #11 Y velocity */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL) {
		return(NULL);
	}
	record->velocity_y = atoi(tmpstr);
	return(record);
}



struct feedstruct *RdRecType2(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char *endstr;
	int len;
	char tmpstr[NAMESIZE];
	unsigned uval;

	/* U_FLIGHT
	csfA,2,107,6014,414,USA514,CLT,BDL,B733,,DPK2,,6259
	Field 1 - Airport Name, csfA is Islip
	Field 2 - Record type = 2
	Field 3 - Track ID
	Field 4 - Beacon Code
	Field 5 - Status 100(hex) = arrival, 200(hex) departure
	Field 6 - Flight ID (ex. COA18 means Continental Flight 18)
	Field 7 - Upline station (departure airport, i.e JFK)
	Field 8 - Downline Station (destination airport i.e. LAX)
	Field 9 - Aircraft type
	Field10 - standard departure (SID) name (Departure Fix i.e. WAVEY)
	Field11 - standard arrival (STAR) name - NM (not meaningful, this application)
	Field12 - AFIX - arrival fix name - NM
	Field13 - crc */

	/* recstr pointing at field #3 Track ID */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	record->TrackID = atoi(tmpstr);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #4 Beacon Code */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	sscanf_s(tmpstr, "%o", &uval);
	record->beacon = uval;

	recstr = endstr;
	recstr++;  /* recstr pointing at field #5 Status 100(hex) = arrival, 200(hex) departure */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #6. Flight ID (ex. COA18 means Continental Flight 18)*/
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	strncpy_s(record->FltNum, FLTNUM_SIZE, tmpstr, _TRUNCATE);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #7 Upline station (departure airport, i.e JFK) */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	strncpy_s(record->origin, O_D_SIZE, tmpstr, 4);
	record->destin[4] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #8 Downline Station (destination airport i.e. LAX) */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	if (len < O_D_SIZE){
		strncpy_s(tmpstr, O_D_SIZE, recstr, len);
		tmpstr[len] = '\0';
		strncpy_s(record->destin, O_D_SIZE, tmpstr, 4);
		record->origin[4] = '\0';
	}
	else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "bad destination field too large %s \n", recstr);
	}

	recstr = endstr;
	recstr++;  /* recstr pointing at field #9 Aircraft type */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, O_D_SIZE, recstr, len);
	tmpstr[len] = '\0';
	strncpy_s(record->actype, ACTYPE_SIZE, tmpstr, 4);
	record->actype[4] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #10 standard departure (SID) name */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	strncpy_s(record->departure_fix, DEP_FIX_SIZE, tmpstr, 5);
	record->departure_fix[5] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #11 standard arrival (STAR) name - NM */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #12 AFIX - arrival fix name - NM */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #13 crc */

	/* all we need for now */
	return(record);
}


struct feedstruct *RdRecType3(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char *stat_ptr;
	char *endstr;
	int len;
	char tmpstr[NAMESIZE];

	/*
	U_TIMOUT - Used to terminate flight - flight id may be re-used after this record

	Field 1 - Airport Name, csfA is Islip
	Field 2 - Record type = 3
	Field 3 - Track ID
	Field 4 - Beacon Code
	Field 5 - Point number
	Field 6 - UNIX time
	Field 7 - crc
	*/


	/* recstr pointing at field #3 */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';
	record->TrackID = atoi(tmpstr);


	recstr = endstr;
	recstr++;  /* recstr pointing at field #4 Beacon Code */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #5 Point number */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	recstr = endstr;
	recstr++;  /* recstr pointing at field #6.  THIS IS TIME  */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	record->eventtime = (long)strtol(tmpstr, &stat_ptr, 10);
	if (*stat_ptr != '\0'){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) RdRecType3, tmpbuf=%s, invalid number\n", GetCurrentThreadId(), tmpstr);
	}

	recstr = endstr;
	recstr++;  /* recstr pointing at field #7 crc */

	/* all we need for now */
	return(record);
}

struct feedstruct* RdRecType4(struct InstanceData* id, struct feedstruct* record, char* recstr)
{
	char *stat_ptr;
	char tmpstr[TMPBUF_SIZE];

	/*
	ETA record

	Field 1 - Airport Name, csfA is Islip
	Field 2 - Record type = 4
	Field 3 - ETA type
	Field 4 - Flight ID (ex. COA18 means Continental Flight 18)
	Field 5 - ETA
	Field 6 - Runway name
	Field 7 - Upline station (departure airport, i.e JFK)
	Field 8 - Downline Station (destination airport i.e. LAX)
	Field 9 - Aircraft type
	Field10 - dist - most recent distance from center of range circles
	Field11 - DFIX
	Field12 - AFIX - arrival fix name - NM

	Every field has a comma after it (even the last one). The first 5 fields appear to be mandatory, the rest are optional (can be empty).
	*/

	/* Field 3 - ETA type */
	recstr = GetNextField(recstr, tmpstr, sizeof(tmpstr));
	if (recstr == NULL) return(NULL);
	record->etatype = atoi(tmpstr);

	/* Fields 4 - Flight ID */
	recstr = GetNextField(recstr, record->FltNum, FLTNUM_SIZE);
	if (recstr == NULL) return(NULL);

	/* Field 5 - ETA */
	recstr = GetNextField(recstr, tmpstr, sizeof(tmpstr));
	if (recstr == NULL) return(NULL);
	record->eta = (long)strtol(tmpstr, &stat_ptr, 10);
	if (*stat_ptr != '\0'){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) RdRecType4, tmpbuf=%s, invalid eta\n", GetCurrentThreadId(), tmpstr);
	}

	/* Field 6 - Runway name */
	recstr = GetNextField(recstr, record->runway, RUNWAY_SIZE);
	if (recstr == NULL) return(record);

	/* Field 7 - Upline station */
	recstr = GetNextField(recstr, record->origin, ORIG_DES_SIZE);
	if (recstr == NULL) return(record);

	/* Field 8 - Downline station */
	recstr = GetNextField(recstr, record->destin, ORIG_DES_SIZE);
	if (recstr == NULL) return(record);

	/* Field 9 - Aircraft type */
	recstr = GetNextField(recstr, record->actype, ACTYPE_SIZE);
	if (recstr == NULL) return(record);

	/* Field10 - dist */
	recstr = GetNextField(recstr, tmpstr, sizeof(tmpstr));
	if (recstr == NULL) return(record);
	record->etadist = atoi(tmpstr);

	/* Field11 - DFIX */
	recstr = GetNextField(recstr, record->departure_fix, DEP_FIX_SIZE);
	if (recstr == NULL) return(record);

	/* Field12 - AFIX */
	recstr = GetNextField(recstr, record->afix, DEP_FIX_SIZE);
	if (recstr == NULL) return(record);

	return(record);
}

struct feedstruct *RdRecType0(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char *stat_ptr;
	char *endstr;
	int len;
	char tmpstr[NAMESIZE];

	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}

	len = endstr - recstr;
	if (len > 10){
		return(NULL);
	}

	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	tmpstr[len] = '\0';

	record->eventtime = (long)strtol(tmpstr, &stat_ptr, 10);
	if (*stat_ptr != '\0'){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) RdRecType0, tmpbuf=%s, invalid number\n", GetCurrentThreadId(), tmpstr);
	}

	/* all we need for now */
	return(record);
}


// Searches for next comma delimited field, now handles last field as well
// returns NULL if strlen == 0
char *GetNextField(char *recstr, char *tmpstr, int tmpsize)
{
	char *endstr = NULL;
	int len = 0;
	int eos = FALSE;

	if( !(len = strlen(recstr)) ){
		return(NULL);
	}

	if ( !(endstr = strchr(recstr, ',') ) ){
		eos = TRUE;
		endstr = recstr + len;
	}else{
		len = endstr - recstr;
	}

	if (len < tmpsize){
		strncpy_s(tmpstr, tmpsize, recstr, len);
		tmpstr[len] = '\0';
	} else {
		/* TRUNCATE */
		strncpy_s(tmpstr, tmpsize, recstr, _TRUNCATE);
	}

	if( eos ){
		recstr = endstr;
	}else{
		recstr = endstr + 1;
	}
	return(recstr);
}



struct feedstruct *RdRecType12(struct feedstruct *record, char *recstr)   // ASD tz record
{
	char tmpstr[TMPBUF_SIZE];

	if (!record){
		return(NULL);
	}

	/* field 1 flightid */
	/* field 2 trackid */
	/* field 3 eta */
	/* field 4 origin */
	/* field 5 destination */
	/* field 6 qualifier  A = actual, E = estimated, 0 is unknown */
	/* field 7 source radar */
	/* field 8 cid */

	record->rectype = 12; /* type 12 is asd AZ record */

	/* field 1 flightid */
	if ((recstr = GetNextField(recstr, record->FltNum, FLTNUM_SIZE)) == NULL){
		return(NULL);
	}

	/* field 2 trackid */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->TrackID = atoi(tmpstr);

	/* field 3 eta */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->eta = atoi(tmpstr);

	/* field 4 origin */
	if ((recstr = GetNextField(recstr, record->origin, 5)) == NULL){
		return(NULL);
	}
	/* field 5 destination */
	if ((recstr = GetNextField(recstr, record->destin, 5)) == NULL){
		return(NULL);
	}
	/* field 6 qualifier  A = actual, E = estimated, 0 is unknown */
	if ((recstr = GetNextField(recstr, tmpstr, 2)) == NULL){
		return(NULL);
	}
	record->qualifier = tmpstr[0];
	/* field 7 source radar */
	if ((recstr = GetNextField(recstr, record->src_radar, 5)) == NULL){
		return(NULL);
	}
	/* field 8 cid */
	if ((recstr = GetNextField(recstr, record->cid, 4)) == NULL){
		return(NULL);
	}

	return(record);
}




struct feedstruct *RdRecType11(struct feedstruct *record, char *recstr)   // ASD tz record
{
	char tmpstr[TMPBUF_SIZE];

	if (!record){
		return(NULL);
	}

	/* field 1 flightid */
	/* field 2 trackid */
	/* field 3 eta */
	/* field 4 origin */
	/* field 5 destination */
	/* field 6 src radar
	field 7 cid */

	record->rectype = 11; /* type 11 is asd RT record */

	/* field 1 flightid */
	if ((recstr = GetNextField(recstr, record->FltNum, FLTNUM_SIZE)) == NULL){
		return(NULL);
	}

	/* field 2 trackid */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->TrackID = atoi(tmpstr);

	/* field 3 eta */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->eta = atoi(tmpstr);


	if ((recstr = GetNextField(recstr, record->origin, 5)) == NULL){
		return(NULL);
	}
	STrimRight(record->origin);

	if ((recstr = GetNextField(recstr, record->destin, 5)) == NULL){
		return(NULL);
	}
	STrimRight(record->destin);

	if ((recstr = GetNextField(recstr, record->src_radar, 5)) == NULL){
		return(NULL);
	}

	if ((recstr = GetNextField(recstr, record->cid, 4)) == NULL){
		return(NULL);
	}

	return(record);
}



struct feedstruct *RdRecType10(struct InstanceData* id, struct feedstruct *record, char *recstr)   // ASD tz record
{
	char tmpstr[TMPBUF_SIZE];
	int pflag = 0;

	if (!record){
		return(NULL);
	}

	/* field 1 flightid */
	/* field 2 trackid */
	/* field 3 eventtime */
	/* field 4 latitude */
	/* field 5 longitude */
	/* field 6 speed */
	/* field 7 altitude
	/* field 8 lat seconds
	/* field 9 longitude seconds */

	record->rectype = 10; /* type 10 is asd TZ record */

	/* field 1 flightid */
	if ((recstr = GetNextField(recstr, record->FltNum, FLTNUM_SIZE)) == NULL){
		return(NULL);
	}

	/* field 2 trackid */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->TrackID = atoi(tmpstr);

	/* field 3 eventtime */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->eventtime = atoi(tmpstr);

	/* record 4 latitude */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->feedy = atoi(tmpstr);

	/* record 5 longitude */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->feedx = atoi(tmpstr);

	/* field 6 speed */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->speed = atoi(tmpstr);

	/* record 7 altitude */
	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->altitude = atoi(tmpstr) * 100;

	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->latsecs = atoi(tmpstr);

	if ((recstr = GetNextField(recstr, tmpstr, TMPBUF_SIZE)) == NULL){
		return(NULL);
	}
	record->longsecs = atoi(tmpstr);

	if ((recstr = GetNextField(recstr, record->src_radar, 5)) == NULL){
		return(NULL);
	}
	if ((recstr = GetNextField(recstr, record->cid, 4)) == NULL){
		return(NULL);
	}


	if (pflag && (record->latsecs || record->longsecs)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Flight %s latsecs=%d longsecs=%d\n",
			GetCurrentThreadId(), record->FltNum, record->latsecs, record->longsecs);
	}
	return(record);

}

int GetNextRec(char *tmpstr, int buflen, char **recstrp)
{
	char *recstr, *endstr;
	int len;


	if (!recstrp){
		return(0);
	}
	recstr = *recstrp;

	if (!(endstr = strchr(recstr, ','))){
		return(0);
	}
	len = endstr - recstr;
	if (len < buflen - 1){
		strncpy_s(tmpstr, buflen, recstr, len);
		tmpstr[len] = '\0';
	} else {
		// buf too small, ignore
		tmpstr[0] = '\0';
	}
	recstr = endstr;
	recstr++;  /* recstr pointing at field #3, asof time for lon/lat */

	*recstrp = recstr;
	return(TRUE);
}


struct feedstruct *RdRecType20(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char tmpstr[NAMESIZE];
	unsigned uval;


	/* type 20 is Mode S tails */
	/*
	Field Names
	0: Airport Name
	1: ASDType = 20
	2: beacon
	3: status
	4: stim
	5: ctim
	6: etim
	7: reg_mark
	8: icao24
	9: flightid
	10: upline
	11: downline
	12: actype
	*/

	//sprintf(dbuf, "%s,%d,%04o,%x,%d,%d,%d,%s,%06X,%s,%s,%s,%s,",
	//  aptnam, U_ICAO25, beacon, status, stim, ctim, etim, reg_mark, icao24,
	// flightid, upline, downline, actype);
	/*ignore status, stim are the first and last times for which this assignment
	* is valid */
	/* example text:
	jfkF,20,2476,3,1256752968,1256753778,1256753739,N409CA,A4CE43,COM399,ORF,KJFK,CRJ1,981E
	jfkF,20,3113,3,1256752570,1256753777,1256753768,N671DN,A8DFC7,DAL1780,KATL,KLGA,B752,303D
	jfkF,20,7110,a,1256753779,1256753782,1256753782,N867DA,ABE924,,,,,0BA7
	jfkF,20,2676,3,1256753480,1256753781,1256753770,N12116,A05A03,COA17,KEWR,KLAX,B752,CE12
	jfkF,20,3353,3,1256753173,1256753781,1256753770,N888ZF,AC3DD2,KEY888,KTEB,KCMH,GLF4,87B4
	jfkF,20,2556,3,1256752275,1256753783,1256753758,N37267,A43E83,COA339,KMIA,KEWR,B738,4CBB
	jfkF,20,1344,3,1256752189,1256753785,1256753785,N695CA,A93D7C,COM342,KORD,KJFK,CRJ9,02C5
	*/

	if (!id->m_bDHSPerm){
		// only dhs allowed to see type 20 records
		return(NULL);
	}
	record->rectype = 20;


	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	sscanf_s(tmpstr, "%o", &uval);
	record->beacon = uval;

	// SKIP STATUS
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){ // skip stime
		return(NULL);
	}
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){ // skip ctime
		return(NULL);
	}
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){ // skip etime
		return(NULL);
	}
	// get reg_mark, registration , or tail number
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	strncpy_s(record->tail, N_TAIL_SIZE, tmpstr, _TRUNCATE);
	// get mode 2 24 bit value
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	sscanf_s(tmpstr, "%06X", &uval);
	record->icao24 = uval;
	// get flightid
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	strncpy_s(record->FltNum, FLTNUM_SIZE, tmpstr, _TRUNCATE);
	// get orig
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	strncpy_s(record->origin, O_D_SIZE, tmpstr, _TRUNCATE);
	// get destination
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	strncpy_s(record->destin, O_D_SIZE, tmpstr, _TRUNCATE);
	// get actype
	if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){
		return(NULL);
	}
	strncpy_s(record->actype, ACTYPE_SIZE, tmpstr, _TRUNCATE);

	/* all we need for now */
	return(record);
}


struct feedstruct *RdRecType9(struct feedstruct *record, char *recstr)
{
	char *endstr;
	int len;
	char tmpstr[NAMESIZE];
	static int type9count;


	/* type 9 is asd record */

	/* example: asd,9,0,3F86D29A,-5186,2050,0,350,3F87078C,3F86CE20,DAL860,ATL,LAS,B763,22,10,4945,KCDZ,031,-5100,2049,  */
	/*
	Field Names
	0: Airport Name
	1: ASDType = 9
	2: always 0
	3: asof time for lon/lat
	4: longitude in minutes
	5: latitude in minutes
	6: speed in knots
	7: altitude in hundreds
	8: ETA
	9: ETD - estimated time of departure
	10: flight id
	11: upline (origin)
	12: downline (destination)
	13: actype
	14: latsecs (old=sid)
	15: longsecs old=star
	16: trackid
	17: source radar
	18: CID
	19: prevlng
	20: prevlat
	21: FltRoute -- flight route
	*/

	/* recstr pointing at field #2, always 0 */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #3, asof time for lon/lat */

	/* field 3 is event time in hex format */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->eventtime = HexStrtod(tmpstr, len);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #4, longitude in minutes */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->feedx = atoi(tmpstr);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #5. latitude in minutes */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->feedy = atoi(tmpstr);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #6 speed in knots*/
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->speed = atoi(tmpstr);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #7 altitude in hundreds of feet */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->altitude = atoi(tmpstr) * 100;

	recstr = endstr;
	recstr++;  /* recstr pointing at field #8  ETA */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	if (len > 1){
		record->eta = HexStrtod(tmpstr, 8);
		if (record->eta < 0){
			//printf("Error, negative eta, tmpstr='%s' eta=%d\n",
			//tmpstr, record->eta );
			record->eta = 0;
		} else {
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) record->eta=%d fltnum=%s time=%s\n",
			//  GetCurrentThreadId(), record->eta, record->FltNum, ShowTime( record->eta, "%H:%M:%S" ) );
		}
	} else {
		record->eta = 0;
	}

	recstr = endstr;
	recstr++;  /* recstr pointing at field #9 ETD */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	if (len > 1){
		record->etd = HexStrtod(tmpstr, 8);
		if (record->etd < 0){
			//printf("Error, negative eta, tmpstr='%s' eta=%d\n",
			//tmpstr, record->eta );
			record->etd = 0;
		} else {
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) record->eta=%d fltnum=%s time=%s\n",
			//  GetCurrentThreadId(), record->eta, record->FltNum, ShowTime( record->eta, "%H:%M:%S" ) );
		}
	} else {
		record->etd = 0;
	}


	recstr = endstr;
	recstr++;  /* recstr pointing at field #10 flight id */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	strncpy_s(record->FltNum, FLTNUM_SIZE, tmpstr, _TRUNCATE);

	STrimRight(record->FltNum);
	//if ( !strcasecmp( record->FltNum, "N813VZ" ) ){
	//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found flight\n", GetCurrentThreadId());
	//}

	recstr = endstr;
	recstr++;  /* recstr pointing at field #11 upline (origin ) */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	strncpy_s(record->origin, O_D_SIZE, tmpstr, _TRUNCATE);
	STrimRight(record->origin);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #12 downline (destination) */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	strncpy_s(record->destin, O_D_SIZE, tmpstr, _TRUNCATE);
	STrimRight(record->destin);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #13 actype */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	strncpy_s(record->actype, ACTYPE_SIZE, tmpstr, _TRUNCATE);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #14 latsecs */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->latsecs = atoi(tmpstr);

	recstr = endstr;
	recstr++;  /* recstr pointing at field #15 longsecs */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);
	record->longsecs = atoi(tmpstr);

	recstr = endstr;

	recstr++;  /* recstr pointing at field #16 trackid  */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	len = endstr - recstr;
	strncpy_s(tmpstr, NAMESIZE, recstr, len);

	record->TrackID = atoi(tmpstr);
	type9count++;

	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL){
		return(NULL);
	}

	if ((recstr = GetNextField(recstr, record->src_radar, 5)) == NULL){
		return(NULL);
	}
	if ((recstr = GetNextField(recstr, record->cid, 4)) == NULL){
		return(NULL);
	}

	/* record 19 prev longitude */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL){
		return(NULL);
	}
	record->prevlng = atoi(tmpstr);

	/* record 20 prev latitude */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) == NULL){
		return(NULL);
	}
	record->prevlat = atoi(tmpstr);

	/* record 21 Flight Plan Route */
	if ((recstr = GetNextField(recstr, tmpstr, NAMESIZE)) != NULL){
		if (strlen(tmpstr)){
			strncpy_s(record->route, MAX_ROUTE_SIZE, tmpstr, _TRUNCATE);
		}
	}
	/* all we need for now */
	return(record);
}



struct feedstruct *RdRecTypeUnknown(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	/* unknown type */
	vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unknown Type<%d>, recstr='%s'\n", GetCurrentThreadId(), record->rectype, recstr);
	return(NULL);
}

struct feedstruct *RdRecType(struct InstanceData* id, struct feedstruct *record, char *recstr)
{
	char *endstr;

	/* skip over rectype string */
	if (!(endstr = strchr(recstr, ','))){
		return(NULL);
	}
	endstr++;

	recstr = endstr;

	switch (record->rectype)
	{
	case 0:
		return(RdRecType0(id, record, recstr));
		break;
	case 1:
		return(RdRecType1(id, record, recstr));
		break;
	case 2:
		return(RdRecType2(id, record, recstr));
		break;
	case 3:
		return(RdRecType3(id, record, recstr));
		break;
	case 4:
		return(RdRecType4(id, record, recstr));
		break;
	case 9:
		return(RdRecType9(record, recstr));
		break;
	case 10:
		return(RdRecType10(id, record, recstr));   // asd tz record
		break;
	case 11:
		return(RdRecType11(record, recstr));   // asd RT record
		break;
	case 12:
		return(RdRecType12(record, recstr));   // asd AZ record
		break;
	case 20:
		return(RdRecType20(id, record, recstr));   // mode s tail info
		break;
	case 37:
		return(RdRecTypeADSB(id, record, recstr));   // adsb
		break;
	case 60:
		return(RdRecType60(id, record, recstr));   // modified, non-positional adsb record with beacon
		break;
	case 70:
		return( RdRecType70(id,record,recstr) );   // air asia flight plan data
		break;
	case 71:
		return( RdRecType71(id,record,recstr) );   // air asia track data
		break;
	case 76:
		return( RdRecType76(id,record,recstr) );   // LMG Vehicle track data
		break;
	default:
		return(RdRecTypeUnknown(id, record, recstr));
	}
}

struct feedstruct *RdRecord(struct InstanceData* id, struct feedstruct *record, char* recstr)
{
	char *endstr;
	int len;
	char tmpstr[TMPBUF_SIZE];
	int pflag = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	memset(record, 0, sizeof(struct feedstruct));
	record->heading = -1.0f; // Always initialize heading to -1.0f 

	/* assumes string points to start of a record */

	//if ( strstr( recstr, "N813VZ") ){
	// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found flight\n", cdwThreadId);
	//}

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) recstr='%s'\n", cdwThreadId, recstr);
	}

	if (!(endstr = strchr(recstr, ','))){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unexpected end of record, recstr='%s'\n",
			cdwThreadId, recstr);
		return(NULL);
	}

	len = endstr - recstr;
	if (len > MXAPCHAR){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "\n(0x%X) Invalid airport record found = '%s'\n",
			cdwThreadId, recstr);
		return(NULL);
	}
	strncpy_s(record->airport, MXAPCHAR + 1, recstr, len);

	if (!strcmp(record->airport, "ASDEX")){
		struct feedstruct *fs = NULL;
		// Fake record type 1

		strcpy_s(record->airport, MXAPCHAR + 1, "jfkF");
		record->rectype = 1;
		fs = RdRecTypeASDEX(id, record, recstr);
		if (NULL == fs){
			D_CONTROL("ASDEX_DATA_CONFLICT", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) recstr='%s'\n", cdwThreadId, recstr));
		}
		return fs;
	}
	/* record type */
	endstr++; /* skip comma */
	recstr = endstr;

	if (!(endstr = strchr(recstr, ','))){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unexpected end of record, recstr='%s'\n",
			cdwThreadId, recstr);
		return(NULL);
	}

	len = endstr - recstr;
	if (len > NAMESIZE){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "\n(0x%X) Invalid airport record found = '%s'\n",
			cdwThreadId, recstr);
		return(NULL);
	}
	strncpy_s(tmpstr, TMPBUF_SIZE, recstr, len);

	record->rectype = atoi(tmpstr);

	return(RdRecType(id, record, recstr));
}

// Handles Empty Tokens, unlike strtok/strtok_s
char *StrTok(char **m, char *s, char c)
{
	char *p = s ? s : *m;
	if (!*p)
		return 0;
	*m = strchr(p, c);
	if (*m)
		*(*m)++ = 0;
	else
		*m = p + strlen(p);
	return p;
}

struct feedstruct *RdNoiseRecord(struct InstanceData* id, struct feedstruct *record, char* recstr)
{
	char *ctx = NULL;
	char *tok = NULL;
	int fld = 0;
	float lat, lng;
	unsigned int uval = 0;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();

	memset(record, 0, sizeof(struct feedstruct));

	if (IS_D_CONTROL(__FUNCTION__)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) recstr='%s'\n", cdwThreadId, recstr);
	}

	tok = StrTok(&ctx, recstr, ',');
	while (tok){
		if (!strlen(tok)){
			fld++;
			tok = StrTok(&ctx, NULL, ',');
			continue;
		}
		switch (fld++){
		case 0: {
			struct tm local;
			time_t rtime = DtStr2Secs(tok, "%Y-%m-%dT%H:%M:%SZ");
			if (!localtime_s(&local, &rtime))
				record->eventtime = _mkgmtime(&local);
		}
				break;
		case 1:	{
			record->rectype = atoi(tok);
			if (0 == record->rectype)
				return (NULL);
		}
				break;
		case 2: strncpy_s(record->airport, MXAPCHAR + 1, tok, strlen(tok)); break;
		case 3: record->TrackID = atoi(tok); break;
		case 4: sscanf_s(tok, "%o", &uval);
			record->beacon = uval;
			break;
		case 5: {
			if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5){
				sscanf_s(tok, "%f", &lat);
			}else if( record->rectype == 2 || record->rectype == 6 || record->rectype == 7 ){
				strncpy_s(record->FltNum, FLTNUM_SIZE, tok, strlen(tok));
			}
		}
				break;
		case 6: {
			if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5){
				sscanf_s(tok, "%f", &lng);
				CalcFeedXY(id, lng, lat, &record->feedx, &record->feedy, 0);
			}else if( record->rectype == 2 || record->rectype == 6 || record->rectype == 7 ){
				strncpy_s(record->origin, O_D_SIZE, tok, strlen(tok));
			}
		}
				break;
		case 7: {
			if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5){
				record->altitude = atoi(tok);
		}else if( record->rectype == 2 || record->rectype == 6 || record->rectype == 7 ){
				strncpy_s(record->destin, O_D_SIZE, tok, strlen(tok));
			}
		}
				break;
		case 8: {
			if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5){
				sscanf_s(tmpstr, "%06X", &uval);
				record->icao24 = uval;
			}else if( record->rectype == 2 || record->rectype == 6 || record->rectype == 7 ){
				strncpy_s(record->actype, ACTYPE_SIZE, tok, strlen(tok));
			}
		}
				break;
		case 9: {
			if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5){
				strncpy_s(record->tail, N_TAIL_SIZE, tok, strlen(tok));
			}else if( record->rectype == 2 || record->rectype == 6 || record->rectype == 7 ){
				sscanf_s(tmpstr, "%06X", &uval);
				record->icao24 = uval;
			}
		}
				break;
		case 10: sscanf_s(tmpstr, "%06X", &uval);
			record->icao24 = uval;
			break;
		}
		tok = StrTok(&ctx, NULL, ',');
	}
	if (IS_D_CONTROL(__FUNCTION__)){
		switch (record->rectype){
		case 0: vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TYPE:(%d), TIME(%d), ARPT(%s)\n", cdwThreadId, record->rectype, record->eventtime, record->airport);
			break;
		case 1:
		case 4:
		case 5: vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TYPE:(%d), TIME(%d), ARPT(%s), TRACK(%d), BEACON(%d), LAT(%d), LNG(%d), ALT(%d), ICAO24(%d), TAIL(%s)\n",
			cdwThreadId, record->rectype, record->eventtime, record->airport, record->TrackID, record->beacon, record->feedx, record->feedy, record->altitude, record->icao24, record->tail);
			break;
		case 2:
		case 6:
		case 7: vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TYPE:(%d), TIME(%d), ARPT(%s), TRACK(%d), BEACON(%d), FLIGHT(%s), ORIGIN(%s), DEST(%s), ACTYPE(%s), ICAO24(%d), TAIL(%s)\n",
			cdwThreadId, record->rectype, record->eventtime, record->airport, record->TrackID, record->beacon, record->FltNum, record->origin, record->destin, record->actype, record->icao24, record->tail);
			break;
		case 3: vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TYPE:(%d), TIME(%d), ARPT(%s), TRACK(%d)\n", cdwThreadId, record->rectype, record->eventtime, record->airport, record->TrackID);
			break;
		}
	}
	return (record);
}


void FreePoly(poly *newpoly)
{
	points *np, *freep = NULL;

	if (newpoly->polyname){
		free(newpoly->polyname);
		newpoly->polyname = NULL;
	}
	if (newpoly->datastruct){
		free(newpoly->datastruct);
		newpoly->datastruct = NULL;
	}

	for (np = newpoly->ppoints; np; np = np->np){
		if (freep){
			vp_free(freep);
			freep = NULL;
		}
		freep = np;
	}
	if (freep){
		vp_free(freep);
		freep = NULL;
	}

	vp_free(newpoly);

}


void FreePolyList(polylist *flist)
{
	polylist *nextpoly, *freepolylist;
	poly *newpoly;


	/* free allpolys lists */
	freepolylist = NULL;
	for (nextpoly = flist; nextpoly; nextpoly = nextpoly->np){
		if (freepolylist){
			vp_free(freepolylist);
			freepolylist = NULL;
		}
		freepolylist = nextpoly;

		newpoly = nextpoly->poly;

		FreePoly(newpoly);
	}

	if (freepolylist){
		vp_free(freepolylist);
		freepolylist = NULL;
	}
	freepolylist = nextpoly;

}

//void CreateProject(char* p)
//{
//	// Use curl to save data to db
//	struct MemoryStruct chunk;
//	char sourcestr[ TMPBUF_SIZE ];
//	char tmpstr[ TMPBUF_SIZE ];
//	char *projectName, *category, *area, *segments, *status, *notes;
//	char *creator, *title, *initials;
//  char *context;
//
//	
//	// example of input string :::
//	// "projectName=Newproj&category=Taxiways&area=Z&segments=Y/H&status=closed"
//	//  &notes=&creator=name&title=title&initials=initials"
//	
//  chunk.memory=NULL; /* we expect realloc(NULL, size) to work */
//  chunk.size = 0;    /* no data at this point */
//	
//	strncpy(sourcestr, p, sizeof( sourcestr) );
//
//	sprintf(sourcestr, "Action=SavePoly&%s", p );
//	StrSubs(sourcestr, "%3D", "=", TMPBUF_SIZE );
//	// StrSubs(tmpstr, "%20", "", TMPBUF_SIZE );
//	StrSubs(sourcestr, "%26", "&", TMPBUF_SIZE );
//
//	do {
//		if ( !( projectName = strtok_s ( sourcestr, "&", &context ) )) ;
//		if ( !( category = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( area = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( segments = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( status = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( notes = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( creator = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( title = strtok_s ( NULL, "&", &context ) )) break;
//		if ( !( initials = strtok_s ( NULL, "&", &context ) )) break;
//	} while (0);
//
//	// string is OK
//
//
//	sprintf(tmpstr, "Action=SaveProject&%s", p );
//	StrSubs(tmpstr, "%3D", "=", TMPBUF_SIZE );
//	// StrSubs(tmpstr, "%20", "", TMPBUF_SIZE );
//	StrSubs(tmpstr, "%26", "&", TMPBUF_SIZE );
//
//	id->m_nSecureMode = FALSE;
//	GetCurlFormPostResults( &chunk, httpDBservername, tmpstr, TRUE );
//	id->m_nSecureMode = TRUE;
//
//	if ( chunk.memory ){
//		free( chunk.memory );
//	}
//
//	// force a read in the new projects
//	vo_free( ProjectsVO );
//	ProjectsVO = NULL;
//}



int FindAirportIndex(struct InstanceData* id, char *arpt)
{
	int i = -1;
	int nIndex = -1;
	VO* PassurArptsVO = NULL;

	EnterCriticalSection(&id->m_csAirportsVO);
	PassurArptsVO = (VO*)id->m_pAirportsVO;
	if (PassurArptsVO) {
		for (i = 0; PassurArptsVO && i < PassurArptsVO->count; i++){
			if (!strcasecmp(VP(PassurArptsVO, i, "icao_code", char), arpt)){
				nIndex = i;
				break;
			}
		}
	}
	LeaveCriticalSection(&id->m_csAirportsVO);

	return(nIndex);

}


AIR *GetASDAir(AIR **airp, int AI)
{
	AIR *air;

	if (!airp) return(NULL);

	if ((air = airp[AI])){
		return(air);
	}
	// create the air struct 
	airp[AI] = (AIR *)calloc(1, sizeof(AIR));
	if ((air = airp[AI])){
		air->heading = -1.0f; // Always initialize heading to expected invalid value
		return(air);
	}
	return(NULL);
}



AIR *GetAir(AIR **airp, int AI)
{
	AIR *air;

	if (!airp) return(NULL);

	if ((air = airp[AI])){
		return(air);
	}
	// create the air struct 
	airp[AI] = (AIR *)calloc(1, sizeof(AIR));
	if ((air = airp[AI])){
		air->heading = -1.0f; // Always initialize heading to expected invalid value
		return(air);
	}
	return(NULL);
}


AIR **GetAirP(struct InstanceData* id, int passur_index)
{
	AIR ***Airs = (AIR ***)id->m_pPASSURAirs;
	if (!Airs)
	{
		id->m_pPASSURAirs = Airs = (AIR ***)calloc(3, sizeof(AIR **));
	}

	if (passur_index < 0 || passur_index >= MAX_PASSURS){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad passur_index =%d\n", GetCurrentThreadId(), passur_index);
		return(NULL);
	}

	if (Airs[passur_index]){
		return(Airs[passur_index]);
	}

	Airs[passur_index] = (AIR **)calloc(N_PASSUR_TRACK_ID, sizeof(AIR *));

	return(Airs[passur_index]);
}



#ifdef AIRVO
VO *GetAirVO( int passur_index )
{
	static VO *AirVOs[MAX_PASSURS];

	if ( passur_index < 0 || passur_index >= MAX_PASSURS ){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad passur_index =%d\n", GetCurrentThreadId(), passur_index );
		return( NULL );
	}

	if ( AirVOs[passur_index] ){
		return( AirVOs[passur_index] );
	}
	AirVOs[passur_index] = (VO *) vo_create( 0 , NULL);
	vo_set( AirVOs[passur_index], V_NAME, "AirVO", NULL );

	VOPropAdd( AirVOs[passur_index], "CurX", FLT8BIND, -1, VO_NO_ROW );  // for updating tracks
	VOPropAdd( AirVOs[passur_index], "CurY", FLT8BIND, -1, VO_NO_ROW );  // for updating tracks
	VOPropAdd( AirVOs[passur_index], "X", FLT8BIND, -1, VO_NO_ROW );      // plotting position of aircraft
	VOPropAdd( AirVOs[passur_index], "Y", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "PrevX", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "PrevY", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "utc", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "beacon", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "TrackID", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "TrackVOPtr", VOIDBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "TrackStart", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "Origin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "Destin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "altitude", INTBIND, -1, VO_NO_ROW );
	// VOPropAdd( AirVOs[passur_index], "prevtime", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "eta", INTBIND, -1, VO_NO_ROW );  // in unix time
	VOPropAdd( AirVOs[passur_index], "ata", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "atd", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "speed", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "actype", NTBSTRINGBIND, ACTYPE_SIZE, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "PassurTracks", INTBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "StartMSECS", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "EndMSECS", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "PlotMSECS", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "X1", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "X2", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "Y1", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "Y2", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "PrevAngle", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "DestDis", FLT8BIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "src_radar", NTBSTRINGBIND, 5, VO_NO_ROW );
	if ( SaveLocalData ){
		VOPropAdd( AirVOs[passur_index], "ZoneInfo", INTBIND, -1, VO_NO_ROW );
		VOPropAdd( AirVOs[passur_index], "UsePassurIndex", INTBIND, -1, VO_NO_ROW );
	}
	VOPropAdd( AirVOs[passur_index], "FltRoute", VOIDBIND, -1, VO_NO_ROW );
	VOPropAdd( AirVOs[passur_index], "FltRouteOrig", VOIDBIND, -1, VO_NO_ROW );

	if ( UserIsAvitat ){
		VOPropAdd( AirVOs[passur_index], "Avitat", INTBIND, -1, VO_NO_ROW ); //0=UNKNOWN,1=NOT an Avitat, 2=Avitat Based,3=Avitat,not based
		// avitat based == blue,  important avitat (not-based) = green
	}

	vo_rm_rows( AirVOs[passur_index], 0, AirVOs[passur_index]->count );

	// preallocate enough for all tracks
	vo_alloc_rows( AirVOs[passur_index], N_PASSUR_TRACK_ID );
	vo_set( AirVOs[passur_index], V_ORDER_COLS, "FltNum", NULL, NULL );


	return( AirVOs[passur_index] );
}
#endif

//VOID ASDThread(PVOID pvoid)
//{
//	static int ASDThreadCount;
//  const DWORD cdwThreadId = GetCurrentThreadId();
//
//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Thread %d starting\n", cdwThreadId, ASDThreadCount++);
//
//  while(WAIT_TIMEOUT == WaitForSingleObject(id->m_evShutdown, 1000)){
//    GetASDZipsThread(TRUE, TRUE );
//  }
//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Thread %d terminating\n", cdwThreadId, ASDThreadCount++);
//}

void RetrieveTails(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char url[256];
	char tailfilename[256];
	char* outbuffer = NULL;
	time_t psecs;
	struct tm tmTemp;
	time_t nowsecs;
	int totbytes;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// read in the next set of tails info

	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) plottime=%s\n", cdwThreadId, VOTimeFmt(timestr, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S" ) );

	if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus){
		nowsecs = id->m_tPlotTime;
	}else{
		nowsecs = time(0);
	}
	if (!id->m_tlasttailsecs){
		id->m_tlasttailsecs = nowsecs - 60; // first time initialize, make sure it runs
	}
	if (nowsecs - id->m_tlasttailsecs < 45){
		return;  // not time yet
	}
	id->m_tlasttailsecs = nowsecs;

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if ((psecs = id->m_tPlotTime) < id->m_tlasttailsecs){
		psecs = nowsecs - 60;
	}
	else {
		psecs -= 60;
	}
	gmtime_s(&tmTemp, &psecs);

	_snprintf_s(tailfilename, _countof(tailfilename), _TRUNCATE, "asd2/%d/%d/%d/%02d/%02dtails.zip",
		tmTemp.tm_year + 1900, tmTemp.tm_mon + 1, tmTemp.tm_mday,
		tmTemp.tm_hour, tmTemp.tm_min);

	sprintf_s(url, _countof(url), "%s/%s", GetTailsSrvr(id), tailfilename);

	if (id->m_pGTailBuf){
		// haven't processed prior data yet
		//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) missed processing of GTailBuf\n", cdwThreadId);
		return;
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlPage id <%x> url <%s>.\n", cdwThreadId, id, url);

	if (GetCurlPage(id, &chunk, url, SM_HTTPS, 3, 5000L)){
		if (chunk.memory){
			// save this file in a buffer

			// unzip the data
			if ((totbytes = imunzip(tailfilename, chunk.memory, chunk.size, &outbuffer)) <= 0){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unzip failed for %s\n", cdwThreadId, tailfilename);
				return;
			}
			EnterCriticalSection(&id->m_csASDSync);

			id->m_pGTailBuf = outbuffer;
			D_CONTROL("MODES_TAILS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) MODE-S DATA:\n%s\n", cdwThreadId, outbuffer));

			LeaveCriticalSection(&id->m_csASDSync);

			//GTailBuf = malloc( chunk.size );
			//strncpy( GTailBuf, chunk.memory, chunk.size );
			//GTailBuf[ chunk.size - 1] = '\0'; // make sure it is null terminated
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) saved %d bytes in GTailBuf, expanded from %d = %g %%\n", cdwThreadId, totbytes, chunk.size, (double) totbytes / chunk.size * 100.0 );
			// move processing to main thread  ProcessModeSTails( chunk.memory );
			free(chunk.memory);
		}
		/* clear out buffer */
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */

		return;
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get curl page '%s'\n", cdwThreadId, url);
		GetNxtTailsSrvr(id);
	}
}

int unzip_init(struct InstanceData* id, z_stream* strm)
{
	int ret;
	strm->zalloc = Z_NULL;
	strm->zfree = Z_NULL;
	strm->opaque = Z_NULL;
	strm->avail_in = 0;
	strm->next_in = Z_NULL;
	ret = inflateInit(strm);
	if (ret != Z_OK) {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) inflateInit error %d\n", GetCurrentThreadId(), ret);
		return ret;
	}
	return SUCCEED;
}

int unzip_chunk(struct InstanceData* id, struct MemoryStruct *in, struct MemoryStruct *out)
{
	z_stream strm;
	int ret;

	if (out->memory == NULL) {
		out->size = in->size * 4;
		out->memory = malloc(out->size);
		if (out->memory == NULL) return Z_MEM_ERROR;
	}

	ret = unzip_init(id, &strm);
	if (ret != SUCCEED) return ret;

	strm.avail_in = in->size;
	strm.next_in = in->memory;

	strm.avail_out = out->size;
	strm.next_out = out->memory;

	do {
		if (strm.avail_out == 0) {
			// need more output space
			out->size += in->size;
			out->memory = realloc(out->memory, out->size);
			if (out->memory == NULL) {
				out->size = 0;
				inflateEnd(&strm);
				return Z_MEM_ERROR;
			}
			strm.avail_out = in->size;
			strm.next_out = out->memory + (out->size - in->size);
		}

		ret = inflate(&strm, Z_NO_FLUSH);

		switch (ret)
		{
		case Z_NEED_DICT:
			ret = Z_DATA_ERROR;     /* and fall through */
		case Z_DATA_ERROR:
		case Z_MEM_ERROR:
			inflateEnd(&strm);
			return ret;
		}
	} while (strm.avail_out == 0);

	out->size = out->size - strm.avail_out; // remove unused portion of buffer from the size

	inflateEnd(&strm);

	if (ret != Z_STREAM_END) {
		/* inflate() says input data is not done */
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) input truncated\n", GetCurrentThreadId());
		return Z_DATA_ERROR;
	}
	return SUCCEED;
}


void GetFusedData(struct InstanceData* id)
{
	//static long id->m_ltrackseq = 0;
	//static CURL* curl_handle = NULL;

	char *outbufptr;
	int totbytes;

	struct MemoryStruct chunk, chunk2;
	char tmpstr[TMPBUF_SIZE];
	char *tmpp;
	int ret;

	if (!id->m_pcurl_handle) {
		id->m_pcurl_handle = GetCurlHandle(id, SM_HTTPS);
	}

	outbufptr = NULL;
	totbytes = 0;

	chunk.memory = NULL;
	chunk.size = 0;

	sprintf_s(tmpstr, TMPBUF_SIZE, "username=fwuser&pwd=rhino&Action=MosaicTracksZip&trackseq=%ld", id->m_ltrackseq);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults_r - CurrentFTracksServer <%s> tmpstr <%s>.\n",
		GetCurrentThreadId(), GetFTrackSrvr(id), tmpstr);

	if (!GetCurlFormGetResults_r(id, id->m_pcurl_handle, &chunk, GetFTrackSrvr(id), tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to get fused tracks\n", GetCurrentThreadId());
		GetNxtFTrackSrvr(id);
	}

	if (chunk.memory) {
		// unzip from chunk2 into chunk
		chunk2 = chunk;
		chunk.memory = NULL;
		ret = unzip_chunk(id, &chunk2, &chunk);
		if (ret != SUCCEED) {
			if (chunk.memory) free(chunk.memory);
			chunk.memory = NULL;
		}
		free(chunk2.memory);
		chunk2.memory = NULL;
	}
	if (chunk.memory){
		tmpp = memchr(chunk.memory, ',', chunk.size);
		if (tmpp) id->m_ltrackseq = atol(tmpp + 1) + 1;
		tmpp = memchr(chunk.memory, '\n', chunk.size);
		if (tmpp) {
			tmpp++;
			totbytes = chunk.size - (tmpp - chunk.memory);
			outbufptr = malloc(totbytes + 1);
			memcpy(outbufptr, tmpp, totbytes);
			outbufptr[totbytes] = '\0';
		}
	}
	if (chunk.memory) {
		free(chunk.memory);
	}
	if (!outbufptr) {
		outbufptr = malloc(1);
		outbufptr[0] = '\0';
	}

	// once per minute, get the tails files
	if (id->m_bDHSPerm){
		// only dhs allowed to see type 20 records
		RetrieveTails(id);
	}

	EnterCriticalSection(&id->m_csASDSync);

	append_rec_buffer(&id->m_pASDfilebuf, &id->m_nASDFileNBytes, outbufptr, totbytes);

	free(outbufptr);

	LeaveCriticalSection(&id->m_csASDSync);

}


#ifdef OLDMERGE
int GetASDZipsThread(  struct InstanceData* id, int CkLastTime, int force_refresh, CURL* curl_handle )
{
	time_t secs;
	struct MemoryStruct chunk;
	struct timeb start_time, done_time;
	int delaysecs, ntries;
	char zipfilename[256];
	char url[256];
	char tmpstr[ TMPBUF_SIZE ];
	char targetname[256];
	static int sendmailcount;
	static int samecount;
	char *outbufptr = NULL;
	int replay_adjust_secs;
	int unzipbytes;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!curl_handle) return FALSE;

	secs = time(0);

	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) plottime=%d\n", cdwThreadId, id->m_tPlotTime );

	if (strcmp(id->m_strCurluser, "fusedtest") == 0) {
		if (CkLastTime && !id->m_nDelaySecs && secs - id->m_tLastASDThreadSecs < 1 ){
			SleepEx( 1000, FALSE); // be nice and don't hog cpu just waiting for loop
			return(SUCCEED);
		}
		GetFusedData(id);
		return(SUCCEED);
	}
	if ( CkLastTime ){
		// see if we are in fast replay mode
		if ( id->m_nDelaySecs ){
			// we are in replay mode, use plottime to retrieve next file
			if ( id->m_tASDFileTime < id->m_tPlotTime ){
				// file is behind, get the next file
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) file is behind, Gfiletime=%d plottime=%d\n", 
					cdwThreadId, id->m_tASDFileTime, id->m_tPlotTime );
			} else if ( secs - id->m_tLastASDThreadSecs < 10 ){
				/* we already got it */
				return(SUCCEED);
			}
		} else if ( secs - id->m_tLastASDThreadSecs < 10 ){
			/* we already got it */
			return(SUCCEED);
		}
	}
	id->m_tLastASDThreadSecs = secs;


	ntries = 0;
	do {
		zipfilename[0] = '\0';
		if ( id->m_nDelaySecs || !Class1 ){
			if ( !Class1 ){
				delaysecs = MAX(id->m_nDelaySecs, 300);
			} else {
				delaysecs = id->m_nDelaySecs;
			}
			if ( id->m_nDelaySecs && id->m_nReplaySpeed ){
				replay_adjust_secs = (id->m_tClientsTime - delaystartsecs) * (id->m_nReplaySpeed - 1);
				delaysecs -= replay_adjust_secs;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) delaysecs reduced by %d\n", cdwThreadId, replay_adjust_secs );
			}
			sprintf(tmpstr, "arpt=%s&replay=%d", "asd2", delaysecs );
		} else {
			sprintf(tmpstr, "arpt=%s&ip=%s&u=%s", "asd2" , m_strIPAddress, id->m_strCurluser );
		}
		if ( timeflag ){ftime( &start_time );}
		chunk.memory=NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */
		setCurlTimeout(curl_handle, 4L);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults_r - id->m_strLatestASDcginame <%s> tmpstr <%s>.\n", 
			cdwThreadId, id->m_strLatestASDcginame, tmpstr );
		GetCurlFormGetResults_r( id, curl_handle, &chunk, id->m_strLatestASDcginame, tmpstr, SM_HTTPS, TRUE);
		if ( timeflag ) {
			ftime( &done_time );
			MGLGridText(id, statusgrid, 5, 0, "asd www3");
			sprintf(tmpstr, "%g", uts_timediff(&start_time, &done_time ));
			MGLGridText(id, statusgrid, 5, 1, tmpstr);
		}
		if ( chunk.memory ){
			strncpy( zipfilename, chunk.memory, 255 );
			free( chunk.memory );
			chunk.memory = NULL;
			chunk.size = 0;
		} else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get latest.cgi, trying again\n", cdwThreadId);
		}
	} while (!strlen(zipfilename) && ntries++ < 3 );

	if ( ntries >= 3 ){
		/* failed to get file */
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FAILED ntries =%d, could not open %s\n", cdwThreadId, ntries, tmpstr );

		// send email about the error, only if user is imaputest
		if ( !strcmp( Login.User, "imaputest" ) ){
			// send email alert
			if ( sendmailcount < 4 ){
				sendmailcount++;
				//SendMail("mattmarcella@passur.com", "mattmarcella@passur.com", "Insight Problem",
				//  "Failed to retrieve latest.cgi\n");
			}
		}
		return(FALSE);
	}

	/* clear out buffer */
	chunk.memory=NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	/* ignore 'data/' in beginning */
	strcpy(targetname, &zipfilename[5]);

	if ( !strlen( httpASDservername ) ){
		setinsightServerVars(id);
		if ( !strlen( httpASDservername ) ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to retrieve httpASDservername, exiting\n", cdwThreadId);
			return( FAIL );
		}
	}

	sprintf(url, "%s/%s", httpASDservername, targetname );
	strcpy( id->m_strLastZipName, targetname );

	if ( !strcmp( url, id->m_strPrevASDUrl ) ){
		/* we already got this file */
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Already got this file(%s), skipping\n", cdwThreadId, url);
		if ( samecount++ > 10 ){
			if ( !strcmp( Login.User, "imaputest" ) ){
				// send email alert
				if ( sendmailcount < 4 ){
					sendmailcount++;
					//SendMail("mattmarcella@passur.com", "mattmarcella@passur.com", "Insight Problem",
					//  "Same file retrieved more than 10 times\n");
				}
			}
		}

		return( SUCCEED );
	}
	samecount = 0;
	strcpy(id->m_strPrevASDUrl, url);
	sendmailcount = 0;  // found a good file, so reset email counter
	if ( !strncmp( id->m_strUserName, "sm", 2 ) ){  // take anything for now
		_snprintf( id->m_strLatestPassurURL, sizeof(id->m_strLatestPassurURL), "ASD: %s" ,url );
	}
	if ( timeflag ){ftime( &start_time );}

	id->m_tASDFileTime = CalcFileTime( id, url );

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlPage_r id <%x> url <%s>.\n", cdwThreadId, id,  url);

	if ( GetCurlPage_r( id, curl_handle, &chunk, url, SM_HTTPS, 3, 4L) ){
		// make sure size if large enough, may be problem if zip wasn't done fast enough
		if ( chunk.size < 500 ){
			// try again
			free( chunk.memory );
			chunk.memory = NULL;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) size smaller than expected for asd file, size=%d, try again\n",
				cdwThreadId, chunk.size );
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlPage_r id <%x> url <%s>.\n", cdwThreadId, id,  url));

			if ( !GetCurlPage_r( id, curl_handle, &chunk, url, SM_HTTPS, 3, 4L ) ){
				return( FALSE );
			}
		}

		if ( timeflag ) {
			ftime( &done_time );
			MGLGridText(id, statusgrid, 7, 0, "ASD zipget");
			sprintf(tmpstr, "%g", uts_timediff(&start_time, &done_time ));
			MGLGridText(id, statusgrid, 7, 1, tmpstr);
			MGLGridText(id, statusgrid, 23, 0, "asd name");
			MGLGridText(id, statusgrid, 23, 1, url);
		}

		// Final Test, make sure downloaded data is valid compressed data so imunzip does not loop forever
		if(chunk.memory[0] != 'P' && chunk.memory[1] != 'K'){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid downloaded compressed data file for %s\n", cdwThreadId, url);
			free_chunk_memory(&chunk);
			return(FAIL);
		}

		// use new memory unzip 
		if ( (unzipbytes = imunzip(zipfilename, chunk.memory, chunk.size, &outbufptr )) <= 0 ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) failed to unzip '%s'\n", cdwThreadId, url);
			free_chunk_memory(&chunk);
			return(FAIL);
		}
		if ( chunk.memory ){
			if ( (0 == id->m_tLastMinuteASDStart) || (secs - id->m_tLastMinuteASDStart >= 60) ){
				// display last minute's download amount
				MGLGridText(id, statusgrid, 6, 0, "asd bpm");
				sprintf(tmpstr, "%d", id->m_nASDTotBytes);
				MGLGridText(id, statusgrid, 6, 1, tmpstr);
				id->m_nASDTotBytes = unzipbytes;
				id->m_tLastMinuteASDStart = secs;
			} else {
				id->m_nASDTotBytes += unzipbytes;
			}
		}
		/* clear out buffer */
		free_chunk_memory(&chunk);

		EnterCriticalSection(&id->m_csASDSync);

		// once per minute, get the tails files
		if ( id->m_bDHSPerm ){
			// only dhs allowed to see type 20 records
			RetrieveTails(id);
		}

		append_rec_buffer(&id->m_pASDfilebuf, &id->m_nASDFileNBytes, outbufptr, unzipbytes);

		LeaveCriticalSection(&id->m_csASDSync);

		free(outbufptr);			

		return( SUCCEED );
	}

	return( FAIL );
}



#endif //OLDMERGE

//VOID ASDThread(PVOID pvoid)
//{
//	static int ASDThreadCount;
//  const DWORD cdwThreadId = GetCurrentThreadId();
//
//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Thread %d starting\n", cdwThreadId, ASDThreadCount++);
//
//  while(WAIT_TIMEOUT == WaitForSingleObject(id->m_evShutdown, 1000)){
//    GetASDZipsThread(TRUE, TRUE );
//  }
//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Thread %d terminating\n", cdwThreadId, ASDThreadCount++);
//}



int UpdPastEndpoint(struct InstanceData* id, PTRACK *trackarr, int i, AIR *air)
{
	double curx, cury;
	static int pflag = 0;

	if (i > 0){
		curx = trackarr[i].x;
		cury = trackarr[i].y;

		air->X1 = (GLfloat)trackarr[i - 1].x;
		air->X2 = (GLfloat)curx;
		air->Y1 = (GLfloat)trackarr[i - 1].y;
		air->Y2 = (GLfloat)cury;
		air->Y = (GLfloat)cury;
		air->X = (GLfloat)curx;
		air->TrackStart = i - 1;
	}

	// do not update since we are not moving it VV(AirVO, AI, "PlotMSECS", double ) = ASDplotmsecs;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s past end, keep static,  curx=%g cury=%g plotmsecs=%1.3f\n",
			GetCurrentThreadId(), air->FltNum, curx, cury, air->PlotMSECS / 1000.0);
	}
	return(TRUE);
}


VO *ProcessPassurAirports(struct InstanceData* id, char *membuf)
{
	int matches, len, insight_active;
	char linebuf[256];
	char *eolstr;
	char arptcode[256], passurcode[256], pulse_db_code[256];
	char units[UNITS_SIZE];
	VO *AirportVO = NULL;
	double lat, lng, zerox, zeroy, radarx, radary, radarz, pssrx, pssry, pssrz, alt, period;
	int i;

	while (membuf && strlen(membuf)){
		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);
			linebuf[len] = '\0';

			membuf = eolstr;
			membuf++; /* skip over eol char */

			matches = sscanf_s(linebuf, "%s %s %s %lf %lf %lf %lf %d %lf %lf %lf %lf %lf %lf %lf %lf %s",
				arptcode, _countof(arptcode), passurcode, _countof(passurcode), pulse_db_code, _countof(pulse_db_code), &lat, &lng, &zerox, &zeroy, &insight_active,
				&radarx, &radary, &radarz, &pssrx, &pssry, &pssrz, &alt, &period, units, UNITS_SIZE);
			D_CONTROL("PASSUR_ARPTS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), linebuf));
			if (matches == 17){
				if (!AirportVO){
					AirportVO = (VO *)vo_create(0, NULL);
					vo_set(AirportVO, V_NAME, "PassurAirportVO", NULL);
					VOPropAdd(AirportVO, "icao_code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					VOPropAdd(AirportVO, "passur_code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					VOPropAdd(AirportVO, "pulse_db_code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);

					VOPropAdd(AirportVO, "lat", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "lng", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "zerox", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "zeroy", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "insight_active", INTBIND, -1, VO_NO_ROW);

					VOPropAdd(AirportVO, "radarx", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "radary", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "radarz", FLT8BIND, -1, VO_NO_ROW);

					VOPropAdd(AirportVO, "pssrx", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "pssry", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "pssrz", FLT8BIND, -1, VO_NO_ROW);

					VOPropAdd(AirportVO, "alt", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "period", FLT8BIND, -1, VO_NO_ROW);


					VOPropAdd(AirportVO, "units", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);

					// TAIS Flag, set from radarx,y and z values of zero
					VOPropAdd(AirportVO, "tais", INTBIND, -1, VO_NO_ROW);

					vo_rm_rows(AirportVO, 0, AirportVO->count);
				}
				vo_alloc_rows(AirportVO, 1);
				strncpy_s(VP(AirportVO, AirportVO->count - 1, "icao_code", char), ARPT_CODE_SIZE, arptcode, _TRUNCATE);
				strncpy_s(VP(AirportVO, AirportVO->count - 1, "passur_code", char), ARPT_CODE_SIZE, passurcode, _TRUNCATE);
				strncpy_s(VP(AirportVO, AirportVO->count - 1, "pulse_db_code", char), ARPT_CODE_SIZE, pulse_db_code, _TRUNCATE);
				VV(AirportVO, AirportVO->count - 1, "lat", double) = lat;
				VV(AirportVO, AirportVO->count - 1, "lng", double) = lng;
				VV(AirportVO, AirportVO->count - 1, "zerox", double) = zerox;
				VV(AirportVO, AirportVO->count - 1, "zeroy", double) = zeroy;
				VV(AirportVO, AirportVO->count - 1, "insight_active", int) = insight_active;

				VV(AirportVO, AirportVO->count - 1, "radarx", double) = radarx;
				VV(AirportVO, AirportVO->count - 1, "radary", double) = radary;
				VV(AirportVO, AirportVO->count - 1, "radarz", double) = radarz;

				VV(AirportVO, AirportVO->count - 1, "pssrx", double) = pssrx;
				VV(AirportVO, AirportVO->count - 1, "pssry", double) = pssry;
				VV(AirportVO, AirportVO->count - 1, "pssrz", double) = pssrz;

				VV(AirportVO, AirportVO->count - 1, "alt", double) = alt;
				VV(AirportVO, AirportVO->count - 1, "period", double) = period;

				strncpy_s(VP(AirportVO, AirportVO->count - 1, "units", char), UNITS_SIZE, units, _TRUNCATE);

				if (0.0 == radarx && 0.0 == radary && 0.0 == radarz)
					VV(AirportVO, AirportVO->count - 1, "tais", int) = 1;
				else
					VV(AirportVO, AirportVO->count - 1, "tais", int) = 0;
			}
		} else {
			membuf = NULL;
		}
	}

	if (IS_D_CONTROL("PASSUR_ARPTS")){
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s TAIS=%d\n",
				GetCurrentThreadId(), i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "icao_code", char), VV(AirportVO, i, "tais", int));
		}
	}
	return(AirportVO);
}

void ResetAirportVO(struct InstanceData* id)
{
	const DWORD cdwThreadId = GetCurrentThreadId();

	EnterCriticalSection(&id->m_csAirportsVO);
	if (id->m_pAirportsVO)
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Resetting Airports VO.\n", cdwThreadId);
		vo_rm_rows(id->m_pAirportsVO, 0, ((VO*)id->m_pAirportsVO)->count);
		vo_free(id->m_pAirportsVO);
		id->m_pAirportsVO = NULL;
	}
	LeaveCriticalSection(&id->m_csAirportsVO);
}


BOOL LoadPassurAirports(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	char buffer[ SERVERNAME_SZ ] = {0};
	static char lastcmdtime[VO_NAME_SIZE];
	char outbuf[TMPBUF_SIZE];
	int retry = 0;
	BOOL bSuccess = FALSE;
	const char* cNoArptSpecified = "no arpt specified";
	const DWORD cdwThreadId = GetCurrentThreadId();

	EnterCriticalSection(&id->m_csAirportsVO);

	ResetAirportVO(id);

	while (!id->m_pAirportsVO && retry++ < 4)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=PassurArpts");
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tmpstr='%s', lastcmdtime='%s'\n", cdwThreadId, tmpstr, VOTimeFmt(lastcmdtime, time(0), "%Y-%m-%d %H:%M:%S")));

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPassurServer <%s> tmpstr <%s>.\n",
			cdwThreadId, GetPassurSrvr(id), tmpstr );
		sprintf_s(buffer, SERVERNAME_SZ, "https://%s/fcgi/fastupdates.fcg", GetPassurSrvr(id));

		if(!GetCurlFormGetResults( id, &chunk, buffer, tmpstr, SM_HTTPS, TRUE ) || 
			!strncmp(chunk.memory, cNoArptSpecified, strlen(cNoArptSpecified))) // Handles Old fastupdates.fcg that does not have PassurArpts action.
		{
			clear_chunk_memory(&chunk);
			NotePassurServerFailure(id);
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=PassurArpts from %s retry attempt %d\n",
				cdwThreadId, GetPassurSrvr(id), retry);
		}

		if (chunk.memory){
			strncpy_s(outbuf, TMPBUF_SIZE, chunk.memory, 255);
			id->m_pAirportsVO = (VO *)ProcessPassurAirports(id, chunk.memory);
			free(chunk.memory);
			bSuccess = TRUE;
			break;
		}
	}

	if (!id->m_pAirportsVO){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) Failed to Load PASSUR Airport Data\n",
			cdwThreadId);
	}

	LeaveCriticalSection(&id->m_csAirportsVO);
	return(bSuccess);
}



VO *ProcessIataArpts(struct InstanceData* id, char *membuf)
{
	const DWORD cdwThreadId = GetCurrentThreadId();
	char iata[ARPT_CODE_SIZE], icao[ARPT_CODE_SIZE], faa[ARPT_CODE_SIZE];
	VO *IATAArptVO = NULL;
	int pflag = 0, len, matches;
	char *eolstr;
	char linebuf[1024];

	while (membuf && strlen(membuf)){

		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);
			linebuf[len] = '\0';

			membuf = eolstr;
			membuf++; /* skip over eol char */

			matches = sscanf_s(linebuf, "%s %s %s",
				iata, _countof(iata), icao, _countof(icao), faa, _countof(faa));

			D_CONTROL("IATA_ARPTS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), linebuf));
			if (matches == 3){
				if (!IATAArptVO){
					IATAArptVO = (VO *)vo_create(0, NULL);
					vo_set(IATAArptVO, V_NAME, "IATAArptVO", NULL);
					VOPropAdd(IATAArptVO, "iata", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					VOPropAdd(IATAArptVO, "icao", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					VOPropAdd(IATAArptVO, "faa", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					vo_rm_rows(IATAArptVO, 0, IATAArptVO->count);
				}
				vo_alloc_rows(IATAArptVO, 1);
				strncpy_s(VP(IATAArptVO, IATAArptVO->count - 1, "iata", char), ARPT_CODE_SIZE, iata, _TRUNCATE);
				strncpy_s(VP(IATAArptVO, IATAArptVO->count - 1, "icao", char), ARPT_CODE_SIZE, icao, _TRUNCATE);
				strncpy_s(VP(IATAArptVO, IATAArptVO->count - 1, "faa", char), ARPT_CODE_SIZE, faa, _TRUNCATE);

			}
		}
		else {
			membuf = NULL;
		}
	}

	return(IATAArptVO);
}

// AirlineCodes
VO *ProcessAirlineCodes(struct InstanceData* id, char *membuf)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	VO *AirlineVO = NULL;
	int pflag = 0;

	if (membuf && strlen(membuf)){
		jobj = json_tokener_parse_verbose(membuf, &jerror);
		if (json_tokener_success == jerror){
			if (jobj && json_type_array == json_object_get_type(jobj)){
				int nPos, nLen = json_object_array_length(jobj);
				for (nPos = 0; nPos < nLen; nPos++){
					struct json_object_iter jiter;
					struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
					if (!AirlineVO){
						AirlineVO = (VO *)vo_create(0, NULL);
						vo_set(AirlineVO, V_NAME, "AirlineCodesVO", NULL);
						VOPropAdd(AirlineVO, "iata", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirlineVO, "icao", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirlineVO, "name", NTBSTRINGBIND, MAX_AIRLINE_NAME_SIZE, VO_NO_ROW);
						vo_rm_rows(AirlineVO, 0, AirlineVO->count);
					}
					vo_alloc_rows(AirlineVO, 1);
					json_object_object_foreachC(jelem, jiter){
						if (!strcmp(jiter.key, "_class")); // Do nothing for class							
						else if (!strcmp(jiter.key, "iata"))
							strncpy_s(VP(AirlineVO, AirlineVO->count - 1, "iata", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "icao"))
							strncpy_s(VP(AirlineVO, AirlineVO->count - 1, "icao", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "name"))
							strncpy_s(VP(AirlineVO, AirlineVO->count - 1, "name", char), MAX_AIRLINE_NAME_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else
							vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring unused element <%s>\n", cdwThreadId, jiter.key);
					}
				}
			}else{
				struct json_object* jdesc = json_object_object_get(jobj, "description");
				if (jdesc){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid Airline Code object.\n", cdwThreadId);
				}
			}
			json_object_put(jobj);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error processing JSON <%s>.\n", cdwThreadId, membuf);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process Airline Codes, memeory buffer is empty.\n", cdwThreadId);
	}
	if (pflag){
		int i;
		for (i = 0; AirlineVO && i < AirlineVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", cdwThreadId, i, AirlineVO->row_index[i].rownum,
				VP(AirlineVO, i, "icao", char));
		}
	}

	return(AirlineVO);
}

VO *ProcessAsdexAirports(struct InstanceData* id, char *membuf)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	VO *AirportVO = NULL;
	int pflag = 0;

	if (membuf && strlen(membuf)){
		jobj = json_tokener_parse_verbose(membuf, &jerror);
		if (json_tokener_success == jerror){
			if (jobj && json_type_array == json_object_get_type(jobj)){
				int nPos, nLen = json_object_array_length(jobj);
				for (nPos = 0; nPos < nLen; nPos++){
					struct json_object_iter jiter;
					struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
					if (!AirportVO){
						AirportVO = (VO *)vo_create(0, NULL);
						vo_set(AirportVO, V_NAME, "AsdexAirportVO", NULL);
						VOPropAdd(AirportVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirportVO, "asdex_code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirportVO, "active", INTBIND, -1, VO_NO_ROW);
						vo_rm_rows(AirportVO, 0, AirportVO->count);
					}
					vo_alloc_rows(AirportVO, 1);
					json_object_object_foreachC(jelem, jiter){
						if (!strcmp(jiter.key, "_class")); // Do nothing for class							
						else if (!strcmp(jiter.key, "code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "asdex_code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "asdex_code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "active"))
							VV(AirportVO, AirportVO->count - 1, "active", int) = json_object_get_int(jiter.val);
						else
							vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring unused element <%s>\n", cdwThreadId, jiter.key);
					}
				}
			}else{
				struct json_object* jdesc = json_object_object_get(jobj, "description");
				if (jdesc){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid Asdex Airport object.\n", cdwThreadId);
				}
			}
			json_object_put(jobj);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error processing JSON <%s>.\n", cdwThreadId, membuf);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process AsdexAirports, memeory buffer is empty.\n", cdwThreadId);
	}
	if (pflag){
		int i;
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", cdwThreadId, i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "icao_code", char));
		}
	}
	return(AirportVO);
}

VO *ProcessAdsbAirports(struct InstanceData* id, char *membuf)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	VO *AirportVO = NULL;
	int pflag = 0;

	if (membuf && strlen(membuf)){
		jobj = json_tokener_parse_verbose(membuf, &jerror);
		if (json_tokener_success == jerror){
			if (jobj && json_type_array == json_object_get_type(jobj)){
				int nPos, nLen = json_object_array_length(jobj);
				for (nPos = 0; nPos < nLen; nPos++){
					struct json_object_iter jiter;
					struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
					if (!AirportVO){
						AirportVO = (VO *)vo_create(0, NULL);
						vo_set(AirportVO, V_NAME, "AdsbAirportVO", NULL);
						VOPropAdd(AirportVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirportVO, "adsb_code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirportVO, "active", INTBIND, -1, VO_NO_ROW);
						vo_rm_rows(AirportVO, 0, AirportVO->count);
					}
					vo_alloc_rows(AirportVO, 1);
					json_object_object_foreachC(jelem, jiter){
						if (!strcmp(jiter.key, "_class")); // Do nothing for class							
						else if (!strcmp(jiter.key, "code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "adsb_code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "adsb_code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "active"))
							VV(AirportVO, AirportVO->count - 1, "active", int) = json_object_get_int(jiter.val);
						else
							vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring unused element <%s>\n", cdwThreadId, jiter.key);
					}
				}
			}else{
				struct json_object* jdesc = json_object_object_get(jobj, "description");
				if (jdesc){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid ADS-B Airport object.\n", cdwThreadId);
				}
			}
			json_object_put(jobj);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error processing JSON <%s>.\n", cdwThreadId, membuf);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process AdsbAirports, memeory buffer is empty.\n", cdwThreadId);
	}
	if (pflag){
		int i;
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", cdwThreadId, i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "icao_code", char));
		}
	}
	return(AirportVO);
}

VO *ProcessLMGAirports( struct InstanceData* id, char *membuf )
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	VO *AirportVO = NULL;
	int pflag = 0;

	if ( membuf && strlen(membuf) ){
		jobj = json_tokener_parse_verbose(membuf, &jerror);
		if(json_tokener_success == jerror){
			if(jobj && json_type_array == json_object_get_type(jobj)){
				int nPos, nLen = json_object_array_length(jobj);
				for(nPos = 0; nPos < nLen; nPos++){
					struct json_object_iter jiter;
					struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
					if ( !AirportVO ){
						AirportVO = (VO *) vo_create( 0, NULL );
						vo_set( AirportVO, V_NAME, "LMGAirportVO", NULL );
						VOPropAdd( AirportVO, "icao", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW );
						VOPropAdd( AirportVO, "iata", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW );
						VOPropAdd( AirportVO, "active", INTBIND, -1, VO_NO_ROW );
						vo_rm_rows( AirportVO, 0, AirportVO->count );
					}
					vo_alloc_rows( AirportVO, 1);
					json_object_object_foreachC(jelem, jiter){
						if(!strcmp(jiter.key, "_class")); // Do nothing for class							
						else if(!strcmp(jiter.key, "icao"))
							strncpy_s( VP(AirportVO, AirportVO->count - 1, "icao", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE );
						else if(!strcmp(jiter.key, "iata"))
							strncpy_s( VP(AirportVO, AirportVO->count - 1, "iata", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE  );
						else if(!strcmp(jiter.key, "active"))
							VV(AirportVO, AirportVO->count - 1, "active", int) = json_object_get_int(jiter.val);
						else
							vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring unused element <%s>\n", cdwThreadId, jiter.key);
					}
				}
			}else{
				struct json_object* jdesc = json_object_object_get(jobj, "description");
				if(jdesc){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid LMG Airport object.\n", cdwThreadId);
				}
			}
			json_object_put(jobj);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error processing JSON <%s>.\n", cdwThreadId, membuf);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process LMGAirports, memeory buffer is empty.\n", cdwThreadId);
	}
	if (pflag){
		int i;
		for (i = 0; AirportVO && i < AirportVO->count; i++ ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) LMG[%d] rowindex=%d, =%s\n", cdwThreadId, i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "icao", char) );
		}
	}
	return( AirportVO );
}

VO *ProcessMlatAirports(struct InstanceData* id, char *membuf)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	VO *AirportVO = NULL;
	int pflag = 0;

	if (membuf && strlen(membuf)){
		jobj = json_tokener_parse_verbose(membuf, &jerror);
		if (json_tokener_success == jerror){
			if (jobj && json_type_array == json_object_get_type(jobj)){
				int nPos, nLen = json_object_array_length(jobj);
				for (nPos = 0; nPos < nLen; nPos++){
					struct json_object_iter jiter;
					struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
					if (!AirportVO){
						AirportVO = (VO *)vo_create(0, NULL);
						vo_set(AirportVO, V_NAME, "MlatAirportVO", NULL);
						VOPropAdd(AirportVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirportVO, "mlat_code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						VOPropAdd(AirportVO, "active", INTBIND, -1, VO_NO_ROW);
						vo_rm_rows(AirportVO, 0, AirportVO->count);
					}
					vo_alloc_rows(AirportVO, 1);
					json_object_object_foreachC(jelem, jiter){
						if (!strcmp(jiter.key, "_class")); // Do nothing for class							
						else if (!strcmp(jiter.key, "code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "mlat_code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "mlat_code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else if (!strcmp(jiter.key, "active"))
							VV(AirportVO, AirportVO->count - 1, "active", int) = json_object_get_int(jiter.val);
						else
							vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring unused element <%s>\n", cdwThreadId, jiter.key);
					}
				}
			}else{
				struct json_object* jdesc = json_object_object_get(jobj, "description");
				if (jdesc){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid M-LAT Airport object.\n", cdwThreadId);
				}
			}
			json_object_put(jobj);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error processing JSON <%s>.\n", cdwThreadId, membuf);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process MlatAirports, memory buffer is empty.\n", cdwThreadId);
	}
	if (pflag){
		int i;
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", cdwThreadId, i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "icao_code", char));
		}
	}
	return(AirportVO);
}

VO *ProcessBMRAirports(struct InstanceData* id, char *membuf)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	VO *AirportVO = NULL;

	if (membuf && strlen(membuf)){
		jobj = json_tokener_parse_verbose(membuf, &jerror);
		if (json_tokener_success == jerror){
			if (jobj && json_type_array == json_object_get_type(jobj)){
				int nPos, nLen = json_object_array_length(jobj);
				for (nPos = 0; nPos < nLen; nPos++){
					struct json_object_iter jiter;
					struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
					if (!AirportVO){
						AirportVO = (VO *)vo_create(0, NULL);
						vo_set(AirportVO, V_NAME, "BMRAirportVO", NULL);
						VOPropAdd(AirportVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
						vo_rm_rows(AirportVO, 0, AirportVO->count);
					}
					vo_alloc_rows(AirportVO, 1);
					json_object_object_foreachC(jelem, jiter){
						if (!strcmp(jiter.key, "_class")); // Do nothing for class							
						else if (!strcmp(jiter.key, "code"))
							strncpy_s(VP(AirportVO, AirportVO->count - 1, "code", char), ARPT_CODE_SIZE, json_object_get_string(jiter.val), _TRUNCATE);
						else
							vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring unused element <%s>\n", cdwThreadId, jiter.key);
					}
				}
			}else{
				struct json_object* jdesc = json_object_object_get(jobj, "description");
				if (jdesc){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid ADS-B Airport object.\n", cdwThreadId);
				}
			}
			json_object_put(jobj);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error processing JSON <%s>.\n", cdwThreadId, membuf);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process AdsbAirports, memeory buffer is empty.\n", cdwThreadId);
	}
	if (IS_D_CONTROL(__FUNCTION__)){
		int i;
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", cdwThreadId, i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "code", char));
		}
	}
	return(AirportVO);
}


VO *LoadAsdexAirports(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static VO *AirportsVO = NULL;


	if (!AirportsVO)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=AsdexArpts");

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentHttpServer <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (GetCurlFormGetResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE))
		{
			if (chunk.memory){
				AirportsVO = (VO *)ProcessAsdexAirports(id, chunk.memory);
				free_chunk_memory(&chunk);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
					"(0x%X) Could not get Action=AsdexArpts from %s, empty dataset from server.\n",
					cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex]);
			}
		}else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=AsdexArpts from %s, GetCurlFormGetResults failed changing server to %s.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], GetNxtSurfSrvr(id));
		}
	}

	return(AirportsVO);
}

// AirlineCodes
VO  *LoadIATA_ICAO_Arpts(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static VO * IATAAirlinesVO = NULL;
	char *servername;

	servername = id->m_strHttpDBservername[id->m_nDBServerIndex];  // once we update, use this line
	servername = "https://www54.passur.com/fcgi/PulseTrack.fcg";  // for testing
	if (!IATAAirlinesVO)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=RdIataArpts");

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentHttpServer <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (GetCurlFormGetResults(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE))
		{
			if (chunk.memory){
				IATAAirlinesVO = (VO *) ProcessIataArpts(id, chunk.memory);
				free_chunk_memory(&chunk);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
					"(0x%X) Could not get Action=AirlineCodes from %s, empty dataset from server.\n",
					cdwThreadId, servername);
			}
		}else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=AirlineCodes from %s, GetCurlFormGetResults failed changing server to %s.\n",
				cdwThreadId, servername, GetNxtSurfSrvr(id));
		}
	}

	
	return IATAAirlinesVO;
}



// AirlineCodes
void LoadAirlineCodes(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static VO * AirlinesVO = NULL;

	if (!AirlinesVO)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=AirlineCodes");

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentHttpServer <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (GetCurlFormGetResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE))
		{
			if (chunk.memory){
				AirlinesVO = (VO *)ProcessAirlineCodes(id, chunk.memory);
				free_chunk_memory(&chunk);
			}
			else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
					"(0x%X) Could not get Action=AirlineCodes from %s, empty dataset from server.\n",
					cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex]);
			}
		}
		else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=AirlineCodes from %s, GetCurlFormGetResults failed changing server to %s.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], GetNxtSurfSrvr(id));
		}
	}

	// Give the user access to the Airline Codes
	if (!id->m_bAirlineCodesLoaded)
	{
		id->m_pAirlineCodes = AirlinesVO;
		id->m_bAirlineCodesLoaded = TRUE;
	}

	return;
}


VO *LoadLMGAirports( struct InstanceData* id )
{
	struct MemoryStruct chunk;
	char tmpstr[ TMPBUF_SIZE ];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static VO *AirportsVO = NULL;


	if(!AirportsVO)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=LMGArpts" );

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentHttpServer <%s> tmpstr <%s>.\n", 
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr );

		if( GetCurlFormGetResults( id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE ))
		{
			if ( chunk.memory ){
				AirportsVO = (VO *) ProcessLMGAirports( id, chunk.memory );
				free_chunk_memory( &chunk );				
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
					"(0x%X) Could not get Action=LMGArpts from %s, empty dataset from server.\n",
					cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex]);
			}			
		}else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=LMGArpts from %s, GetCurlFormGetResults failed changing server to %s.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], GetNxtSurfSrvr(id));			
		}
	}

	return( AirportsVO );
}

VO *LoadAdsbAirports(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static VO *AirportsVO = NULL;


	if (!AirportsVO)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=AdsbArpts");

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentHttpServer <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (GetCurlFormGetResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE))
		{
			if (chunk.memory){
				AirportsVO = (VO *)ProcessAdsbAirports(id, chunk.memory);
				free_chunk_memory(&chunk);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
					"(0x%X) Could not get Action=AdsbArpts from %s, empty dataset from server.\n",
					cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex]);
			}
		}else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=AdsbArpts from %s, GetCurlFormGetResults failed changing server to %s.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], GetNxtSurfSrvr(id));
		}
	}

	return(AirportsVO);
}

VO *LoadMLATAirports(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static VO *AirportsVO = NULL;


	if (!AirportsVO)
	{
		clear_chunk_memory(&chunk);

		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=MlatArpts");

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentHttpServer <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (GetCurlFormGetResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE))
		{
			if (chunk.memory){
				AirportsVO = (VO *)ProcessMlatAirports(id, chunk.memory);
				free_chunk_memory(&chunk);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
					"(0x%X) Could not get Action=MlatArpts from %s, empty dataset from server.\n",
					cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex]);
			}
		}else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) Could not get Action=MlatArpts from %s, GetCurlFormGetResults failed changing server to %s.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], GetNxtSurfSrvr(id));
		}
	}

	return(AirportsVO);
}

int IsValidPassurAirport(struct InstanceData* id, char* strArpt)
{
	int i, bFound = FALSE;
	VO* AirportsVO = (VO*)id->m_pAirportsVO;
	if (AirportsVO){
		for (i = 0; AirportsVO && i < AirportsVO->count && !bFound; i++){
			if (!strcasecmp(VP(AirportsVO, i, "passur_code", char), strArpt)){
				bFound = TRUE;
			}
		}
	}
	return bFound;
}

int IsValidAsdexAirport(struct InstanceData* id, char* strArpt)
{
	int i, bFound = FALSE;
	VO* AirportsVO = NULL;
	AirportsVO = LoadAsdexAirports(id);
	if (AirportsVO){
		for (i = 0; AirportsVO && i < AirportsVO->count && !bFound; i++){
			if (!strcasecmp(VP(AirportsVO, i, "asdex_code", char), strArpt)){
				bFound = TRUE;
			}
		}
	}
	return bFound;
}

int IsValidAdsbAirport(struct InstanceData* id, char* strArpt)
{
	int i, bFound = FALSE;
	VO* AirportsVO = NULL;
	AirportsVO = LoadAdsbAirports(id);
	if (AirportsVO){
		for (i = 0; AirportsVO && i < AirportsVO->count && !bFound; i++){
			if (!strcasecmp(VP(AirportsVO, i, "adsb_code", char), strArpt)){
				bFound = TRUE;
			}
		}
	}
	return bFound;
}

int IsValidLMGAirport( struct InstanceData* id, char* strArpt )
{
	int i, bFound = FALSE;
	VO* AirportsVO = NULL;
	AirportsVO = LoadLMGAirports(id);
	if(AirportsVO){		
		for (i = 0; AirportsVO && i < AirportsVO->count && !bFound; i++ ){
			if ( !strcasecmp( VP(AirportsVO, i, "icao", char ), strArpt ) ){
				bFound = TRUE;
			}
		}
	}
	return bFound;
}

int IsValidMLATAirport(struct InstanceData* id, char* strArpt)
{
	int i, bFound = FALSE;
	VO* AirportsVO = NULL;
	AirportsVO = LoadMLATAirports(id);
	if (AirportsVO){
		for (i = 0; AirportsVO && i < AirportsVO->count && !bFound; i++){
			if (!strcasecmp(VP(AirportsVO, i, "mlat_code", char), strArpt)){
				bFound = TRUE;
			}
		}
	}
	return bFound;
}

void GetAirplaneImage(  struct InstanceData* id, char *filename, int ngroup, int ntexture )
{
	gdImagePtr im;
	FILE *in;
	int row, col;
	unsigned int c;
	int alpha, pflag = 0;
	char tmpstr[TMPBUF_SIZE];

	/* use gdlib to grab image */


	if (!GetLocalFile(id, id->m_strImageDir, filename, id->m_strHttpImagePath, SM_HTTPS)){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename);
		// MessageBox(MainWin, tmpstr,"GetAirplaneImage",MB_OK);
		return;
	}

	sprintf_s(tmpstr, TMPBUF_SIZE, "%s%s", id->m_strImageDir, filename);
	if (fopen_s(&in, tmpstr, "rb")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename);
		//   MessageBox(MainWin, tmpstr,"GetAirplaneImage",MB_OK);
		return;
	}


	im = gdImageCreateFromPng(in);
	fclose(in);
	/* ... Use the image ... */

	if (!im){
		sprintf_s(tmpstr, TMPBUF_SIZE, "PNG file %s corrupted, could not create image.", filename);
		return;
	}

	ARows = 64;
	ACols = 64;

	for (row = 0; row < ARows; row++){
		for (col = 0; col < ACols; col++){

			c = gdImageGetPixel(im, col, row);

			if (c < 0 || c > 255){
				alpha = 0;
				id->m_gluAirImages[ngroup][ntexture][row][col][0] = 0;
				id->m_gluAirImages[ngroup][ntexture][row][col][1] = 0;
				id->m_gluAirImages[ngroup][ntexture][row][col][2] = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if (alpha > 255) alpha = 255;
				id->m_gluAirImages[ngroup][ntexture][row][col][0] = im->red[c];
				id->m_gluAirImages[ngroup][ntexture][row][col][1] = im->green[c];
				id->m_gluAirImages[ngroup][ntexture][row][col][2] = im->blue[c];
			}

#define MAKE_PLANE_OPAQUE 1
#if MAKE_PLANE_OPAQUE
			// make any non-black pixels, completely opaque
			if (alpha != 0)  {
				alpha = 255;
			}
#else
			// if ( alpha > 255 ){alpha=255;}
			// add some transparency if alpha < 255
			if ( alpha > 196 ){alpha=196;}
#endif

			id->m_gluAirImages[ngroup][ntexture][row][col][3] = alpha;

			if (pflag){
				const DWORD cdwThreadId = GetCurrentThreadId();
				if (c < 0 || c > 255)
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ntexture=%d image[%d][%d] imred=0 imgr=0 imbl=0 im_alpha=0\n",
					cdwThreadId, ntexture, row, col);
				else
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ntexture=%d image[%d][%d] imred=%d imgr=%d imbl=%d im_alpha=%d\n",
					cdwThreadId, ntexture, row, col, im->red[c], im->green[c], im->blue[c], im->alpha[c]);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) image[%d][%d] red=%d gr=%d bl=%d al=%d\n",
					row, col, id->m_gluAirImages[ngroup][ntexture][row][col][0], id->m_gluAirImages[ngroup][ntexture][row][col][1],
					cdwThreadId, id->m_gluAirImages[ngroup][ntexture][row][col][2], alpha);
			}

		}
	}

	gdImageDestroy(im);
}

void GetVehicleImage(  struct InstanceData* id, char *filename, int ntexture )
{
	gdImagePtr im;
	FILE *in;
	int row, col;
	unsigned int c;
	int alpha, pflag = 0;
	char tmpstr[TMPBUF_SIZE];

	/* use gdlib to grab image */


	if( !GetLocalFile(id, id->m_strImageDir, filename, id->m_strHttpImagePath, SM_HTTPS)  ){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename );
		// MessageBox(MainWin, tmpstr,"GetAirplaneImage",MB_OK);
		return;
	}

	sprintf_s( tmpstr, TMPBUF_SIZE, "%s%s", id->m_strImageDir, filename );
	if ( fopen_s(&in, tmpstr, "rb") ){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename );
		//   MessageBox(MainWin, tmpstr,"GetAirplaneImage",MB_OK);
		return;
	}


	im = gdImageCreateFromPng(in);
	fclose(in);
	/* ... Use the image ... */

	if ( !im ){
		sprintf_s(tmpstr, TMPBUF_SIZE, "PNG file %s corrupted, could not create image.", filename );
		return;
	}

	ARows = 64;
	ACols = 64;

	for ( row = 0; row < ARows; row++ ){
		for ( col = 0; col < ACols; col++ ){

			c = gdImageGetPixel(im, col, row);

			if ( c < 0 || c > 255 ){
				alpha = 0;
				id->m_gluVehImages[ntexture][row][col][0] = 0;
				id->m_gluVehImages[ntexture][row][col][1] = 0;
				id->m_gluVehImages[ntexture][row][col][2] = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if ( alpha > 255 ) alpha = 255;
				id->m_gluVehImages[ntexture][row][col][0] = im->red[c];
				id->m_gluVehImages[ntexture][row][col][1] = im->green[c];
				id->m_gluVehImages[ntexture][row][col][2] = im->blue[c];
			}

#define MAKE_PLANE_OPAQUE 1
#if MAKE_PLANE_OPAQUE
			// make any non-black pixels, completely opaque
			if ( alpha != 0 )  {
				alpha = 255;
			}
#else
			// if ( alpha > 255 ){alpha=255;}
			// add some transparency if alpha < 255
			if ( alpha > 196 ){alpha=196;}
#endif

			id->m_gluVehImages[ntexture][row][col][3] = alpha;

			if ( pflag ){
				const DWORD cdwThreadId = GetCurrentThreadId();
				if ( c < 0 || c > 255 )
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ntexture=%d image[%d][%d] imred=0 imgr=0 imbl=0 im_alpha=0\n",
					cdwThreadId, ntexture, row, col );
				else
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ntexture=%d image[%d][%d] imred=%d imgr=%d imbl=%d im_alpha=%d\n",
					cdwThreadId, ntexture, row, col, im->red[c], im->green[c], im->blue[c], im->alpha[c] );
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) image[%d][%d] red=%d gr=%d bl=%d al=%d\n",
					row, col, id->m_gluVehImages[ntexture][row][col][0], id->m_gluVehImages[ntexture][row][col][1],
					cdwThreadId, id->m_gluVehImages[ntexture][row][col][2], alpha);
			}

		}
	}

	gdImageDestroy(im);
}


int GetAirplaneTexImage(struct InstanceData* id)
{
	int i, j;
	char filename[FILENAME_SZ] = {0};
	const char cColors[17][12] = { "darkBlue",
								   "silver",
								   "gold",
								   "maroon",
								   "red",
								   "orange",
								   "kumquat",
								   "olive",
								   "lime",
								   "forest",
								   "teal",
								   "lightBlue",
								   "blueGray",
								   "lightPurple",
								   "darkPurple",
								   "passion",
								   "ghost" };
	const char cAcTypes[N_AC_GROUPS][15] = { "regional",
											 "midbody_wings",
											 "midbody_tail",
											 "widebody" };

	for(j = 0; j < N_AC_GROUPS; j++){
		for(i = 0; i < N_AIRCRAFT_COLORS; i++){
			sprintf_s(filename, FILENAME_SZ, "%s_%s.png", cColors[i], cAcTypes[j]);
			GetAirplaneImage(id, filename, j, i);
			D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile,__FUNCTION__, "(0x%X) Loading Aircraft Texture %s_%s.png.\n", GetCurrentThreadId(), cColors[i], cAcTypes[j])); 
		}
	}
	return( TRUE );
}

int GetVehicleTexImage( struct InstanceData* id )
{	
	// Load Vehicle Colors
	GetVehicleImage(id, "icon_01_darkblue.png", 0 );
	GetVehicleImage(id, "icon_01_silver.png", 1 );
	GetVehicleImage(id, "icon_01_gold.png", 2 );
	GetVehicleImage(id, "icon_01_maroon.png" , 3 );
	GetVehicleImage(id, "icon_01_red.png", 4 );
	GetVehicleImage(id, "icon_01_orange.png", 5 );
	GetVehicleImage(id, "icon_01_kumquat.png", 6 );
	GetVehicleImage(id, "icon_01_olive.png", 7 );
	GetVehicleImage(id, "icon_01_lime.png", 8 );
	GetVehicleImage(id, "icon_01_forrest.png", 9 );
	GetVehicleImage(id, "icon_01_teal.png", 10 );
	GetVehicleImage(id, "icon_01_lightblue.png", 11 );
	GetVehicleImage(id, "icon_01_bluegrey.png", 12 );
	GetVehicleImage(id, "icon_01_lightpurple.png", 13 );
	GetVehicleImage(id, "icon_01_darkpurple.png", 14 );
	GetVehicleImage(id, "icon_01_passion.png", 15 );

	return(TRUE);
}


/* function to load in bitmap as a GL texture */
int LoadGLTextures(struct InstanceData* id)
{
	/* Status indicator */
	int Status = FALSE;
	int i, j;

	GetAirplaneTexImage(id);
	GetVehicleTexImage(id);

	/* Load The Bitmap, Check For Errors, If Bitmap's Not Found Quit */
	GL_ASSERT(glPixelStorei(GL_UNPACK_ALIGNMENT, 1));
	for (j = 0; j < N_AC_GROUPS; j++){
		GL_ASSERT(glGenTextures( N_AIRCRAFT_COLORS, &id->m_gluAircraftTextures[j][0] ));
	for (i = 0; i < N_AIRCRAFT_COLORS; i++){
			D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile,__FUNCTION__, "(0x%X) Generated Aircraft Texture %d: %d.\n", GetCurrentThreadId(), i, id->m_gluAircraftTextures[j][i])); 
		}
	}

	for (j = 0; j < N_AC_GROUPS; j++){
	for (i = 0; i < N_AIRCRAFT_COLORS; i++){
			GL_ASSERT(glBindTexture( GL_TEXTURE_2D,  id->m_gluAircraftTextures[j][i] ));
			// Generate The Texture
		GL_ASSERT(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 64, 64, 0, GL_RGBA,
			GL_UNSIGNED_BYTE,
				id->m_gluAirImages[j][i] ));

			// Linear Filtering
			GL_ASSERT(glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
				GL_LINEAR ));
			GL_ASSERT(glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
				GL_LINEAR ));
		}
	}

	GL_ASSERT(glGenTextures( N_VEHICLE_COLORS, &id->m_gluVehicleTextures[0] ));
	for(i = 0; i < N_VEHICLE_COLORS; i++){
		D_CONTROL("VEHICLE_TEXTURES", vo_log_info(id->m_pfVoLogFile,__FUNCTION__, "(0x%X) Generated Vehicle Texture %d: %d.\n", GetCurrentThreadId(), i, id->m_gluVehicleTextures[i])); 
	}

	for (i = 0; i < N_VEHICLE_COLORS; i++ ){
		GL_ASSERT(glBindTexture( GL_TEXTURE_2D,  id->m_gluVehicleTextures[i] ));
		// Generate The Texture 
		GL_ASSERT(glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, 64,64, 0, GL_RGBA,
			GL_UNSIGNED_BYTE,
			id->m_gluVehImages[i] ));

		// Linear Filtering 
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
			GL_LINEAR));
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
			GL_LINEAR));
	}

	//GUIGetImages();
	//GUIGenTextures();
	WxGenTextures(id);
	// glGenTextures( NActiveRadars, &wxtexture[0] );

#ifdef TERRAIN
	if ( UseTerrainMaps ){
		if ( !UseSingleImage && !UseSingleTexture ){
			MapGenTextures();
			// MapGenImages();
			//SingleMapImage();
			SmallMapGenTextures();
		}
	}
#endif
	id->m_bIconsLoaded = TRUE;
	return TRUE;

}



void SetUpPassur(struct InstanceData* id)
{
	int airportindex;
	char defarpt[] = "jfkF";
	char defcode[] = "jfk";
	VO* PassurArptsVO = NULL;

	// for now, until we setup logins, use hardwired logins
	strcpy_s(id->m_sLogin.User, LOGIN_MAX_SZ, "fwuser");
	strcpy_s(id->m_sLogin.Password, LOGIN_MAX_SZ, "rhino");
	sprintf_s(id->m_strCurlupwd, 256, "%s:%s", id->m_sLogin.User, id->m_sLogin.Password);
	strncpy_s(id->m_strCurluser, 64, id->m_sLogin.User, _TRUNCATE);
	strncpy_s(id->m_strCurlpwd, 64, id->m_sLogin.Password, _TRUNCATE);

	// strcpy(id->m_strPassurArpts[0], "jfkF" );
	if (id->m_sCurLayout.m_strPassurArpt[0] == '\0'){
		strcpy_s(id->m_strPassurArpts[0], 5, defarpt); // avoid overriding to lga when UI has a different value
		strcpy_s(id->m_sCurLayout.m_strPassurArpt, LAYOUT_PASSUR_SIZE, defcode);
		// Set asdex airport to default airport
		sprintf_s(id->m_strAsdexArpt, 5, "%sF", defcode);
		sprintf_s(id->m_strAdsbArpt, 5, "%sF", defcode);
		sprintf_s(id->m_strMLATArpt, 5, "%sF", defcode);
		sprintf_s(id->m_strNoiseArpt, 5, "%s", defcode);
		id->m_nAsdexArpt = -1;
		id->m_nAdsbArpt = -1;
		id->m_nMLATArpt = -1;
	}

	id->m_bIsPassurTais = FALSE;
	EnterCriticalSection(&id->m_csAirportsVO);
	PassurArptsVO = (VO*)id->m_pAirportsVO;
	if (PassurArptsVO && (airportindex = FindAirportIndex(id, id->m_sCurLayout.m_strPassurArpt)) >= 0){
		strncpy_s(id->m_strPassurArpts[0], LAYOUT_PASSUR_SIZE, VP(PassurArptsVO, airportindex, "passur_code", char), ORIG_DES_SIZE - 1);
		id->m_dLatitudes[0] = VV(PassurArptsVO, airportindex, "lat", double);
		id->m_dLongitudes[0] = VV(PassurArptsVO, airportindex, "lng", double);
		id->m_dZeroX[0] = VV(PassurArptsVO, airportindex, "zerox", double);
		id->m_dZeroY[0] = VV(PassurArptsVO, airportindex, "zeroy", double);
		id->m_dAltitudes[0] = VV(PassurArptsVO, airportindex, "alt", double);
		id->m_bIsPassurTais = VV(PassurArptsVO, airportindex, "tais", int);
	}
	LeaveCriticalSection(&id->m_csAirportsVO);

	LoadAirportGroundAltitude(id);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)Airport %s, Altitude %f\n", GetCurrentThreadId(), id->m_sCurLayout.m_strPassurArpt, id->m_dAltitudes[0]);
}


void LoadPassurData(struct InstanceData* id)
{
	int airportindex;
	VO* PassurArptsVO = NULL;

	EnterCriticalSection(&id->m_csAirportsVO);
	PassurArptsVO = (VO*)id->m_pAirportsVO;

	if (PassurArptsVO){

		if ((airportindex = FindAirportIndex(id, "dca")) >= 0){
			id->m_dLatitudes[0] = VV(PassurArptsVO, airportindex, "lat", double);
			id->m_dLongitudes[0] = VV(PassurArptsVO, airportindex, "lng", double);
			id->m_dZeroX[0] = VV(PassurArptsVO, airportindex, "zerox", double);
			id->m_dZeroY[0] = VV(PassurArptsVO, airportindex, "zeroy", double);
			id->m_dAltitudes[0] = VV(PassurArptsVO, airportindex, "alt", double);
		}

		if ((airportindex = FindAirportIndex(id, "iad")) >= 0){
			id->m_dLatitudes[1] = VV(PassurArptsVO, airportindex, "lat", double);
			id->m_dLongitudes[1] = VV(PassurArptsVO, airportindex, "lng", double);
			id->m_dZeroX[1] = VV(PassurArptsVO, airportindex, "zerox", double);
			id->m_dZeroY[1] = VV(PassurArptsVO, airportindex, "zeroy", double);
			id->m_dAltitudes[0] = VV(PassurArptsVO, airportindex, "alt", double);
		}
		LoadAirportGroundAltitude(id);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)Airport %s, Altitude %f\n", GetCurrentThread(), id->m_sCurLayout.m_strPassurArpt, id->m_dAltitudes[0]);
	}
	LeaveCriticalSection(&id->m_csAirportsVO);
}

int clipaircraft(struct InstanceData* id, AIR *air)
{
	GLfloat x, y;

	x = air->X;
	y = air->Y;

	if(0.0f != id->m_glfRotateAngle){
		RotatePoint(id, &x, &y);
	}

	//x = (GLfloat) VV(AirVO, i, "X", double );
	//y = (GLfloat) VV(AirVO, i, "Y", double );
	if (x < id->m_sCurLayout.m_dWorldXmin || x > id->m_sCurLayout.m_dWorldXmax || y < id->m_sCurLayout.m_dWorldYmin || y > id->m_sCurLayout.m_dWorldYmax){
		return(TRUE);  // clip this aircraft, it's not in our window
	}
	return(FALSE);
}

void ProcessCnstrProjects(char *membuf, int memsize)
{
	int len, goodproj;
	char linebuf[256];
	char *eolstr;
	char *name, *category, *area, *segment, *status, *notes, *creator, *title, *initials;
	char *context;

	if (ProjectsVO){
		vo_free(ProjectsVO);
		ProjectsVO = NULL;
	}

	while (membuf && memsize){
		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);

			membuf = eolstr;
			membuf++; /* skip over eol char */
			// we need to put in a space in case of any blanks fields so strtok will work
			StrSubs(linebuf, "||||", "|| ||", TMPBUF_SIZE);
			do {
				goodproj = FALSE;
				if (!(name = strtok_s(linebuf, "||", &context))) break;
				if (!(category = strtok_s(NULL, "||", &context))) break;
				if (!(area = strtok_s(NULL, "||", &context))) break;
				if (!(segment = strtok_s(NULL, "||", &context))) break;
				if (!(status = strtok_s(NULL, "||", &context))) break;
				if (!(notes = strtok_s(NULL, "||", &context))) break;
				if (!(creator = strtok_s(NULL, "||", &context))) break;
				if (!(title = strtok_s(NULL, "||", &context))) break;
				if (!(initials = strtok_s(NULL, "||", &context))) break;
				goodproj = TRUE;
			} while (0);
			if (goodproj){
				if (!ProjectsVO){
					ProjectsVO = (VO *)vo_create(0, 0);
					vo_set(ProjectsVO, V_NAME, "ProjectsVO", NULL);
					VOPropAdd(ProjectsVO, "name", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "category", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "area", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "segment", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "status", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "notes", NTBSTRINGBIND, 512, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "creator", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "title", NTBSTRINGBIND, 64, VO_NO_ROW);
					VOPropAdd(ProjectsVO, "initials", NTBSTRINGBIND, 64, VO_NO_ROW);

					vo_set(ProjectsVO, V_ORDER_COLS, "name", NULL, NULL);
					vo_rm_rows(ProjectsVO, 0, ProjectsVO->count);
				}
				vo_alloc_rows(ProjectsVO, 1);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "name", char), 64, name);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "category", char), 64, category);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "area", char), 64, area);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "segment", char), 64, segment);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "status", char), 64, status);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "notes", char), 64, notes);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "creator", char), 64, creator);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "title", char), 64, title);
				strcpy_s(VP(ProjectsVO, ProjectsVO->count - 1, "initials", char), 64, initials);

			}
		} else {
			membuf = NULL;
		}
	}
}

polylist *ProcessCnstrPolys(struct InstanceData* id, char *membuf, int memsize)
{
	int matches, len;
	char linebuf[256];
	char *eolstr;
	int n;
	double lat, lng;
	polylist *plist = NULL;
	polylist *nextpolylist;
	poly *newpoly = NULL;
	points *np;
	char *stopstring;
	char lngstr[64], latstr[64];
	char *polystr, *category, *area, *segment;
	char tmpnamestr[256], svcat[64], svarea[64], svseg[64];
	constrc *constrcp;
	char *context;


	while (membuf && memsize){
		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);

			membuf = eolstr;
			membuf++; /* skip over eol char */

			if (!strncmp(linebuf, "polyid:", 7)){
				// new poly
				if (!(polystr = strtok_s(linebuf, "\t", &context))) break;
				if (!(category = strtok_s(NULL, "\t", &context))) break;
				if (!(area = strtok_s(NULL, "\t", &context))) break;
				if (!(segment = strtok_s(NULL, "\t", &context))) break;
				_snprintf_s(tmpnamestr, _countof(tmpnamestr), _TRUNCATE, "%s::%s::%s::", category, area, segment);

				strncpy_s(svcat, _countof(svcat), category, _TRUNCATE);
				strncpy_s(svarea, _countof(svarea), area, _TRUNCATE);
				strncpy_s(svseg, _countof(svseg), segment, _TRUNCATE);


				newpoly = NULL;
				if (!plist){
					plist = (polylist *)vo_malloc(sizeof(polylist));
					nextpolylist = plist;
					plist->lastpoly = plist;
				} else {
					nextpolylist->np = (polylist *)vo_malloc(sizeof(polylist));
					nextpolylist = nextpolylist->np;
					plist->lastpoly = nextpolylist;
				}


			} else {
				// another point to add to the poly
				sscanf_s(linebuf, "%d\t%63s\t%63s", &n, lngstr, _countof(lngstr), latstr, _countof(latstr));
				lng = strtod(lngstr, &stopstring);
				lat = strtod(latstr, &stopstring);

				// this did not convert well enough---  matches = sscanf(linebuf, "%d\t%lf\t%lf", &n, &lng, &lat );
				if (matches = 3){
					if (!newpoly){
						newpoly = (poly *)vo_malloc(sizeof(poly));

						newpoly->polyname = str_falloc(tmpnamestr);

						// add in special data here for construction
						// create the datastruct to store contruction info in the poly
						newpoly->datastruct = calloc(1, sizeof(constrc));
						constrcp = (constrc *)newpoly->datastruct;
						constrcp->category = str_falloc(svcat);
						constrcp->area = str_falloc(svarea);
						constrcp->segment = str_falloc(svseg);


						if (nextpolylist){
							nextpolylist->poly = newpoly;
						} else {
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) nextpolylist null\n", GetCurrentThread());
							return(0);
						}
					}
					if (!newpoly->ppoints){
						/* first points */
						newpoly->ppoints = (points *)vo_malloc(sizeof(points));
						np = newpoly->ppoints;
					} else {
						np->np = (points *)vo_malloc(sizeof(points));
						np = np->np;
					}
					np->vt[0] = lng;
					np->vt[1] = lat;
					np->vt[2] = 0.0;
				}
			}
		} else {
			membuf = NULL;
		}
	}
	return(plist);
}


void WorldFill(struct InstanceData* id, char *data)
{
	char *str;
	// example data = "trails="Off"

	if (!data){
		return;
	}
	str = data;

	// example data = 0x1277efd8 "trails="On"&points="13"&times="Off""

	if ((str = strstr(data, "world")) && !strncasecmp(&str[7], "Off", 3)){
		// turn world maps off
		id->m_sCurLayout.m_bShowWorldMap = FALSE;
		id->m_sCurLayout.m_bShowWorldBorders = FALSE; // for now, the same
	} else {
		id->m_sCurLayout.m_bShowWorldMap = TRUE;
		id->m_sCurLayout.m_bShowWorldBorders = TRUE;
	}

}



void TrailsFill(struct InstanceData* id, char *data, struct json_object* jobj)
{
	char *str, *stopstring;
	long points;
	int nPos;
	int nLen;

	// New JSON Format
	if (jobj){
		// Verify Array and Length of three
		if ((json_type_array == json_object_get_type(jobj)) && (nLen = json_object_array_length(jobj))){
			for (nPos = 0; nPos < nLen; nPos++){
				struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
				int point = json_object_get_int(jelem);
				double point2 = json_object_get_double(jelem);
				switch (nPos){
				case 0: {
					if (point > 60)
						id->m_sCurLayout.m_nAsdiTrailCount = 60;
					else{
						while (point % 5) point--;
						if (point < 5)
							id->m_sCurLayout.m_nAsdiTrailCount = 5;
						else
							id->m_sCurLayout.m_nAsdiTrailCount = point;
					}
				}
				break;
				case 1: {
					if (point > 60)
						id->m_sCurLayout.m_nPassurTrailCount = 60;
					else{
						while (point > 5 && point % 5) point--;
						if (point < 1)
							id->m_sCurLayout.m_nPassurTrailCount = 1;
						else
							id->m_sCurLayout.m_nPassurTrailCount = point;
					}
				}
				break;
				case 2: {
					if (point > 5)
						id->m_sCurLayout.m_dAsdexTrailCount = 5;
					else{
						id->m_sCurLayout.m_dAsdexTrailCount = point2;
					}
				}
				break;
				case 3: {
					if (point > 5)
						// NOISE Trails do not have UI, piggyback on ADSB Controls.
						id->m_sCurLayout.m_dNoiseTrailCount = id->m_sCurLayout.m_dAdsbTrailCount = 5;
					else{
						// NOISE Trails do not have UI, piggyback on ADSB Controls.
						id->m_sCurLayout.m_dNoiseTrailCount = id->m_sCurLayout.m_dAdsbTrailCount = point2;
					}
				}
				break;
				case 4: {
					if (point > 5)
						// MLAT Trail Controls
						id->m_sCurLayout.m_dMlatTrailCount = 5;
					else{
						id->m_sCurLayout.m_dMlatTrailCount = point2;
					}
				}
				break;
				case 5: {
						if( point > 60)
							id->m_sCurLayout.m_nAirAsiaTrailCount = 60;
						else{
							while(point % 5) point--;
							if( point < 5 )
								id->m_sCurLayout.m_nAirAsiaTrailCount = 5;
							else
								id->m_sCurLayout.m_nAirAsiaTrailCount = point;
						}
				}
				break;
			}
		}
		}else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Points invalid: (%s)!\n", GetCurrentThreadId(), json_object_to_json_string(jobj));
	}
	}else{
		// Old example data = "trails="Off"
		if (!data){
			return;
		}
		str = data;
		// example data = 0x1277efd8 "trails="On"&points="13"&times="Off""
		if ((str = strstr(data, "trails")) && !strncasecmp(&str[8], "Off", 3)){
			// turn trails off
			id->m_sCurLayout.m_bShowTrails = FALSE;
		} else if ( ( str = strstr( data, "points="))){
			if ((str = strchr(str, '"'))){
				points = strtol(&str[1], &stopstring, 10);
				id->m_sCurLayout.m_nAsdiTrailCount = (int)points;
				if (stopstring[0] == ','){
					str = stopstring + 1;
					points = strtol(str, &stopstring, 10);
					id->m_sCurLayout.m_nPassurTrailCount = (int)points;
					if (stopstring[0] == ','){
						str = stopstring + 1;
						points = strtol(str, &stopstring, 10);
						id->m_sCurLayout.m_dAsdexTrailCount = points;
						if (stopstring[0] == ','){
							str = stopstring + 1;
							points = strtol(str, &stopstring, 10);
							id->m_sCurLayout.m_dAdsbTrailCount = points;
							// NOISE Trails do not have UI, piggyback on ADSB Controls.
							id->m_sCurLayout.m_dNoiseTrailCount = points;
							//@@@MCT TODO: MLAT Trails do not yet have UI, piggyback on ADSB Controls.
							id->m_sCurLayout.m_dMlatTrailCount = points;
						}else{
							id->m_sCurLayout.m_dAdsbTrailCount = points;
							// NOISE Trails do not have UI, piggyback on ADSB Controls.
							id->m_sCurLayout.m_dNoiseTrailCount = points;
							//@@@MCT TODO: MLAT Trails do not yet have UI, piggyback on ADSB Controls.
							id->m_sCurLayout.m_dMlatTrailCount = points;
						}
					}
				}else{
					id->m_sCurLayout.m_nPassurTrailCount = (int)points;
					id->m_sCurLayout.m_dMlatTrailCount =
						id->m_sCurLayout.m_dNoiseTrailCount =
						id->m_sCurLayout.m_dAdsbTrailCount =
						id->m_sCurLayout.m_dAsdexTrailCount = points;
				}
			}
			id->m_sCurLayout.m_bShowTrails = TRUE;
		}
		if ((str = strstr(data, "times="))) {
			if (!strncasecmp(&str[7], "false", 5) || !strncasecmp(&str[7], "Off", 3))
				// turn off trail times
				id->m_sCurLayout.m_bShowTrailTimes = FALSE;
			else
				// turn on trail times
				id->m_sCurLayout.m_bShowTrailTimes = TRUE;
		}
	}
}

void StringToGLFloat(GLfloat* pColor, const char* str){
	if (pColor){
		if (strlen(str) >= 7){
			pColor[0] = (GLfloat)HexStrtod(&str[1], 2) / 255.0f;
			pColor[1] = (GLfloat)HexStrtod(&str[3], 2) / 255.0f;
			pColor[2] = (GLfloat)HexStrtod(&str[5], 2) / 255.0f;
		}else{
			pColor[0] = pColor[1] = pColor[2] = 0.0f;
		}
	}
}


void OutlineColors(struct InstanceData* id, char *data, struct json_object* jobj)
{
	char *str;
	GLfloat *pColor = NULL;

	// New JSON Method
	if (jobj){
		struct json_object_iter jiter;
		if (json_type_object == json_object_get_type(jobj)){
			json_object_object_foreachC(jobj, jiter){
				if (!strcmp("apron", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfApronColor, json_object_get_string(jiter.val));
				}else if(!strcmp("boundary", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfUSColor, json_object_get_string(jiter.val));
				}else if(!strcmp("buildings", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfBuildingColor, json_object_get_string(jiter.val));
				} else if (!strcmp("closed", jiter.key)) {
					StringToGLFloat(id->m_sCurLayout.m_glfClosedOutlineColor, json_object_get_string(jiter.val));
				} else if (!strcmp("construction", jiter.key)) {
					StringToGLFloat(id->m_sCurLayout.m_glfConstructionOutlineColor, json_object_get_string(jiter.val));
				}else if(!strcmp("custom", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfCustomOutlineColor, json_object_get_string(jiter.val));
				}else if(!strcmp("deicing", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfDeicingOutlineColor, json_object_get_string(jiter.val));
				}else if(!strcmp("frequency", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfFrequencyOutlineColor, json_object_get_string(jiter.val));
				}else if(!strcmp("markings", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfMarkingsColor, json_object_get_string(jiter.val));
				}else if(!strcmp("parking", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfParkingColor, json_object_get_string(jiter.val));
				}else if(!strcmp("road", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfRoadOutlineColor, json_object_get_string(jiter.val));
				}else if(!strcmp("runway", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfRunwayColor, json_object_get_string(jiter.val));
				}else if(!strcmp("shoulder", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfShoulderColor, json_object_get_string(jiter.val));
				}else if(!strcmp("taxiway", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfTaxiColor, json_object_get_string(jiter.val));
				}else if(!strcmp("water", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfWaterColor, json_object_get_string(jiter.val));
				}
			}
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid MapColors Object (%s).\n", GetCurrentThreadId(), json_object_to_json_string(jobj));
		}
	}else{
		// Old Method
		// example data = "outline=\"boundary,#FFFFFF\""
		// example data = "outline=\"taxiway,#FFFFFF\""

		if (!data){
			return;
		}
		if (str = strstr(data, "outline"))
		{
			str += strlen("outline");
			if (str = strstr(data, "boundary")){
				str += strlen("boundary") + 1;
				pColor = id->m_sCurLayout.m_glfUSColor;
			}else if(str = strstr( data, "taxiway") ){
				str += strlen("taxiway") + 1;
				pColor = id->m_sCurLayout.m_glfTaxiColor;
			}else if(str = strstr( data, "buildings") ){
				str += strlen("buildings") + 1;
				pColor = id->m_sCurLayout.m_glfBuildingColor;
			}else if(str = strstr( data, "runway") ){
				str += strlen("runway") + 1;
				pColor = id->m_sCurLayout.m_glfRunwayColor;
			}else if(str = strstr( data, "water") ){
				str += strlen("water") + 1;
				pColor = id->m_sCurLayout.m_glfWaterColor;
			}else if(str = strstr( data, "apron") ){
				str += strlen("apron") + 1;
				pColor = id->m_sCurLayout.m_glfApronColor;
			}else if(str = strstr( data, "parking") ){
				str += strlen("parking") + 1;
				pColor = id->m_sCurLayout.m_glfParkingColor;
			}else if(str = strstr( data, "markings") ){
				str += strlen("markings") + 1;
				pColor = id->m_sCurLayout.m_glfMarkingsColor;
			}else if(str = strstr( data, "shoulder") ){
				str += strlen("shoulder") + 1;
				pColor = id->m_sCurLayout.m_glfShoulderColor;
			}else if(str = strstr( data, "deicing") ){
				str += strlen("deicing") + 1;
				pColor = id->m_sCurLayout.m_glfDeicingOutlineColor;
			}else if(str = strstr( data, "construction") ){
				str += strlen("construction") + 1;
				pColor = id->m_sCurLayout.m_glfConstructionOutlineColor;
			}else if(str = strstr( data, "frequency") ){
				str += strlen("frequency") + 1;
				pColor = id->m_sCurLayout.m_glfFrequencyOutlineColor;
			}else if(str = strstr( data, "road") ){
				str += strlen("road") + 1;
				pColor = id->m_sCurLayout.m_glfRoadOutlineColor;
			}else if(str = strstr( data, "term_fixes") ){
				str += strlen("term_fixes") + 1;
				// TODO: Set pColor = to Terminal Fixes Color var
				//pColor = ;
			}else if(str = strstr( data, "high_fixes") ){
				str += strlen("high_fixes") + 1;
				// TODO: Set pColor = to High Fixes Color var
				//pColor = ;
			}else if(str = strstr( data, "low_fixes") ){
				str += strlen("low_fixes") + 1;
				// TODO: Set pColor = to Low Fixes Color var
				//pColor = ;
			}
			if (pColor){
				if (strlen(str) >= 7){
					pColor[0] = (GLfloat)HexStrtod(&str[1], 2) / 255.0f;
					pColor[1] = (GLfloat)HexStrtod(&str[3], 2) / 255.0f;
					pColor[2] = (GLfloat)HexStrtod(&str[5], 2) / 255.0f;
				}else{
					pColor[0] = pColor[1] = pColor[2] = 0.0f;
				}
			}
		}
	}
}



void BuildLine(char *layoutstr, char *linestr, char *TagLine)
{
	char *tagstr, *startstr, *endstr;
	int len;

	if ((tagstr = strstr(layoutstr, linestr))){
		startstr = &tagstr[7];
		if ((endstr = strchr(startstr, '"'))){
			if ((len = endstr - startstr) < TAG_LENGTH){
				strncpy_s(TagLine, TAG_LENGTH, startstr, len);
			}
		}
	}

}



void BuildLargeTags(struct InstanceData* id, char *str)
{
	// build tag parameters int tagline1-5

	BuildLine(str, "line1=", id->m_sCurLayout.m_strTagLine1);
	BuildLine(str, "line2=", id->m_sCurLayout.m_strTagLine2);
	BuildLine(str, "line3=", id->m_sCurLayout.m_strTagLine3);
	BuildLine(str, "line4=", id->m_sCurLayout.m_strTagLine4);

}

int ishexdigit(int c){
	int nReturn = isdigit(c);
	if (!nReturn){
		nReturn = ((c <= 70 && c >= 65) || (c <= 102 && c >= 97));
	}
	return nReturn;
}

int LoadTagColorValues(const char* str, GLfloat* TextColor, GLfloat* BkColor, int* Transparency){
	int nSuccess = FALSE;
	int nPos = 0;
	int nValid = TRUE;

	TextColor[0] = TextColor[1] = TextColor[2] = (GLfloat) 0.0f;
	BkColor[0] = BkColor[1] = BkColor[2] = (GLfloat) 0.0f;
	*Transparency = 100;

	if (strlen(str) >= 17){
		for (nPos = 1; nPos < 7 || !nValid; nPos++){
			nValid = ishexdigit(str[nPos]);
		}
		if (nValid){
			TextColor[0] = (GLfloat)HexStrtod(&str[1], 2) / 255.0f;
			TextColor[1] = (GLfloat)HexStrtod(&str[3], 2) / 255.0f;
			TextColor[2] = (GLfloat)HexStrtod(&str[5], 2) / 255.0f;
		}
		for (nValid = TRUE, nPos = 9; nPos < 15 || !nValid; nPos++){
			nValid = ishexdigit(str[nPos]);
		}
		if (nValid){
			BkColor[0] = (GLfloat)HexStrtod(&str[9], 2) / 255.0f;
			BkColor[1] = (GLfloat)HexStrtod(&str[11], 2) / 255.0f;
			BkColor[2] = (GLfloat)HexStrtod(&str[13], 2) / 255.0f;
		}
		*Transparency = atoi(&str[16]);
		if (nValid)
			nSuccess = TRUE;
	}

	return nSuccess;
}

void SetTagBorders(struct InstanceData* id, char *data, struct json_object* jobj)
{
	char *str;
	char *context;
	char *sprtr = ",";
	int nPos = 0;
	int nLen = 0;
	int nFlag = TB_PASSUR;
	if (jobj){
		// Verify Array and Length of three
		if ((json_type_array == json_object_get_type(jobj)) && (nLen = json_object_array_length(jobj))){
			for (nPos = 0; nPos < nLen; nPos++){
				struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
				switch (nPos){
				case 0: nFlag = TB_PASSUR;
					break;
				case 1: nFlag = TB_ASDI;
					break;
				case 2: nFlag = TB_ASDEX;
					break;
				case 3: nFlag = TB_ADSB;
					break;
				case 4: nFlag = TB_ALERTS;
					break;
				case 5: nFlag = TB_MLAT;
					break;
				case 6: nFlag = TB_AIRASIA;
					break;
				case 7: nFlag = TB_GATE;
					break;
				}
				if (json_object_get_boolean(jelem))
					id->m_sCurLayout.m_nTagBorderEnableFlag |= nFlag;
				else
					id->m_sCurLayout.m_nTagBorderEnableFlag &= ~nFlag;
			}
		}else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag borders invalid: (%s)!\n", GetCurrentThreadId(), json_object_to_json_string(jobj));
		}
	}else{
		str = strtok_s(data, sprtr, &context);
		do{
			switch (nPos){
			case 0: nFlag = TB_PASSUR;
				break;
			case 1: nFlag = TB_ASDI;
				break;
			case 2: nFlag = TB_ASDEX;
				break;
			case 3: nFlag = TB_ADSB;
				break;
			case 4: nFlag = TB_ALERTS;
				break;
			case 5: nFlag = TB_MLAT;
				break;
			case 6: nFlag = TB_AIRASIA;
				break;
			case 7: nFlag = TB_GATE;
				break;
			}
			if (strstr(str, "true")){
				id->m_sCurLayout.m_nTagBorderEnableFlag |= nFlag;
			}else{
				id->m_sCurLayout.m_nTagBorderEnableFlag &= ~nFlag;
			}
			nPos++;
		} while (str = strtok_s(NULL, sprtr, &context));
	}
}

void SetTags(struct InstanceData* id, char *data, struct json_object* jobj)
{
	char *str;
	int nPos;
	int TagColorIndex;
	int nLen = 0;

	// New JSON method
	if (jobj){
		// Verify Array and Length of three
		if (json_type_array == json_object_get_type(jobj)){
			nLen = json_object_array_length(jobj);
			for (nPos = 0; nPos < nLen; nPos++){
				struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
				const char* str;
				switch (nPos){
				case 0: str = json_object_get_string(jelem);
					if (!strcmp("Large", str)){
						// large tags only
						id->m_sCurLayout.m_bShowLargeTags = TRUE;
						id->m_sCurLayout.m_bShowSmallTags = FALSE;
					}else if(!strcmp("Small", str)){
						// small tags only
						id->m_sCurLayout.m_bShowLargeTags = FALSE;
						id->m_sCurLayout.m_bShowSmallTags = TRUE;
					}else{
						// turn tags off
						id->m_sCurLayout.m_bShowLargeTags = FALSE;
						id->m_sCurLayout.m_bShowSmallTags = FALSE;
					}
					break;
				case 1: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorPASSUR, json_object_get_string(jelem));
					break;
				case 2: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorPASSUR, json_object_get_string(jelem));
					break;
				case 3: id->m_sCurLayout.m_nLargeTagTransparencyPASSUR = json_object_get_int(jelem);
					break;
				case 4: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorASDI, json_object_get_string(jelem));
					break;
				case 5: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorASDI, json_object_get_string(jelem));
					break;
				case 6: id->m_sCurLayout.m_nLargeTagTransparencyASDI = json_object_get_int(jelem);
					break;
				case 7: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorASDEX, json_object_get_string(jelem));
					break;
				case 8: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorASDEX, json_object_get_string(jelem));
					break;
				case 9: id->m_sCurLayout.m_nLargeTagTransparencyASDEX = json_object_get_int(jelem);
					break;
				case 10: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorADSB, json_object_get_string(jelem));
					break;
				case 11: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorADSB, json_object_get_string(jelem));
					break;
				case 12: id->m_sCurLayout.m_nLargeTagTransparencyADSB = json_object_get_int(jelem);
					break;
				case 13: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorAlerts, json_object_get_string(jelem));
					break;
				case 14: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorAlerts, json_object_get_string(jelem));
					break;
				case 15: id->m_sCurLayout.m_nLargeTagTransparencyAlerts = json_object_get_int(jelem);
					break;
				case 16: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorMLAT, json_object_get_string(jelem));
					break;
				case 17: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorMLAT, json_object_get_string(jelem));
					break;
				case 18: id->m_sCurLayout.m_nLargeTagTransparencyMLAT = json_object_get_int(jelem);
					break;
				case 19: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorAirAsia, json_object_get_string(jelem));
					break;
				case 20: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorAirAsia, json_object_get_string(jelem));
					break;
				case 21: id->m_sCurLayout.m_nLargeTagTransparencyAirAsia = json_object_get_int(jelem);
					break;
				case 22: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagTextColorGate, json_object_get_string(jelem));
					break;
				case 23: StringToGLFloat(id->m_sCurLayout.m_glfLargeTagBkColorGate, json_object_get_string(jelem));
					break;
				case 24: id->m_sCurLayout.m_nLargeTagTransparencyGate = json_object_get_int(jelem);
					break;
				}
			}
		}else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag settings invalid: (%s)!\n", GetCurrentThreadId(), json_object_to_json_string(jobj));
		}
	}else{
		// Old Method
		//  "tags=\"Off\"					- Turn tags off
		//	"tags=\"Large,#000000,#FFFFFF,0"&line1=\"Airline,,\"	
		//									- Turn tags on to large and set
		//										text color = #000000
		//										background color = #FFFFFF
		//										transparency percent = 0
		//										line1 = airline, none, none
		//										possible line values:
		//											"Airline", "Origin", "Destination", 
		//											"Departure Fix", "Passur Tail", 
		//											"Aircraft Type", "Time in Queue", 
		//											"Scheduled Departure Time", 
		//											"Planned Departure Time", 
		//											"Estimated Departure Time"
		if (!data){
			return;
		}
		if (str = strstr(data, "tags")) {
			int nLen = strlen(str);
			int nValid = TRUE;
			int nPos = 28;
			if (!strncasecmp(&str[6], "Off", 3)){
				// turn tags off
				id->m_sCurLayout.m_bShowLargeTags = FALSE;
				id->m_sCurLayout.m_bShowSmallTags = FALSE;
			} else if ( !strncasecmp( &str[6], "Large", 5 ) ){
				id->m_sCurLayout.m_bShowLargeTags = TRUE;
				id->m_sCurLayout.m_bShowSmallTags = FALSE;
			} else if ( str && !strncasecmp( &str[6], "Small", 5 ) ) {
				// small tags only
				id->m_sCurLayout.m_bShowLargeTags = FALSE;
				id->m_sCurLayout.m_bShowSmallTags = TRUE;
			}
			// PASSUR Color Values			
			if (nLen >= 29)
				nValid = LoadTagColorValues(&str[12], id->m_sCurLayout.m_glfLargeTagTextColorPASSUR, id->m_sCurLayout.m_glfLargeTagBkColorPASSUR, &id->m_sCurLayout.m_nLargeTagTransparencyPASSUR);
			while (str[nPos] != ',' && str[nPos] != '\"') nPos++;

			// ASDI Color Values			
			if (nValid && (nLen - nPos) >= 17){
				nValid = LoadTagColorValues(&str[nPos + 1], id->m_sCurLayout.m_glfLargeTagTextColorASDI, id->m_sCurLayout.m_glfLargeTagBkColorASDI, &id->m_sCurLayout.m_nLargeTagTransparencyASDI);
				nPos += 17;
				while (str[nPos] != ',' && str[nPos] != '\"') nPos++;

				// ASDE-X Color Values			
				if (nValid && (nLen - nPos) >= 17){
					nValid = LoadTagColorValues(&str[nPos + 1], id->m_sCurLayout.m_glfLargeTagTextColorASDEX, id->m_sCurLayout.m_glfLargeTagBkColorASDEX, &id->m_sCurLayout.m_nLargeTagTransparencyASDEX);
					nPos += 17;
					while (str[nPos] != ',' && str[nPos] != '\"') nPos++;

					// ADS-B Color Values			
					if (nValid && (nLen - nPos) >= 17){
						nValid = LoadTagColorValues(&str[nPos + 1], id->m_sCurLayout.m_glfLargeTagTextColorADSB, id->m_sCurLayout.m_glfLargeTagBkColorADSB, &id->m_sCurLayout.m_nLargeTagTransparencyADSB);
					}
				}
			}

			BuildLargeTags(id, str);
		}

		if ((str = strstr(data, "line"))){
			// fill large or small tags
			BuildLargeTags(id, str);
		}
	}
	// Validate Settings
	if (id->m_sCurLayout.m_nLargeTagTransparencyPASSUR > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyPASSUR = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyPASSUR < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyPASSUR = 0;
	if (id->m_sCurLayout.m_nLargeTagTransparencyASDI > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyASDI = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyASDI < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyASDI = 0;
	if (id->m_sCurLayout.m_nLargeTagTransparencyASDEX > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyASDEX = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyASDEX < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyASDEX = 0;
	if (id->m_sCurLayout.m_nLargeTagTransparencyADSB > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyADSB = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyADSB < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyADSB = 0;
	if (id->m_sCurLayout.m_nLargeTagTransparencyAlerts > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyAlerts = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyAlerts < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyAlerts = 0;
	if (id->m_sCurLayout.m_nLargeTagTransparencyMLAT > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyMLAT = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyMLAT < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyMLAT = 0;
	if(id->m_sCurLayout.m_nLargeTagTransparencyAirAsia > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyAirAsia = 100;
	else if(id->m_sCurLayout.m_nLargeTagTransparencyAirAsia < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyAirAsia = 0;
	if (id->m_sCurLayout.m_nLargeTagTransparencyGate > 100)
		id->m_sCurLayout.m_nLargeTagTransparencyGate = 100;
	else if (id->m_sCurLayout.m_nLargeTagTransparencyGate < 0)
		id->m_sCurLayout.m_nLargeTagTransparencyGate = 0;

	// Force Textures to be Rebuilt
	for (TagColorIndex = 0; TagColorIndex < N_GUI_IMAGES; TagColorIndex++){
		if (id->m_gluGuiTextures[TagColorIndex]){
			glDeleteTextures(1, &id->m_gluGuiTextures[TagColorIndex]);
			id->m_gluGuiTextures[TagColorIndex] = 0;
		}
	}
}

void SetRangeRings(struct InstanceData* id, char *data, struct json_object* jobj)
{
	char *str;

	if (jobj){
		// Verify Array type and Length of two
		if (json_type_array == json_object_get_type(jobj) && 2 == json_object_array_length(jobj)){
			struct json_object* jelem = json_object_array_get_idx(jobj, 0);
			id->m_sCurLayout.m_bShowAircraftRings = json_object_get_boolean(jelem);
			jelem = json_object_array_get_idx(jobj, 1);
			id->m_sCurLayout.m_dRingSize = json_object_get_double(jelem);
		}else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft Range Rings invalid: (%s)!\n", GetCurrentThreadId(), json_object_to_json_string(jobj));
		}
	}else{
		//	"range=\"Off\"					- Range rings off
		//	"range=\"On,1.5\"				- Range rings on, requested radius of range ring of 1.3 nmiles
		// Old method
		if (!data){
			return;
		}

		if ((str = strstr(data, "range"))) {
			if (!strncasecmp(&str[7], "false", 5) || !strncasecmp(&str[7], "Off", 3)){
				// turn rings off
				id->m_sCurLayout.m_bShowAircraftRings = FALSE;
				id->m_sCurLayout.m_dRingSize = 1.0;
			} else {
				id->m_sCurLayout.m_bShowAircraftRings = TRUE;
				if (!strncasecmp(&str[7], "On", 2))
					id->m_sCurLayout.m_dRingSize = atof(&str[10]);
				else if (!strncasecmp(&str[7], "true", 2))
					id->m_sCurLayout.m_dRingSize = atof(&str[12]);
			}
		}
	}
}

void LoadAirportRingData(struct InstanceData* id)
{
	double lat, lng;
	int i;
	char* arpt;
	ARPT *Arpt;
	char *sprtr = ",";
	char *tptr;
	char *context;
	VO* pRangeRingVO = NULL;
	char* sRangeRingArpts = NULL;
	int found;

	// Copy Arpt List
	EnterCriticalSection(&id->m_csArptRangeRing);
	if( !id->m_sCurLayout.m_pstrRangeRingArpts || !strlen(id->m_sCurLayout.m_pstrRangeRingArpts) )
	{
		LeaveCriticalSection(&id->m_csArptRangeRing);
		return;
	}

	sRangeRingArpts = _strdup(id->m_sCurLayout.m_pstrRangeRingArpts);
	// Build Range Ring GUI Thread VO
	if (!id->m_pRangeRingVO){
		VO* pVO = vo_create(0, NULL);
		vo_set(pVO, V_NAME, "RangeRingVO", NULL);
		VOPropAdd(pVO, "arpt", NTBSTRINGBIND, 128, VO_NO_ROW);
		VOPropAdd(pVO, "Lat", FLT8BIND, -1, VO_NO_ROW);
		VOPropAdd(pVO, "Lng", FLT8BIND, -1, VO_NO_ROW);
		id->m_pRangeRingVO = pVO;
	}
	// Build Range Ring Worker Thread VO 
	if (!id->m_pTempRangeRingVO){
		VO* pVO = vo_create(0, NULL);
		vo_set(pVO, V_NAME, "RangeRingVO", NULL);
		VOPropAdd(pVO, "arpt", NTBSTRINGBIND, 128, VO_NO_ROW);
		VOPropAdd(pVO, "Lat", FLT8BIND, -1, VO_NO_ROW);
		VOPropAdd(pVO, "Lng", FLT8BIND, -1, VO_NO_ROW);
		id->m_pTempRangeRingVO = pVO;
	}
	LeaveCriticalSection(&id->m_csArptRangeRing);

	pRangeRingVO = (VO*)id->m_pTempRangeRingVO;
	vo_rm_rows(pRangeRingVO, 0, pRangeRingVO->count);

	if (strlen(sRangeRingArpts)){

		tptr = sRangeRingArpts;
		while ((arpt = strtok_s(tptr, sprtr, &context))){
			tptr = NULL; // next call to strtok must be null
			found = FALSE;
			if (arpt[strlen(arpt) - 1] == '"')
				arpt[strlen(arpt) - 1] = '\0';

			if (strlen(arpt) == 5){
				// fix id
				if (g_bFixesLoaded){
					for (i = 0; i < g_nFixCount; i++) {
						if (!strncmp(arpt, g_pFixes[i].fixname, 5)){
							lat = g_pFixes[i].lat;
							lng = g_pFixes[i].lng;
							found = 1;
							break;
						}
					}
				}
			}
			else {
				// airport or nav id
				if (!(Arpt = FindArptRow(id, arpt, MATCH_ALL))){
					// not in airports list, check navaids
					if (g_bNavLoaded){
						for (i = found = 0; i < g_nNavCount; i++){
							if (!strncmp(arpt, g_pNavs[i].navname, 3)){
								lat = g_pNavs[i].lat;
								lng = g_pNavs[i].lng;
								found = 1;
								break;
							}
						}
					}
					if (!found){
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) User specified airport/navaid/fix <%s> is not in Arpt/Navs/Fixes lists. Ignored.\n",
							GetCurrentThreadId(), arpt);
						continue;
					}
				}
				else {
					// found airport with maching name
					lat = Arpt->lat;
					lng = Arpt->lng;
					found = 1;
				}
			}
			if (found){
				vo_alloc_rows(pRangeRingVO, 1);
				strcpy_s(VP(pRangeRingVO, pRangeRingVO->count - 1, "arpt", char), 128, arpt);
				VV(pRangeRingVO, pRangeRingVO->count - 1, "Lat", double) = lat;
				VV(pRangeRingVO, pRangeRingVO->count - 1, "Lng", double) = lng;
				// VV( RangeRingVO, RangeRingVO->count - 1, "NauticalMiles", double ) = NauticalMiles;
				// VV( RangeRingVO, RangeRingVO->count - 1, "NumRings", int ) = NumRings;
				found = 0;
			}
		}
		// Modified inSight RangeRingsCmd(() code ends ----------------------------------
	}
	// Swap Range Ring VO's
	EnterCriticalSection(&id->m_csArptRangeRing);
	pRangeRingVO = id->m_pRangeRingVO;
	id->m_pRangeRingVO = id->m_pTempRangeRingVO;
	id->m_pTempRangeRingVO = pRangeRingVO;
	LeaveCriticalSection(&id->m_csArptRangeRing);
}


void SetAirportRings(struct InstanceData* id, char *data)
{
	// Sets airport range rings:
	//	"arptrings="Off"					- Airport rings off
	//	"arptrings="On,10,3,JFK,HPN,..."	- Airport rings on, 10 mile interval rings, 3 of them

	char *str;
	char tmp[512];
	char *linebuf;
	char *sprtr = ",";
	int n = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if ((str = strstr(data, "arptrings")) && !strncasecmp(&str[11], "Off", 3)){
		id->m_sCurLayout.m_bShowAirportRings = FALSE;
	} else if ( !strncasecmp(&str[11], "On", 2) ) {
		strncpy_s(tmp, _countof(tmp), &str[14], 512);
		if (!(str = strchr(tmp, ','))){
			id->m_sCurLayout.m_bShowAirportRings = FALSE;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) invalid data str <%s>, ignored\n", cdwThreadId, data);
			return;
		}
		*str = '\0';
		id->m_sCurLayout.m_nAirportRingSize = atoi(tmp);
		*(strchr(++str, ',')) = '\0';
		id->m_sCurLayout.m_nAirportRingCount = atoi(str);
		linebuf = strchr(str, '\0') + 1;

		if (id->m_sCurLayout.m_pstrRangeRingArpts){
			free(id->m_sCurLayout.m_pstrRangeRingArpts);
			id->m_sCurLayout.m_pstrRangeRingArpts = NULL;
		}
		n = strlen(linebuf) + 1;
		id->m_sCurLayout.m_pstrRangeRingArpts = calloc(n, sizeof(char));
		strcpy_s(id->m_sCurLayout.m_pstrRangeRingArpts, n, linebuf);
		StrUpper(id->m_sCurLayout.m_pstrRangeRingArpts);

		// Modified inSight RangeRingsCmd(() code ends ----------------------------------
		id->m_sCurLayout.m_bShowAirportRings = TRUE;
	} else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) invalid data str <%s>, ignored\n", cdwThreadId, data);
	}
}

void ClearSelectedAircraft(struct InstanceData* id)
{
	int i;
	char *DataSource;
	VO *DataAppVO;
	MGLGRID *ROIGrid = NULL;
	MGLGRID *FDOGrid = NULL;
	id->m_strFltRoute[0] = '\0';
	id->m_pSelectedAirP = NULL;
	id->m_pSelectedAircraft = NULL;
	id->m_nSelectedTrackID = 0;
	id->m_nSelectedAirIndex = 0;
	id->m_nSelectedAircraftType = SAT_NONE;


	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;
	extern int UpdateFDO(struct InstanceData* id, MGLGRID *FDOGrid);
	if (SecondTabGrid)
	{
		for (i = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && i < DataAppVO->count; i++)
		{
			DataSource = VP(DataAppVO, i, "DataSource", char);
			if (!strcmp(DataSource, "ROI")){
				ROIGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
				strcpy_s(ROIGrid->Flightnum, 20, "0");
				strcpy_s(id->m_selectedaircraft, 20, "0");
				SecondTabGrid->aircraftcolor_change_MLAT = 1;
				SecondTabGrid->aircraftcolor_change_ASDEX = 1;
				SecondTabGrid->aircraftcolor_change_Noise = 1;
				SecondTabGrid->aircraftcolor_change_Gate = 1;
				SecondTabGrid->aircraftcolor_change_ASD = 1;
				SecondTabGrid->aircraftcolor_change = 1;
				id->m_selectedaircraftcolor = 100;
				SecondTabGrid->updateroi = 1;
			}
			else if (!strcmp(DataSource, "FDO"))
			{
				FDOGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
				strcpy_s(FDOGrid->Flightnum, 20, "0");
				strcpy_s(id->m_selectedaircraft, 20, "0");
				SecondTabGrid->aircraftcolor_change_MLAT = 1;
				SecondTabGrid->aircraftcolor_change_ASDEX = 1;
				SecondTabGrid->aircraftcolor_change_Noise = 1;
				SecondTabGrid->aircraftcolor_change_Gate = 1;
				SecondTabGrid->aircraftcolor_change_ASD = 1;
				SecondTabGrid->aircraftcolor_change = 1;
				id->m_selectedaircraftcolor = 100;
				if (FDOGrid->parent_w->visible == 1)
					UpdateFDO(id, FDOGrid);

			}

		}

	}
	Callback2Javascript(id, "UpdateSelected:");
}

// NAME: GetPostRequest - Simulate an XMLHttpRequest
// PURPOSE: Should return the result for a request
// INPUT: p - Request (post string)
// OUTPUT: m, Returned result from post request
// EXAMPLE(S): 
void GetPostRequest(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	const DWORD cdwThreadId = GetCurrentThreadId();
	clear_chunk_memory(m);

	if (p){
		char* data = curl_unescape(p, strlen(p));
		char* url = data;
		char* postfields = strstr(url, "&");
		*(postfields++) = 0;

		D_CONTROL("PostRequest", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) url<%s>, postfields<%s>\n", cdwThreadId, url, postfields));
		if (!GetCurlFormPostResults(id, m, url, postfields, SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to perform post request to \"%s\".\n", cdwThreadId, url);
		}else{
			D_CONTROL("PostRequest", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Result:<%s>\n", cdwThreadId, m->memory));
		}
		curl_free(data);
	}
}

// NAME: GetPermission - GetData callback, for "Permission" 
// PURPOSE: Should return the result for a specific permission setting
// INPUT: p - JSON array of Permission's needed value like 'DHS'
// OUTPUT: m, JSON string of requested permission values
// EXAMPLE(S): 
void GetPermission(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	enum json_tokener_error jerror;
	struct json_object* jobjin = NULL;
	struct json_object* jobjout = NULL;
	int jlen = 0;
	int i = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();
	clear_chunk_memory(m);
	// Create returned json object for results
	jobjout = json_object_new_object();

	if (p && strlen(p)){
		char* data = curl_unescape(p, strlen(p));
		jobjin = json_tokener_parse_verbose(data, &jerror);
		if (json_tokener_success == jerror && json_object_is_type(jobjin, json_type_array)){
			jlen = json_object_array_length(jobjin);
			for (i = 0; i < jlen; i++){
				struct json_object* jelem = json_object_array_get_idx(jobjin, i);
				if (json_object_is_type(jelem, json_type_string)){
					const char* perm = json_object_get_string(jelem);
					json_object_object_add(jobjout, perm, json_object_new_boolean(HavePermission(id, perm)));
				}else{
					vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unexpected array element type, expecting string.\n", cdwThreadId);
				}
			}
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) parse of \"%s\" failed with(%d).\n", cdwThreadId, p, jerror);
		}
		curl_free(data);
	}else{
		// Return All Known Permissions
		int nPos = 0;
		if (id->m_pstrPerms && id->m_nPermCount){
			for (nPos = 0; nPos < id->m_nPermCount; nPos++){
				json_object_object_add(jobjout, id->m_pstrPerms + (nPos * PERM_SZ), json_object_new_boolean(TRUE));
			}
		}
	}

	if (jobjout){
		char* data = NULL;
		const char* jstr = json_object_to_json_string(jobjout);

		// Convert to curl escaped text for return
		data = curl_escape(jstr, strlen(jstr));
		if (data){
			// Add data to memory struct
			clear_chunk_memory(m);
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);

			// Release curl escaped data
			curl_free(data);
		}
		// Release entire json object
		json_object_put(jobjout);
	}
}

// NAME: IsConfigDefined - GetData callback, for "HasConfigName" 
// PURPOSE: Should return the result if a configuration name (DEBUG_NAME) has been defined in configuration file
// INPUT: p - ConfigName Request
// OUTPUT: m, JSON string of config values
// EXAMPLE(S): 
void IsConfigDefined(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	enum json_tokener_error jerror;
	struct json_object* jobjin = NULL;
	struct json_object* jobjout = NULL;
	int jlen = 0;
	int i = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();
	clear_chunk_memory(m);
	// Create returned json object for results
	jobjout = json_object_new_object();

	if (p && strlen(p)){
		char* data = curl_unescape(p, strlen(p));
		jobjin = json_tokener_parse_verbose(data, &jerror);
		if (json_tokener_success == jerror && json_object_is_type(jobjin, json_type_array)){
			jlen = json_object_array_length(jobjin);
			for (i = 0; i < jlen; i++){
				struct json_object* jelem = json_object_array_get_idx(jobjin, i);
				if (json_object_is_type(jelem, json_type_string)){
					const char* name = json_object_get_string(jelem);
					json_object_object_add(jobjout, name, json_object_new_boolean(IsDebugNameDefined(id, name)));
				}
				else{
					vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unexpected array element type, expecting string.\n", cdwThreadId);
				}
			}
		}
		else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) parse of \"%s\" failed with(%d).\n", cdwThreadId, p, jerror);
		}
		curl_free(data);
	}
	
	if (jobjout){
		char* data = NULL;
		const char* jstr = json_object_to_json_string(jobjout);

		// Convert to curl escaped text for return
		data = curl_escape(jstr, strlen(jstr));
		if (data){
			// Add data to memory struct
			clear_chunk_memory(m);
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);

			// Release curl escaped data
			curl_free(data);
		}
		// Release entire json object
		json_object_put(jobjout);
	}
}

void LayersFill(struct InstanceData* id, char *data, struct json_object* jobj)
{
	enum json_tokener_error jerror = json_tokener_success;
	struct json_object_iter jiter;
	const DWORD cdwThreadId = GetCurrentThreadId();
	if (!jobj && data)
		jobj = json_tokener_parse_verbose(data, &jerror);
	if (jobj){
		if (json_tokener_success == jerror){
			json_object_object_foreachC(jobj, jiter){
				if (json_object_is_type(jiter.val, json_type_boolean)){
					json_boolean val = json_object_get_boolean(jiter.val);
					D_CONTROL("UserFillLayers", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) key(%s), value(%d).\n", cdwThreadId, jiter.key, val));
					if (!strcmp("apron", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_AIRPORT_APRON;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_AIRPORT_APRON;
					}else if(!strcmp("parking", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_AIRPORT_PARKING;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_AIRPORT_PARKING;
					}else if(!strcmp("buildings", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_BUILDINGS;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_BUILDINGS;
					}else if(!strcmp("construction", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_CONSTRUCTION;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_CONSTRUCTION;
					} else if (!strcmp("closed", jiter.key)) {
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_CLOSED;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_CLOSED;
					} else if (!strcmp("custom", jiter.key)) {
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_CUSTOM;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_CUSTOM;
					}else if(!strcmp("deicing", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_DEICING;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_DEICING;
					}else if(!strcmp("frequency", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_FREQUENCY;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_FREQUENCY;
					}else if(!strcmp("markings", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_MARKINGS;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_MARKINGS;
					}else if(!strcmp("road", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_ROADS;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_ROADS;
					}else if(!strcmp("runway", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_RUNWAY;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_RUNWAY;
					}else if(!strcmp("shoulder", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_SHOULDER;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_SHOULDER;
					}else if(!strcmp("taxiway", jiter.key)){
						if (val)
							id->m_sCurLayout.m_nLayerEnableFlag |= LEF_TAXIWAY;
						else
							id->m_sCurLayout.m_nLayerEnableFlag &= ~LEF_TAXIWAY;
					}
					// The following were not implemented since they were not part of airport map layers.
					//boundary
					//water
					//term_fixes
					//high_fixes
					//low_fixes
				}
			}
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) parse of \"%s\" failed with(%d).\n", cdwThreadId, data, jerror);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) parse of \"%s\" failed with(%d).\n", cdwThreadId, data, jerror);
	}

}

void SettingsFill(struct InstanceData* id, char *data, struct json_object* jobj)
{
	char *str;
	GLfloat* pColor = NULL;

	// New JSON Method
	if (jobj){
		struct json_object_iter jiter;
		if (json_type_object == json_object_get_type(jobj)){
			json_object_object_foreachC(jobj, jiter){
				if (!strcmp("apron", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfApronFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("boundary", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfUSFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("buildings", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfBuildingFillColor, json_object_get_string(jiter.val));
				} else if (!strcmp("closed", jiter.key)) {
					StringToGLFloat(id->m_sCurLayout.m_glfClosedFillColor, json_object_get_string(jiter.val));
				} else if (!strcmp("construction", jiter.key)) {
					StringToGLFloat(id->m_sCurLayout.m_glfConstructionFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("custom", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfCustomFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("deicing", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfDeicingFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("frequency", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfFrequencyFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("high_fixes", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfFixHighFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("low_fixes", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfFixLowFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("markings", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfMarkingsFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("parking", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfParkingFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("road", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfRoadFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("runway", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfRunwayFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("shoulder", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfShoulderFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("taxiway", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfTaxiFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("term_fixes", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfFixTermFillColor, json_object_get_string(jiter.val));
				}else if(!strcmp("water", jiter.key)){
					StringToGLFloat(id->m_sCurLayout.m_glfWaterFillColor, json_object_get_string(jiter.val));
				}
			}
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid MapColors Object (%s).\n", GetCurrentThreadId(), json_object_to_json_string(jobj));
		}
	}else{
		// Old Method
		// example data = "fill="boundary,#CC6600"
		if (!data){
			return;
		}
		if (str = strstr(data, "fill"))
		{
			str += strlen("fill");
			if (str = strstr(data, "boundary")){
				str += strlen("boundary") + 1;
				pColor = id->m_sCurLayout.m_glfUSFillColor;
			}else if(str = strstr( data, "taxiway") ){
				str += strlen("taxiway") + 1;
				pColor = id->m_sCurLayout.m_glfTaxiFillColor;
			}else if(str = strstr( data, "buildings") ){
				str += strlen("buildings") + 1;
				pColor = id->m_sCurLayout.m_glfBuildingFillColor;
			}else if(str = strstr( data, "runway") ){
				str += strlen("runway") + 1;
				pColor = id->m_sCurLayout.m_glfRunwayFillColor;
			}else if(str = strstr( data, "water") ){
				str += strlen("water") + 1;
				pColor = id->m_sCurLayout.m_glfWaterFillColor;
			}else if(str = strstr( data, "apron") ){
				str += strlen("apron") + 1;
				pColor = id->m_sCurLayout.m_glfApronFillColor;
			}else if(str = strstr( data, "parking") ){
				str += strlen("parking") + 1;
				pColor = id->m_sCurLayout.m_glfParkingFillColor;
			}else if(str = strstr( data, "markings") ){
				str += strlen("markings") + 1;
				pColor = id->m_sCurLayout.m_glfMarkingsFillColor;
			}else if(str = strstr( data, "shoulder") ){
				str += strlen("shoulder") + 1;
				pColor = id->m_sCurLayout.m_glfShoulderFillColor;
			}else if(str = strstr( data, "deicing") ){
				str += strlen("deicing") + 1;
				pColor = id->m_sCurLayout.m_glfDeicingFillColor;
			}else if(str = strstr( data, "construction") ){
				str += strlen("construction") + 1;
				pColor = id->m_sCurLayout.m_glfConstructionFillColor;
			}else if(str = strstr( data, "frequency") ){
				str += strlen("frequency") + 1;
				pColor = id->m_sCurLayout.m_glfFrequencyFillColor;
			}else if(str = strstr( data, "road") ){
				str += strlen("road") + 1;
				pColor = id->m_sCurLayout.m_glfRoadFillColor;
			}else if(str = strstr( data, "term_fixes") ){
				str += strlen("term_fixes") + 1;
				pColor = id->m_sCurLayout.m_glfFixTermFillColor;
			}else if(str = strstr( data, "high_fixes") ){
				str += strlen("high_fixes") + 1;
				pColor = id->m_sCurLayout.m_glfFixHighFillColor;
			}else if(str = strstr( data, "low_fixes") ){
				str += strlen("low_fixes") + 1;
				pColor = id->m_sCurLayout.m_glfFixLowFillColor;
			}
			if (pColor){
				if (strlen(str) >= 7){
					pColor[0] = (GLfloat)HexStrtod(&str[1], 2) / 255.0f;
					pColor[1] = (GLfloat)HexStrtod(&str[3], 2) / 255.0f;
					pColor[2] = (GLfloat)HexStrtod(&str[5], 2) / 255.0f;
				}else{
					pColor[0] = pColor[1] = pColor[2] = 0.0f;
				}
			}
		}
	}
}

// NAME: ChangePassurAirport - SendMessage callback for "ChangePassurAirport" 
// PURPOSE: Should display the passur tracks for the airport selected 
// INPUT: p - passur airport name 
// EXAMPLE: JFK or NONE
int ChangePassurAirport(struct InstanceData* id, char* p)
{
	int i, airportindex = -1;
	char *data = NULL;
	int bReturn = FALSE;
	static int bInit = FALSE;

	data = curl_unescape(p, strlen(p));
	strncpy_s(id->m_strAirportMap, ARPTNAME_SZ, data, _TRUNCATE);
	if (!bInit || strcasecmp(id->m_sCurLayout.m_strPassurArpt, data)){
		id->m_bResetTracks = TRUE;
		id->m_bResetASDTracks = FALSE;
		SetEvent(id->m_evAirDataReset);
		if (!strcasecmp("NONE", data)) { // dont show any tracks when 'NONE' is chosen
			id->m_sCurLayout.m_bShowPassurAircraft = FALSE;
			strncpy_s(id->m_sCurLayout.m_strPassurArpt, ARPTNAME_SZ, "None", _TRUNCATE);
			id->m_sCurLayout.m_strPassurArpt[ORIG_DES_SIZE - 1] = '\0';
		} else {
			VO* PassurArptsVO = NULL;

			EnterCriticalSection(&id->m_csAirportsVO);
			PassurArptsVO = (VO*)id->m_pAirportsVO;

			if (PassurArptsVO){
				for (i = 0; PassurArptsVO && i < PassurArptsVO->count; i++){
					if (!strcasecmp(VP(PassurArptsVO, i, "icao_code", char), data)){
						airportindex = i;
						break;
					}
				}
				if (airportindex >= 0){
					// Create new ASDE-X string for airport name
					// - This is done becuase some PASSUR airports may not have actual passur's and may contain
					//   incorrect info, i.e. MDW uses ORD data
					strncpy_s(id->m_strAsdexArpt, ARPTNAME_SZ, data, 3);
					_strlwr_s(id->m_strAsdexArpt, ARPTNAME_SZ);
					id->m_strAsdexArpt[3] = 'F';
					id->m_strAsdexArpt[4] = '\0';
					id->m_nAsdexArpt = -1;
					strcpy_s(id->m_strAdsbArpt, ARPTNAME_SZ, id->m_strAsdexArpt);
					strcpy_s(id->m_strMLATArpt, ARPTNAME_SZ, id->m_strAsdexArpt);
					strncpy_s(id->m_strNoiseArpt, ARPTNAME_SZ, id->m_strAsdexArpt, 3);
					id->m_nAdsbArpt = -1;
					id->m_nMLATArpt = -1;

					strncpy_s(id->m_sCurLayout.m_strPassurArpt, LAYOUT_PASSUR_SIZE, VP(PassurArptsVO, airportindex, "icao_code", char), ORIG_DES_SIZE - 1);
					id->m_sCurLayout.m_strPassurArpt[ORIG_DES_SIZE - 1] = '\0';

					// Passur Airport changed, change Regions to reflect the change
					if (id->m_pGRegions){
						free(id->m_pGRegions);
						id->m_pGRegions = NULL;
					}

					// NOTE: Some airports do not really have a passur, so the passur_code may relate to another airport
					//       e.g. MDW uses ORD.
					strncpy_s(id->m_strPassurArpts[0], LAYOUT_PASSUR_SIZE, VP(PassurArptsVO, airportindex, "passur_code", char), ORIG_DES_SIZE - 1);
					id->m_strPassurArpts[0][ORIG_DES_SIZE - 1] = '\0';
					strncpy_s(pulse_db_arpt, ORIG_DES_SIZE, VP(PassurArptsVO, airportindex, "pulse_db_code", char), ORIG_DES_SIZE - 1);
					pulse_db_arpt[ORIG_DES_SIZE - 1] = '\0';
					id->m_dLatitudes[0] = VV(PassurArptsVO, airportindex, "lat", double);
					id->m_dLongitudes[0] = VV(PassurArptsVO, airportindex, "lng", double);
					id->m_dZeroX[0] = VV(PassurArptsVO, airportindex, "zerox", double);
					id->m_dZeroY[0] = VV(PassurArptsVO, airportindex, "zeroy", double);
					id->m_dAltitudes[0] = VV(PassurArptsVO, airportindex, "alt", double);
					id->m_bIsPassurTais = VV(PassurArptsVO, airportindex, "tais", int);
					LoadAirportGroundAltitude(id);
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)Airport %s, Altitude %f\n", GetCurrentThreadId(), id->m_sCurLayout.m_strPassurArpt, id->m_dAltitudes[0]);

					LoadSurfaceVehicles(id);
					LoadAirportGates(id);
				}
#ifdef OLDWAY
				StrLower( id->m_strPassurArpts[0] );
				StrLower( current_arpt );
#endif
				// platitude[0] = atof( latstr );
				LatOrig = id->m_dLatitudes[0];
				//plongitude[0] = atof( lngstr );
				LngOrig = id->m_dLongitudes[0];
			}
			LeaveCriticalSection(&id->m_csAirportsVO);
			//PassurThreadStarted = TRUE; // Start passur data collection
			resizeWindow(id, id->m_nWidth, id->m_nHeight);
			//MCT - Temporarily Removed, Not sure of intent: for ( n=0; n<PULS_SRVR_LIST_SZ+1 && GetETAs()==FALSE; n++);
		}
		bInit = TRUE;
	}
	curl_free(data);
	return (bReturn);
}

// NAME: HtmlLog - SendMessage callback for "Log" 
// PURPOSE: Log HTML/UI messages to the logfile
// INPUT: p - string to log
int HtmlLog(struct InstanceData* id, char* p)
{
	char* data = curl_unescape(p, strlen(p));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), data);
	curl_free(data);
	return (TRUE);
}

// NAME: Grid - SendMessage callback for "Grid" 
// PURPOSE: Activate the Grid, just like 'D' used to do.
// INPUT: p - N/A
int Grid(struct InstanceData* id, char* p)
{
	//char* data = curl_unescape(p, strlen(p));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)\n", GetCurrentThreadId());
	ShowDataViewer(id);
	//curl_free(data);
	return (TRUE);
}

// NAME: ROIColors - SendMessage callback for "ROIColors" 
// PURPOSE: Provide the DLL with the current Region Outline Colors
// INPUT: p - JSON: Array of {region, color} pairs
// EXAMPLE: [ { "region" : "Rwy 13R 31L", "color" : "#FF9966" }, ... ]
int ROIColors(struct InstanceData* id, char* p)
{
	enum   json_tokener_error jerror;
	int    bReturn = TRUE;
	int    nPos, nLen = 0;
	char*  data = NULL;
	struct json_object* jobj = NULL;
	struct json_object_iter jiter;
	struct json_object* jelem = NULL;
	REGION_OUTLINE_COLOR * pROIColors = NULL;
	REGION_OUTLINE_COLOR * rocp = NULL;

	EnterCriticalSection(&id->m_csROI);
	// Clear old color list
	if (id->m_pROIColors)
	{
		free(id->m_pROIColors);
		id->m_pROIColors = NULL;
		id->m_nROIColors = 0;
	}

	// New JSON solution.
	data = curl_unescape(p, strlen(p));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Data <%s>\n", GetCurrentThreadId(), data);
	jobj = json_tokener_parse_verbose(data, &jerror);
	if (json_tokener_success == jerror)
	{
		// Parse the data array
		if (jobj && json_type_array == json_object_get_type(jobj))
		{
			// Create a place for us to hold the outline color information
			nLen = json_object_array_length(jobj);
			if (nLen > 0)
			{
				id->m_pROIColors = (REGION_OUTLINE_COLOR *)calloc(nLen, sizeof(REGION_OUTLINE_COLOR));
				memset(id->m_pROIColors, 0x0, nLen * sizeof(REGION_OUTLINE_COLOR));
				id->m_nROIColors = nLen;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region Color Count <%d>\n", GetCurrentThreadId(), id->m_nROIColors);

				if (id->m_pROIColors)
				{
					rocp = (REGION_OUTLINE_COLOR *)id->m_pROIColors;
					for (nPos = 0; nPos < nLen; nPos++, rocp++)
					{
						jelem = json_object_array_get_idx(jobj, nPos);
						json_object_object_foreachC(jelem, jiter)
						{
							if (!strcmp("region", jiter.key))
							{
								strcpy_s(rocp->region, ROI_REGION_NAME_LEN + 1, json_object_get_string(jiter.val));
							}
							else if (!strcmp("color", jiter.key))
							{
								strcpy_s(rocp->color, ROI_COLOR_LEN + 1, json_object_get_string(jiter.val));
								StringToGLFloat(&rocp->glColor[0], rocp->color);
								vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region <%s>, Color <%s>\n", GetCurrentThreadId(), rocp->region, rocp->color);
							}
						}
					}
				}
			}
		}

		// Free the JSON object
		json_object_put(jobj);
	}

	curl_free(data);
	LeaveCriticalSection(&id->m_csROI);
	return (bReturn);
}

void FilterPriority(struct InstanceData* id, char *data, struct json_object* jobj)
{
	const DWORD cdwThreadId = GetCurrentThreadId();
	char *nexttok;
	char *context;
	int f = 0, i = 0, j = 0, len = 0, nPos = 0;
	int count = 0;
	FILTERS* pFilters = (FILTERS*)id->m_pFilters;

	if (jobj)
	{
		// clear priority list
		memset(id->m_pActiveFilterPriorityIndices, -1, id->m_nMaxFilters * sizeof(int));

		if (json_object_is_type(jobj, json_type_array)){
			count = json_object_array_length(jobj);
			for (i = 0; i < count; i++){
				struct json_object* jelem = json_object_array_get_idx(jobj, i);
				const char* cstrFilterName = json_object_get_string(jelem);
				for (j = 0; j < id->m_nFilterCount; j++){
					if (!strcmp(cstrFilterName, pFilters[j].filtername)){
						id->m_pActiveFilterPriorityIndices[f++] = j;
						break;
					}
				}
			}
		}
	}
	else
	{

		// Handle Empty list
		if (strlen(data) <= 2) return;

		// Remove Quotes from data
		data++;
		data[strlen(data) - 1] = '\0';

		// clear priority list
		memset(id->m_pActiveFilterPriorityIndices, -1, id->m_nMaxFilters * sizeof(int));
		// Identify index of filter into priority list
		nexttok = strtok_s(data, ",", &context);
		while (nexttok != NULL){
			for (i = 0; i < id->m_nFilterCount; i++){
				if (!strcmp(nexttok, pFilters[i].filtername)){
					id->m_pActiveFilterPriorityIndices[f++] = i;
					break;
				}
			}
			nexttok = strtok_s(NULL, ",", &context);
		}

	}
	if (IS_D_CONTROL("FILTERS")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter Count <%d>\n", cdwThreadId, id->m_nFilterCount);
		for (nPos = 0; nPos < id->m_nFilterCount; nPos++)
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FILTER[%d] = <%s>\n", cdwThreadId, nPos, pFilters[nPos].filtername);
		}
		for (nPos = 0; nPos < id->m_nFilterCount && id->m_pActiveFilterPriorityIndices[nPos] != -1; nPos++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ACTIVE FILTER PRIORITY[%d]=<%d>,<%s>\n",
				cdwThreadId, nPos, id->m_pActiveFilterPriorityIndices[nPos], pFilters[id->m_pActiveFilterPriorityIndices[nPos]].filtername);
		}
	}
}

void SetTagFilters(struct InstanceData* id, char *data, struct json_object* jobj)
{
	const DWORD cdwThreadId = GetCurrentThreadId();
	int f = 0, i = 0, j = 0, len = 0, nPos = 0;
	int count = 0;
	FILTERS* pTagFilters = (FILTERS*)id->m_pTagFilters;

	// Unset all tag filters
	id->m_nActiveTagFilters = 0;
	for (j = 0; j < id->m_nTagFilterCount; j++){
		pTagFilters[j].IsActive = FALSE;
	}

	if (jobj)
	{
		if (json_object_is_type(jobj, json_type_array)){
			count = json_object_array_length(jobj);
			for (i = 0; i < count; i++){
				struct json_object* jelem = json_object_array_get_idx(jobj, i);
				const char* cstrTagFilterName = json_object_get_string(jelem);
				for (j = 0; j < id->m_nTagFilterCount; j++){
					if (!strcmp(cstrTagFilterName, pTagFilters[j].filtername)){
						pTagFilters[j].IsActive = TRUE;
						id->m_nActiveTagFilters++;
						break;
					}
				}
			}
		}
	}
	if (IS_D_CONTROL("TAGFILTERS")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter Count <%d>\n", cdwThreadId, id->m_nTagFilterCount);
		for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++)
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TAG FILTER[%d] = <%s, %d>\n", cdwThreadId, nPos, pTagFilters[nPos].filtername, pTagFilters[nPos].IsActive);
		}
	}
}


// NAME: ChangeLayout - SendMessage callback, for "ChangeLayout" 
// PURPOSE: Should convert the ActiveX control to use new settings 
// INPUT: p - Any individual settings
// EXAMPLE(s): 
//	"layout=\"Layout 1\""			- Use all current settings of "Layout 1"
//  "world=\"Off\"					- Turn off world map
//  "world=\"On\"					- Turn on world map
//  "roads=\"Off\"					- Turn off mapped roads
//  "roads=\"On\"					- Turn on mapped roads
//  "legend=\"Off\"					- Turn off map legend
//  "legend=\"On\"					- Turn on map legend
//	"range=\"Off\"					- Aircraft range rings off
//	"range=\"On,1.5\"				- Aircraft range rings on, requested radius of range ring of 1.3 nmiles
//  "arptrange=\"Off\"				- Airport range rings off
//  "arptrange=\"On,10,3,JFK\"		- 3 rings around JFK, 10 mile intervals
//	"trails=\"On\"&points=\"10\""	- Turn on trails using 10 point trails
//	"trails=\"Off\""				- Turn off trails
//	"points=\"10\""					- Set point value for trails to 10
//	"times=\"On\"					- Enable trail times
//	"tags=\"Off\"					- Turn tags off
//	"tags=\"Small,#000000,#FFFFFF,0"&line1=\"Airline,,\"	
//									- Turn tags on to small and set
//										text color = #000000
//										background color = #FFFFFF
//										transparency percent = 0
//										line1 = airline, none, none
//										possible line values:
//											"Airline", "Origin", "Destination", 
//											"Departure Fix", "Passur Tail", 
//											"Aircraft Type", "Time in Queue", 
//											"Scheduled Departure Time", 
//											"Planned Departure Time", 
//											"Estimated Departure Time"
//	"tags=\"Large,#000000,#FF0000,100"&line1=\"Airline,,\"&line2=\"Origin,,\"&line3=\"Aircraft Type,,\"	
//									- Turn tags on to large and set 
//                                      text color = #000000
//										background color = #FF0000
//										transparency = 100%
//										line1 = airline, none, none
//										line2 = origin, none, none
//										line3 = aircraft type, none, none
//	"icon=\"Off\"					- Turn icon color off
//	"icon=\"On,fix,Shipp,Yellow\"	- Turn icon color on, use departure fix "Shipp"="Yellow"
//	"icon=\"On,airline,Delta,Blue\"- Turn icon color on, use airline "Delta"="Blue"
//	"outline=\"boundary,\""		- No State Boundary Outline Color
//	"outline=\"boundary,#FFFFFF\"" Set State Boundary Outline Color to White/rgb #FFFFFF
//	"outline=\"buildings,\""		- No Buildings Outline Color
//	"outline=\"buildings,#FFFFFF\""	- Set Buildings Outline Color to White/rgb #FFFFFF
//	"outline=\"runway,\""		- No Runways Outline Color
//	"outline=\"runway,#FFFFFF\""	- Set Runways Outline Color to White/rgb #FFFFFF
//	"outline=\"taxiway,\""		- No Taxiways Outline Color
//	"outline=\"taxiway,#FFFFFF\""- Set Taxiways Outline Color to White/rgb #FFFFFF
//	"outline=\"water,\""		- No Water Outline Color
//	"outline=\"water,#FFFFFF\""	- Set Water Outline Color to White/rgb #FFFFFF
//	"fill=\"boundary,\""		- No State Boundary Fill Color
//	"fill=\"boundary,#FFFFFF\""	- Set State Boundary Fill Color to White/rgb #FFFFFF
//	"fill=\"buildings,\""		- No Buildings Fill Color
//	"fill=\"buildings,#FFFFFF\""- Set Buildings Fill Color to White/rgb #FFFFFF
//	"fill=\"runway,\""			- No Runways Fill Color
//	"fill=\"runway,#FFFFFF\""	- Set Runways Fill Color to White/rgb #FFFFFF
//	"fill=\"taxiway,\""			- No Taxiways Fill Color
//	"fill=\"taxiway,#FFFFFF\""	- Set Taxiways Fill Color to White/rgb #FFFFFF
//	"fill=\"water,\""			- No Water Fill Color
//	"fill=\"water,#FFFFFF\""	- Set Water Fill Color to White/rgb #FFFFFF
//	"passurAirport=\"JFK""		- Use passur tracks from JFK
int ChangeLayout(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	/* TODO: Connect to DB, extract data per user */
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	struct json_object_iter jiter;
	GLfloat ratio;
	double CurrentYSize, CurrentXSize;
	char *data = NULL;
	char *search = NULL;
	char arpt[5] = { 0 };
	int bReturn = TRUE;
	int bCoords = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) ENTRY: p <%s>.\n", cdwThreadId, p));
	data = curl_unescape(p, strlen(p));

	// New JSON solution.	
	jobj = json_tokener_parse_verbose(data, &jerror);
	if (json_tokener_success == jerror){
		D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile,
			__FUNCTION__, "(0x%X) (2).\n", cdwThreadId, p));
		json_object_object_foreachC(jobj, jiter){
			D_CONTROL("CHANGE_LAYOUT", vo_log_info(id->m_pfVoLogFile,
				__FUNCTION__, "(0x%X) Processing JSON Key <%s> with value <%s>.\n", cdwThreadId, jiter.key, json_object_to_json_string(jiter.val)));
			if (!strcmp("airways", jiter.key)){
				id->m_bShowAirways = json_object_get_boolean(jiter.val);
			}else if(!strcmp("adsb", jiter.key)){
				if (IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))
				{
					id->m_sCurLayout.m_bShowADSBAircraft = json_object_get_boolean(jiter.val);
					if (!id->m_sCurLayout.m_bShowADSBAircraft){
						if (SAT_ADSB == id->m_nSelectedAircraftType)
							ClearSelectedAircraft(id);
						// Unmark any tracks tracked by this PASSUR Feed
						ClearADSBTrackedTracks(id);
					}
				}
				else
				{
					id->m_sCurLayout.m_bShowADSBAircraft = TRUE;
				}
			}else if(!strcmp("airasia", jiter.key)){
				if (IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))
				{
					id->m_sCurLayout.m_bShowAirAsiaAircraft = json_object_get_boolean(jiter.val);
					if(!id->m_sCurLayout.m_bShowAirAsiaAircraft){
						if( SAT_AIRASIA == id->m_nSelectedAircraftType)
							ClearSelectedAircraft(id);					
					}
				}
				else
				{
					if (HavePermission(id, "AIRASIA")){
						id->m_sCurLayout.m_bShowAirAsiaAircraft = TRUE;
					}else{
						id->m_sCurLayout.m_bShowAirAsiaAircraft = FALSE;
					}
				}
			}else if(!strcmp("alerts", jiter.key)){
				// Process Alerts Object ... array of alert objects 
				ChangeAlertConfig(id, jiter.val);
			}else if(!strcmp("allsurf", jiter.key)){
				id->m_nAllSurface = json_object_get_boolean(jiter.val);
			}else if(!strcmp("angle", jiter.key)){
				id->m_glfRotateAngle = (GLfloat)json_object_get_double(jiter.val);
			}else if(!strcmp("arptrings", jiter.key)){
				id->m_sCurLayout.m_bShowAirportRings = json_object_get_boolean(jiter.val);
			}else if(!strcmp("arptring", jiter.key)){
				id->m_sCurLayout.m_nAirportRingSize = json_object_get_int(jiter.val);
			}else if(!strcmp("arptcount", jiter.key)){
				id->m_sCurLayout.m_nAirportRingCount = json_object_get_int(jiter.val);
			}else if(!strcmp("arptList", jiter.key)){
				const char* arptList = json_object_get_string(jiter.val);
				int n = strlen(arptList) + 1;
				if (id->m_sCurLayout.m_pstrRangeRingArpts){
					free(id->m_sCurLayout.m_pstrRangeRingArpts);
					id->m_sCurLayout.m_pstrRangeRingArpts = NULL;
				}
				id->m_sCurLayout.m_pstrRangeRingArpts = calloc(n, sizeof(char));
				strcpy_s(id->m_sCurLayout.m_pstrRangeRingArpts, n, arptList);
				StrUpper(id->m_sCurLayout.m_pstrRangeRingArpts);
			}else if(!strcmp("arptStatus", jiter.key)){
				id->m_sCurLayout.m_bShowFAAStatus = json_object_get_boolean(jiter.val);
			}else if(!strcmp("ARTCC", jiter.key)){
				if (id->m_sCurLayout.m_pstrARTCC){
					free(id->m_sCurLayout.m_pstrARTCC);
					id->m_sCurLayout.m_pstrARTCC = NULL;
				}
				id->m_sCurLayout.m_pstrARTCC = _strdup(json_object_to_json_string(jiter.val));
			}else if(!strcmp("artcc_lbl", jiter.key)){
				id->m_sCurLayout.m_nARTCCLabel = json_object_get_boolean(jiter.val);
			}else if(!strcmp("artcc_clr", jiter.key)){
				StringToGLFloat(id->m_sCurLayout.m_glfARTCCColor, json_object_get_string(jiter.val));
			}else if (!strcmp("artcc_fntidx", jiter.key)){
				id->m_sCurLayout.m_nARTCCFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("asdex", jiter.key)){
				if (IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))
				{
					id->m_sCurLayout.m_bShowASDEXAircraft = json_object_get_boolean(jiter.val);
					if (!id->m_sCurLayout.m_bShowASDEXAircraft){
						if (SAT_ASDEX == id->m_nSelectedAircraftType)
							ClearSelectedAircraft(id);
						// Unmark any tracks tracked by this PASSUR Feed
						ClearASDEXTrackedTracks(id);
					}
				}
				else
				{
					id->m_sCurLayout.m_bShowASDEXAircraft = TRUE;
				}
			}else if(!strcmp("asdi", jiter.key)){
				if (IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))
				{
					id->m_sCurLayout.m_bShowASDAircraft = json_object_get_boolean(jiter.val);
					if (!id->m_sCurLayout.m_bShowASDAircraft && SAT_ASDI == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
				}
				else
				{
					id->m_sCurLayout.m_bShowASDAircraft = TRUE;
				}

			}else if(!strcmp("compression", jiter.key)){
				id->m_sCurLayout.m_bShowCompression = json_object_get_boolean(jiter.val);

			}else if(!strcmp("COORDS", jiter.key)){
				if (json_type_array == json_object_get_type(jiter.val) && 4 == json_object_array_length(jiter.val)){
					struct json_object* jelem = json_object_array_get_idx(jiter.val, 0);
					id->m_sCurLayout.m_dWorldXmin = json_object_get_double(jelem);
					jelem = json_object_array_get_idx(jiter.val, 1);
					id->m_sCurLayout.m_dWorldXmax = json_object_get_double(jelem);
					jelem = json_object_array_get_idx(jiter.val, 2);
					id->m_sCurLayout.m_dWorldYmin = json_object_get_double(jelem);
					jelem = json_object_array_get_idx(jiter.val, 3);
					id->m_sCurLayout.m_dWorldYmax = json_object_get_double(jelem);
					bCoords = TRUE;
				}
			}else if(!strcmp("fill", jiter.key)){
				SettingsFill(id, NULL, jiter.val);
			}else if(!strcmp("filters", jiter.key)){
				D_CONTROL("FILTERS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filters <%s>\n", cdwThreadId, json_object_to_json_string(jiter.val)));
				FilterPriority(id, NULL, jiter.val);
			}else if(!strcmp("fi", jiter.key)){
				SetFontIndex(id, json_object_get_int(jiter.val));
			}else if(!strcmp("high_fixes", jiter.key)){
				id->m_sCurLayout.m_bShowFixesH = json_object_get_boolean(jiter.val);
			}else if (!strcmp("fixesh_fntidx", jiter.key)){
				id->m_sCurLayout.m_nFixesHFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("fixesl_fntidx", jiter.key)){
				id->m_sCurLayout.m_nFixesLFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("gates_lbl", jiter.key)){
				id->m_sCurLayout.m_nGATESLabel = json_object_get_boolean(jiter.val);
			}else if(!strcmp("gates_clr", jiter.key)){
				StringToGLFloat(id->m_sCurLayout.m_glfGATESColor, json_object_get_string(jiter.val));
			}else if (!strcmp("gates_fntidx", jiter.key)){
				id->m_sCurLayout.m_nGATESFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("icon", jiter.key)){
				id->m_sCurLayout.m_nAircraftSize = json_object_get_int(jiter.val);
			}else if(!strcmp("layers", jiter.key)){
				LayersFill(id, NULL, jiter.val);
			}else if(!strcmp("line1", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strTagLine1, TAG_LENGTH, json_object_get_string(jiter.val));
			}else if(!strcmp("line2", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strTagLine2, TAG_LENGTH, json_object_get_string(jiter.val));
			}else if(!strcmp("line3", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strTagLine3, TAG_LENGTH, json_object_get_string(jiter.val));
			}else if(!strcmp("lkp", jiter.key)){
				id->m_sUserSettings.LKP = json_object_get_boolean(jiter.val);
				if (!id->m_sUserSettings.LKP)
					ClearSelectedAircraft(id);
			}else if(!strcmp("local", jiter.key)){
				id->m_sUserSettings.TimeDisplayLocal = json_object_get_boolean(jiter.val);
				// Dump the Historical and Delete JSON ROI Data strings, they now have to be recreated with new times.
				EnterCriticalSection(&id->m_csROIHist);
				if (id->m_pGRegionsHistorical) {
					free(id->m_pGRegionsHistorical);
					id->m_pGRegionsHistorical = NULL;
				}
				if (id->m_pGRegionsDelete){
					free(id->m_pGRegionsDelete);
					id->m_pGRegionsDelete = NULL;
				}
				LeaveCriticalSection(&id->m_csROIHist);
			}else if(!strcmp("low_fixes", jiter.key)){
				id->m_sCurLayout.m_bShowFixesL = json_object_get_boolean(jiter.val);
			}else if(!strcmp("mlat", jiter.key)){
				if (IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))
				{
				id->m_sCurLayout.m_bShowMLATAircraft = json_object_get_boolean(jiter.val);
				if (!id->m_sCurLayout.m_bShowMLATAircraft){
					if (SAT_MLAT == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
					// Unmark any tracks tracked by this PASSUR Feed
					ClearMLATTrackedTracks(id);
				}
				}
				else
				{
					id->m_sCurLayout.m_bShowMLATAircraft = TRUE;
				}
			}else if(!strcmp("name", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strLayoutName, LAYOUT_NAME_SIZE, json_object_get_string(jiter.val));
			}else if(!strcmp("noise", jiter.key)){
				id->m_sCurLayout.m_bShowNoiseAircraft = json_object_get_boolean(jiter.val);
			}else if(!strcmp("outline", jiter.key)){
				OutlineColors(id, NULL, jiter.val);
			}else if(!strcmp("owner", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strOwner, CHAR24, json_object_get_string(jiter.val));
			}else if(!strcmp("passur", jiter.key)){
				if (IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))
				{
					id->m_sCurLayout.m_bShowPassurAircraft = json_object_get_boolean(jiter.val);
					// Do the following if PASSUR is turned off
					if (!id->m_sCurLayout.m_bShowPassurAircraft){
						if (SAT_PASSUR == id->m_nSelectedAircraftType)
							ClearSelectedAircraft(id);
						// Unmark any tracks tracked by this PASSUR Feed
						ClearPASSURTrackedTracks(id);
					}
				}
				else
				{
					id->m_sCurLayout.m_bShowPassurAircraft = TRUE;
				}
			}else if(!strcmp("plan", jiter.key)){
				id->m_sCurLayout.m_bShowFltPlan = json_object_get_boolean(jiter.val);
			}else if(!strcmp("points", jiter.key)){
				TrailsFill(id, NULL, jiter.val);
			}else if(!strcmp("psrArpt", jiter.key)){
				strcpy_s(arpt, ARPTNAME_SZ, json_object_get_string(jiter.val));
				ChangePassurAirport(id, arpt);
				strcpy_s(id->m_strAirportMap, ARPTNAME_SZ, arpt);
			}else if(!strcmp("range", jiter.key)){
				SetRangeRings(id, NULL, jiter.val);
			}else if(!strcmp("roi", jiter.key)){
				D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (1) m_bShowRoi value was <%d>.\n",
					cdwThreadId, id->m_sCurLayout.m_bShowRoi));

				id->m_sCurLayout.m_bShowRoi = json_object_get_boolean(jiter.val);

				D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (1) m_bShowRoi value is now <%d>.\n",
					cdwThreadId, id->m_sCurLayout.m_bShowRoi));
			}else if(!strcmp("runways", jiter.key)){
				id->m_sCurLayout.m_bShowRunways = json_object_get_boolean(jiter.val);
			}else if (!strcmp("rois_lbl", jiter.key)){
				id->m_sCurLayout.m_nROISLabel = json_object_get_boolean(jiter.val);
			}else if (!strcmp("rois_clr", jiter.key)){
				StringToGLFloat(id->m_sCurLayout.m_glfROISColor, json_object_get_string(jiter.val));
			}else if (!strcmp("rois_fntidx", jiter.key)){
				id->m_sCurLayout.m_nROISFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("sids", jiter.key)){
				if (id->m_sCurLayout.m_pstrSIDS){
					free(id->m_sCurLayout.m_pstrSIDS);
					id->m_sCurLayout.m_pstrSIDS = NULL;
				}
				id->m_sCurLayout.m_pstrSIDS = _strdup(json_object_get_string(jiter.val));
			}else if(!strcmp("sids_lbl", jiter.key)){
				id->m_sCurLayout.m_nSIDSLabel = json_object_get_boolean(jiter.val);
			}else if(!strcmp("sids_clr", jiter.key)){
				StringToGLFloat(id->m_sCurLayout.m_glfSIDSColor, json_object_get_string(jiter.val));
			}else if (!strcmp("sids_fntidx", jiter.key)){
				id->m_sCurLayout.m_nSIDSFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("stars", jiter.key)){
				if (id->m_sCurLayout.m_pstrSTARS){
					free(id->m_sCurLayout.m_pstrSTARS);
					id->m_sCurLayout.m_pstrSTARS = NULL;
				}
				id->m_sCurLayout.m_pstrSTARS = _strdup(json_object_get_string(jiter.val));
			}else if(!strcmp("stars_lbl", jiter.key)){
				id->m_sCurLayout.m_nSTARSLabel = json_object_get_boolean(jiter.val);
			}else if(!strcmp("stars_clr", jiter.key)){
				StringToGLFloat(id->m_sCurLayout.m_glfSTARSColor, json_object_get_string(jiter.val));
			}else if (!strcmp("stars_fntidx", jiter.key)){
				id->m_sCurLayout.m_nSTARSFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("tagBorders", jiter.key)){
				SetTagBorders(id, NULL, jiter.val);
			}else if(!strcmp("tagfilters", jiter.key)){
				D_CONTROL("TAGFILTERS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filters <%s>\n", cdwThreadId, json_object_to_json_string(jiter.val)));
				SetTagFilters(id, NULL, jiter.val);
			}else if(!strcmp("tags", jiter.key)){
				SetTags(id, NULL, jiter.val);
			}else if(!strcmp("term_fixes", jiter.key)){
				id->m_sCurLayout.m_bShowFixesT = json_object_get_boolean(jiter.val);
			}else if (!strcmp("fixest_fntidx", jiter.key)){
				id->m_sCurLayout.m_nFixesTFontIndex = json_object_get_int(jiter.val);
			}else if (!strcmp("times", jiter.key)){
				id->m_sCurLayout.m_bShowTrailTimes = json_object_get_boolean(jiter.val);
			}else if(!strcmp("trails", jiter.key)){
				id->m_sCurLayout.m_bShowTrails = json_object_get_boolean(jiter.val);
			}else if(!strcmp("vehicles", jiter.key)){
				if(!id->m_nVehicles){
					if( SAT_LMG == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
				}
				id->m_nVehicles = json_object_get_int(jiter.val);
			}else if(!strcmp("vclr", jiter.key)){
				id->m_nVColorIndex = json_object_get_int(jiter.val);
			}else if(!strcmp("vline1", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strTagVLine1, TAG_LENGTH, json_object_get_string(jiter.val));
			}else if(!strcmp("vline2", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strTagVLine2, TAG_LENGTH, json_object_get_string(jiter.val));
			}else if(!strcmp("vline3", jiter.key)){
				strcpy_s(id->m_sCurLayout.m_strTagVLine3, TAG_LENGTH, json_object_get_string(jiter.val));
			}else if(!strcmp("vtag", jiter.key)){
				id->m_bDisableVTag = json_object_get_int(jiter.val);
			}else if(!strcmp("weather", jiter.key)){
				id->m_sCurLayout.m_bShowWeather = json_object_get_boolean(jiter.val);
			}else if(!strcmp("world", jiter.key)){
				id->m_sCurLayout.m_bShowWorldMap =
					id->m_sCurLayout.m_bShowWorldBorders = json_object_get_boolean(jiter.val);
			}
		}
		json_object_put(jobj);
	}else{
		// Use specified settings
		// ...
		// example data = "outline="boundary,#FF99FF"  or "fill="boundary,#CC6600" 

		// Old Comptibility Methods
		// NOTE: New code should be in JSON format, this code is provided only for older layouts 
		//       that have not been converted yet to JSON. Conversion happens automatically on
		//		 a Save. Javascript works with both forms, converts to JSON.
		if (!(search = strchr(data, '='))){
			curl_free(data);
			return (FALSE); // bad layout item
		}
		search++;
		D_CONTROL("CHANGE_LAYOUT", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Processing <%s>.\n",
			cdwThreadId, data));
		if (!strncmp(data, "layout", 6)){
			p = strchr(++search, '\"');
			memset(id->m_sCurLayout.m_strLayoutName, 0, sizeof(id->m_sCurLayout.m_strLayoutName));
			strncpy_s(id->m_sCurLayout.m_strLayoutName, LAYOUT_NAME_SIZE, search, p - search);
		}else if(!strncmp(data, "icon", 4)){
			if (isdigit(*(data + 6)))
				id->m_sCurLayout.m_nAircraftSize = atoi(data + 6);
			else
				id->m_sCurLayout.m_nAircraftSize = 12;
		} else if ( !strncmp( data, "filters", 7 ) ){
			FilterPriority(id, data + 8, NULL);
		} else if ( !strncmp( data, "outline", 7 ) ){
			OutlineColors(id, data, NULL);
		} else if ( !strncmp( data, "fill", 4 ) ){
			SettingsFill(id, data, NULL);
		} else if ( !strncmp( data, "layers", 6 ) ){
			LayersFill(id, data + 7, NULL);
		} else if ( !strncmp( data, "trails", 6 ) ){
			TrailsFill(id, data, NULL);
		} else if ( !strncmp( data, "points", 6 ) ){
			TrailsFill(id, data, NULL);
		} else if ( !strncmp( data, "times", 5 ) ){
			TrailsFill(id, data, NULL);
		} else if ( !strncmp( data, "world", 5 ) ){
			WorldFill(id, data);
		} else if ( !strncmp( data, "tagBorders", 10 ) ){
			SetTagBorders(id, data + 11, NULL);
		} else if ( !strncmp( data, "tags", 4 ) ||  !strncmp( data, "line", 4 )){
			SetTags(id, data, NULL);
		} else if ( !strncmp( data, "range", 5 ) ){
			SetRangeRings(id, data, NULL);
		} else if ( !strncmp( data, "arptrings", 9 ) ){
			SetAirportRings(id, data);
		} else if ( !strncmp( data, "legend", 6 ) ){
			/* NOT YET IMPLEMENTED */
		} else if ( !strncmp( data, "plan", 4 ) ){
			if (!strncmp(data + 6, "Off", 3)){
				id->m_sCurLayout.m_bShowFltPlan = FALSE;
			}else{
				id->m_sCurLayout.m_bShowFltPlan = TRUE;
			}
		} else if ( !strncmp( data, "local", 5 ) ){
			if (!strncmp(data + 7, "Off", 3)){
				id->m_sUserSettings.TimeDisplayLocal = FALSE;
			}else{
				id->m_sUserSettings.TimeDisplayLocal = TRUE;
			}
		} else if ( !strncmp( data, "roads", 5 ) ){
			/* NOT YET IMPLEMENTED */
		} else if ( !strncmp( data, "passur", 6 ) ){
			if (!strncmp(data + 8, "Off", 3)){
				if (id->m_sCurLayout.m_bShowPassurAircraft){
					id->m_sCurLayout.m_bShowPassurAircraft = FALSE;
					if (SAT_PASSUR == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
				}
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) PASSUR Data Feed Disabled\n", cdwThreadId);
			}else{
				id->m_sCurLayout.m_bShowPassurAircraft = TRUE;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) PASSUR Data Feed Enabled\n", cdwThreadId);
			}
		} else if ( !strncmp( data, "asdi", 4 ) ){
			if (!strncmp(data + 6, "Off", 3)){
				if (id->m_sCurLayout.m_bShowASDAircraft){
					id->m_sCurLayout.m_bShowASDAircraft = FALSE;
					if (SAT_ASDI == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
				}
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASD Data Feed Disabled\n", cdwThreadId);
			}else{
				id->m_sCurLayout.m_bShowASDAircraft = TRUE;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASD Data Feed Enabled\n", cdwThreadId);
			}
		} else if ( !strncmp( data, "asdex", 5 ) ){
			if (!strncmp(data + 7, "Off", 3)){
				if (id->m_sCurLayout.m_bShowASDEXAircraft){
					id->m_sCurLayout.m_bShowASDEXAircraft = FALSE;
					if (SAT_ASDEX == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
				}
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX Data Feed Disabled\n", cdwThreadId);
			}else{
				id->m_sCurLayout.m_bShowASDEXAircraft = TRUE;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX Data Feed Enabled\n", cdwThreadId);
			}
		} else if ( !strncmp( data, "adsb", 4 ) ){
			if (!strncmp(data + 6, "Off", 3)){
				if (id->m_sCurLayout.m_bShowADSBAircraft){
					id->m_sCurLayout.m_bShowADSBAircraft = FALSE;
					if (SAT_ADSB == id->m_nSelectedAircraftType)
						ClearSelectedAircraft(id);
				}
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ADS-B Data Feed Disabled\n", cdwThreadId);
			}else{
				id->m_sCurLayout.m_bShowADSBAircraft = TRUE;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ADS-B Data Feed Enabled\n", cdwThreadId);
			}
		} else if ( !strncmp( data, "psrArpt", 7 ) ){		
			int nPos = 9;
			//call changePassurAirport with the airport name		
			strncpy_s(arpt, ARPTNAME_SZ, data + 9, 4);
			if (arpt[3] == '\"')
				arpt[3] = '\0';
			else
				arpt[4] = '\0';
			ChangePassurAirport(id, arpt);
			strcpy_s(id->m_strAirportMap, ARPTNAME_SZ, arpt);
		} else if ( !strncmp( data, "arptStatus", 10 ) ){
			if (!strncmp(data + 12, "Off", 3))
				id->m_sCurLayout.m_bShowFAAStatus = FALSE;
			else
				id->m_sCurLayout.m_bShowFAAStatus = TRUE;
		} else if ( !strncmp( data, "COORDS", 6) ){
			// Aspect Ratio's may be different if logins occur from different machines
			// or even different IE windows.
			char* pVal = data + 7;
			bCoords = TRUE;
			id->m_sCurLayout.m_dWorldXmin = atof(pVal);
			pVal = strchr(pVal, ',') + 1;
			id->m_sCurLayout.m_dWorldXmax = atof(pVal);
			pVal = strchr(pVal, ',') + 1;
			id->m_sCurLayout.m_dWorldYmin = atof(pVal);
			pVal = strchr(pVal, ',') + 1;
			id->m_sCurLayout.m_dWorldYmax = atof(pVal);
		} else if ( !strncmp( data, "weather", 7 ) ){
			if (!strncmp(data + 9, "Off", 3))
				id->m_sCurLayout.m_bShowWeather = FALSE;
			else
				id->m_sCurLayout.m_bShowWeather = TRUE;
#if 0
		} else if ( !strncmp( data, "fastupdates", 11 ) ){
			if(!strncmp(data + 13, "Off", 3))
				id->m_bFastUpdates = FALSE;
			else
				id->m_bFastUpdates = TRUE;
#endif
		} else if ( !strncmp( data, "roi=", 4) ){
			if (!strncmp(data + 5, "On", 2)) {
				D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (2) m_bShowRoi value was <%d>.\n",
					cdwThreadId, id->m_sCurLayout.m_bShowRoi));
				id->m_sCurLayout.m_bShowRoi = TRUE;

				D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (2) m_bShowRoi value is now <%d>.\n",
					cdwThreadId, id->m_sCurLayout.m_bShowRoi));
			} else {
				D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3) m_bShowRoi value was <%d>.\n",
					cdwThreadId, id->m_sCurLayout.m_bShowRoi));
				id->m_sCurLayout.m_bShowRoi = FALSE;

				D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3) m_bShowRoi value is now <%d>.\n",
					cdwThreadId, id->m_sCurLayout.m_bShowRoi));
			}
		} else if ( !strncmp( data, "term_fixes", 10 ) ){
			if (!strncmp(data + 12, "Off", 3)){
				// TODO: Set Terminal Fixes Off
				id->m_sCurLayout.m_bShowFixesT = 0;
			} else {
				// TODO: Set Terminal Fixes On
				id->m_sCurLayout.m_bShowFixesT = 1;
			}
		} else if ( !strncmp( data, "high_fixes", 10 ) ){
			if (!strncmp(data + 12, "Off", 3)){
				// TODO: Set High Fixes Off
				id->m_sCurLayout.m_bShowFixesH = 0;
			} else {
				// TODO: Set High Fixes On
				id->m_sCurLayout.m_bShowFixesH = 1;
			}
		} else if ( !strncmp( data, "low_fixes", 9 ) ){
			if (!strncmp(data + 11, "Off", 3)){
				// TODO: Set Low Fixes Off
				id->m_sCurLayout.m_bShowFixesL = 0;
			} else {
				// TODO: Set High Fixes On
				id->m_sCurLayout.m_bShowFixesL = 1;
			}
		} else if ( !strncmp( data, "fixes", 5 ) ){
			// fixes - Deprecated: Kept for backward compatibility, now using term_fixes, high_fixes and low_fixes.
			if (!strncmp(data + 7, "Off", 3)){
				//ShowFixes = 0;
			} else {
				//ShowFixes = 1;
			}
		} else if ( !strncmp( data, "runways", 7 ) ){
			id->m_sCurLayout.m_bShowRunways = TRUE;
			if (!strncmp(data + 9, "Off", 3))
				id->m_sCurLayout.m_bShowRunways = FALSE;
		}
	}
	// not yet implemented, set default
	id->m_sUserSettings.DisplayDegrees = 0;

	if (bCoords){
		// Adjust The World Coordinates to Window Size
		ratio = (GLfloat)id->m_nWidth / (GLfloat)id->m_nHeight;
		id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
		id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
		if (id->m_sCurLayout.m_dWorldXSize > id->m_sCurLayout.m_dWorldYSize){
			CurrentYSize = id->m_sCurLayout.m_dWorldYSize;
			id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldXSize / ratio);
			id->m_sCurLayout.m_dWorldYmax = id->m_sCurLayout.m_dWorldYmin + id->m_sCurLayout.m_dWorldYSize;
		} else {
			CurrentXSize = id->m_sCurLayout.m_dWorldXSize;
			id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldYSize * ratio);
			id->m_sCurLayout.m_dWorldXmax = id->m_sCurLayout.m_dWorldXmin + id->m_sCurLayout.m_dWorldXSize;
		}
	}

	curl_free(data);
	return (bReturn);
}



int ProcessFilter(struct InstanceData* id, struct json_object* jobj, int bUpdate)
{
	struct json_object_iter jiter;
	struct json_object* jname;
	int nPos = id->m_nFilterCount;
	int bReturn = FALSE;
	const char* cstrFilter = NULL;
	FILTERS* pFilters = (FILTERS*)id->m_pFilters;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Make sure we have room for new filter if it is being added
	if (!bUpdate && (id->m_nFilterCount + 1) > id->m_nMaxFilters){
		// Enlarge filter structure by 10 elements
		FILTERS* pFilters2 = NULL;
		id->m_nMaxFilters += 10;
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter structure not large enough to store user defined filters, enlarging ( to %d ).\n", cdwThreadId, id->m_nMaxFilters);
		pFilters2 = realloc(pFilters, id->m_nMaxFilters * sizeof(FILTERS));
		if (pFilters2){
			id->m_pFilters = pFilters = pFilters2;
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to realloc Filter structure, not large enough to store new user defined filter!\n", cdwThreadId);
			return 0;
		}
		// Redo Active Filter Priority Indices as well
		if (id->m_pActiveFilterPriorityIndices){
			free(id->m_pActiveFilterPriorityIndices);
			id->m_pActiveFilterPriorityIndices = calloc(id->m_nMaxFilters, sizeof(int));
			memset(id->m_pActiveFilterPriorityIndices, -1, id->m_nMaxFilters * sizeof(int));
		}
	}

	jname = json_object_object_get(jobj, "filter");
	cstrFilter = json_object_get_string(jname);

	if (bUpdate){
		int i;
		// Find nPos from jobj filter
		for (i = 0; i < id->m_nFilterCount; i++){
			if (!strcmp(pFilters[i].filtername, cstrFilter)){
				nPos = i;
				break;
			}
		}
	}else{
		id->m_nFilterCount++;
	}

	json_object_object_foreachC(jobj, jiter){
		if (!strcmp("filter", jiter.key)){
			// Initialize nullable (-1) int values
			pFilters[nPos].out2off =
				pFilters[nPos].on2in =
				pFilters[nPos].delayed =
				pFilters[nPos].stranded = -1;
			// get Filtername
			if (!stripOuterWhitespace(pFilters[nPos].filtername, json_object_get_string(jiter.val), FILTER_NAME_SIZE))
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filtername truncated from \"%s\" to \"%s\"!\n",
				cdwThreadId, json_object_get_string(jiter.val), pFilters[nPos].filtername);
		}else if(!strcmp("isactive", jiter.key)){
			// get Active Status
			if (json_object_get_boolean(jiter.val)){
				pFilters[nPos].IsActive = TRUE;
				id->m_nActiveFilters++;
			}
			else
				pFilters[nPos].IsActive = FALSE;
		}else if(!strcmp("isinclude", jiter.key)){
			pFilters[nPos].IsIncludeFilter = json_object_get_int(jiter.val);
		}else if(!strcmp("ismatchall", jiter.key)){
			pFilters[nPos].matchall = json_object_get_int(jiter.val);
		}else if(!strcmp("airlines", jiter.key)){
			strcpy_s(pFilters[nPos].airlines, FILTER_AIRLINES_SIZE, json_object_get_string(jiter.val));
			StrUpper(pFilters[nPos].airlines);
		}else if(!strcmp("owner", jiter.key)){
			const char* owner = json_object_get_string(jiter.val);
			if (!strlen(owner))
				strcpy_s(pFilters[nPos].owner, FILTER_OWNER_SIZE, id->m_strUserName);
			else
				strcpy_s(pFilters[nPos].owner, FILTER_OWNER_SIZE, owner);
		}else if(!strcmp("origins", jiter.key)){
			strcpy_s(pFilters[nPos].origins, FILTER_ORIGINS_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("color", jiter.key)){
			pFilters[nPos].colorindex = json_object_get_int(jiter.val);
		}else if(!strcmp("destinations", jiter.key)){
			strcpy_s(pFilters[nPos].destinations, FILTER_DESTINATIONS_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("flights", jiter.key)){
			strcpy_s(pFilters[nPos].flightnumbers, FILTER_FLIGHTNUMBERS_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("fixes", jiter.key)){
			strcpy_s(pFilters[nPos].fixes, FILTER_DEPARTUREFIX_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("gates", jiter.key)){
			strcpy_s(pFilters[nPos].gates, FILTER_DESTGATE_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("actypes", jiter.key)){
			strcpy_s(pFilters[nPos].actypes, FILTER_ACTYPES_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("out2off", jiter.key)){
			pFilters[nPos].out2off = json_object_get_int(jiter.val);
		}else if(!strcmp("on2in", jiter.key)){
			pFilters[nPos].on2in = json_object_get_int(jiter.val);
		}else if(!strcmp("delay", jiter.key)){
			pFilters[nPos].delayed = json_object_get_int(jiter.val);
		}else if(!strcmp("stranded", jiter.key)){
			pFilters[nPos].stranded = json_object_get_int(jiter.val);
		}
	} // End foreachC			
	return bReturn;
}

int ProcessTagFilter(struct InstanceData* id, struct json_object* jobj, int bUpdate)
{
	struct json_object_iter jiter;
	struct json_object* jname;
	int nPos = id->m_nTagFilterCount;
	int bReturn = FALSE;
	const char* cstrFilter = NULL;
	FILTERS* pTagFilters = (FILTERS*)id->m_pTagFilters;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Make sure we have room for new filter if it is being added
	if (!bUpdate && (id->m_nTagFilterCount + 1) > id->m_nMaxTagFilters){
		// Enlarge filter structure by 10 elements
		FILTERS* pTagFilters2 = NULL;
		id->m_nMaxTagFilters += 10;
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter structure not large enough to store user defined tag filters, enlarging ( to %d ).\n", cdwThreadId, id->m_nMaxTagFilters);
		pTagFilters2 = realloc(pTagFilters, id->m_nMaxTagFilters * sizeof(FILTERS));
		if (pTagFilters2){
			id->m_pTagFilters = pTagFilters = pTagFilters2;
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to realloc Tag Filter structure, not large enough to store new user defined Tag Filter!\n", cdwThreadId);
			return 0;
		}
	}

	jname = json_object_object_get(jobj, "filter");
	cstrFilter = json_object_get_string(jname);

	if (bUpdate){
		int i;
		// Find nPos from jobj filter
		for (i = 0; i < id->m_nTagFilterCount; i++){
			if (!strcmp(pTagFilters[i].filtername, cstrFilter)){
				nPos = i;
				break;
			}
		}
	}else{
		id->m_nTagFilterCount++;
	}

	json_object_object_foreachC(jobj, jiter){
		if (!strcmp("filter", jiter.key)){
			// Initialize nullable (-1) int values
			pTagFilters[nPos].out2off =
				pTagFilters[nPos].on2in =
				pTagFilters[nPos].delayed =
				pTagFilters[nPos].stranded = -1;
			// get Filtername
			if (!stripOuterWhitespace(pTagFilters[nPos].filtername, json_object_get_string(jiter.val), FILTER_NAME_SIZE))
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filtername truncated from \"%s\" to \"%s\"!\n",
				cdwThreadId, json_object_get_string(jiter.val), pTagFilters[nPos].filtername);
		}else if(!strcmp("isactive", jiter.key)){
			// get Active Status
			if (json_object_get_boolean(jiter.val)){
				pTagFilters[nPos].IsActive = TRUE;
				id->m_nActiveTagFilters++;
			}
			else
				pTagFilters[nPos].IsActive = FALSE;
		}else if(!strcmp("isinclude", jiter.key)){
			pTagFilters[nPos].IsIncludeFilter = json_object_get_int(jiter.val);
		}else if(!strcmp("ismatchall", jiter.key)){
			pTagFilters[nPos].matchall = json_object_get_int(jiter.val);
		}else if(!strcmp("airlines", jiter.key)){
			strcpy_s(pTagFilters[nPos].airlines, FILTER_AIRLINES_SIZE, json_object_get_string(jiter.val));
			StrUpper(pTagFilters[nPos].airlines);
		}else if(!strcmp("owner", jiter.key)){
			const char* owner = json_object_get_string(jiter.val);
			if (!strlen(owner))
				strcpy_s(pTagFilters[nPos].owner, FILTER_OWNER_SIZE, id->m_strUserName);
			else
				strcpy_s(pTagFilters[nPos].owner, FILTER_OWNER_SIZE, owner);
		}else if(!strcmp("origins", jiter.key)){
			strcpy_s(pTagFilters[nPos].origins, FILTER_ORIGINS_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("color", jiter.key)){
			pTagFilters[nPos].colorindex = json_object_get_int(jiter.val);
		}else if(!strcmp("destinations", jiter.key)){
			strcpy_s(pTagFilters[nPos].destinations, FILTER_DESTINATIONS_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("flights", jiter.key)){
			strcpy_s(pTagFilters[nPos].flightnumbers, FILTER_FLIGHTNUMBERS_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("fixes", jiter.key)){
			strcpy_s(pTagFilters[nPos].fixes, FILTER_DEPARTUREFIX_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("gates", jiter.key)){
			strcpy_s(pTagFilters[nPos].gates, FILTER_DESTGATE_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("actypes", jiter.key)){
			strcpy_s(pTagFilters[nPos].actypes, FILTER_ACTYPES_SIZE, json_object_get_string(jiter.val));
		}else if(!strcmp("out2off", jiter.key)){
			pTagFilters[nPos].out2off = json_object_get_int(jiter.val);
		}else if(!strcmp("on2in", jiter.key)){
			pTagFilters[nPos].on2in = json_object_get_int(jiter.val);
		}else if(!strcmp("delay", jiter.key)){
			pTagFilters[nPos].delayed = json_object_get_int(jiter.val);
		}else if(!strcmp("stranded", jiter.key)){
			pTagFilters[nPos].stranded = json_object_get_int(jiter.val);
		}
	} // End foreachC			
	return bReturn;
}


int ProcessFilters(struct InstanceData* id, struct json_object* jobj)
{
	int f;
	int nLen;
	int nPos;
	FILTERS* pFilters = (FILTERS*)id->m_pFilters;
	const DWORD cdwThreadId = GetCurrentThreadId();
	// break string into individual values, fill structures
	id->m_nFilterCount = 0;
	if (!pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process filters.\n", cdwThreadId);
		return FALSE;
	}

	if (jobj && json_type_array == json_object_get_type(jobj)){
		nLen = json_object_array_length(jobj);
		for (nPos = 0; nPos < nLen; nPos++){
			struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
			ProcessFilter(id, jelem, FALSE);
		}// End for
	}else{
		struct json_object* jdesc = json_object_object_get(jobj, "description");
		if (jdesc){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid filter object.\n", cdwThreadId);
		}
		return FALSE;
	}

	// Determine if ShowAllAircraft is on
	for (f = 0; f < id->m_nFilterCount; f++){
		if (pFilters[f].IsActive && pFilters[f].IsIncludeFilter){
			id->m_sCurLayout.m_bShowAllAircraft = FALSE;
			break;
		}
	}
	return TRUE;
}

int ProcessTagFilters(struct InstanceData* id, struct json_object* jobj)
{
	//int f;
	int nLen;
	int nPos;
	FILTERS* pTagFilters = (FILTERS*)id->m_pTagFilters;
	const DWORD cdwThreadId = GetCurrentThreadId();
	// break string into individual values, fill structures
	id->m_nTagFilterCount = 0;
	if (!pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process tag filters.\n", cdwThreadId);
		return FALSE;
	}

	if (jobj && json_type_array == json_object_get_type(jobj)){
		nLen = json_object_array_length(jobj);
		for (nPos = 0; nPos < nLen; nPos++){
			struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
			ProcessTagFilter(id, jelem, FALSE);
		}// End for
	}else{
		struct json_object* jdesc = json_object_object_get(jobj, "description");
		if (jdesc){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s.\n", cdwThreadId, json_object_get_string(jdesc));
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid tag filter object.\n", cdwThreadId);
		}
		return FALSE;
	}

	return TRUE;
}


void LoadUserLayout2(struct InstanceData* id, struct json_object* jobj)
{
	int nLen = 0, nPos = 0;
	const char* cstrOwner, *cstrName;
	const char* cstrDefault = "-default-";
	struct json_object* jLayouts = NULL, *jPair = NULL;
	char strLayoutPath[MAX_PATH_SZ] = { 0 };
	const DWORD cdwThreadId = GetCurrentThreadId();

	jLayouts = json_object_new_array();

	if (jobj && json_type_array == json_object_get_type(jobj)){
		nLen = json_object_array_length(jobj);
		for (nPos = 0; nPos < nLen; nPos++){
			int nIsActive = FALSE;
			struct json_object_iter jiter;
			struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
			json_object_object_foreachC(jelem, jiter){
				if (!strcmp("name", jiter.key)){
					cstrName = json_object_get_string(jiter.val);
					jPair = json_object_new_object();
					if (jPair){
						json_object_object_add(jPair, "_class", json_object_new_string("pair"));
						json_object_object_add(jPair, "first", json_object_new_string(cstrName));
					}
				}else if(!strcmp("owner", jiter.key)){
					cstrOwner = json_object_get_string(jiter.val);
					if (jPair){
						json_object_object_add(jPair, "second", json_object_new_string(cstrOwner));
						if (jLayouts)
							json_object_array_add(jLayouts, jPair);
					}
				}else if(!strcmp("isactive", jiter.key)){
					nIsActive = json_object_get_int(jiter.val);
				}else if(!strcmp("layout", jiter.key)){					
					if (!strcmp(cstrName, "<default>")){
						cstrName = cstrDefault;
					}
					sprintf_s(strLayoutPath, MAX_PATH_SZ, "%s\\%s.json", id->m_strCachedDir, cstrName);
					if (json_object_to_file(strLayoutPath, jiter.val)){
						vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\" to file \"%s\"!\n", cdwThreadId, cstrName, strLayoutPath);
					}
					if (nIsActive){
						sprintf_s(strLayoutPath, MAX_PATH_SZ, "%s\\-active-.json", id->m_strCachedDir);
						if (json_object_to_file(strLayoutPath, jiter.val)){
							vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\" to file \"%s\"!\n", cdwThreadId, cstrName, strLayoutPath);
						}
						ProcessJSONLayout(id, (char*)json_object_to_json_string(jiter.val));
					}
				}
			}
		}
	}
	if (jLayouts){
		CacheLayouts(id, jLayouts);
		id->m_pstrLayouts = _strdup(json_object_to_json_string(jLayouts));
		json_object_put(jLayouts);
	}
}

void LoadUserFilters(struct InstanceData* id, struct json_object* jobj, int bSave)
{
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Manage/Empty Filter Array Structure
	if (id->m_pFilters){
		free(id->m_pFilters);
		id->m_pFilters = NULL;
	}

	// Determine starting Filter Array Length
	if (jobj && json_object_is_type(jobj, json_type_array)){
		id->m_nFilterCount = json_object_array_length(jobj);
		id->m_nMaxFilters = id->m_nFilterCount + 10;
	}else{
		id->m_nFilterCount = 0;
		id->m_nMaxFilters = 200;
	}

	// Allocate Filter Array
	id->m_pFilters = calloc(id->m_nMaxFilters, sizeof(FILTERS));

	// Alloc filter Priority Indices if not already allocated
	if (!id->m_pActiveFilterPriorityIndices){
		id->m_pActiveFilterPriorityIndices = calloc(id->m_nMaxFilters, sizeof(int));
		memset(id->m_pActiveFilterPriorityIndices, -1, id->m_nMaxFilters * sizeof(int));
	}

	if (!id->m_pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to allocate user filters!\n", cdwThreadId);
		return;
	}

	// Store Filters in Array
	if (ProcessFilters(id, jobj) && bSave){
		char strFilterPath[MAX_PATH_SZ] = { 0 };
		sprintf_s(strFilterPath, MAX_PATH_SZ, "%s\\-filters-.json", id->m_strCachedDir);
		if (json_object_to_file(strFilterPath, jobj)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save filters to file \"%s\"!\n", cdwThreadId, strFilterPath);
		}
	}
}

void LoadUserTagFilters(struct InstanceData* id, struct json_object* jobj, int bSave)
{
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Manage Filter Structure
	if (id->m_pTagFilters){
		free(id->m_pTagFilters);
		id->m_pTagFilters = NULL;
	}

	// Determine starting Tag Filter Array Length
	if (jobj && json_object_is_type(jobj, json_type_array)){
		id->m_nTagFilterCount = json_object_array_length(jobj);
		id->m_nMaxTagFilters = id->m_nTagFilterCount + 10;
	}else{
		id->m_nTagFilterCount = 0;
		id->m_nMaxTagFilters = 200;
	}

	id->m_pTagFilters = calloc(id->m_nMaxTagFilters, sizeof(FILTERS));

	if (!id->m_pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to allocate user tag filters structure!\n", cdwThreadId);
		return;
	}

	if (ProcessTagFilters(id, jobj) && bSave){
		char strTagFilterPath[MAX_PATH_SZ] = { 0 };
		sprintf_s(strTagFilterPath, MAX_PATH_SZ, "%s\\-tagfilters-.json", id->m_strCachedDir);
		if (json_object_to_file(strTagFilterPath, jobj)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save tag filters to file \"%s\"!\n", cdwThreadId, strTagFilterPath);
		}
	}
}

void LoadCachedUserFilters(struct InstanceData* id){
	struct json_object* jobj = NULL;
	char strPath[MAX_PATH_SZ] = { 0 };
	sprintf_s(strPath, MAX_PATH_SZ, "%s\\-filters-.json", id->m_strCachedDir);
	jobj = json_object_from_file(strPath);
	if (jobj && -1 != ((int)jobj)){
		LoadUserFilters(id, jobj, FALSE);
		json_object_put(jobj);
	}
}

void LoadCachedUserTagFilters(struct InstanceData* id){
	struct json_object* jobj = NULL;
	char strPath[MAX_PATH_SZ] = { 0 };
	sprintf_s(strPath, MAX_PATH_SZ, "%s\\-tagfilters-.json", id->m_strCachedDir);
	jobj = json_object_from_file(strPath);
	if (jobj && -1 != ((int)jobj)){
		LoadUserTagFilters(id, jobj, FALSE);
		json_object_put(jobj);
	}
}

void CacheLayouts(struct InstanceData* id, struct json_object* jobj)
{
	char strPath[MAX_PATH_SZ] = { 0 };
	const DWORD cdwThreadId = GetCurrentThreadId();

	sprintf_s(strPath, MAX_PATH_SZ, "%s\\-layouts-.json", id->m_strCachedDir);
	if (json_object_to_file(strPath, jobj)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save layouts to file \"%s\"!\n", cdwThreadId, strPath);
	}
}

void CachePerms(struct InstanceData* id, struct json_object* jobj)
{
	char strPath[MAX_PATH_SZ] = { 0 };
	const DWORD cdwThreadId = GetCurrentThreadId();

	sprintf_s(strPath, MAX_PATH_SZ, "%s\\-perms-.json", id->m_strCachedDir);
	if (json_object_to_file(strPath, jobj)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save permissions to file \"%s\"!\n", cdwThreadId, strPath);
	}
}

void LoadCachedPermissions(struct InstanceData* id){
	struct json_object* jobj = NULL;
	char strPath[MAX_PATH_SZ] = { 0 };
	sprintf_s(strPath, MAX_PATH_SZ, "%s\\-perms-.json", id->m_strCachedDir);
	jobj = json_object_from_file(strPath);
	if (jobj && -1 != ((int)jobj)){
		ProcessPermissions(id, jobj);
		json_object_put(jobj);
	}
}

int LoadCachedLayouts(struct InstanceData* id){
	int bLoaded = FALSE;
	struct json_object* jobj = NULL;
	char strPath[MAX_PATH_SZ] = { 0 };
	sprintf_s(strPath, MAX_PATH_SZ, "%s\\-layouts-.json", id->m_strCachedDir);
	jobj = json_object_from_file(strPath);
	if (jobj && -1 != ((int)jobj)){
		bLoaded = TRUE;
		id->m_pstrLayouts = _strdup(json_object_to_json_string(jobj));
		json_object_put(jobj);
	}
	return bLoaded;
}

int LoadCachedLayout(struct InstanceData* id, const char* strLayout, struct MemoryStruct* chunk){
	int bLoaded = FALSE;
	const char* cstrDefault = "-default-";
	struct json_object* jobj = NULL;
	char strPath[MAX_PATH_SZ] = { 0 };
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (strLayout){
		if (!strcmp(strLayout, "<default>")){
			strLayout = cstrDefault;
		}
		sprintf_s(strPath, MAX_PATH_SZ, "%s\\%s.json", id->m_strCachedDir, strLayout);
	}else{
		sprintf_s(strPath, MAX_PATH_SZ, "%s\\-active-.json", id->m_strCachedDir);
	}
	jobj = json_object_from_file(strPath);
	if (jobj && -1 != ((int)jobj)){
		bLoaded = TRUE;
		ProcessJSONLayout(id, (char*)json_object_to_json_string(jobj));

		// Save Loaded Layout as new active layout
		if (strLayout && jobj){
			sprintf_s(strPath, MAX_PATH_SZ, "%s\\-active-.json", id->m_strCachedDir);
			if (json_object_to_file(strPath, jobj)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\" to file \"%s\"!\n", cdwThreadId, strLayout, strPath);
			}
			if (chunk){
				chunk->memory = _strdup(json_object_to_json_string(jobj));
				chunk->size = strlen(chunk->memory) + 1;
			}
		}

		json_object_put(jobj);
	}
	else
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to load Layout \"%s\" from file \"%s\"!\n", cdwThreadId, strLayout, strPath);

	return bLoaded;
}

int HavePermission(struct InstanceData* id, const char* strPerm){
	int nPos = 0, bFound = FALSE;
	if (id->m_pstrPerms && id->m_nPermCount){
		for (nPos = 0; nPos < id->m_nPermCount; nPos++){
			if (!strcmp(strPerm, id->m_pstrPerms + (nPos * PERM_SZ))){
				bFound = TRUE;
				break;
			}
		}
	}
	return bFound;
}

void ProcessCustomMapPermission(struct InstanceData* id, const char* val)
{
	char *ctx = NULL;
	char *tok = NULL;
	char PERM[25] = { 0 };
	char ARPT[ARPTNAME_SZ] = { 0 };
	char TYPE[3] = { 0 };
	int  start = 0, count = 0, type = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();
	// Format is CUSTMAP-ARPT-TYPE-START#-COUNT#
	D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Custom Map Permission (%s)\n", cdwThreadId, val));
	strcpy_s(PERM, 25, val);
	tok = StrTok(&ctx, PERM, '-');
	if (tok && !strcmp(tok, "CUSTMAP")){
		// Skip CUSTMAP text
		tok = StrTok(&ctx, NULL, '-');
		if (tok && strlen(tok)){
			// Load ARPT identifier
			strcpy_s(ARPT, ARPTNAME_SZ, tok);
			StrUpper(ARPT);
			tok = StrTok(&ctx, NULL, '-');
			if (tok && strlen(tok)){
				strcpy_s(TYPE, 3, tok);
				StrUpper(TYPE);
				if (!strcmp(TYPE, "LS")) // Check for Line Strip
					type = GL_LINE_STRIP;
				else
					type = GL_POLYGON;
				tok = StrTok(&ctx, NULL, '-');
				if (tok && strlen(tok)){
					// Get end Identifier
					start = atoi(tok);
					tok = StrTok(&ctx, NULL, '-');
					if (tok && strlen(tok)){
						// Get end Identifier
						count = atoi(tok);
						AddCustomMap(id, ARPT, start, count, type);
					}else{
						vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error parsing Count value on CUSTMAP permission.\n", cdwThreadId);
					}
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error parsing Start Value on CUSTMAP permission.\n", cdwThreadId);
				}
			}else{
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error parsing Type Value on CUSTMAP permission.\n", cdwThreadId);
			}
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error parsing Airport on CUSTMAP permission.\n", cdwThreadId);
		}
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error parsing CUSTMAP permission.\n", cdwThreadId);
	}
}

void ProcessPermissions(struct InstanceData* id, struct json_object* jobj)
{
	int nPos = 0, nLen = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();
	// Clear previous values
	if (id->m_pstrPerms && id->m_nPermCount){
		free(id->m_pstrPerms);
		id->m_pstrPerms = NULL;
		id->m_nPermCount = 0;
	}

	if (jobj && json_type_array == json_object_get_type(jobj)){
		nLen = json_object_array_length(jobj);
		if (!id->m_pstrPerms){
			id->m_pstrPerms = (char*)calloc(nLen, PERM_SZ * sizeof(char));
			id->m_nPermCount = nLen;
		}
		for (nPos = 0; nPos < nLen; nPos++){
			struct json_object_iter jiter;
			struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
			json_object_object_foreachC(jelem, jiter){
				if (!strcmp(jiter.key, "_class")){
					// We only care about Permission Objects
					if (strcmp("Perm", json_object_get_string(jiter.val)))
						break;
				}
				if (!strcmp("status", jiter.key)){
					const char* val = json_object_get_string(jiter.val);
					if (!strcmp("Class1", val)){
						id->m_bClass1 = TRUE;
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Class1 Status (%s)\n", cdwThreadId, (id->m_bClass1 ? "TRUE" : "FALSE")));
					}else if(!strcmp("London", val)){
						id->m_bUserHasLondon = TRUE;
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) London Status (%s)\n", cdwThreadId, (id->m_bUserHasLondon ? "TRUE" : "FALSE")));
					}else if(!strcmp("DHS", val)){
						id->m_bDHSPerm = TRUE;
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DHS Status (%s)\n", cdwThreadId, (id->m_bDHSPerm ? "TRUE" : "FALSE")));
					}else if(!strcmp("ASDEX_ALL", val)){
						id->m_bAsdexAll = TRUE;
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX_ALL Status (%s)\n", cdwThreadId, (id->m_bAsdexAll ? "TRUE" : "FALSE")));
					}else if(!strcmp("ADSB_ALL", val)){
						id->m_bAdsbAll = TRUE;
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ADSB_ALL Status (%s)\n", cdwThreadId, (id->m_bAdsbAll ? "TRUE" : "FALSE")));
					}else if(!strcmp("MLAT_ALL", val)){
						id->m_bMLATAll = TRUE;
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) MLAT_ALL Status (%s)\n", cdwThreadId, (id->m_bMLATAll ? "TRUE" : "FALSE")));
					}else if(!strcmp("AIRASIA", val)){
						id->m_bAirAsia = TRUE;
						D_CONTROL("PERM",vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) AIRASIA Status (%s)\n", cdwThreadId, (id->m_bAirAsia ? "TRUE" : "FALSE")));
					}else if( !strncmp("CUSTMAP-", val, 5) ){
						ProcessCustomMapPermission(id, val);
					} else if (!strncmp("WT_GID=", val, 7)) {
						const char* sgid = val + 7;
						id->m_nGroupID = atoi(sgid);
					} else {
						D_CONTROL("PERM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) PERMISSION (%s)\n", cdwThreadId, val));
					}
					// Copy Permissions into allocated array
					strncpy_s(id->m_pstrPerms + (nPos * PERM_SZ), PERM_SZ, val, _TRUNCATE);
				}
			}
		}
	}
}

void LoadUserData(struct InstanceData* id){
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	char tmpstr[8192];
	struct MemoryStruct chunk;
	int nRetry = 0, nLen = 0, nPos = 0;
	int bSucceeded = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();

	_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "Action=LoadSurfUserData&username=%s", id->m_strUserName);

	// Try to load data from db 3 times
	do{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		clear_chunk_memory(&chunk);
		if (!GetCurlFormPostResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load filters for user \'%s\', attempt <%d>.\n",
				cdwThreadId, id->m_strUserName, nRetry);
			GetNxtSurfSrvr(id);
		}else{
			// Check for valid data from server
			if (chunk.memory){
				if (!strstr(chunk.memory, "404 Not Found")){
					char* data = curl_unescape(chunk.memory, strlen(chunk.memory));
					jobj = json_tokener_parse_verbose(data, &jerror);

					if (json_tokener_success == jerror && jobj && json_type_array == json_object_get_type(jobj)){
						bSucceeded = TRUE;
						nLen = json_object_array_length(jobj);
						for (nPos = 0; nPos < nLen; nPos++){
							struct json_object_iter jiter;
							struct json_object* jelem = json_object_array_get_idx(jobj, nPos);
							json_object_object_foreachC(jelem, jiter){
								if (!strcmp(jiter.key, "_class")){
									const char* val = json_object_get_string(jiter.val);
									// Load Permissions
									if (!strcmp(val, "permissions")){
										json_object_object_foreachC_next(jelem, jiter);
										ProcessPermissions(id, jiter.val);
										CachePerms(id, jiter.val);
									}else if(!strcmp(val, "filters")){
										json_object_object_foreachC_next(jelem, jiter);
										LoadUserFilters(id, jiter.val, TRUE);
									}else if(!strcmp(val, "layouts")){
										json_object_object_foreachC_next(jelem, jiter);
										LoadUserLayout2(id, jiter.val);
									}else if(!strcmp(val, "tagfilters")){
										json_object_object_foreachC_next(jelem, jiter);
										LoadUserTagFilters(id, jiter.val, TRUE);
									}else if(!strcmp(val, "Error")){
										// Handle Error for each possible failure, Load data from a file
										// This handles when errors occur for part of data returned.
										json_object_object_foreachC_next(jelem, jiter);
										if (!strcmp("description", jiter.key)){
											val = json_object_get_string(jiter.val);
											if (strstr(val, "permissions")){
												LoadCachedPermissions(id);
											}else if(strstr(val, "filters")){
												LoadCachedUserFilters(id);
											}else if(strstr(val, "layouts")){
												LoadCachedLayouts(id);
												LoadCachedLayout(id, NULL, NULL);
											}
										}else{
											vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unknown/unrecognized JSON error object \'%s\'.\n",
												cdwThreadId, jiter.key);
										}
									}else{
										vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unknown/unsuppored JSON object \'%s\'.\n",
											cdwThreadId, val);
									}
								}
							}
						}
						json_object_put(jobj);
					}
					curl_free(data);
					free_chunk_memory(&chunk);
				}else{
					vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load user %s filters, attempt <%d>.\n", cdwThreadId, id->m_strUserName, nRetry);
				}
			}else{
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load user %s filters, attempt <%d>.\n", cdwThreadId, id->m_strUserName, nRetry);
			}
		}
	} while (!bSucceeded && (++nRetry < 3));

	if (!bSucceeded){
		//Load all from cached files
		LoadCachedPermissions(id);
		LoadCachedUserFilters(id);
		LoadCachedLayouts(id);
		LoadCachedLayout(id, NULL, NULL);
	}
}

// NAME: EnableFilters - SendMessage callback, for "EnableFilters" 
// PURPOSE: Should change activex use of filters 
// INPUT: p - filters, and On/Off
// OUTPUT: N/A
// EXAMPLE(s): "filter=\"test1,On\"&filter=..."
//			   "filter=\"test 2,Off\"&filter=..."
int EnableFilters(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	char username[USERNAME_SZ] = { 0 };
	char *data = NULL;
	char name[FILTER_NAME_SIZE] = { 0 };
	char tmp[FILTER_NAME_SIZE] = { 0 };
	char* p1 = NULL, *p2 = NULL;
	int nPos = 0, bActive = FALSE;
	int bReturn = TRUE;
	FILTERS* pFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (0 == id->m_nFilterCount){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list empty!\n", cdwThreadId);
		return (FALSE);
	}

	if (!id->m_pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list empty!\n", cdwThreadId);
		return (FALSE);
	}
	pFilters = (FILTERS*)id->m_pFilters;

	if (!GetJavascriptValue(id, "username", username, USERNAME_SZ)){
		strcpy_s(username, USERNAME_SZ, "unknown");
	}

	data = curl_unescape(p, strlen(p));

	p1 = strstr(data, "filter=\"");
	while (p1){
		p1 += 8;
		p2 = strchr(p1, ',');
		strncpy_s(tmp, FILTER_NAME_SIZE, p1, p2 - p1);
		if (!stripOuterWhitespace(name, tmp, FILTER_NAME_SIZE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filtername truncated to \"%s\", database manipulation will not succeed!\n",
				cdwThreadId, name);
			bReturn = FALSE;
		}

		p1 = p2 + 1;
		p2 = strchr(p1, '\"');

		if (!strncmp(p1, "On", 2) || !strncmp(p1, "true", 4)){
			bActive = TRUE;
			id->m_nActiveFilters++;
		}else{
			bActive = FALSE;
			id->m_nActiveFilters--;
		}

		for (nPos = 0; nPos < id->m_nFilterCount; nPos++){
			if (!strcmp(pFilters[nPos].filtername, name)){
				pFilters[nPos].IsActive = bActive;
			}
		}
		p1 = strstr(p2, "filter=\"");
	}
	curl_free(data);

	// Determine if ShowAllAircraft is on
	id->m_sCurLayout.m_bShowAllAircraft = TRUE;
	for (nPos = 0; nPos < id->m_nFilterCount; nPos++){
		if (pFilters[nPos].IsActive && pFilters[nPos].IsIncludeFilter){
			id->m_sCurLayout.m_bShowAllAircraft = FALSE;
			break;
		}
	}
	return (bReturn);
}

// NAME: EnableTagFilters - SendMessage callback, for "EnableTagFilters" 
// PURPOSE: Should change activex use of tag filters 
// INPUT: p - filter name and isactive (true/false)
// OUTPUT: N/A
// EXAMPLE(s): ""
int EnableTagFilters(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jfield = NULL;
	char username[USERNAME_SZ] = { 0 };
	char *data = NULL;
	char name[FILTER_NAME_SIZE] = { 0 };
	char tmp[FILTER_NAME_SIZE] = { 0 };
	char strFilter[FILTER_NAME_SIZE] = { 0 };
	char* p1 = NULL, *p2 = NULL;
	int nPos = 0, bActive = FALSE;
	int bReturn = TRUE;
	FILTERS* pTagFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (0 == id->m_nTagFilterCount){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list empty!\n", cdwThreadId);
		return (FALSE);
	}

	if (!id->m_pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list empty!\n", cdwThreadId);
		return (FALSE);
	}
	pTagFilters = (FILTERS*)id->m_pTagFilters;

	if (!GetJavascriptValue(id, "username", username, USERNAME_SZ)){
		strcpy_s(username, USERNAME_SZ, "unknown");
	}

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	curl_free(data);
	if (jobj && json_tokener_success == jerror){
		jfield = json_object_object_get(jobj, "filter");
		if (jfield){
			strcpy_s(strFilter, FILTER_NAME_SIZE, json_object_get_string(jfield));
			jfield = json_object_object_get(jobj, "isactive");
			if (jfield){
				bActive = json_object_get_boolean(jfield);
				// determine whether tag filter is enabled/disabled
				if (bActive)
					id->m_nActiveTagFilters++;
				else
					id->m_nActiveTagFilters--;

				// Enable or disable actual filter
				for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++){
					if (!strcmp(pTagFilters[nPos].filtername, strFilter)){
						pTagFilters[nPos].IsActive = bActive;
					}
				}
			}
		}
	}
	json_object_put(jobj);
	return (bReturn);
}


void FillFilter(struct InstanceData* id, FILTERS* filter, char* data)
{
	char* p1 = NULL, *p2 = NULL;
	char username[USERNAME_SZ] = { 0 };
	char poststr[8192] = { 0 };
	char tmpstr[600] = { 0 };
	struct MemoryStruct chunk;
	const DWORD cdwThreadId = GetCurrentThreadId();
	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if (!GetJavascriptValue(id, "username", username, USERNAME_SZ)){
		strcpy_s(username, USERNAME_SZ, "unknown");
	}

	sprintf_s(poststr, _countof(poststr), "Action=SaveSurfFilter&username=%s&filter=%s", username, filter->filtername);

	// Set filter Owner as current user
	strcpy_s(filter->owner, FILTER_OWNER_SIZE, username);

	// Set Filter Logic
	p1 = strstr(data, "logic=\"") + 7;
	p2 = strchr(p1, ',');
	if (!strncmp(p1, "include", 7))
		filter->IsIncludeFilter = TRUE;
	else
		filter->IsIncludeFilter = FALSE;
	p1 = strchr(p1, ',') + 1;
	if (!strncmp(p1, "all", 3))
		filter->matchall = TRUE;
	else
		filter->matchall = FALSE;
	sprintf_s(tmpstr, _countof(tmpstr), "&logic=%s,%s", filter->IsIncludeFilter ? "include" : "exclude", filter->matchall ? "all" : "any");
	strcat_s(poststr, _countof(poststr), tmpstr);

	// Set Airlines
	memset(filter->airlines, 0, FILTER_AIRLINES_SIZE * sizeof(char));
	p1 = strstr(data, "airlines=\"");
	if (p1){
		p1 += strlen("airlines=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->airlines, FILTER_AIRLINES_SIZE, p1, p2 - p1);
		StrUpper(filter->airlines);
		sprintf_s(tmpstr, _countof(tmpstr), "&airlines=%s", filter->airlines);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Origins
	memset(filter->origins, 0, FILTER_ORIGINS_SIZE * sizeof(char));
	p1 = strstr(data, "origins=\"");
	if (p1){
		p1 += strlen("origins=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->origins, FILTER_ORIGINS_SIZE, p1, p2 - p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&origins=%s", filter->origins);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Destinations
	memset(filter->destinations, 0, FILTER_DESTINATIONS_SIZE * sizeof(char));
	p1 = strstr(data, "destinations=\"");
	if (p1){
		p1 += strlen("destinations=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->destinations, FILTER_DESTINATIONS_SIZE, p1, p2 - p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&destinations=%s", filter->destinations);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Departure Fixes
	memset(filter->fixes, 0, FILTER_DEPARTUREFIX_SIZE * sizeof(char));
	p1 = strstr(data, "fixes=\"");
	if (p1){
		p1 += strlen("fixes=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->fixes, FILTER_DEPARTUREFIX_SIZE, p1, p2 - p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&fixes=%s", filter->fixes);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Destination Gates
	memset(filter->gates, 0, FILTER_DESTGATE_SIZE * sizeof(char));
	p1 = strstr(data, "gates=\"");
	if (p1){
		p1 += strlen("gates=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->gates, FILTER_DESTGATE_SIZE, p1, p2 - p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&gates=%s", filter->gates);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Flight Numbers
	memset(filter->flightnumbers, 0, FILTER_FLIGHTNUMBERS_SIZE * sizeof(char));
	p1 = strstr(data, "flights=\"");
	if (p1){
		p1 += strlen("flights=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->flightnumbers, FILTER_FLIGHTNUMBERS_SIZE, p1, p2 - p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&flights=%s", filter->flightnumbers);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Aircraft Types
	memset(filter->actypes, 0, FILTER_ACTYPES_SIZE * sizeof(char));
	p1 = strstr(data, "actypes=\"");
	if (p1){
		p1 += strlen("actypes=\"");
		p2 = strchr(p1, '\"');
		strncpy_s(filter->actypes, FILTER_ACTYPES_SIZE, p1, p2 - p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&actypes=%s", filter->actypes);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Out to Off Threshold
	filter->out2off = -1;
	p1 = strstr(data, "out2off=\"");
	if (p1){
		p1 += strlen("out2off=\"");
		filter->out2off = atoi(p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&out2off=%d", filter->out2off);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set On to In Threshold
	filter->on2in = -1;
	p1 = strstr(data, "on2in=\"");
	if (p1){
		p1 += strlen("on2in=\"");
		filter->on2in = atoi(p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&on2in=%d", filter->on2in);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Delayed Threshold
	filter->delayed = -1;
	p1 = strstr(data, "delay=\"");
	if (p1){
		p1 += strlen("delay=\"");
		filter->delayed = atoi(p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&delay=%d", filter->delayed);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Stranded Threshold
	filter->stranded = -1;
	p1 = strstr(data, "stranded=\"");
	if (p1){
		p1 += strlen("stranded=\"");
		filter->stranded = atoi(p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&stranded=%d", filter->stranded);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	// Set Color Index
	filter->colorindex = -1;
	p1 = strstr(data, "color=\"");
	if (p1){
		p1 += strlen("color=\"");
		filter->colorindex = atoi(p1);
		sprintf_s(tmpstr, _countof(tmpstr), "&color=%d", filter->colorindex);
		strcat_s(poststr, _countof(poststr), tmpstr);
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> posstr <%s>.\n",
		cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr);

	if (!GetCurlFormPostResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr, SM_HTTPS, TRUE)){
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to save surf filter \'%s\' for user \'%s\'.\n",
			cdwThreadId, filter->filtername, username);
		GetNxtSurfSrvr(id);
	}else{
		// Check for success or failure
		if (chunk.memory){
			if (strncmp(chunk.memory, "success", strlen("success")))
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", cdwThreadId, chunk.memory);
			free(chunk.memory);
		}
	}
}

// NAME: SaveFilter - SendMessage callback, for "SaveFilter" 
// PURPOSE: Save a named filter
// INPUT: p - filters, and On/Off
// OUTPUT: N/A
// EXAMPLE(s): 
//			   
int SaveFilter(struct InstanceData* id, char* p)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jname = NULL;
	struct json_object* jarr = NULL;
	char *data = NULL;
	const char *json_data = NULL;
	char strFilter[FILTER_NAME_SIZE] = { 0 };
	char strPath[MAX_PATH_SZ] = { 0 };
	char poststr[8192] = { 0 };
	int nPos = 0, bUpdate = FALSE;
	int bReturn = FALSE;
	FILTERS* pFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!id->m_pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list not allocated!\n", cdwThreadId);
		return (bReturn);
	}
	pFilters = (FILTERS*)id->m_pFilters;

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	curl_free(data);
	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "filter");
		strcpy_s(strFilter, FILTER_NAME_SIZE, json_object_get_string(jname));

		// Determin if we have a new or updated filter
		for (nPos = 0; nPos < id->m_nFilterCount; nPos++){
			if (!strcmp(pFilters[nPos].filtername, strFilter)){
				bUpdate = TRUE;
				break;
			}
		}
		if (bUpdate)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating Filter <%s>\n", cdwThreadId, strFilter);
		else
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Creating New Filter <%s>\n", cdwThreadId, strFilter);

		// Add to data structure
		ProcessFilter(id, jobj, bUpdate);

		// Add to cached file
		sprintf_s(strPath, MAX_PATH_SZ, "%s\\-filters-.json", id->m_strCachedDir);
		jarr = json_object_from_file(strPath);
		if (jarr && -1 != ((int)jarr)){
			if (bUpdate){
				int nIdx = 0;
				struct json_object* jelem = NULL;
				struct json_object* jarr2 = json_object_new_array();
				// Increment Ref count for jobj, since we are also putting it into arr2 which will be released.
				json_object_get(jobj);
				while (jelem = json_object_array_get_idx(jarr, nIdx++)){
					jname = json_object_object_get(jelem, "filter");
					if (strcmp(strFilter, json_object_get_string(jname))){
						// Add other elements to new array
						json_object_array_add(jarr2, jelem);
					}else{
						// Add Update
						json_object_array_add(jarr2, jobj);
					}
				}
				if (json_object_to_file(strPath, jarr2)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save filters json file \"%s\"!\n", cdwThreadId, strPath);
				}
				json_object_put(jarr2);
			}else{
				json_object_array_add(jarr, jobj);
				if (json_object_to_file(strPath, jarr)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save filters json file \"%s\"!\n", cdwThreadId, strPath);
				}
			}

			json_data = json_object_to_json_string(jobj);
			data = curl_escape(json_data, strlen(json_data));
			json_object_put(jobj);
			json_object_put(jarr);
		}

		// Save to DB, using background request
		sprintf_s(poststr, _countof(poststr), "Action=SaveSurfFilter2&username=%s&filter=%s", id->m_strUserName, data);
		Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr);
		curl_free(data);

	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to add filter, JSON parse error(%d)!\n", cdwThreadId, jerror);
	}

	if (IS_D_CONTROL("FILTERS")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter Count <%d>\n", cdwThreadId, id->m_nFilterCount);
		for (nPos = 0; nPos < id->m_nFilterCount; nPos++)
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FILTER[%d] = <%s>\n", cdwThreadId, nPos, pFilters[nPos].filtername);
		}
		for (nPos = 0; nPos < id->m_nFilterCount && id->m_pActiveFilterPriorityIndices[nPos] != -1; nPos++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ACTIVE FILTER PRIORITY[%d]=<%d>,<%s>\n",
				cdwThreadId, nPos, id->m_pActiveFilterPriorityIndices[nPos], pFilters[id->m_pActiveFilterPriorityIndices[nPos]].filtername);
		}
	}

	return bReturn;
}

// NAME: SaveTagFilter - SendMessage callback, for "SaveTagFilter" 
// PURPOSE: Save a named Tag filter
// INPUT: p - filters, and On/Off
// OUTPUT: N/A
// EXAMPLE(s): 
//			   
int SaveTagFilter(struct InstanceData* id, char* p)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jname = NULL;
	struct json_object* jarr = NULL;
	char *data = NULL;
	const char *json_data = NULL;
	char strFilter[FILTER_NAME_SIZE] = { 0 };
	char strPath[MAX_PATH_SZ] = { 0 };
	char poststr[8192] = { 0 };
	int nPos = 0, bUpdate = FALSE;
	int bReturn = FALSE;
	FILTERS* pTagFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!id->m_pTagFilters){
		id->m_pTagFilters = calloc(id->m_nMaxTagFilters, sizeof(FILTERS));
		if (!id->m_pTagFilters){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter unable to be allocated!\n", cdwThreadId);
			return (bReturn);
		}
	}
	pTagFilters = (FILTERS*)id->m_pTagFilters;

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	curl_free(data);
	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "filter");
		strcpy_s(strFilter, FILTER_NAME_SIZE, json_object_get_string(jname));

		// Determin if we have a new or updated filter
		for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++){
			if (!strcmp(pTagFilters[nPos].filtername, strFilter)){
				bUpdate = TRUE;
				break;
			}
		}
		if (bUpdate)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating Tag Filter <%s>\n", cdwThreadId, strFilter);
		else
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Creating New Tag Filter <%s>\n", cdwThreadId, strFilter);

		// Add to data structure
		ProcessTagFilter(id, jobj, bUpdate);

		// Add to cached file
		sprintf_s(strPath, MAX_PATH_SZ, "%s\\-tagfilters-.json", id->m_strCachedDir);
		jarr = json_object_from_file(strPath);
		if (jarr && -1 != ((int)jarr)){
			if (bUpdate){
				int nIdx = 0;
				struct json_object* jelem = NULL;
				struct json_object* jarr2 = json_object_new_array();
				// Increment Ref count for jobj, since we are also putting it into arr2 which will be released.
				json_object_get(jobj);
				while (jelem = json_object_array_get_idx(jarr, nIdx++)){
					jname = json_object_object_get(jelem, "filter");
					if (strcmp(strFilter, json_object_get_string(jname))){
						// Add other elements to new array
						json_object_array_add(jarr2, jelem);
					}else{
						// Add Update
						json_object_array_add(jarr2, jobj);
					}
				}
				if (json_object_to_file(strPath, jarr2)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save tag filters json file \"%s\"!\n", cdwThreadId, strPath);
				}
				json_object_put(jarr2);
			}else{
				json_object_array_add(jarr, jobj);
				if (json_object_to_file(strPath, jarr)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save tag filters json file \"%s\"!\n", cdwThreadId, strPath);
				}
			}

			json_data = json_object_to_json_string(jobj);
			data = curl_escape(json_data, strlen(json_data));
			json_object_put(jobj);
			json_object_put(jarr);
		}else{
			// File not created (no filters yet), creating one for newly added filter
			jarr = json_object_new_array();
			json_object_array_add(jarr, jobj);
			if (json_object_to_file(strPath, jarr)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save tag filters json file \"%s\"!\n", cdwThreadId, strPath);
			}
			json_data = json_object_to_json_string(jobj);
			data = curl_escape(json_data, strlen(json_data));
			json_object_put(jobj);
			json_object_put(jarr);
		}

		// Save to DB, using background request
		sprintf_s(poststr, _countof(poststr), "Action=SaveSurfTagFilter&username=%s&filter=%s", id->m_strUserName, data);
		Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr);
		curl_free(data);

	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to add tag filter, JSON parse error(%d)!\n", cdwThreadId, jerror);
	}

	if (IS_D_CONTROL("TAGFILTERS")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter Count <%d>\n", cdwThreadId, id->m_nTagFilterCount);
		for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++)
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FILTER[%d] = <%s>\n", cdwThreadId, nPos, pTagFilters[nPos].filtername);
		}
	}

	return bReturn;
}


// NAME: DeleteFilter - SendMessage callback, for "DeleteFilter" 
// PURPOSE: Delete a named filter
// INPUT: p - filter name
// OUTPUT: N/A
// EXAMPLE(s): 
//			   
int DeleteFilter(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jname = NULL;
	char *data = NULL;
	char strFilter[FILTER_NAME_SIZE] = { 0 };
	char strPath[MAX_PATH_SZ] = { 0 };
	char poststr[8192] = { 0 };
	int nPos = 0, nPos2 = 0;
	int bReturn = TRUE;
	FILTERS* pFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (0 == id->m_nFilterCount){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list empty!\n", cdwThreadId);
		return (bReturn);
	}

	if (!id->m_pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list not allocated!\n", cdwThreadId);
		return (bReturn);
	}

	pFilters = (FILTERS*)id->m_pFilters;

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "filter");
		strcpy_s(strFilter, FILTER_NAME_SIZE, json_object_get_string(jname));
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Deleting Filter <%s>\n", cdwThreadId, strFilter);

		// Remove filter from Internal Memory Structures
		for (nPos = 0; nPos < id->m_nFilterCount; nPos++)
		{
			if (!strcmp(pFilters[nPos].filtername, strFilter)){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Deleted Filter at Index <%d>, adjusting remaining filters\n", cdwThreadId, nPos);
				// Erase Filter
				memset(&pFilters[nPos], 0, sizeof(FILTERS));
				// Move up other filters
				for (nPos2 = nPos + 1; nPos2 < id->m_nFilterCount; nPos2++){
					memcpy(&pFilters[nPos2 - 1], &pFilters[nPos2], sizeof(FILTERS));
					memset(&pFilters[nPos2], 0, sizeof(FILTERS));
				}
				// Adjust Active Filter Indices which may now have changed
				for (nPos2 = 0; nPos2 < id->m_nFilterCount; nPos2++){
					if (id->m_pActiveFilterPriorityIndices[nPos2] > nPos)
						--id->m_pActiveFilterPriorityIndices[nPos2];
				}
				id->m_nFilterCount--;

				// Delete from DB 
				break;
			}
		}
		// Release current json objects
		json_object_put(jobj);

		// Remove from Cache, there isn't a convenient delete from array json function so we copy into
		// a new json array from the file, skipping the deleted element, then we rewrite the file from
		// new array
		sprintf_s(strPath, MAX_PATH_SZ, "%s\\-filters-.json", id->m_strCachedDir);
		jobj = json_object_from_file(strPath);
		if (jobj && -1 != ((int)jobj)){
			int nIdx = 0;
			struct json_object* jelem = NULL;
			struct json_object* jarray = json_object_new_array();
			while (jelem = json_object_array_get_idx(jobj, nIdx++)){
				jname = json_object_object_get(jelem, "filter");
				if (strcmp(strFilter, json_object_get_string(jname))){
					json_object_array_add(jarray, jelem);
				}
			}
			if (json_object_to_file(strPath, jarray)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save filters json file \"%s\"!\n", cdwThreadId, strPath);
			}

			// Remove json objects
			json_object_put(jarray);
			json_object_put(jobj);
		}

		// Remove from Database, background request
		sprintf_s(poststr, _countof(poststr), "Action=DeleteSurfFilter&username=%s&filter=%s", id->m_strUserName, strFilter);
		Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr);

		bReturn = TRUE;
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to delete filter, JSON parse error(%d)!\n", cdwThreadId, jerror);
	}
	curl_free(data);

	if (IS_D_CONTROL("FILTERS")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter Count <%d>\n", cdwThreadId, id->m_nFilterCount);
		for (nPos = 0; nPos < id->m_nFilterCount; nPos++)
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FILTER[%d] = <%s>\n", cdwThreadId, nPos, pFilters[nPos].filtername);
		}
		for (nPos = 0; nPos < id->m_nFilterCount && id->m_pActiveFilterPriorityIndices[nPos] != -1; nPos++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ACTIVE FILTER PRIORITY[%d]=<%d>,<%s>\n",
				cdwThreadId, nPos, id->m_pActiveFilterPriorityIndices[nPos], pFilters[id->m_pActiveFilterPriorityIndices[nPos]].filtername);
		}
	}

	return bReturn;
}

// NAME: DeleteTagFilter - SendMessage callback, for "DeleteTagFilter" 
// PURPOSE: Delete a named tag filter
// INPUT: p - filter name
// OUTPUT: N/A
// EXAMPLE(s): 
//			   
int DeleteTagFilter(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jname = NULL;
	char *data = NULL;
	char strFilter[FILTER_NAME_SIZE] = { 0 };
	char strPath[MAX_PATH_SZ] = { 0 };
	char poststr[8192] = { 0 };
	int nPos = 0, nPos2 = 0;
	int bReturn = TRUE;
	FILTERS* pTagFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (0 == id->m_nTagFilterCount){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list empty!\n", cdwThreadId);
		return (bReturn);
	}

	if (!id->m_pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list not allocated!\n", cdwThreadId);
		return (bReturn);
	}

	pTagFilters = (FILTERS*)id->m_pTagFilters;

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "filter");
		strcpy_s(strFilter, FILTER_NAME_SIZE, json_object_get_string(jname));
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Deleting Tag Filter <%s>\n", cdwThreadId, strFilter);

		// Remove filter from Internal Memory Structures
		for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++)
		{
			if (!strcmp(pTagFilters[nPos].filtername, strFilter)){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Deleted Tag Filter at Index <%d>, adjusting remaining filters\n", cdwThreadId, nPos);
				// Erase Filter
				memset(&pTagFilters[nPos], 0, sizeof(FILTERS));
				// Move up other filters
				for (nPos2 = nPos + 1; nPos2 < id->m_nTagFilterCount; nPos2++){
					memcpy(&pTagFilters[nPos2 - 1], &pTagFilters[nPos2], sizeof(FILTERS));
					memset(&pTagFilters[nPos2], 0, sizeof(FILTERS));
				}

				id->m_nTagFilterCount--;

				// Delete from DB 
				break;
			}
		}
		// Release current json objects
		json_object_put(jobj);

		// Remove from Cache, there isn't a convenient delete from array json function so we copy into
		// a new json array from the file, skipping the deleted element, then we rewrite the file from
		// new array
		sprintf_s(strPath, MAX_PATH_SZ, "%s\\-tagfilters-.json", id->m_strCachedDir);
		jobj = json_object_from_file(strPath);
		if (jobj && -1 != ((int)jobj)){
			int nIdx = 0;
			struct json_object* jelem = NULL;
			struct json_object* jarray = json_object_new_array();
			while (jelem = json_object_array_get_idx(jobj, nIdx++)){
				jname = json_object_object_get(jelem, "filter");
				if (strcmp(strFilter, json_object_get_string(jname))){
					json_object_array_add(jarray, jelem);
				}
			}
			if (json_object_to_file(strPath, jarray)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save tag filters json file \"%s\"!\n", cdwThreadId, strPath);
			}

			// Remove json objects
			json_object_put(jarray);
			json_object_put(jobj);
		}

		// Remove from Database, background request
		sprintf_s(poststr, _countof(poststr), "Action=DeleteSurfTagFilter&username=%s&filter=%s", id->m_strUserName, strFilter);
		Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr);

		bReturn = TRUE;
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to delete tag filter, JSON parse error(%d)!\n", cdwThreadId, jerror);
	}
	curl_free(data);

	if (IS_D_CONTROL("TAGFILTERS")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter Count <%d>\n", cdwThreadId, id->m_nTagFilterCount);
		for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++)
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FILTER[%d] = <%s>\n", cdwThreadId, nPos, pTagFilters[nPos].filtername);
		}
	}

	return bReturn;
}

// NAME: GetAirlineName - GetData callback, for "AirlineCodeLookup" 
// PURPOSE: Return the airline name for the given icao or itata code
// INPUT: p - comma seperated list of airline codes
// OUTPUT: m, text string, 
// EXAMPLE: 
#define UNKN_CODE_TYPE 0
#define IATA_CODE_TYPE 1
#define ICAO_CODE_TYPE 2

void GetAirlineName(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	int i = 0;
	int len = 0;
	int found = 0;
	int codeType = UNKN_CODE_TYPE;
	char * context = NULL;
	char * data = NULL;
	char * cp = NULL;
	char * iata = NULL;
	char * icao = NULL;
	char * name = NULL;
	VO * voCodes = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();
	char code[40];
	char temp[128];
	char rsp[2048];

	EnterCriticalSection(&id->m_csAirlineCodesVO);
	D_CONTROL("AIRLINE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Started.\n", cdwThreadId));

	memset(code, 0, sizeof(code));
	memset(rsp, 0, sizeof(rsp));

	// Are we looking for iata(2) or icao(3)
	data = curl_unescape(p, strlen(p));
	strncpy_s(code, _countof(code), data, sizeof(code) - 1);
	curl_free(data);
	StrUpper(code);

	// Allow multiple lookup codes
	cp = strtok_s(code, ",", &context);
	while (cp != NULL)
	{
		len = strlen(cp);
		codeType = UNKN_CODE_TYPE;
		if (len == 2)
			codeType = IATA_CODE_TYPE;
		else if (len == 3)
			codeType = ICAO_CODE_TYPE;

		if (codeType != UNKN_CODE_TYPE)
		{
			// Get Airline Codes VO
			voCodes = id->m_pAirlineCodes;
			if (voCodes)
			{
				// Loop through Airline codes looking for a match.
				// There might be more than one.
				found = FALSE;
				for (i = 0; voCodes && i < voCodes->count; i++)
				{
					iata = VP(voCodes, i, "iata", char);
					icao = VP(voCodes, i, "icao", char);
					name = VP(voCodes, i, "name", char);

					// Check both columns since iata can have 2 or 3 char codes
					if (!strcasecmp(cp, iata) || !strcasecmp(cp, icao))
					{
						found = TRUE;
						if (strlen(rsp) > 0)
							strcat_s(rsp, _countof(rsp), "\n");

						sprintf_s(temp, sizeof(temp) - 1, "%3s - %s", cp, name);
						strcat_s(rsp, _countof(rsp), temp);
					}
				}

				// Handle unknown code
				if (!found)
				{
					if (strlen(rsp) > 0)
						strcat_s(rsp, _countof(rsp), "\n");

					sprintf_s(temp, sizeof(temp) - 1, "%3s - %s", cp, "Unknown Airline Code");
					strcat_s(rsp, _countof(rsp), temp);
				}
			}
		}
		else
		{
			if (strlen(rsp) > 0)
				strcat_s(rsp, _countof(rsp), "\n");

			sprintf_s(temp, sizeof(temp) - 1, "%3s - %s", cp, "Unknown Airline Code");
			strcat_s(rsp, _countof(rsp), temp);
		}

		cp = strtok_s(NULL, ",", &context);
	}

	// Convert to curl escaped text for return
	if (strlen(rsp) == 0)
		strncpy_s(rsp, _countof(rsp), "Unknown Airline Code", sizeof(rsp) - 1);

	data = curl_escape(rsp, strlen(rsp));
	if (data)
	{
		// Add data to memory struct
		clear_chunk_memory(m);
		m->size = strlen(data) + 1;
		m->memory = (char*)calloc(m->size, sizeof(char));
		strcat_s(m->memory, m->size, data);
		D_CONTROL("AIRLINE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) <%s>.\n", cdwThreadId, m->memory));

		// Release curl escaped data
		curl_free(data);
    }else
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to escape json string!\n", cdwThreadId);

	D_CONTROL("AIRLINE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Completed.\n", cdwThreadId));
	LeaveCriticalSection(&id->m_csAirlineCodesVO);
}

// NAME: GetRegionList - GetData callback, for "RegionList" 
// PURPOSE: Return list of Regions for current airport
// INPUT: p - UNUSED
// OUTPUT: m, formatted JSON data, 
// EXAMPLE: 
void GetRegionList(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	struct json_object* jobj = NULL;
	struct json_object* jarr = NULL;
	char* data = NULL;
	char* region = NULL;
	char* arpt = NULL;
	const char* jstr = NULL;
	VO* voROI = NULL;
	int i = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	EnterCriticalSection(&id->m_csROI);
	D_CONTROL("REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Started.\n", cdwThreadId));

	// Get Region VO
	voROI = id->m_pROIVO;
	if (voROI){
		// Create json array
		jarr = json_object_new_array();

		if (jarr){
			// Loop through all Regions and add to array
			for (i = 0; voROI && i < voROI->count; i++){
				arpt = VP(voROI, i, "arpt", char);
				// Adjust arpt code (skip first 'K' of 'KJFK')
				if (strlen(arpt) == 4 && arpt[0] == 'K') arpt++;
				// Region must match airport
				if (!strcasecmp(id->m_sCurLayout.m_strPassurArpt, arpt)){
					// Only Add new region names, hopefully duplicate names are never out of sequence
					if (!region || strcmp(region, VP(voROI, i, "Region", char))){
						region = VP(voROI, i, "Region", char);
						json_object_array_add(jarr, json_object_new_string(region));
					}
				}
			}
			// Create json parent object
			jobj = json_object_new_object();
			if (jobj){
				// Add airport to object
				json_object_object_add(jobj, "arpt", json_object_new_string(id->m_sCurLayout.m_strPassurArpt));
				// Add array to object and get json string
				json_object_object_add(jobj, "regions", jarr);
				jstr = json_object_to_json_string(jobj);

				// Convert to curl escaped text for return
				data = curl_escape(jstr, strlen(jstr));
				if (data){
					// Add data to memory struct
					clear_chunk_memory(m);
					m->size = strlen(data) + 1;
					m->memory = (char*)calloc(m->size, sizeof(char));
					strcat_s(m->memory, m->size, data);
					D_CONTROL("REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) <%s>.\n", cdwThreadId, m->memory));

					// Release curl escaped data
					curl_free(data);
				}else
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to escape json string!\n", cdwThreadId);

				// Release entire json object
				json_object_put(jobj);
			}else{
				// Release json array if object could not be created
				json_object_put(jarr);
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to create json object!\n", cdwThreadId);
			}
		}else
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to create json array!\n", cdwThreadId);

		D_CONTROL("REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Completed.\n", cdwThreadId));
	}
	LeaveCriticalSection(&id->m_csROI);
}

// NAME: GetRegionOfInterest - GetData callback, for UI "GetROI" Message
// PURPOSE: 
// INPUT: p - UNUSED
// OUTPUT: m, formatted data, 
// EXAMPLE: 
/*This is what the JSON data looks like:
{
"arpt": "JFK",
"data": [
{
"region": "TWY B",
"flightid": "DAL99",
"start": "10:11",
"end": "10:20",
"elapsed": "10:00",
"fix": "PLL",
"active": "N"
},
{
"region": "TWY B",
"flightid": "UAL77",
"start": "9:50",
"end": "9:55",
"elapsed": "6:00",
"fix": "WHITE",
"active": "N"
},
{
"region": "31R",
"flightid": "DAL99",
"start": "10:20",
"end": "10:21",
"elapsed": "1:00",
"fix": "MERIC",
"active": "Y"
}
]
}*/
void GetRegionOfInterest(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	struct json_object* jobj = NULL, *jfield = NULL;
	enum json_tokener_error jerror;
	char *data = NULL;
	char *sample = "{\"arpt\": \"JFK\",\"data\": [{\"region\": \"TWY B\",\"flightid\": \"DAL99\",\"start\": \"10:11\",\"end\": \"10:20\",\"elapsed\": \"10:00\",\"fix\":\"PLL\",\"active\": \"N\"},"
		"{\"region\": \"TWY B\",\"flightid\": \"UAL77\",\"start\": \"9:50\",\"end\": \"9:55\",\"elapsed\": \"6:00\",\"fix\":\"PLL\",\"active\": \"N\"},"
		"{\"region\": \"31R\",\"flightid\": \"DAL99\",\"start\": \"10:20\",\"end\": \"10:21\",\"elapsed\": \"1:00\",\"fix\":\"PLL\",\"active\": \"Y\"}]}";
	const char* empty = "{\"arpt\":\"\", \"replay\":0, \"data\":[]}";
	int bHistoryNeeded = 0;
	char* strData = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("GET_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Started.\n", cdwThreadId));
	// Check input message for data needed
	if (p){
		data = curl_unescape(p, strlen(p));
		D_CONTROL("GET_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ROI Window Request\n%s.\n", cdwThreadId, data));
		jobj = json_tokener_parse_verbose(data, &jerror);
		curl_free(data);

		if (jobj && json_tokener_success == jerror){
			jfield = json_object_object_get(jobj, "hist");
			if (jfield)
				bHistoryNeeded = json_object_get_int(jfield);
		}
		json_object_put(jobj);
	}

	clear_chunk_memory(m);

	//@@@ Check use of m_csROI?
	EnterCriticalSection(&id->m_csROI);

	if (id->m_pGRegions && strlen(id->m_pGRegions)){
		// Copy over data to temp string
		strData = str_falloc(id->m_pGRegions);

		// Add delete data to Incremental String
		if (TryEnterCriticalSection(&id->m_csROIHist)){
			// Add History to this if requested
			if (bHistoryNeeded){
				if (id->m_pGRegionsHistorical && strlen(id->m_pGRegionsHistorical)){
					char* lastcurly = strrchr(strData, '}');
					*lastcurly = 0;
					strData = strcat_alloc(strData, id->m_pGRegionsHistorical);
				}
			}
			if (id->m_pGRegionsDelete){
				char* lastcurly = strrchr(strData, '}');
				*lastcurly = 0;
				strData = strcat_alloc(strData, id->m_pGRegionsDelete);
			}
			LeaveCriticalSection(&id->m_csROIHist);
		}
		// data = curl_escape(sample, strlen(sample));
		data = curl_escape(strData, strlen(strData));
		D_CONTROL("GET_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X): Current Regions %s\n", cdwThreadId, strData));
		s_free(strData);
		strData = NULL;
	}else{
		data = curl_escape(empty, strlen(empty));
		D_CONTROL("GET_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X): Current Regions %s\n", cdwThreadId, empty));
	}

	// Copy escaped data into callback structure
	if (data && !m->size){
		m->size = strlen(data) + 1;
		m->memory = (char*)calloc(m->size, sizeof(char));
		strcat_s(m->memory, m->size, data);
	}
	curl_free(data);
	D_CONTROL("GET_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Completed.\n", cdwThreadId));
	LeaveCriticalSection(&id->m_csROI);
}

// NAME: GetTagFilters - GetData callback, for "TagFilters" 
// PURPOSE: Should return a list of tag filters maintained in db for user 
// INPUT: p - UNUSED
// OUTPUT: m, formatted data, names of user defined tag filters and active status
// EXAMPLE: 
void GetTagFilters(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	const int cnOffset = 15;
	char *data = NULL;
	const char *filters = NULL;
	int nPos = 0, sz = FILTER_NAME_SIZE + cnOffset, len = 0;
	FILTERS* pTagFilters = NULL;
	struct json_object* jarr = NULL, *jobj = NULL;

	if (!id->m_pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list not allocated!\n", GetCurrentThreadId());
		return;
	}
	pTagFilters = (FILTERS*)id->m_pTagFilters;

	jarr = json_object_new_array();
	//filters = calloc(sz, sizeof(char));	
	for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++){
		jobj = json_object_new_object();
		json_object_object_add(jobj, "_class", json_object_new_string("TagFilter"));
		json_object_object_add(jobj, "filter", json_object_new_string(pTagFilters[nPos].filtername));
		json_object_object_add(jobj, "owner", json_object_new_string(pTagFilters[nPos].owner));
		json_object_object_add(jobj, "isactive", json_object_new_boolean(pTagFilters[nPos].IsActive));
		json_object_array_add(jarr, jobj);
	}
	filters = json_object_to_json_string(jarr);
	len = strlen(filters);
	clear_chunk_memory(m);
	if (len){
		data = curl_escape(filters, len);
		if (!m->size){
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);
		}
		curl_free(data);
	}
	json_object_put(jarr);
}

// NAME: GetFilters - GetData callback, for "Filters" 
// PURPOSE: Should return a list of filters maintained in db for user 
// INPUT: p - UNUSED
// OUTPUT: m, formatted data, names of user defined filters and active status
// EXAMPLE: "filter=\"test1,On\"&filter=\"test 2,Off\""
void GetFilters(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	const int cnOffset = 15;
	char *data = NULL;
	const char *filters = NULL;
	int nPos = 0, sz = FILTER_NAME_SIZE + cnOffset, len = 0;
	FILTERS* pFilters = NULL;
	struct json_object* jarr = NULL, *jobj = NULL;

	if (!id->m_pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list not allocated!\n", GetCurrentThreadId());
		return;
	}
	pFilters = (FILTERS*)id->m_pFilters;

	jarr = json_object_new_array();
	//filters = calloc(sz, sizeof(char));	
	for (nPos = 0; nPos < id->m_nFilterCount; nPos++){
		jobj = json_object_new_object();
		json_object_object_add(jobj, "_class", json_object_new_string("Filter"));
		json_object_object_add(jobj, "filter", json_object_new_string(pFilters[nPos].filtername));
		json_object_object_add(jobj, "owner", json_object_new_string(pFilters[nPos].owner));
		json_object_object_add(jobj, "isactive", json_object_new_boolean(pFilters[nPos].IsActive));
		json_object_array_add(jarr, jobj);
	}
	filters = json_object_to_json_string(jarr);
	len = strlen(filters);
	clear_chunk_memory(m);
	if (len){
		data = curl_escape(filters, len);
		if (!m->size){
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);
		}
		curl_free(data);
	}
	json_object_put(jarr);
}

// NAME: GetFilterData - GetData callback, for "Filter" 
// PURPOSE: Should return a list of filter properties maintained in db for user 
// INPUT: p - filter name, "filter=\"my filter,On\""
// OUTPUT: m, formatted data, specific filter properties
// EXAMPLE: 
void GetFilterData(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	struct json_object* jobj = NULL, *jname = NULL;
	enum json_tokener_error jerror;
	const char* cstrFilter = NULL;
	const char *cFilterData = NULL;
	char *data = NULL;
	int nPos = 0;
	FILTERS* pFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(m);

	if (!id->m_pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list not allocated!\n", cdwThreadId);
		return;
	}
	pFilters = (FILTERS*)id->m_pFilters;

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	curl_free(data);

	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "filter");
		cstrFilter = json_object_get_string(jname);
		for (nPos = 0; nPos < id->m_nFilterCount; nPos++){
			// Find Filter in Structure
			if (!strcmp(cstrFilter, pFilters[nPos].filtername)){
				// Augment existing json object
				json_object_object_add(jobj, "airlines", json_object_new_string(pFilters[nPos].airlines));
				json_object_object_add(jobj, "origins", json_object_new_string(pFilters[nPos].origins));
				json_object_object_add(jobj, "destinations", json_object_new_string(pFilters[nPos].destinations));
				json_object_object_add(jobj, "actypes", json_object_new_string(pFilters[nPos].actypes));
				json_object_object_add(jobj, "gates", json_object_new_string(pFilters[nPos].gates));
				json_object_object_add(jobj, "flights", json_object_new_string(pFilters[nPos].flightnumbers));
				json_object_object_add(jobj, "fixes", json_object_new_string(pFilters[nPos].fixes));
				json_object_object_add(jobj, "out2off", json_object_new_int(pFilters[nPos].out2off));
				json_object_object_add(jobj, "on2in", json_object_new_int(pFilters[nPos].on2in));
				json_object_object_add(jobj, "delayed", json_object_new_int(pFilters[nPos].delayed));
				json_object_object_add(jobj, "stranded", json_object_new_int(pFilters[nPos].stranded));
				json_object_object_add(jobj, "color", json_object_new_int(pFilters[nPos].colorindex));

				json_object_object_add(jobj, "isinclude", json_object_new_int(pFilters[nPos].IsIncludeFilter));
				json_object_object_add(jobj, "ismatchall", json_object_new_int(pFilters[nPos].matchall));

				break;
			}
		}

		cFilterData = json_object_to_json_string(jobj);
		data = curl_escape(cFilterData, strlen(cFilterData));
		m->memory = _strdup(data);
		m->size = strlen(data) + 1;
		curl_free(data);
		json_object_put(jobj);
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to get filter data, json parse failed (%d)!\n", cdwThreadId, jerror);
	}
}

// NAME: GetTagFilterData - GetData callback, for "TagFilter" 
// PURPOSE: Should return a list of tag filter properties maintained in db for user 
// INPUT: p - filter name, "filter=\"my filter,On\""
// OUTPUT: m, formatted data, specific filter properties
// EXAMPLE: 
void GetTagFilterData(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	struct json_object* jobj = NULL, *jname = NULL;
	enum json_tokener_error jerror;
	const char* cstrFilter = NULL;
	const char *cFilterData = NULL;
	char *data = NULL;
	int nPos = 0;
	FILTERS* pTagFilters = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(m);

	if (!id->m_pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list not allocated!\n", cdwThreadId);
		return;
	}
	pTagFilters = (FILTERS*)id->m_pTagFilters;

	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	curl_free(data);

	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "filter");
		cstrFilter = json_object_get_string(jname);
		for (nPos = 0; nPos < id->m_nTagFilterCount; nPos++){
			// Find Filter in Structure
			if (!strcmp(cstrFilter, pTagFilters[nPos].filtername)){
				// Augment existing json object
				json_object_object_add(jobj, "airlines", json_object_new_string(pTagFilters[nPos].airlines));
				json_object_object_add(jobj, "origins", json_object_new_string(pTagFilters[nPos].origins));
				json_object_object_add(jobj, "destinations", json_object_new_string(pTagFilters[nPos].destinations));
				json_object_object_add(jobj, "actypes", json_object_new_string(pTagFilters[nPos].actypes));
				json_object_object_add(jobj, "gates", json_object_new_string(pTagFilters[nPos].gates));
				json_object_object_add(jobj, "flights", json_object_new_string(pTagFilters[nPos].flightnumbers));
				json_object_object_add(jobj, "fixes", json_object_new_string(pTagFilters[nPos].fixes));
				json_object_object_add(jobj, "out2off", json_object_new_int(pTagFilters[nPos].out2off));
				json_object_object_add(jobj, "on2in", json_object_new_int(pTagFilters[nPos].on2in));
				json_object_object_add(jobj, "delayed", json_object_new_int(pTagFilters[nPos].delayed));
				json_object_object_add(jobj, "stranded", json_object_new_int(pTagFilters[nPos].stranded));
				json_object_object_add(jobj, "color", json_object_new_int(pTagFilters[nPos].colorindex));

				json_object_object_add(jobj, "isinclude", json_object_new_int(pTagFilters[nPos].IsIncludeFilter));
				json_object_object_add(jobj, "ismatchall", json_object_new_int(pTagFilters[nPos].matchall));

				break;
			}
		}

		cFilterData = json_object_to_json_string(jobj);
		data = curl_escape(cFilterData, strlen(cFilterData));
		m->memory = _strdup(data);
		m->size = strlen(data) + 1;
		curl_free(data);
		json_object_put(jobj);
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to get tag filter data, json parse failed (%d)!\n", cdwThreadId, jerror);
	}
}


// NAME: GetMaxTagFilters - GetData callback, for "MaxTagFilters" 
// PURPOSE: Should return the number of tag filters the applet can manage 
// INPUT: p - UNUSED
// OUTPUT: m, value in MAX_FILTERS
void GetMaxTagFilters(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char szBuffer[100] = { 0 };
	int nLen = 0;
	char* pszEscaped = NULL;
	sprintf_s(szBuffer, _countof(szBuffer), "MAX_FILTERS=\"%d\"", id->m_nMaxTagFilters);
	pszEscaped = curl_escape(szBuffer, strlen(szBuffer));
	nLen = strlen(pszEscaped);
	memset(m, 0, sizeof(struct MemoryStruct));
	if (nLen)
	{
		if (!m->size){
			m->size = nLen + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcpy_s(m->memory, m->size, pszEscaped);
		}
	}
	curl_free(pszEscaped);
}

// NAME: GetMaxFilters - GetData callback, for "MaxFilters" 
// PURPOSE: Should return the number of filters the applet can manage 
// INPUT: p - UNUSED
// OUTPUT: m, value in MAX_FILTERS
void GetMaxFilters(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char szBuffer[100] = { 0 };
	int nLen = 0;
	char* pszEscaped = NULL;
	sprintf_s(szBuffer, _countof(szBuffer), "MAX_FILTERS=\"%d\"", id->m_nMaxFilters);
	pszEscaped = curl_escape(szBuffer, strlen(szBuffer));
	nLen = strlen(pszEscaped);
	memset(m, 0, sizeof(struct MemoryStruct));
	if (nLen)
	{
		if (!m->size){
			m->size = nLen + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcpy_s(m->memory, m->size, pszEscaped);
		}
	}
	curl_free(pszEscaped);
}

// NAME: GetUser - GetData callback, for "User" 
// PURPOSE: Should return the username (defaulted if the page was loaded using debug)
// INPUT: p - UNUSED
// OUTPUT: m, username
void GetUser(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char szBuffer[100] = { 0 };
	char username[USERNAME_SZ] = { 0 };
	char* pszEscaped = NULL;
	int nLen = 0;
	if (!GetJavascriptValue(id, "username", username, USERNAME_SZ)){
		strcpy_s(username, USERNAME_SZ, "unknown");
	}
	sprintf_s(szBuffer, _countof(szBuffer), "username=\"%s\"", username);
	pszEscaped = curl_escape(szBuffer, strlen(szBuffer));
	nLen = strlen(pszEscaped);
	memset(m, 0, sizeof(struct MemoryStruct));
	if (nLen)
	{
		if (!m->size){
			m->size = nLen + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcpy_s(m->memory, m->size, pszEscaped);
		}
	}
	curl_free(pszEscaped);
}

int SetSelected(struct InstanceData* id, char* p)
{
	AIR **airp = NULL;
	AIR *air = NULL;
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jflight_id = NULL, *jtmpflight_id = NULL,
		*jvehicle = NULL, *jicao24 = NULL, *jbeacon = NULL;
	int vehicle = FALSE, icao24 = 0, beacon = 0;
	char fltnum[FLTNUM_SIZE + 1] = { 0 };
	char tmpfltnum[FLTNUM_SIZE + 1] = {0};
	char* data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);

	if (jobj && json_tokener_success == jerror)
	{
		jflight_id = json_object_object_get(jobj, "flight_id");
		if (jflight_id && json_type_string == json_object_get_type(jflight_id))
			strcpy_s(fltnum, FLTNUM_SIZE + 1, json_object_get_string(jflight_id));
		jtmpflight_id = json_object_object_get(jobj, "tmp_flight_id");
		if(jtmpflight_id && json_type_string == json_object_get_type(jtmpflight_id))
			strcpy_s(tmpfltnum, FLTNUM_SIZE + 1, json_object_get_string(jtmpflight_id));
		jvehicle = json_object_object_get(jobj, "vehicle");
		if (jvehicle && json_type_boolean == json_object_get_type(jvehicle))
			vehicle = json_object_get_boolean(jvehicle);
		jicao24 = json_object_object_get(jobj, "icao24");
		if (jicao24 && json_type_int == json_object_get_type(jicao24))
			icao24 = json_object_get_int(jicao24);
		jbeacon = json_object_object_get(jobj, "beacon");
		if (jbeacon && json_type_int == json_object_get_type(jbeacon))
			beacon = json_object_get_int(jbeacon);

		airp = id->m_pSelectedAirP;
		if (airp)
		{
			air = airp[id->m_nSelectedAirIndex];
			if (air)
			{
				if(air->vehicle)
				strcpy_s(air->FltNum, FLTNUM_SIZE + 1, fltnum);
				strcpy_s(air->TmpFltNum, FLTNUM_SIZE+1, tmpfltnum);

				// If it has an icao24, save to Vehicles list
				if (0 != icao24)
				{
					AddUserDefinedVehicle(id, icao24, air->FltNum, air->trackid, jobj);
				}
				else if (air->vehicle)
					// Manually Create Vehicle Data Object
				{
					air->VInfoPtr = (VINFO*)calloc(1, sizeof(VINFO));
					strcpy_s(air->VInfoPtr->Id, FLTNUM_SIZE + 1, fltnum);
				}
			}
		}
		json_object_put(jobj);
	}


	curl_free(data);
	return (TRUE);
}

int SetSelectedDetails(struct InstanceData* id, char* p)
{
	AIR **airp = NULL;
	AIR *air = NULL;
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jfield = NULL;
	int track_id = 0, icao24 = 0, beacon = 0, stime = 0, etime = 0, gid = 0, del = 0, priv = 0;
	char fltnum[FLTNUM_SIZE + 1] = {0};
	const char *freeform = 0;
	char uuid[UUID_SIZE] = { 0 };
	char* data = curl_unescape(p, strlen(p));
	const DWORD cdwThreadId = GetCurrentThreadId();

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) <%s>\n", cdwThreadId, data);
	jobj = json_tokener_parse_verbose(data, &jerror);

	if(jobj && json_tokener_success == jerror)
	{
		// These elements stay in share data string, they are share specific
		jfield = json_object_object_get(jobj, "flight_id");
		if (jfield && json_type_string == json_object_get_type(jfield))
			strcpy_s(fltnum, FLTNUM_SIZE + 1, json_object_get_string(jfield));
		jfield = json_object_object_get(jobj, "icao24");
		if (jfield && json_type_int == json_object_get_type(jfield))
			icao24 = json_object_get_int(jfield);
		jfield = json_object_object_get(jobj, "beacon");
		if (jfield && json_type_int == json_object_get_type(jfield))
			beacon = json_object_get_int(jfield);
		jfield = json_object_object_get(jobj, "track_id");
		if (jfield && json_type_int == json_object_get_type(jfield))
			track_id = json_object_get_int(jfield);
		jfield = json_object_object_get(jobj, "freeform");
		if (jfield && json_type_string == json_object_get_type(jfield))
			freeform = json_object_get_string(jfield);
		jfield = json_object_object_get(jobj, "private");
		if (jfield && json_type_boolean == json_object_get_type(jfield)){
			priv = json_object_get_boolean(jfield);
			if (priv)
				gid = id->m_nGroupID;
		}

		// These elements are removed from share string, they are common to all shares
		jfield = json_object_object_get(jobj, "delete");
		if (jfield && json_type_boolean == json_object_get_type(jfield)) {
			del = json_object_get_boolean(jfield);
			json_object_object_del(jobj, "delete");
		}
		jfield = json_object_object_get(jobj, "uuid");
		if (jfield && json_type_string == json_object_get_type(jfield)){
			strcpy_s(uuid, UUID_SIZE, json_object_get_string(jfield));
			json_object_object_del(jobj, "uuid");
		}
		jfield = json_object_object_get(jobj, "stime");
		if (jfield && json_type_int == json_object_get_type(jfield)){
			stime = json_object_get_int(jfield);
			json_object_object_del(jobj, "stime");
		} else
			stime = (int)time(0);
		if (del) {
			etime = (int)time(0);
		} else {
			jfield = json_object_object_get(jobj, "etime");
			if (jfield && json_type_int == json_object_get_type(jfield)) {
				etime = stime + (json_object_get_int(jfield) * 3600);
				json_object_object_del(jobj, "etime");
			} else
				etime = stime + 3600; // @@@MCT Temp etime of 1 Hr
		}
		
		if (strlen(uuid)) {
			if (del) {
				ExpireShare(id, uuid);
			} else {
				UpdateShare(id, uuid, gid, etime, json_object_to_json_string(jobj));
			}
		} else {
			CreateShare(id, gid, SDT_FREE_FORM_TEXT, stime, etime, json_object_to_json_string(jobj), uuid);
		}

		airp = id->m_pSelectedAirP;
		if(airp)
		{		
			air = airp[id->m_nSelectedAirIndex];
			SetFreeFormTextInfo(id, air, uuid, stime, etime, priv, freeform);
		}
		json_object_put(jobj);
	}

	
	curl_free(data);
	return (TRUE);
}

// NAME: GetSelectedDetails - GetData callback, for "SelectedDetails" message
// PURPOSE: Should return the detailed information about the selected aircraft/vehicle
// INPUT: p - UNUSED
// OUTPUT: m, json of data
void GetSelectedDetails(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char bufstr[64] = {0};
	char* data = NULL;
	const char* json_str = NULL;
	struct json_object* jobj = NULL;
	AIR **airp = NULL;
	AIR *air = NULL;
	int speed = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	jobj = json_object_new_object();
	json_object_object_add(jobj, "_class", json_object_new_string("SelectedDetails"));
			
	airp = id->m_pSelectedAirP;
	if(airp)
	{		
		air = airp[id->m_nSelectedAirIndex];
		if(air)
		{
			json_object_object_add(jobj, "flight_id", json_object_new_string(air->FltNum));
			json_object_object_add(jobj, "actype", json_object_new_string(air->actype));
			if(air->altitude > 0){
				sprintf_s(bufstr, _countof(bufstr), "%03d", (air->altitude / 100));
				json_object_object_add(jobj, "altitude", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "altitude", json_object_new_string(""));
			}
			json_object_object_add(jobj, "arrfix", json_object_new_string(air->ArrivalFix));
			json_object_object_add(jobj, "beacon", json_object_new_int(air->beacon));
			json_object_object_add(jobj, "depfix", json_object_new_string(air->DepartureFix));
			json_object_object_add(jobj, "dest", json_object_new_string(air->Destin));
			json_object_object_add(jobj, "divfrom", json_object_new_string(air->DivDestin));
			json_object_object_add(jobj, "eta", json_object_new_string(ShowTime(id, air->eta)));
			json_object_object_add(jobj, "etd", json_object_new_string(ShowTime(id, air->etd)));
			if(air->fob){
				sprintf_s(bufstr, _countof(bufstr), "%d", air->fob);
				json_object_object_add(jobj, "fob", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "fob", json_object_new_string(""));
			}
			json_object_object_add(jobj, "gate", json_object_new_string(air->gate));
			json_object_object_add(jobj, "group_id", json_object_new_int(id->m_nGroupID));
			if(air->heading >= 0.0f && air->heading <= 360.0f){
				sprintf_s(bufstr, _countof(bufstr), "%3.1f\xB0", air->heading);
				json_object_object_add(jobj, "heading", json_object_new_string(bufstr));
			}else if(air->PrevAngle){
				float h = PolarToCompass(air->PrevAngle);
				sprintf_s(bufstr, _countof(bufstr), "%3.1f\xB0", h);
				json_object_object_add(jobj, "heading", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "heading", json_object_new_string(""));
			}
			json_object_object_add(jobj, "icao24", json_object_new_int(air->icao24));
			if(air->CurY){
				sprintf_s(bufstr, _countof(bufstr), "%2.5f", air->CurY);
				json_object_object_add(jobj, "latitude", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "latitude", json_object_new_string(""));
			}
			if(air->CurX){
				sprintf_s(bufstr, _countof(bufstr), "%2.5f", air->CurX);
				json_object_object_add(jobj, "longitude", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "longitude", json_object_new_string(""));
			}
			if(air->DestDis){
				sprintf_s(bufstr, _countof(bufstr), "%2.1f N.M.", air->DestDis);
				json_object_object_add(jobj, "nmtd", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "nmtd", json_object_new_string(""));
			}
			json_object_object_add(jobj, "origin", json_object_new_string(air->Origin));
			json_object_object_add(jobj, "region", json_object_new_string(air->Region));
			json_object_object_add(jobj, "runway", json_object_new_string(air->runway));
			if ( (speed = CalcSpeed(id, airp, id->m_nSelectedAirIndex, -1 )) || (speed = air->speed )  ){
				sprintf_s(bufstr, _countof(bufstr), "%dkt", speed);
				json_object_object_add(jobj, "speed", json_object_new_string(bufstr));
			}else{
				json_object_object_add(jobj, "speed", json_object_new_string(""));
			}
			json_object_object_add(jobj, "tail", json_object_new_string(air->tail));
			if(air->tt){
				int hours = air->tt / 3600;
				int mins = (air->tt - (hours * 3600)) / 60;
				int secs = (air->tt - (hours * 3600) - (mins * 60));
				if ( hours > 0 ){
					_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "%02d:%02d:%02d", hours, mins, secs );
					json_object_object_add(jobj, "taxitime", json_object_new_string(bufstr));
				}else{
					_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "%02d:%02d", mins, secs );
					json_object_object_add(jobj, "taxitime", json_object_new_string(bufstr));
				}
			}else{
				json_object_object_add(jobj, "taxitime", json_object_new_string(""));
			}
			json_object_object_add(jobj, "track_id", json_object_new_int(air->trackid));
			if(air->FFTInfoPtr) {
				if( air->FFTInfoPtr->text )
					json_object_object_add(jobj, "freeform", json_object_new_string(air->FFTInfoPtr->text));
				json_object_object_add(jobj, "stime", json_object_new_int(air->FFTInfoPtr->stime));
				json_object_object_add(jobj, "etime", json_object_new_int((air->FFTInfoPtr->etime - air->FFTInfoPtr->stime)/3600));
				json_object_object_add(jobj, "private", json_object_new_boolean(air->FFTInfoPtr->priv));
				if ( air->FFTInfoPtr->uuid )
					json_object_object_add(jobj, "uuid", json_object_new_string(air->FFTInfoPtr->uuid));
			}else{
				json_object_object_add(jobj, "freeform", json_object_new_string(""));
			}
			json_object_object_add(jobj, "username", json_object_new_string(id->m_strUserName));			
		}else{
			json_object_object_add(jobj, "flight_id", json_object_new_string(""));
			json_object_object_add(jobj, "actype", json_object_new_string(""));
			json_object_object_add(jobj, "altitude", json_object_new_string(""));
			json_object_object_add(jobj, "arrfix", json_object_new_string(""));
			json_object_object_add(jobj, "beacon", json_object_new_int(0));
			json_object_object_add(jobj, "depfix", json_object_new_string(""));
			json_object_object_add(jobj, "dest", json_object_new_string(""));
			json_object_object_add(jobj, "divfrom", json_object_new_string(""));
			json_object_object_add(jobj, "eta", json_object_new_string(""));
			json_object_object_add(jobj, "etd", json_object_new_string(""));
			json_object_object_add(jobj, "fob", json_object_new_string(""));
			json_object_object_add(jobj, "gate", json_object_new_string(""));
			json_object_object_add(jobj, "heading", json_object_new_string(""));
			json_object_object_add(jobj, "icao24", json_object_new_int(0));
			json_object_object_add(jobj, "latitude", json_object_new_string(""));
			json_object_object_add(jobj, "longitude", json_object_new_string(""));
			json_object_object_add(jobj, "nmtd", json_object_new_string(""));
			json_object_object_add(jobj, "origin", json_object_new_string(""));
			json_object_object_add(jobj, "region", json_object_new_string(""));
			json_object_object_add(jobj, "runway", json_object_new_string(""));
			json_object_object_add(jobj, "speed", json_object_new_string(""));
			json_object_object_add(jobj, "tail", json_object_new_string(""));
			json_object_object_add(jobj, "taxitime", json_object_new_string(""));
			json_object_object_add(jobj, "track_id", json_object_new_int(-1));
			json_object_object_add(jobj, "freeform", json_object_new_string(""));
			json_object_object_add(jobj, "username", json_object_new_string(id->m_strUserName));
		}
	}else{
		json_object_object_add(jobj, "flight_id", json_object_new_string(""));
		json_object_object_add(jobj, "actype", json_object_new_string(""));
		json_object_object_add(jobj, "altitude", json_object_new_string(""));
		json_object_object_add(jobj, "arrfix", json_object_new_string(""));
		json_object_object_add(jobj, "beacon", json_object_new_int(0));
		json_object_object_add(jobj, "depfix", json_object_new_string(""));
		json_object_object_add(jobj, "dest", json_object_new_string(""));
		json_object_object_add(jobj, "divfrom", json_object_new_string(""));
		json_object_object_add(jobj, "eta", json_object_new_string(""));
		json_object_object_add(jobj, "etd", json_object_new_string(""));
		json_object_object_add(jobj, "fob", json_object_new_string(""));
		json_object_object_add(jobj, "gate", json_object_new_string(""));
		json_object_object_add(jobj, "heading", json_object_new_string(""));
		json_object_object_add(jobj, "icao24", json_object_new_int(0));
		json_object_object_add(jobj, "latitude", json_object_new_string(""));
		json_object_object_add(jobj, "longitude", json_object_new_string(""));
		json_object_object_add(jobj, "nmtd", json_object_new_string(""));
		json_object_object_add(jobj, "origin", json_object_new_string(""));
		json_object_object_add(jobj, "region", json_object_new_string(""));
		json_object_object_add(jobj, "runway", json_object_new_string(""));
		json_object_object_add(jobj, "speed", json_object_new_string(""));
		json_object_object_add(jobj, "tail", json_object_new_string(""));
		json_object_object_add(jobj, "taxitime", json_object_new_string(""));
		json_object_object_add(jobj, "track_id", json_object_new_int(-1));
		json_object_object_add(jobj, "freeform", json_object_new_string(""));
		json_object_object_add(jobj, "username", json_object_new_string(id->m_strUserName));
	}
	json_str = json_object_to_json_string(jobj);
	D_CONTROL("LABEL_GETSEL", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) <%s>\n", cdwThreadId, json_str));
	data = curl_escape(json_str, strlen(json_str));
	json_object_put(jobj);	

	clear_chunk_memory(m);
	m->size = strlen(data) + 1;
	m->memory = (char*)calloc(m->size, sizeof(char*));
	strcpy_s(m->memory, m->size, data);		
	curl_free(data);
}

// NAME: GetSelected - GetData callback, for "Selected" message
// PURPOSE: Should return the information about the selected aircraft/vehicle
// INPUT: p - UNUSED
// OUTPUT: m, json of data
void GetSelected(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char* data = NULL;
	const char* json_str = NULL;
	struct json_object* jobj = NULL;
	AIR **airp = NULL;
	AIR *air = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	jobj = json_object_new_object();
	json_object_object_add(jobj, "_class", json_object_new_string("Selected"));

	airp = id->m_pSelectedAirP;
	if (airp)
	{
		air = airp[id->m_nSelectedAirIndex];
		if (air)
		{
			json_object_object_add(jobj, "flight_id", json_object_new_string(air->FltNum));
			json_object_object_add(jobj, "tmp_flight_id", json_object_new_string(air->TmpFltNum));
			json_object_object_add(jobj, "beacon", json_object_new_int(air->beacon));
			json_object_object_add(jobj, "tail", json_object_new_string(air->tail));
			json_object_object_add(jobj, "icao24", json_object_new_int(air->icao24));
			json_object_object_add(jobj, "track_id", json_object_new_int(air->trackid));
			json_object_object_add(jobj, "vehicle", json_object_new_boolean(air->vehicle));
		}else{
			json_object_object_add(jobj, "flight_id", json_object_new_string(""));
			json_object_object_add(jobj, "tmp_flight_id", json_object_new_string(""));
			json_object_object_add(jobj, "beacon", json_object_new_int(0));
			json_object_object_add(jobj, "tail", json_object_new_string(""));
			json_object_object_add(jobj, "icao24", json_object_new_int(0));
			json_object_object_add(jobj, "track_id", json_object_new_int(-1));
			json_object_object_add(jobj, "vehicle", json_object_new_boolean(0));
		}
	}else{
		json_object_object_add(jobj, "flight_id", json_object_new_string(""));
		json_object_object_add(jobj, "tmp_flight_id", json_object_new_string(""));
		json_object_object_add(jobj, "beacon", json_object_new_int(0));
		json_object_object_add(jobj, "tail", json_object_new_string(""));
		json_object_object_add(jobj, "icao24", json_object_new_int(0));
		json_object_object_add(jobj, "track_id", json_object_new_int(-1));
		json_object_object_add(jobj, "vehicle", json_object_new_boolean(0));
	}
	json_str = json_object_to_json_string(jobj);
	D_CONTROL("LABEL_GETSEL", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) <%s>\n", cdwThreadId, json_str));
	data = curl_escape(json_str, strlen(json_str));
	json_object_put(jobj);

	clear_chunk_memory(m);
	m->size = strlen(data) + 1;
	m->memory = (char*)calloc(m->size, sizeof(char*));
	strcpy_s(m->memory, m->size, data);
	curl_free(data);
}

// NAME: HasFlightId - GetData callback, for "FlightId" message
// PURPOSE: Should return whether a flight id already exists
// INPUT: p - UNUSED
// OUTPUT: m, json of data
void HasFlightId(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	enum json_tokener_error jerror;
	char* data = NULL;
	const char* json_str = NULL;
	struct json_object* jobj = NULL, *jfltnum = NULL;
	const char* strFlightId = NULL;
	int exists = FALSE;
	AIR **airp = NULL;
	AIR *air = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(m);
	data = curl_unescape(p, strlen(p));
	jobj = json_tokener_parse_verbose(data, &jerror);
	curl_free(data);

	if(jobj && json_tokener_success == jerror){
		jfltnum = json_object_object_get(jobj, "flight_id");
		strFlightId = json_object_get_string(jfltnum);
		exists = FindFlightId(id, strFlightId);
		json_object_object_add(jobj, "exists", json_object_new_boolean(exists));
		json_str = json_object_to_json_string(jobj);
		data = curl_escape(json_str, strlen(json_str));
		json_object_put(jobj);
		m->size = strlen(data) + 1;
		m->memory = (char*)calloc(m->size, sizeof(char*));
		strcpy_s(m->memory, m->size, data);		
		curl_free(data);
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to extract flight_id for find flight JSON parse error(%d)!\n", cdwThreadId, jerror);
	}
}

// NAME: GetPassurAirports - GetData callback, for "Passur Airports" 
// PURPOSE: Should return a list of passur airports maintained in db 
// INPUT: p - UNUSED
// OUTPUT: m, comma separated names of passur airports
void GetPassurAirports(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	int i, len = 0;
	char *arpt = NULL;
	char fname[256];
	VO* PassurArptsVO = NULL;

	memset(m, 0, sizeof(struct MemoryStruct));

	EnterCriticalSection(&id->m_csAirportsVO);
	PassurArptsVO = (VO*)id->m_pAirportsVO;
	if (PassurArptsVO)
	{
		arpt = calloc(PassurArptsVO->count * 10, sizeof(char));
		for (i = 0; PassurArptsVO && i < PassurArptsVO->count; i++){
			strncpy_s(fname, _countof(fname), VP(PassurArptsVO, i, "icao_code", char), 255);
			StrUpper(fname);
			strcat_s(arpt, 600, fname);
			if (i < PassurArptsVO->count - 1) // don't append an extra comma in the end
				strcat_s(arpt, 600, ",");
		}
		if (arpt)
			len = strlen(arpt);
		if (len)
		{
			if (!m->size){
				m->size = strlen(arpt) + 1;
				m->memory = (char*)calloc(m->size, sizeof(char*));
				strcat_s(m->memory, m->size, arpt);
			}
		}
		free(arpt);
	}
	LeaveCriticalSection(&id->m_csAirportsVO);
}

// Adds Pair object if layout does not exist
void SaveCachedLayout(struct InstanceData* id, const char* cstrName)
{
	enum json_tokener_error jerror;
	int bFound = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();
	if(id->m_pstrLayouts && strlen(id->m_pstrLayouts)){
		struct json_object* jarr = NULL;
		jarr = json_tokener_parse_verbose(id->m_pstrLayouts, &jerror);
		if(json_tokener_success == jerror){
			if(json_type_array == json_object_get_type(jarr)){
				int i = 0;
				int l = json_object_array_length(jarr);
				for(i = 0; i < l && !bFound; i++){
					struct json_object* jelem = json_object_array_get_idx(jarr, i);
					if(json_type_object == json_object_get_type(jelem)){
						struct json_object* jfirst = json_object_object_get(jelem, "first");
						if(!strcmp(cstrName, json_object_get_string(jfirst))){
							bFound = TRUE;;
						}
					}
				}
				if(!bFound){
					struct json_object* jobj = json_object_new_object();
					json_object_object_add(jobj, "_class", json_object_new_string("pair"));
					json_object_object_add(jobj, "first", json_object_new_string(cstrName));
					json_object_object_add(jobj, "second", json_object_new_string(id->m_strUserName));
					json_object_array_add(jarr, jobj);

					free(id->m_pstrLayouts);
					id->m_pstrLayouts = _strdup(json_object_to_json_string(jarr));
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New cached layout string <%s>.\n", cdwThreadId, id->m_pstrLayouts);
				}else{
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Cached layout string not modified <%s>.\n", cdwThreadId, id->m_pstrLayouts);
				}
				json_object_put(jarr);
			}					
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to parse existing cached layouts <%s>.\n", cdwThreadId, id->m_pstrLayouts);
		}
	}
}

// NAME: DeleteLayout - SendMessage callback, for "DeleteLayout" 
// PURPOSE: Delete a layout
// INPUT: p - layout name
// OUTPUT: N/A
// EXAMPLE(s): 
//			   
int DeleteLayout(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL, *jname = NULL;
	char *data = NULL;
	char strPath[MAX_PATH_SZ] = { 0 };
	const char* strLayout = NULL;
	char poststr[8192] = { 0 };
	int bReturn = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();


	data = curl_unescape(p, strlen(p));

	jobj = json_tokener_parse_verbose(data, &jerror);

	if (jobj && json_tokener_success == jerror){
		jname = json_object_object_get(jobj, "name");
		strLayout = json_object_get_string(jname);

		if (strcmp("<default>", strLayout)){
			// Remove from Cached file list.
			sprintf_s(strPath, MAX_PATH_SZ, "%s\\%s.json", id->m_strCachedDir, strLayout);
			if (remove(strPath)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to delete cached Layout file \"%s\\%s.json\"!\n", cdwThreadId, strPath, strLayout);
			}

			// Remove from Database, background request
			sprintf_s(poststr, _countof(poststr), "Action=DeleteSurfLayout&username=%s&layout=%s", id->m_strUserName, strLayout);
			Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], poststr);

			// Remove from Cached List
			if(id->m_pstrLayouts && strlen(id->m_pstrLayouts)){
				struct json_object* jarr = NULL;
				struct json_object* jarr2 = NULL;
				jarr = json_tokener_parse_verbose(id->m_pstrLayouts, &jerror);
				if(json_tokener_success == jerror){
					if(json_type_array == json_object_get_type(jarr)){
						int i = 0;
						int l = json_object_array_length(jarr);
						jarr2 = json_object_new_array();
						for(i = 0; i < l; i++){
							struct json_object* jelem = json_object_array_get_idx(jarr, i);
							if(json_type_object == json_object_get_type(jelem)){
								struct json_object* jfirst = json_object_object_get(jelem, "first");
								if(!strcmp(strLayout, json_object_get_string(jfirst))){
									continue;
								}else{
									json_object_array_add(jarr2, jelem);
								}
							}
						}
						free(id->m_pstrLayouts);
						id->m_pstrLayouts = _strdup(json_object_to_json_string(jarr2));
						json_object_put(jarr2);
						json_object_put(jarr);
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New cached layout string <%s>.\n", cdwThreadId, id->m_pstrLayouts);
					}					
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to parse existing cached layouts <%s>.\n", cdwThreadId, id->m_pstrLayouts);
				}
			}
			
			bReturn = TRUE;
		}
		json_object_put(jobj);

	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to delete Layout, JSON parse error(%d)!\n", cdwThreadId, jerror);
	}
	curl_free(data);

	return (bReturn);
}



// NAME: SaveLayout - SendMessage callback, for "SaveLayout" 
// PURPOSE: Should save the settings of a layout 
// INPUT: p - layout name and settings
// EXAMPLE: "layout=\"<default>\"&layout=\"Layout 1\"&layout=\"Layout 2\""
int SaveLayout(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	/* TODO: Connect to DB, extract data per user */
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	char *dataIn = NULL;
	char *dataOut = NULL;
	const char* cstrName = NULL;
	char tmpstr[8192];
	char coords[200] = { 0 };
	int bReturn = TRUE;
	struct MemoryStruct chunk;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(&chunk);

	dataIn = curl_unescape(p, strlen(p));
	if (dataIn) {
		D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) dataIn <%s>.\n", cdwThreadId, dataIn));
	}

	// New JSON solution.
	jobj = json_tokener_parse_verbose(dataIn, &jerror);
	if (json_tokener_success == jerror){
		char strLayoutPath[MAX_PATH_SZ] = { 0 };
		const char* cstrDefault = "-default-";
		const char* str;
		struct json_object* jname = json_object_object_get(jobj, "name");
		struct json_object* jCoords = json_object_new_array();
		cstrName = json_object_get_string(jname);
		json_object_object_add(jobj, "angle", json_object_new_double(id->m_glfRotateAngle));
		json_object_object_add(jobj, "fi", json_object_new_int(id->m_nCustFontIdx));
		json_object_object_add(jobj, "icon", json_object_new_int(id->m_sCurLayout.m_nAircraftSize));
		json_object_array_add(jCoords, json_object_new_double(id->m_sCurLayout.m_dWorldXmin));
		json_object_array_add(jCoords, json_object_new_double(id->m_sCurLayout.m_dWorldXmax));
		json_object_array_add(jCoords, json_object_new_double(id->m_sCurLayout.m_dWorldYmin));
		json_object_array_add(jCoords, json_object_new_double(id->m_sCurLayout.m_dWorldYmax));
		json_object_object_add(jobj, "COORDS", jCoords);

		// Debug the output to -debug-.json text file.
		sprintf_s(strLayoutPath, MAX_PATH_SZ, "%s\\-debug-.json", id->m_strCachedDir);
		D_CONTROL(__FUNCTION__, json_object_to_file(strLayoutPath, jobj));

		str = json_object_to_json_string(jobj);

		dataOut = curl_escape(str, strlen(str));
		if (dataOut) {
			D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) dataOut <%s>.\n", cdwThreadId, dataOut));
		}

		// Background SaveLayout to Server
		_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "Action=SaveSurfLayout&username=%s&layout=%s&json=%s", id->m_strUserName, cstrName, dataOut);
		Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);
		curl_free(dataOut);

		if (!strcmp(cstrName, "<default>")){
			cstrName = cstrDefault;
		}
		// Save as Named File
		sprintf_s(strLayoutPath, MAX_PATH_SZ, "%s\\%s.json", id->m_strCachedDir, cstrName);
		if (json_object_to_file(strLayoutPath, jobj)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\" to file \"%s\"!\n", cdwThreadId, cstrName, strLayoutPath);
		}
		// Save as Active File too!
		sprintf_s(strLayoutPath, MAX_PATH_SZ, "%s\\-active-.json", id->m_strCachedDir);
		if (json_object_to_file(strLayoutPath, jobj)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\" to file \"%s\"!\n", cdwThreadId, cstrName, strLayoutPath);
		}

		// Save to Cached Layouts List
		SaveCachedLayout(id, cstrName);

		json_object_put(jobj);
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\", invalid JSON data!\n", cdwThreadId, cstrName);
	}
	curl_free(dataIn);

	return (bReturn);
}

// NAME: GetLayouts - GetData callback, for "Layouts" 
// PURPOSE: Should return a list of layouts maintained in db for user 
// INPUT: p - UNUSED
// OUTPUT: m, JSON formatted data, names, owner of user defined layouts
// EXAMPLE: "[{"_class":"pair", "first":"<default>","second":"PASSUR"} ...]"
void GetLayouts(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	struct json_object* jerr = NULL;
	char* data = NULL;
	char tmpstr[8192];
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(m);
	if (!id->m_pstrLayouts){
		// Try to Read from Cache first (may have failed to load from server first time around)
		if (!LoadCachedLayouts(id)){
			// Load Layout list from server if we haven't already cached it
			_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "Action=LoadSurfLayoutNames2&username=%s", id->m_strUserName);

			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

			if (!GetCurlFormPostResults(id, m, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load layouts from Database.\n", cdwThreadId);
				GetNxtSurfSrvr(id);
			}

			// Check for error	
			if (m->memory){
				// Parse data, returns an Array of Layouts or an Object with errors
				data = curl_unescape(m->memory, strlen(m->memory));
				if (data) {
					D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) data <%s>.\n", cdwThreadId, data));
				}
				jobj = json_tokener_parse_verbose(data, &jerror);
				if (json_tokener_success == jerror){
					enum json_type jtype = json_object_get_type(jobj);
					switch (jtype){
					case json_type_array: // OK, Expected data, pass on to UI
						id->m_pstrLayouts = _strdup(m->memory);
						CacheLayouts(id, jobj);
						break;
					case json_type_object: // Unexpected, error is returned in Error object
						jerr = json_object_object_get(jobj, "_class");
						if (jerr && !strcmp("Error", json_object_get_string(jerr))){
							jerr = json_object_object_get(jobj, "description");
							if (jerr && json_object_is_type(jerr, json_type_string))
								vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load layouts from Database: %s\n", cdwThreadId, json_object_get_string(jerr));
							else
								vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load layouts from Database.\n", cdwThreadId);
							}else{
							vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load layouts from Database, unknown object returned: %s.\n", cdwThreadId, data);
						}
						break;
					default:
						vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load layouts from Database, unknown type returned: %s.\n", cdwThreadId, data);
					}
				}else{
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load layouts from Database, invalid JSON array returned: %s.\n", cdwThreadId, data);
				}
				curl_free(data);
				// Release entire json object
				json_object_put(jobj);
			}
		}else{
			// Load from Cached List
			data = curl_unescape(id->m_pstrLayouts, strlen(id->m_pstrLayouts));
			m->size = strlen(data) + 1;
			m->memory = _strdup(data);
			curl_free(data);
		}
	}else{
		// Load from Cached List
		data = curl_unescape(id->m_pstrLayouts, strlen(id->m_pstrLayouts));
		m->size = strlen(data) + 1;
		m->memory = _strdup(data);
		curl_free(data);
	}
}

// NAME: GetARTCC - GetData callback, for "ARTCC" 
// PURPOSE: 
// INPUT: 
// OUTPUT: 
// EXAMPLE: 
void GetARTCC(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char* data = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	const char* strARTCC = ARTCCtoJSON(id);
	data = curl_unescape(strARTCC, strlen(strARTCC));
	m->size = strlen(data) + 1;
	m->memory = _strdup(data);
	curl_free(data);
}

// NAME: GetSIDs - GetData callback, for "SID" 
// PURPOSE: 
// INPUT: 
// OUTPUT: 
// EXAMPLE: 
void GetSIDs(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char* data = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	const char* strSID = SIDtoJSON(id);
	if (strSID){
		data = curl_unescape(strSID, strlen(strSID));
		m->size = strlen(data) + 1;
		m->memory = _strdup(data);
		curl_free(data);
	}
}

// NAME: GetSTARs - GetData callback, for "STAR" 
// PURPOSE: 
// INPUT: 
// OUTPUT: 
// EXAMPLE: 
void GetSTARs(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char* data = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	const char* strSTAR = STARtoJSON(id);
	if (strSTAR){
		data = curl_unescape(strSTAR, strlen(strSTAR));
		m->size = strlen(data) + 1;
		m->memory = _strdup(data);
		curl_free(data);
	}
}

void ProcessJSONLayout(struct InstanceData* id, char* p)
{
	ChangeLayout(id, p);
}

void ProcessLayout(struct InstanceData* id, char *layout)
{
	char *nexttok;
	char *context;
	char *data;
	int len;
	const DWORD cdwThreadId = GetCurrentThreadId();
	len = strlen(layout) + 1;
	data = calloc(len, sizeof(char));
	strcat_s(data, len, layout);
	D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) id->m_sCurLayout.m_bShowRoi was <%d> layout <%s>.\n",
		cdwThreadId, id->m_sCurLayout.m_bShowRoi, layout));

	id->m_sCurLayout.m_bShowRoi = FALSE;

	D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) id->m_sCurLayout.m_bShowRoi is now <%d>.\n",
		cdwThreadId, id->m_sCurLayout.m_bShowRoi));
	// break string into individual values, then call ChangeLayout() to set values

	if (!(nexttok = strtok_s(data, "&", &context))){
		return;
	}
	ChangeLayout(id, nexttok);

	do {
		if (!(nexttok = strtok_s(NULL, "&", &context))) break;
		ChangeLayout(id, nexttok);
	} while (1);
	free(data);
}

unsigned _stdcall ServerBackgroundThread(PVOID pvoid){
	struct ServerData* pServerData = (struct ServerData*)pvoid;
	struct MemoryStruct chunk;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(&chunk);

	vo_log_info(pServerData->id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - <%s> <%s>.\n",
		cdwThreadId, pServerData->pstrUrl, pServerData->pstrPostFields);

	if (!GetCurlFormPostResults(pServerData->id, &chunk, pServerData->pstrUrl, pServerData->pstrPostFields, SM_HTTPS, TRUE)){
		vo_log_error(pServerData->id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Server failure for <%s:%s>\n", cdwThreadId, pServerData->pstrUrl, pServerData->pstrPostFields);
	}

	free_chunk_memory(&chunk);

	vo_log_info(pServerData->id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread Terminated\n", cdwThreadId, pServerData->id->m_nControlId);

	free(pServerData->pstrUrl);
	free(pServerData->pstrPostFields);
	free(pServerData);

	_endthreadex(0);
	return 0;
}

void Submit2BackgroundServer(struct InstanceData* id, const char* cpstrUrl, const char* cpstrPostFields)
{
	struct ServerData* pServerData = (struct ServerData*)calloc(1, sizeof(struct ServerData));
	if (pServerData){
		pServerData->id = id;
		pServerData->pstrUrl = _strdup(cpstrUrl);
		pServerData->pstrPostFields = _strdup(cpstrPostFields);

		_beginthreadex(NULL, 0, ServerBackgroundThread, pServerData, 0, NULL);
	}else{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to background server request <%s:%s>, unable to allocate thread data!\n",
			GetCurrentThreadId(), cpstrUrl, cpstrPostFields);
	}
}

void LoadNamedLayout( struct InstanceData* id, char *Layout, struct MemoryStruct* chunk, BOOL bActivate )
{
	enum json_tokener_error jerror;
	struct json_object* jobj = NULL;
	char tmpstr[8192];
	char* data = NULL;
	char* p = NULL;
	char* dataOut;
	const char* config = "config\":";
	const char* name = "name\":\"";
	const char* owner = "owner\":\"";
	int nRetry = 1;
	int bSucceeded = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: Layout <%s>.\n",
		cdwThreadId, Layout));

	_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "Action=LoadSurfLayout&username=%s&Layout=%s",
		id->m_strUserName, Layout);

	// Initialize the system with off boolean values from new overlay items until loaded and saved
	id->m_nAllSurface = TRUE;
	id->m_bShowAirways = FALSE;
	id->m_sCurLayout.m_bShowADSBAircraft = FALSE;
	if (id->m_sCurLayout.m_pstrARTCC){
		free(id->m_sCurLayout.m_pstrARTCC);
		id->m_sCurLayout.m_pstrARTCC = NULL;
	}

	id->m_sCurLayout.m_nARTCCLabel = 1;
	id->m_sCurLayout.m_nSIDSLabel = 1;
	id->m_sCurLayout.m_nSTARSLabel = 1;
	id->m_sCurLayout.m_nGATESLabel = 1;
	id->m_sCurLayout.m_nROISLabel = 0;
	id->m_sCurLayout.m_nARTCCFontIndex = 2;
	id->m_sCurLayout.m_nGATESFontIndex = 2;
	id->m_sCurLayout.m_nROISFontIndex = 2;
	id->m_sCurLayout.m_nSIDSFontIndex = 2;
	id->m_sCurLayout.m_nSTARSFontIndex = 2;
	StringToGLFloat(id->m_sCurLayout.m_glfARTCCColor, "#8000FF");
	StringToGLFloat(id->m_sCurLayout.m_glfSIDSColor, "#008000");
	StringToGLFloat(id->m_sCurLayout.m_glfSTARSColor, "#800000");
	StringToGLFloat(id->m_sCurLayout.m_glfGATESColor, "#000000");
	StringToGLFloat(id->m_sCurLayout.m_glfROISColor, "#000000");
	StringToGLFloat(id->m_sCurLayout.m_glfCustomFillColor, "#000000");
	StringToGLFloat(id->m_sCurLayout.m_glfCustomOutlineColor, "#000000");
	StringToGLFloat(id->m_sCurLayout.m_glfClosedFillColor, "#FF0000");
	StringToGLFloat(id->m_sCurLayout.m_glfClosedOutlineColor, "#FF0000");
	id->m_sCurLayout.m_nLayerEnableFlag |= LEF_CLOSED;
	id->m_nVColorIndex = 0;
	id->m_bDisableVTag = 0;
	id->m_sCurLayout.m_bShowMLATAircraft = FALSE;
	id->m_sUserSettings.LKP = TRUE;
	// Alert Settings:
	id->m_nRegionAlertEnabled = TRUE;
	id->m_nRegionOTOYellow = 30 /* mins */ * 60 /* secs */;		// Default Region Out to Off Med Alert Threshold
	id->m_nRegionOTORed = 46 /* mins */ * 60 /* secs */;		// Default Region Out to Off High Alert Threshold
	id->m_nRegionOTIYellow = 16 /* mins */ * 60 /* secs */;		// Default Region On to In Med Alert Threshold
	id->m_nRegionOTIRed = 31 /* mins */ * 60 /* secs */;		// Default Region On to In High Alert Threshold
	id->m_nTarmacDelayEnabled = TRUE;
	id->m_nTarmacDelayOTOYellow = 30 /* mins */ * 60 /* secs */;	// Default Tarmac Delay Out to Off Med Alert Threshold
	id->m_nTarmacDelayOTORed = 46 /* mins */ * 60 /* secs */;		// Default Tarmac Delay Out to Off High Alert Threshold
	id->m_nTarmacDelayOTIYellow = 16 /* mins */ * 60 /* secs */;	// Default Tarmac Delay On to In Med Alert Threshold
	id->m_nTarmacDelayOTIRed = 31 /* mins */ * 60 /* secs */;		// Default Tarmac Delay On to In High Alert Threshold
	id->m_nVehicles = 0;
	id->m_glfRotateAngle = 0.0f;

	// Initialize all Feeds to TRUE in case values not saved in layout data
	if (!(IS_D_CONTROL("FEED_CNTRL") || HavePermission(id, "FEED_CNTRL"))) {
		id->m_sCurLayout.m_bShowADSBAircraft = TRUE;
		id->m_sCurLayout.m_bShowASDEXAircraft = TRUE;
		id->m_sCurLayout.m_bShowASDAircraft = TRUE;
		id->m_sCurLayout.m_bShowMLATAircraft = TRUE;
		id->m_sCurLayout.m_bShowPassurAircraft = TRUE;

		if (HavePermission(id, "AIRASIA")) {
			id->m_sCurLayout.m_bShowAirAsiaAircraft = TRUE;
		} else {
			id->m_sCurLayout.m_bShowAirAsiaAircraft = FALSE;
		}
	}

	if (LoadCachedLayout(id, Layout, chunk))
	{
		// Background Activation of Layout
		if(bActivate){
			Submit2BackgroundServer(id, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);
		}
	} else	{
		// Get the named layout from the DB	
		do
		{
			clear_chunk_memory(chunk);
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
				cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);
			if (!GetCurlFormPostResults(id, chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load data for layout %s\n", cdwThreadId, Layout);
				GetNxtSurfSrvr(id);
			}

			// break string into individual values, then call ChangeLayout() to set values
			// NOTE: Use copy of data as the curl results need to be passed back to UI and
			//		 ProcessLayout uses strtok, which destroys the data string.
			if (chunk->memory) {
				if (strstr(chunk->memory, "404 Not Found")){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load data for layout %s, data<%s>, retry<%d>\n", cdwThreadId, Layout, nRetry, chunk->memory);
				}else{
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) id->m_sCurLayout.m_bShowRoi was <%d>.\n", cdwThreadId, id->m_sCurLayout.m_bShowRoi);

					id->m_sCurLayout.m_bShowRoi = FALSE;

					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) id->m_sCurLayout.m_bShowRoi is now <%d>.\n", cdwThreadId, id->m_sCurLayout.m_bShowRoi);

					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) chunk->memory <%s>.\n", cdwThreadId, chunk->memory);

					// Check for JSON Object
					// break string into individual values, then call ChangeLayout() to set values
					data = curl_unescape(chunk->memory, strlen(chunk->memory));
					jobj = json_tokener_parse_verbose(data, &jerror);
					if (json_tokener_success == jerror){
						struct json_object_iter jiter;
						json_object_object_foreachC(jobj, jiter){
							if (!strcmp("name", jiter.key)){
								strcpy_s(id->m_sCurLayout.m_strLayoutName, LAYOUT_NAME_SIZE, json_object_get_string(jiter.val));
							}else if(!strcmp("owner", jiter.key)){
								strcpy_s(id->m_sCurLayout.m_strOwner, CHAR24, json_object_get_string(jiter.val));
							}else if(!strcmp("config", jiter.key)){
								const char* jstr = json_object_to_json_string(jiter.val);
								ProcessJSONLayout(id, (char*)jstr);
								// Remove ActiveX "ONLY" properties
								json_object_object_del(jiter.val, "angle");
								json_object_object_del(jiter.val, "fi");
								json_object_object_del(jiter.val, "icon");
								json_object_object_del(jiter.val, "COORDS");
								jstr = json_object_to_json_string(jiter.val);
								dataOut = curl_escape(jstr, strlen(jstr));
								free_chunk_memory(chunk);
								chunk->size = strlen(dataOut) + 1;
								chunk->memory = calloc(chunk->size, sizeof(char));
								strcat_s(chunk->memory, chunk->size, dataOut);
								D_CONTROL("TRC-ROI", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
									"(0x%X) (2) chunk->memory <%s>.\n", cdwThreadId, chunk->memory));
								curl_free(dataOut);
							}
						}
						json_object_put(jobj);
					}else{
						char* p1, *p2;
						p1 = strstr(data, name) + strlen(name);
						p2 = strstr(p1, "\"");
						strncpy_s(id->m_sCurLayout.m_strLayoutName, LAYOUT_NAME_SIZE, p1, p2 - p1);
						p1 = strstr(p2, owner) + strlen(owner);
						p2 = strstr(p1, "\"");
						strncpy_s(id->m_sCurLayout.m_strOwner, CHAR24, p1, p2 - p1);
						p1 = strstr(p2, config) + strlen(config);
						ProcessLayout(id, p1);
						// Return Old format in chunk
						_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "layout=\"%s\"&%s", Layout, p1);
						dataOut = curl_escape(tmpstr, strlen(tmpstr));
						free_chunk_memory(chunk);
						chunk->size = strlen(dataOut) + 1;
						chunk->memory = calloc(chunk->size, sizeof(char));
						strcat_s(chunk->memory, chunk->size, dataOut);
						curl_free(dataOut);
					}
					curl_free(data);
					bSucceeded = TRUE;
				}
			}else{
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load data for layout %s.\n", cdwThreadId, Layout);
			}
		} while (!bSucceeded && (++nRetry < 3));

		if (!bSucceeded){
			SetFailedRequest(chunk);
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to load user %s layouts.\n", cdwThreadId, id->m_strUserName);
		}
	}
}


void GetLaunchedLayout(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char strLayoutPath[MAX_PATH_SZ] = {0};
	const char* ts = "timestamp";
	char* data = curl_unescape(p, strlen(p));
	struct json_object* jobj = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s called with %s!\n", cdwThreadId, __FUNCTION__, data);
	
	sprintf_s(strLayoutPath, MAX_PATH_SZ, "%s\\-launched-.json", id->m_strCachedDir, data);

	clear_chunk_memory(m);

	if(strlen(data)){
		enum json_tokener_error jerror;
		jobj = json_tokener_parse_verbose(data, &jerror);
		json_object_object_add(jobj, ts, json_object_new_int(time(NULL)));
		if(jobj && json_tokener_success == jerror){
			if(json_object_to_file(strLayoutPath, jobj)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to save Layout \"%s\" to file \"%s\"!\n", cdwThreadId, data, strLayoutPath);
			}
		}
		json_object_put(jobj);
	}else{
		if(!_access(strLayoutPath, 0)){
			jobj = json_object_from_file(strLayoutPath);
			if(jobj && -1 != ((int)jobj)){
				struct json_object* jtimestamp = json_object_object_get(jobj, ts);
				time_t timestamp = 0;
				if(NULL != jtimestamp){
					time_t now = time(NULL);
					timestamp = json_object_get_int(jtimestamp);
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Launched layout file time=%d current time=%d\n", cdwThreadId, timestamp, now);
					// Only use if less than 20 secs old, should be ample time for refresh event
					if((now - timestamp) < 20){
						m->memory = _strdup(json_object_to_json_string(jobj));
						m->size = strlen(m->memory) + 1;
					}
				}
				json_object_put(jobj);
				// delete file
				if(remove(strLayoutPath)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to delete Launched Layout file \"%s\"!\n", cdwThreadId, strLayoutPath);
				}
			}
		}
	}
	curl_free(data);
}

void GetLayoutData(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	// NAME: GetLayoutData - GetData callback, for "Layout" 
	// PURPOSE: Should return the data specific to a named layout (all of the settings) 
	// INPUT: p - Layout Name
	// OUTPUT: m, formatted data, va;ue/name pairs of settings
	// EXAMPLE(S): 
	//	"<default>" = "layout=\"<default>\"&world=\"Off\"&roads=\"Off\"&legend=\"Off\"&range=\"Off\"&trails=\"Off\"&tags=\"Off\"&icon=\"Off\"&outline=\"boundary,\"&outline=\"ramps,\"&outline=\"runway,\"&outline=\"taxiway,\"&outline=\"water,\"&fill=\"boundary,\"&fill=\"ramps,\"&fill=\"runway,\"&fill=\"taxiway,\"&fill=\"water,\""
	//  "Layout 1" = "layout=\"Layout 1\"&world=\"On\"&roads=\"On\"&legend=\"On\"&range=\"On,1.5\"&trails=\"On\"&points=\"10\"&times=\"On\"&tags=\"Small\"&line1=\"Flight ID,Destination,\"&icon=\"On,fix,Bette,#008000\"&outline=\"boundary,#FF0000\"&outline=\"ramps,#FFFFFF\"&outline=\"runway,#0000FF\"&outline=\"taxiway,#800080\"&outline=\"water,#FFFF00\"&fill=\"boundary,#008000\"&fill=\"ramps,#FFA500\"&fill=\"runway,#FFFFFF\"&fill=\"taxiway,#000000\"&fill=\"water,#0000FF\""
	//  "Layout 2" = "layout=\"Layout 2\"&world=\"Off\"&roads=\"Off\"&legend=\"Off\"&&range=\"Off\"trails=\"Off\"&tags=\"Large\"&line1=\"Flight ID,Origin,Destination\"&line2=\"Departure Fix,PASSUR Tail,\"&line3=\"Aircraft Type,Time in Queue,Scheduled Departure Time\"&icon=\"On,airline,American,#0000FF\"&outline=\"boundary,\"&outline=\"ramps,\"&outline=\"runway,\"&outline=\"taxiway,\"&outline=\"water,\"&fill=\"boundary,\"&fill=\"ramps,\"&fill=\"runway,\"&fill=\"taxiway,\"&fill=\"water,\""

	/* This function only has sample data */
	/* TODO: Connect to DB, extract data per user */
	int idx = -1, len = 0;
	char *Layout = NULL, *data = NULL, *Activate = NULL;
	char *p1 = NULL, *p2 = NULL;
	const char* samples[3] = {
		"layout=\"<default>\"&world=\"Off\"&roads=\"Off\"&legend=\"Off\"&range=\"Off\"&arptrings=\"Off\"&trails=\"Off\"&tags=\"Off\"&icon=\"Off\"&outline=\"boundary,\"&outline=\"ramps,\"&outline=\"runway,\"&outline=\"taxiway,\"&outline=\"water,\"&outline=\"apron,\"&outline=\"parking,\"&outline=\"markings,\"&outline=\"shoulder,\"&fill=\"boundary,\"&fill=\"ramps,\"&fill=\"runway,\"&fill=\"taxiway,\"&fill=\"water,\"&fill=\"apron,\"&fill=\"parking,\"&fill=\"markings,\"&fill=\"shoulder,\"",
		"layout=\"Layout 1\"&world=\"On\"&roads=\"On\"&legend=\"On\"&range=\"On,1.3\"&arptrings=\"On,10,3,JFK\"&trails=\"On\"&points=\"10\"&times=\"On\"&tags=\"Small\"&line1=\"Flight ID,Destination,\"&icon=\"On,fix,Bette,#008000\"&outline=\"boundary,#FF0000\"&outline=\"ramps,#FFFFFF\"&outline=\"runway,#0000FF\"&outline=\"taxiway,#800080\"&outline=\"water,#FFFF00\"&outline=\"apron,#080808\"&outline=\"parking,#808080\"&outline=\"markings,#0F0F0F\"&outline=\"shoulder,#F0F0F0\"&fill=\"boundary,#008000\"&fill=\"ramps,#FFA500\"&fill=\"runway,#FFFFFF\"&fill=\"taxiway,#000000\"&fill=\"water,#0000FF\"&fill=\"apron,#FF0000\"&fill=\"parking,#00FF00\"&fill=\"markings,#0000FF\"&fill=\"shoulder,#000000\"",
		"layout=\"Layout 2\"&world=\"Off\"&roads=\"Off\"&legend=\"Off\"&range=\"Off\"&arptrings=\"On,5,5,JFK\"&trails=\"Off\"&tags=\"Large\"&line1=\"Flight ID,Origin,Destination\"&line2=\"Departure Fix,Passur Taul,\"&line3=\"Aircraft Type,Time in Queue,Scheduled Departure Time\"&icon=\"On,airline,American,#0000FF\"&outline=\"boundary,\"&outline=\"ramps,\"&outline=\"runway,\"&outline=\"taxiway,\"&outline=\"water,\"&outline=\"apron,\"&outline=\"parking,\"&outline=\"markings,\"&outline=\"shoulder,\"&fill=\"boundary,\"&fill=\"ramps,\"&fill=\"runway,\"&fill=\"taxiway,\"&fill=\"water,\"&fill=\"apron,\"&fill=\"parking,\"&fill=\"markings,\"&fill=\"shoulder,\""
	};


	if (strlen(p)){
		data = curl_unescape(p, strlen(p));
		// Extract Layout name from data
		p1 = strchr(data, '=') + 2;
		p2 = strchr(p1, '"');
		len = p2 - p1;
		Layout = calloc(len + 1, sizeof(char));
		strncpy_s(Layout, len + 1, p1, len);
		p1 += len;
		p1 = strchr(p1, '=') + 2;	
		p2 = strchr(p1, '"');
		len = p2 - p1;
		Activate = calloc(len + 1, sizeof(char));
		strncpy_s(Activate, len + 1, p1, len);
		curl_free(data);
		if (Layout) {
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Layout <%s> and Activate is <%s>.\n", GetCurrentThreadId(), Layout, Activate));
		}
		LoadNamedLayout( id, Layout, m, !_stricmp("true", Activate));
		free(Activate);
		free(Layout);
	} else {
		// UI Wants Default Layout name
		char strLayoutName[LAYOUT_NAME_SIZE + 10] = { 0 };
		if (strlen(id->m_sCurLayout.m_strLayoutName))
			sprintf_s(strLayoutName, LAYOUT_NAME_SIZE + 10, "layout=\"%s\"", id->m_sCurLayout.m_strLayoutName);
		else // Use Default layout if not assigned yet
			sprintf_s(strLayoutName, LAYOUT_NAME_SIZE + 10, "layout=\"%s\"", "<default>");
		data = curl_escape(strLayoutName, strlen(strLayoutName));
		memset(m, 0, sizeof(struct MemoryStruct));
		if (!m->size){
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);
		}
		curl_free(data);
	}

#ifdef OLDWAY
	if(!strcmp(Layout, "<default>"))
		idx = 0;
	else if(!strcmp(Layout, "Layout 1"))
		idx = 1;
	else if(!strcmp(Layout, "Layout 2"))
		idx = 2;
	free(Layout);
	if(-1 != idx)
	{
		data = curl_escape(samples[idx], strlen(samples[idx]));
		memset(m, 0, sizeof(struct MemoryStruct));
		if(!m->size){
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);
		}
		curl_free(data);
	}	
#endif
}

void ClearAirFields(AIR *air)
{
	if (air->TrackPtr) free(air->TrackPtr);
	if (air->FltRouteOrig) free(air->FltRouteOrig);
	if (air->FltRoute) free(air->FltRoute);
	if (air->FltRouteWaypoints) free(air->FltRouteWaypoints);
	if (air->vehicle && air->VInfoPtr) {
		free(air->VInfoPtr);
	}
	if (air->FFTInfoPtr){
		if (air->FFTInfoPtr->text)
			free(air->FFTInfoPtr->text);
		if (air->FFTInfoPtr->uuid)
			free(air->FFTInfoPtr->uuid);
		free(air->FFTInfoPtr);
	}
	memset(air, 0, sizeof(AIR));
	air->heading = -1.0f; // Always initialize heading to expected invalid value
}

int RemoveASDTrack(struct InstanceData* id, AIR **airp, int AI, int reset_flag)
{
	AIR *air;

	if (!(air = airp[AI])){
		return(SUCCEED);
	}

	D_CONTROL("ASD_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing trackid %d\n", GetCurrentThreadId(), air->trackid));

	ASDtrackcount--;

	RemoveIndex(id, id->m_pASDIndexMap, air->FltNum, air->icao24, air->beacon, ASDI);

	// free anything inside struct
	ClearAirFields(air);

	// remove the pointer
	free(air);
	airp[AI] = NULL;

	return(SUCCEED);
}

void AddTestFlight(struct InstanceData* id, AIR** airp, int i, char* flightid, char* gate, float lat, float lng, float ang)
{
	const DWORD cdwThreadId = GetCurrentThreadId();
	AIR* air = GetAir(airp, i); // creates the new struct for tracking
	strcpy_s(air->FltNum, FLTNUM_SIZE, flightid);
	air->CurX = air->X = lng;
	air->CurY = air->Y = lat;
	air->PrevAngle = ang;
	air->utc = time(NULL);
	air->trackid = i;
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s at %s <%f, %f, %f>.\n",
		cdwThreadId, air->FltNum, gate, lat, lng, ang);
	AddTrail(id, air, i, NULL, FALSE, MAX(MIN(ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), ASDEX_TRACK_MODIFIER(MAX_ASDEX_TRACK_POINTS)), 3));
}

int CreateTestAircraft(struct InstanceData* id, AIR** airp, char* arpt, char* term, char* gate_format, char* flightid_format, int trackid, int start, int count)
{
	int i = 0;
	int e = 0;
	float lat = 0.0f, lng = 0.0f, ang = 0.0f;
	char gate[GATE_SIZE] = { 0 };
	char flightid[FLTNUM_SIZE] = { 0 };
	e = start + count;
	for (i = start; i < e; i++){
		sprintf_s(gate, GATE_SIZE, gate_format, (i + 1));
		sprintf_s(flightid, FLTNUM_SIZE, flightid_format, (i + 1));
		if (GetAirportGateData(id, arpt, term, gate, flightid, &lat, &lng, &ang)){
			AddTestFlight(id, airp, trackid, flightid, gate, lat, lng, ang);
			trackid++;
		}
	}
	return trackid;
}

void AddTestGateAircraft(struct InstanceData* id, AIR** airp)
{
	char arpt[ORIG_DES_SIZE] = { 0 };
	char term[GATE_SIZE] = { 0 };
	char gate[GATE_SIZE] = { 0 };
	char flightid[FLTNUM_SIZE] = { 0 };
	int i = 0;
	float lat = 0.0f, lng = 0.0f, ang = 0.0f;
	VO* LabelVO = NULL;
	static time_t last = 0;
	static int count = 0;
	time_t cur = 0;

	const DWORD cdwThreadId = GetCurrentThreadId();

	cur = time(NULL);
	if (count < 3 || ((cur - last) > 30)){
		if (count < 3) count++;
		last = cur;
	}else{
		return;
	}

	strcat_s(arpt, ORIG_DES_SIZE, "K");
	strncat_s(arpt, ORIG_DES_SIZE, id->m_strAsdexArpt, 3);
	StrUpper(arpt);
	strcpy_s(term, GATE_SIZE, "null");
	LabelVO = GetGateLabelList(id, arpt);
	for (i = 0; i < LabelVO->count; i++){
		strcpy_s(gate, GATE_SIZE, VP(LabelVO, i, "gate", char));
		if (GetAirportGateData(id, arpt, term, gate, gate, &lat, &lng, &ang)){
			AddTestFlight(id, airp, (i + 1), gate, gate, lat, lng, ang);
		}
	}
	vo_free(LabelVO);
	/*if(!strcmp(arpt, "KSLC")){
		i = CreateTestAircraft(id, airp, arpt, term, "A%d", "A%d", i, 0, 8);
		i = CreateTestAircraft(id, airp, arpt, term, "B%d", "B%d", i, 0, 22);
		i = CreateTestAircraft(id, airp, arpt, term, "C%d", "C%d", i, 0, 13);
		i = CreateTestAircraft(id, airp, arpt, term, "D%d", "D%dS", i, 5, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "D%d", "D%d", i, 0, 13);
		i = CreateTestAircraft(id, airp, arpt, term, "E66", "E%d", i, 0, 41);
		}
		if(!strcmp(arpt, "KDAL")){
		i = CreateTestAircraft(id, airp, arpt, term, "%d", "%d", i, 0, 14);
		i = CreateTestAircraft(id, airp, arpt, term, "%d", "%d", i, 41, 3);
		}
		if(!strcmp(arpt, "KBWI")){
		i = CreateTestAircraft(id, airp, arpt, term, "A%d", "A%d", i, 0, 11);
		i = CreateTestAircraft(id, airp, arpt, term, "B%d", "B%d", i, 0, 15);
		i = CreateTestAircraft(id, airp, arpt, term, "C%d", "C%d", i, 0, 14);
		i = CreateTestAircraft(id, airp, arpt, term, "C%dA", "C%dA", i, 9, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "C%dA", "C%dA", i, 13, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "D%d", "D%d", i, 0, 47);
		i = CreateTestAircraft(id, airp, arpt, term, "E%d", "E%d", i, 0, 8);
		}
		if(!strcmp(arpt, "KEWR")){
		i = CreateTestAircraft(id, airp, arpt, term, "%d", "%d", i, 9, 139);
		i = CreateTestAircraft(id, airp, arpt, term, "%dA", "%dA", i, 15, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "%dA", "%dA", i, 40, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "%dB", "%dB", i, 40, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "%dA", "%dA", i, 45, 1);
		i = CreateTestAircraft(id, airp, arpt, term, "%dB", "%dB", i, 45, 1);
		}

		*/
}

AIR **GetGateAirP(struct InstanceData* id)
{
	if (id->m_pGateAir){

		// Debug Code To Add Test Gate Aircraft
		if (IS_D_CONTROL("TEST_GATES")){
			if (!((AIR**)id->m_pGateAir)[0]){
				AddTestGateAircraft(id, id->m_pGateAir);
			}
		}

		return((AIR **)id->m_pGateAir);
	}
	id->m_pGateAir = calloc(N_GATE_TRACK_ID, sizeof(AIR *));

	// Debug Code To Add Test Gate Aircraft
	if (IS_D_CONTROL("TEST_GATES")){
		if (!((AIR**)id->m_pGateAir)[0]){
			AddTestGateAircraft(id, id->m_pGateAir);
		}
	}

	return((AIR **)id->m_pGateAir);
}

AIR **GetMLATAirP(struct InstanceData* id)
{
	if (id->m_pMLATAir){
		return((AIR **)id->m_pMLATAir);
	}
	id->m_pMLATAir = calloc(N_MLAT_TRACK_ID, sizeof(AIR *));

	return((AIR **)id->m_pMLATAir);
}

AIR **GetADSBAirP(struct InstanceData* id)
{
	if (id->m_pADSBAir){
		return((AIR **)id->m_pADSBAir);
	}
	id->m_pADSBAir = calloc(N_ADSB_TRACK_ID, sizeof(AIR *));

	return((AIR **)id->m_pADSBAir);
}

AIR **GetAirAsiaAirP(struct InstanceData* id)
{
	if (id->m_pAirAsiaAir){
		return((AIR **)id->m_pAirAsiaAir);
	}
	id->m_pAirAsiaAir = calloc(N_AIRASIA_TRACK_ID, sizeof(AIR *));

	return((AIR **)id->m_pAirAsiaAir);
}

AIR **GetASDEXAirP(struct InstanceData* id)
{
	if (id->m_pASDEXAir){
		return((AIR **)id->m_pASDEXAir);
	}
	id->m_pASDEXAir = calloc(N_TRACK_ID, sizeof(AIR *));

	return((AIR **)id->m_pASDEXAir);
}

AIR **GetLMGAirP( struct InstanceData* id )
{
	if ( id->m_pLMGAir ){
		return( (AIR **)id->m_pLMGAir );
	}
	id->m_pLMGAir = calloc( N_TRACK_ID, sizeof( AIR *) );

	return( (AIR **)id->m_pLMGAir );
}


AIR **GetASDAirP(struct InstanceData* id)
{
	if (id->m_pASDAir){
		return((AIR **)id->m_pASDAir);
	}
	id->m_pASDAir = calloc(N_TRACK_ID, sizeof(AIR *));

	return((AIR **)id->m_pASDAir);
}

AIR **GetNoiseAirP(struct InstanceData* id)
{
	if (id->m_pNoiseAir){
		return((AIR **)id->m_pNoiseAir);
	}
	id->m_pNoiseAir = calloc(N_NOISE_TRACK_ID, sizeof(AIR *));

	return((AIR **)id->m_pNoiseAir);
}



int CalcASDLatLon(struct feedstruct *record, double *xptr, double *yptr, double *prevxptr, double *prevyptr)
{
	double newlat, newlng, deltalng,
		realdelta;

	/* ASD values are in minutes of arc */
	newlat = (double)record->feedy / 60.0;
	newlng = (double)record->feedx / 60.0;

	if (record->latsecs){
		newlat += (double)record->latsecs / 3600.0;
	}
	if (record->longsecs){
		newlng += (double)record->longsecs / 3600.0;
	}

	if (projflag){
		deltalng = newlng - LngOrig;
		realdelta = deltalng * cos(newlat * M_PI / 180.0);
		newlng = LngOrig + realdelta;
	}

	*xptr = newlng;
	*yptr = newlat;

	/* ASD values are in minutes of arc */
	newlat = (double)record->prevlat / 60.0;
	newlng = (double)record->prevlng / 60.0;

	if (projflag){
		deltalng = newlng - LngOrig;
		realdelta = deltalng * cos(newlat * M_PI / 180.0);
		newlng = LngOrig + realdelta;
	}

	*prevxptr = newlng;
	*prevyptr = newlat;
	return(SUCCEED);
}

VO *GetBarrOverridesVO(struct InstanceData* id)
{
	static VO *BarrOverrideVO;
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char username[VO_NAME_SIZE], urltime[VO_NAME_SIZE];
	char outbuf[100000]; // big temp buffer for all of the barr data
	static int firsttime = 1;
	time_t secs;
	char tail[10];
	char *str, *endstr;
	char linebuf[512];
	int len, pflag = 0, count;
	struct timeb start_time, done_time;
	const DWORD cdwThreadId = GetCurrentThreadId();


	if (BarrOverrideVO){
		return(BarrOverrideVO);
	}

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	strcpy_s(username, VO_NAME_SIZE, "pulse");
	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=GetBARROverrides");
	if (pflag){
		printf("GetBarrOverrideVO, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	}
	if (timeflag){ ftime(&start_time); }

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), tmpstr);

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Call to %s failed, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return(NULL);
	}

	if (timeflag) {
		ftime(&done_time);
	}

	if (chunk.memory && strncmp(chunk.memory, "Error", 5)){
		strncpy_s(outbuf, _countof(outbuf), chunk.memory, sizeof(outbuf));
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No BARR override data retrieved from server.\n",
			cdwThreadId);
		return(NULL);
	}

	// Create VO here in case PulseServer fails.
	BarrOverrideVO = (VO *)vo_create(0, NULL);
	vo_set(BarrOverrideVO, V_NAME, "BarrOverrideVO", NULL);

	VOPropAdd(BarrOverrideVO, "Tail", NTBSTRINGBIND, N_TAIL_SIZE, VO_NO_ROW);
	VOPropAdd(BarrOverrideVO, "username", NTBSTRINGBIND, USERNAME_SZ, VO_NO_ROW);
	vo_rm_rows(BarrOverrideVO, 0, BarrOverrideVO->count);

	str = outbuf;

	do {
		if (!(endstr = strchr(str, '\n'))){
			break;
		}
		len = endstr - str;
		strncpy_s(linebuf, _countof(linebuf), str, len);
		linebuf[len] = '\0';
		str += len + 1; /* add one to length to skip over newline character */

		if ((count = sscanf_s(linebuf, "%s %s", tail, _countof(tail), username, VO_NAME_SIZE))){
			vo_alloc_rows(BarrOverrideVO, 1);
			strcpy_s(VP(BarrOverrideVO, BarrOverrideVO->count - 1, "Tail", char), N_TAIL_SIZE, tail);
			strcpy_s(VP(BarrOverrideVO, BarrOverrideVO->count - 1, "username", char), USERNAME_SZ, username);
		}

	} while (*str != '\0');
	D_CONTROL("BARR", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) BarrOverrideVO='%s'\n", cdwThreadId, vo_printstr(BarrOverrideVO)));
	return(BarrOverrideVO);
}

VO *GetBarrVO(struct InstanceData* id)
{
	static VO *BarrVO;
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char username[VO_NAME_SIZE], urltime[VO_NAME_SIZE];
	char outbuf[100000]; // big temp buffer for all of the barr data
	static int firsttime = 1;
	time_t secs;
	char *str, *endstr;
	char linebuf[512];
	int len, pflag = 0;
	struct timeb start_time, done_time;
	const DWORD cdwThreadId = GetCurrentThreadId();


	if (BarrVO){
		return(BarrVO);
	}

	BarrVO = (VO *)vo_create(0, NULL);
	vo_set(BarrVO, V_NAME, "BarrVO", NULL);

	VOPropAdd(BarrVO, "TailNumber", NTBSTRINGBIND, N_TAIL_SIZE, VO_NO_ROW);
	vo_rm_rows(BarrVO, 0, BarrVO->count);


	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	strcpy_s(username, VO_NAME_SIZE, "pulse");
	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=GetBARR&username=%s", username);
	if (pflag){
		printf("GetBarrVO, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	}
	if (timeflag){ ftime(&start_time); }

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), tmpstr);

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Call to %s failed, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return(NULL);
	}

	if (timeflag) {
		ftime(&done_time);
	}

	if (chunk.memory){
		strncpy_s(outbuf, _countof(outbuf), chunk.memory, sizeof(outbuf));
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No BARR data retrieved from server.\n",
			cdwThreadId);
		return(NULL);
	}

	str = outbuf;

	do {
		if (!(endstr = strchr(str, '\n'))){
			break;
		}
		len = endstr - str;
		strncpy_s(linebuf, _countof(linebuf), str, len);
		linebuf[len] = '\0';
		str += len + 1; /* add one to length to skip over newline character */

		if ((len = strlen(linebuf)) < 8 && len > 0){
			vo_alloc_rows(BarrVO, 1);
			strcpy_s(VP(BarrVO, BarrVO->count - 1, "TailNumber", char), N_TAIL_SIZE, linebuf);
		}

	} while (*str != '\0');
	D_CONTROL("BARR", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) BarrVO='%s'\n", cdwThreadId, vo_printstr(BarrVO)));
	return(BarrVO);
}


ARPT *FindArptRow(struct InstanceData* id, char *arpt, int match_type)
{
	static char **result;
	ARPT key;
	char icao[12];

	/* use Arpts struct to find the arpt */
	// Make sure Arpts has been loaded.
	if (id->m_bArptLoaded){

		/* if match_type == EXACT_MATCH, then do not try alternate extensions. We need this logic for cases
		like ATL, where we do NOT want to match to PATL */

		if (strlen(arpt) == 3){
			strncpy_s(key.icao, ARPTNAME_SZ, arpt, 4);
			StrUpper(key.icao);

			result = (char **)bsearch((char *)&key, (char *)id->m_pArpts, id->m_nArptCount,
				sizeof(ARPT), (int(*)(const void*, const void*)) compareArpt);
			if (result || match_type == MATCH_EXACT){
				//vo_log_info(id->m_pfVoLogFile, __FUNCTION__,  "\n(0x%X) %s found at %Fp\n", GetCurrentThreadId(), *result, result );
				return((ARPT *)result);
			}
			/* 3 letter code not found, try US with 'K' */
			/* convert into icao code, assume US for first pass */
			_snprintf_s(icao, 12, _TRUNCATE, "K%s", arpt);
			StrUpper(icao);
			strncpy_s(key.icao, ARPTNAME_SZ, icao, 4);
		} else {
			strncpy_s(key.icao, ARPTNAME_SZ, arpt, 4);
			StrUpper(key.icao);
		}

		result = (char **)bsearch((char *)&key, (char *)id->m_pArpts, id->m_nArptCount,
			sizeof(ARPT), (int(*)(const void*, const void*)) compareArpt);
		if (result || match_type == MATCH_EXACT){
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__,  "\n(0x%X) %s found at %Fp\n", GetCurrentThreadId(), *result, result );
			return((ARPT *)result);
		} else if ( strlen( arpt ) == 3 ){
			/* try canadian airports */
			sprintf_s(icao, 12, "C%s", arpt);
			StrUpper(icao);
			strncpy_s(key.icao, ARPTNAME_SZ, icao, 4);
			result = (char **)bsearch((char *)&key, (char *)id->m_pArpts, id->m_nArptCount,
				sizeof(ARPT), (int(*)(const void*, const void*)) compareArpt);
			if (result){
				//vo_log_info(id->m_pfVoLogFile, __FUNCTION__,  "\n(0x%X) %s found at %Fp\n", GetCurrentThreadId(), *result, result );
				return((ARPT *)result);
			} else if ( strlen( arpt ) == 3 ){
				/* try pacific airports, like PANC, PHNL */
				sprintf_s(icao, 12, "P%s", arpt);
				StrUpper(icao);
				strncpy_s(key.icao, ARPTNAME_SZ, icao, 4);
				result = (char **)bsearch((char *)&key, (char *)id->m_pArpts, id->m_nArptCount,
					sizeof(ARPT), (int(*)(const void*, const void*)) compareArpt);
			}
			return((ARPT *)result);
		} else if ( strlen( arpt ) == 4 ){
			/* might be a US airline, which we get from FAA database that only uses 3 character ID's */
			if (arpt[0] == 'K'){
				strncpy_s(key.icao, ARPTNAME_SZ, &arpt[1], 3);
				result = (char **)bsearch((char *)&key, (char *)id->m_pArpts, id->m_nArptCount,
					sizeof(ARPT), (int(*)(const void*, const void*)) compareArpt);
				return((ARPT *)result);
			}
			if (arpt[0] == 'P'){
				strncpy_s(key.icao, ARPTNAME_SZ, &arpt[1], 3);
				result = (char **)bsearch((char *)&key, (char *)id->m_pArpts, id->m_nArptCount,
					sizeof(ARPT), (int(*)(const void*, const void*)) compareArpt);
				return((ARPT *)result);
			}
		}
	}


	return((ARPT *)NULL);
}

int IsBARRFlight(struct InstanceData* id, char *FltNum)
{
	VO *BarrVO, *BarrOverridesVO;
	struct row_index *row_index;
	char buf[9];
	int count = 0;

	if (FltNum && strlen(FltNum)){
		strncpy_s(buf, 9, FltNum, _TRUNCATE);
		StrUpper(buf);
		while (!(BarrVO = GetBarrVO(id)) && count++ < 5);
		count = 0;
		while (!(BarrOverridesVO = GetBarrOverridesVO(id)) && count++ < 5);

		if (!BarrVO){
			// must be temp net problem
			return(TRUE); // assume BARR flights until we get the barr list
		}

		if ((row_index = (struct row_index *) vo_search(BarrVO, "TailNumber", buf, NULL))){
			// found a BARR restricted flight, do not show flight to class 2 users
			return(TRUE);
		}
	}

	return(FALSE);
}


int UpdASDAircraft(struct InstanceData* id, struct feedstruct *record)
{
	double x, y, prevlat, prevlng; /* screen position */
	int AI, len;
	char *str, *FltRoute;
	PTRACK *trackarr;
	AIR **airp;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flightid='%s' rectype=%d\n", cdwThreadId, record->FltNum, record->rectype));
	//if ( !strcmp( record->FltNum, "N888FM" ) ){
	//  vo_log_info(id->m_pfVoLogFile, "test", "test\n");
	//}
	//if ( record->TrackID == 5573 ){
	//  vo_log_info(id->m_pfVoLogFile, "test", "test\n");
	//}

	if (record->eventtime < 0){
		// bad record found
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad record, utc=%d\n", cdwThreadId, record->eventtime);
		return(FAIL);
	}
	if (record->TrackID >= N_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		// MyStop();
		return(SUCCEED);
	}

	airp = GetASDAirP(id);

	if (!(air = airp[record->TrackID])){
		// no tracks yet
		air = GetASDAir(airp, record->TrackID);

		AI = record->TrackID;
		air->trackid = record->TrackID;
		if (record->rectype == 10 && !strlen(record->destin) &&
			strcmp(air->FltNum, record->FltNum)){
			// record from tz without previous hdr, clear out old fields
			ClearAirFields(air);
			air->trackid = record->TrackID;
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TZ rec without hdr, trackid = %d, Prev FltNum='%s'\n",
				cdwThreadId, record->TrackID, air->FltNum));

		}
		strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI));
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		CkNewASDOverlap(id, air);
	} else {
		// track already exists
		AI = record->TrackID;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
		if (!strlen(air->FltNum)){
			strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		}
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		CkNewASDOverlap(id, air);
	}

	if (IsBARRFlight(id, record->FltNum)){
		// flight is in BARR list
		if (!id->m_bDHSPerm){
			if (id->m_nDelaySecs < 1800){
				// Mark the flight as blocked
				air->IsBARR = TRUE;
				D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) aircraft fltnum=%s marked as blocked from BARR.\n",
					cdwThreadId, record->FltNum));
			} else {
				// flight is in replay mode so show it
			}
		} else {
			// DHS allowed to see flights
		}
	}

	if (strlen(record->src_radar)){
		strncpy_s(air->src_radar, 6, record->src_radar, 5);
	} else if ( record->rectype == 11 ){
		// make sure the record does not get deleted by IsBadTracks , so set to ETMS
		strncpy_s(air->src_radar, 6, "ETMS", 5);
	}


	if (record->rectype == 9){

		//if ( !strcmp( record->FltNum , "AAL1166" )){
		//	vo_log_info(id->m_pfVoLogFile, "test code", "found it\n");	
		//}	
		/* ASD Header record */
		STrimRight(record->FltNum);
		STrimRight(record->origin);
		STrimRight(record->destin);
		strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		if (strlen(record->origin) && HasPrintStr(record->origin)){
			strncpy_s(air->Origin, ORIG_DES_SIZE + 1, record->origin, ORIG_DES_SIZE);
		}
		if (strlen(record->destin) && HasPrintStr(record->destin)){
			strncpy_s(air->Destin, ORIG_DES_SIZE + 1, record->destin, ORIG_DES_SIZE);
			air->Destin[ORIG_DES_SIZE - 1] = '\0';
		}

		if (strlen(record->actype)){
			if (!HasPrintStr(record->actype)){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
			} else {
				strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
			}
		}

		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "\nrectype 9, fltnum=%s Des=%s origin=%s\n", air->FltNum,
			air->Destin, air->Origin));

		if (record->TrackID != air->trackid){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad trackid for fltnum=%s record->trackid=%d airvo trackid=%d\n",
				cdwThreadId, record->FltNum, record->TrackID, air->trackid);
			// MyStop();
		}
		air->trackid = record->TrackID;
		if (record->eta != 0){
			air->eta = (int)record->eta;
		} else {
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) 0 eta found for '%s', keeping %d\n",
				cdwThreadId, record->FltNum, air->eta));
		}

		if (record->etd != 0){
			air->atd = (int)record->etd;
		}

		if (record->speed){
			air->speed = record->speed;
		}
		if ((len = strlen(record->route)) > 0 && len < MAX_ROUTE_SIZE && HasPrintStr(record->route)){
			if (!(air->FltRouteOrig)){
				/* first route, so save this forever to be able to draw route from the beginning */
				FltRoute = malloc(len + 1);
				strcpy_s(FltRoute, len + 1, record->route);
				air->FltRouteOrig = FltRoute;
			}
			if (!(str = air->FltRoute)){
				FltRoute = malloc(len + 1);
				strcpy_s(FltRoute, len + 1, record->route);
				air->FltRoute = FltRoute;
			} else {
				/* if different, then free and malloc again */
				if (strcmp(str, record->route)){
					free(str);
					FltRoute = malloc(len + 1);
					strcpy_s(FltRoute, len + 1, record->route);
					air->FltRoute = FltRoute;
				} else {
					/* it's the same route, so do nothing */
				}
			}
		}
		// end of type9 processing
	} else if ( record->rectype == 3 ){
		// these no longer included in ASD feed, see type 12
		if (AI >= 0){
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing track, got rectype 3 for '%s', trackid='%d'\n",
				cdwThreadId, air->FltNum, air->trackid));
			RemoveASDTrack(id, airp, AI, TRUE);
			// SaveASDRemoveRecord( record );
		}
		return(SUCCEED);
	} else if ( record->rectype == 10 ){
		// TZ record, no header information
		// may be before hdr info, so save flightid
		if (!strlen(air->FltNum)){
			STrimRight(record->FltNum);
			strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
		}
		if (strcmp(record->FltNum, air->FltNum)){
			// fltnumbers differ
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Flt ID's mismatch record->Fltnum='%s' Vp='%s'\n",
				cdwThreadId, record->FltNum, air->FltNum);
			ClearAirFields(air);
			air->trackid = record->TrackID;
			STrimRight(record->FltNum);
			strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
		}
	} else if ( record->rectype == 11 ){
		if (strlen(record->origin) && HasPrintStr(record->origin)){
			strncpy_s(air->Origin, ORIG_DES_SIZE + 1, record->origin, ORIG_DES_SIZE);
		}
		if (strlen(record->destin) && HasPrintStr(record->destin)){
			strncpy_s(air->Destin, ORIG_DES_SIZE + 1, record->destin, ORIG_DES_SIZE);
		}
		if (record->eta){ // dont write over good eta
			air->eta = (int)record->eta;
		}
		return(SUCCEED);
	} else if ( record->rectype == 12 && record->qualifier == 'A' ){
		if (strlen(record->origin) && HasPrintStr(record->origin)){
			strncpy_s(air->Origin, ORIG_DES_SIZE + 1, record->origin, ORIG_DES_SIZE);
		}
		if (strlen(record->destin) && HasPrintStr(record->destin)){
			strncpy_s(air->Destin, ORIG_DES_SIZE + 1, record->destin, ORIG_DES_SIZE);
		}
		if (record->eta){ // dont write over good eta
			air->eta = (int)record->eta;
		}
		if (record->eta > id->m_tPlotTime){
			// future eta, do not stop tracks
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) got FUTURE rectype 12 (AZ) for '%s', trackid='%d'\n",
				cdwThreadId, air->FltNum, air->trackid));
			air->ata = (int)record->eta;
		} else {
			D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing track, got rectype 12 (AZ) for '%s', trackid='%d'\n",
				cdwThreadId, air->FltNum, air->trackid));
			// should we allow aircraft to time out normally? Or save this somewhere?
			air->ata = (int)record->eta;
			// do not remove until tracks time out, should stop extrapolation, however--- RemoveASDTrack( AirVO, AI , TRUE );
			return(SUCCEED);
		}
	}

	if (id->m_tPlotTime < 10000 || id->m_tDelayTime <= -9999){
		// firsttime set plottime

		// Only change plottime if behind, prevents staggered results from multiple feeds
		if (id->m_tPlotTime < record->eventtime){
			id->m_tPlotTime = record->eventtime;

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, record->eventtime);

		}
		/* some tracks are slower than others, so jump up since
		we take latest track */

	}
	if ((trackarr = air->TrackPtr) &&
		record->eventtime < (air->utc + ASD_NEXT_TRACK_OK)){
		/* latest point is in the past, or too soon. It must be from another radar
		so do not use it */
		// verify time of last track, since previous utc may be from hdr track type 9, or 11
#ifdef USE_PREV_RADAR   
		// is this needed??
		if ( TrackVO->count ){
			prevutc = VV(TrackVO, TrackVO->count - 1, "utc", int );
			// prev_radar = VP(TrackVO, TrackVO->count - 1, "src_radar", char );
			if ( record->eventtime < (prevutc + ASD_NEXT_TRACK_OK ) 
				&& strcmp(prev_radar, record->src_radar) ){
				// time too short and diff radars
				if ( pflag ){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flight %s point is in past, or too soon, prev=%d utc=%d\n",
						cdwThreadId, air->FltNum, prevutc, record->eventtime );
				}
				return( SUCCEED );
			} else if ( record->eventtime < (prevutc + ASD_SAME_TRACK_OK ) ){
				// time too short, even for the same radar
				if ( pflag ){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flight %s point is in past, or too soon, prev=%d utc=%d\n",
						cdwThreadId, air->FltNum, prevutc, record->eventtime );
				}
				return( SUCCEED );
			}
		}
#endif
	}

	if (!id->m_tASDFileTime){
		id->m_tASDFileTime = time(0);
	}
	if (record->eventtime > id->m_tLatestASDtime && record->eventtime < id->m_tASDFileTime + 20){
		// do not use time(0) since users clock may be off and that will cause updates to stop
		// Must test to see what ramifications are of bad times in ASD data, which does happen
		//if ( record->eventtime > (time(0) + 300) ){
		/* time is in the future, assume bad time */
		//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) record->eventtime is in the future, assume bad time\n", cdwThreadId);
		//} else {

		// for sanity check, since ASD has bad times, if this time is more than 1 minute ahead
		// of the file time, then ignore it
		id->m_tLatestASDtime = record->eventtime;
		//}
	}
	CalcASDLatLon(record, &x, &y, &prevlng, &prevlat);

	if (id->m_bUserHasLondon){
		// do not filter out london data
	} else {
		if ((fabs(x) < 14.0) && (fabs(x) > 0.0001) &&
			(fabs(y - 52.0) < 14.0)){
			// London data, cannot use this data
			RemoveASDTrack(id, airp, AI, TRUE);
			// SaveASDRemoveRecord( record );
			return(FAIL);
		}
	}

	air->CurX = (GLfloat)x;
	air->CurY = (GLfloat)y;

	air->X2 = (GLfloat)x;
	air->Y2 = (GLfloat)y;

	air->X1 = (GLfloat)prevlng;
	air->Y1 = (GLfloat)prevlat;

	// VV(AirVO, AI, "PrevX", double ) = prevlng;
	// VV(AirVO, AI, "PrevY", double ) = prevlat;

	air->utc = (int)record->eventtime;
	if (record->rectype == 9){
		// VV(AirVO, AI, "prevtime", int ) = record->prevtime;
	}
	air->altitude = record->altitude;


	if (strlen(record->actype)){
		if (!HasPrintStr(record->actype)){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
		} else {
			strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
		}
	}
	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) rectype=%d, flt '%s' trackid=%d x=%g y=%g\n",
		cdwThreadId, record->rectype, air->FltNum, record->TrackID, air->CurX, air->CurY));



	if (!record->feedx || !record->feedy){
		// do not add trail if no lat/lon info. (DZ) records do not have lat/lon.
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Skipping report w/o position\n", cdwThreadId));
	} else if ( record->rectype == 12 ){
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Skipping type 12, rectype=%d, flt '%s' trackid=%d x=%g y=%g\n",
			cdwThreadId, record->rectype, air->FltNum, record->TrackID, air->CurX, air->CurY));
	} else {
		AddTrail(id, air, AI, record, TRUE, MAX(MIN(ASD_TRACK_MODIFIER(id->m_sCurLayout.m_nAsdiTrailCount), ASD_TRACK_MODIFIER(MAX_ASD_TRACK_POINTS)), 5));
	}

#if DHS
	if ( DHSOutfile ){
		SaveASDOutRecord( record, AirVO, AI );
	}
#endif

	return(SUCCEED);
}

// Deletes ADSB Flights for change of PASSUR(and ASDEX) Airport
int ResetADSBTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	// Remove ASDEX Aircraft
	airp = GetADSBAirP(id);
	if (airp){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks for ADSB flights\n", GetCurrentThreadId());
	}

	/* clear out all current tracks */
	for (i = 0; i < N_ADSB_TRACK_ID; i++){
		if ((air = airp[i])){
			RemoveTrack(id, airp, i, ADSB, FALSE);
		}
	}

	return (SUCCEED);
}

// Deletes AirAsia Flights for change of ?
int ResetAirAsiaTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	// Remove AirAsia Aircraft
	airp = GetAirAsiaAirP(id);
	if (airp){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks for AirAsia flights\n", GetCurrentThreadId());
	}

	/* clear out all current tracks */
	for (i = 0; i < N_AIRASIA_TRACK_ID; i++){
		if ((air = airp[i])){
			RemoveTrack(id, airp, i, ADSB, FALSE);
		}
	}

	return (SUCCEED);
}

// Deletes ASDEX Flights for change of PASSUR(and ASDEX) Airport
int ResetASDEXTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	// Remove ASDEX Aircraft
	airp = GetASDEXAirP(id);
	if (airp){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks for ASDEX flights\n", GetCurrentThreadId());
	}

	/* clear out all current tracks */
	for (i = 0; i < N_PASSUR_TRACK_ID; i++){
		if ((air = airp[i])){
			RemoveTrack(id, airp, i, ASDEX, FALSE);
		}
	}

	// Clear out ROI Records
	if (id->m_pROIDataVO) {
		vo_rm_rows(id->m_pROIDataVO, 0, ((VO*)(id->m_pROIDataVO))->count);
	}

	return (SUCCEED);
}

// Deletes LMG Flights 
int ResetLMGTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	// Remove LMG Aircraft
	airp = GetLMGAirP(id);
	if ( airp ){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks for LMG flights\n", GetCurrentThreadId() );
	}

	/* clear out all current tracks */
	for (i = 0; i < N_TRACK_ID; i++ ){
		if ( (air = airp[i] )){
			RemoveTrack( id, airp, i, LMG, FALSE  );
		}
	}

	return ( SUCCEED );
}

int ResetGateTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	// Remove Gate Aircraft
	airp = GetGateAirP(id);
	if (airp){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks from Gate Message Data\n", GetCurrentThreadId());
	}

	/* clear out all current tracks */
	for (i = 0; i < N_TRACK_ID; i++){
		if ((air = airp[i])){
			RemoveTrack(id, airp, i, GATE, FALSE);
		}
	}
	return (SUCCEED);
}


// Deletes NOISE Flights for change
int ResetNoiseTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	// Remove Noise Aircraft
	airp = GetNoiseAirP(id);
	if (airp){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks for NOISE flights\n", GetCurrentThreadId());
	}

	/* clear out all current tracks */
	for (i = 0; i < N_NOISE_TRACK_ID; i++){
		if ((air = airp[i])){
			RemoveTrack(id, airp, i, NOISE, FALSE);
		}
	}

	return (SUCCEED);
}

// Deletes PASSUR Flights for change of PASSUR Airport
int ResetPASSURTracks(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;

	airp = GetAirP(id, 0);
	if (airp){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ALL tracks for Passur flights\n", GetCurrentThreadId());
	}

	/* clear out all current PASSUR tracks */
	for (i = 0; i < N_PASSUR_TRACK_ID; i++){
		if ((air = airp[i])){
			RemoveTrack(id, airp, i, PASSUR, FALSE);
		}
	}

	return(SUCCEED);
}

// Deletes ASD Flights
int ResetASDTracks(struct InstanceData* id)
{
	static int pflag = 0;
	AIR **airp;
	AIR *air;
	int i;

	airp = GetASDAirP(id);
	// clear out all current tracks
	for (i = 0; i < N_TRACK_ID; i++){
		if (pflag && ((air = airp[i]))){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing ASD flight '%s', trackid='%d'\n",
				GetCurrentThreadId(), air->FltNum, air->trackid);
		}
		RemoveASDTrack(id, airp, i, FALSE);
	}

	return(SUCCEED);
}

void ResetPlanned(struct InstanceData* id)
{
	EnterCriticalSection(&id->m_csPlanned);
	vo_free(id->m_pPlannedDepVO);
	id->m_pPlannedDepVO = NULL;
	vo_free(id->m_pPlannedArrVO);
	id->m_pPlannedArrVO = NULL;
	id->m_tPlannedFileTime = 0;
	id->m_tLastPlannedGetTime = 0;
	id->m_LastASDEXFillTags = 0;
	SetEvent(id->m_evPlannedReset);
	LeaveCriticalSection(&id->m_csPlanned);

}



int ResetTracks(struct InstanceData* id, int ClearASD)
{
	ResetPlanned(id);
	ResetPASSURTracks(id);
	ResetASDEXTracks(id);
	ResetADSBTracks(id);
	ResetAirAsiaTracks(id);
	ResetNoiseTracks(id);
	ResetGateTracks(id);
	ResetLMGTracks(id);

	if (ClearASD) {
		ResetASDTracks(id);
	}

	id->m_tPlotTime = 0;
	delaystartsecs = 0;

	id->m_pSelectedAircraft = NULL;
	Callback2Javascript(id, "UpdateSelected:");

	return(SUCCEED);
}



void FreeHisVO()
{
	int i;
	VO *HistoricalTrackVO, *HistoricalHdrVO;

	for (i = 0; HisVO && i < HisVO->count; i++){

		HistoricalTrackVO = VV(HisVO, i, "HTrackVO", void *);
		HistoricalHdrVO = VV(HisVO, i, "HHdrVO", void *);

		if (HistoricalTrackVO && HistoricalHdrVO){// empty, so clear out VO's 
			vo_free(HistoricalTrackVO);
			vo_free(HistoricalHdrVO);
		}

	}
	vo_free(HisVO);
	HisVO = NULL;

}




void ReplayStop(struct InstanceData* id)
{
	int nSelItems, lword, hword, parval;
	HWND hwndList;

	id->m_nDelaySecs = 0;
	id->m_tPlotTime = 0;
	id->m_tDelayTime = 0;
	id->m_dDelayMSecs = 0;
	id->m_bResetTracks = TRUE;
	id->m_bResetASDTracks = TRUE;

	// stop block mode if activated
	if (HisVO && HisVO->count > 0){
		// HistoricalCount = 0;
		// clear out list of rows in dialog
		hwndList = GetDlgItem(id->m_hDlgBlockReplayDialog, IDC_BLOCK_FLIGHTS_LIST);
		nSelItems = SendMessage(hwndList, LB_GETSELCOUNT, 0, 0);
		lword = 0;  // low order bits are for the start index
		hword = nSelItems << 16;  // last item to deselect
		parval = hword + lword;
		SendMessage(hwndList, LB_SELITEMRANGE, 0, parval);
		BlockSelectedBuffer[0] = -1;
		if (id->m_hDlgBlockReplayDialog){
			ShowWindow(id->m_hDlgBlockReplayDialog, SW_HIDE);
		}

		FreeHisVO();
	}

	SetEvent(id->m_evAirDataReset);
}



VO *NewTrack()
{
	VO *TrackVO;

	TrackVO = vo_create(0, NULL);
	vo_set(TrackVO, V_NAME, "TrackVO", NULL);

	VOPropAdd(TrackVO, "X", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(TrackVO, "Y", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(TrackVO, "utc", INTBIND, -1, VO_NO_ROW);
	// not needed   31jul 2009 VOPropAdd( TrackVO, "src_radar", NTBSTRINGBIND, 5, VO_NO_ROW );


	vo_rm_rows(TrackVO, 0, TrackVO->count);

	return(TrackVO);
}



VO *NewHdrTrack()
{
	VO *TrackVO;

	TrackVO = vo_create(0, NULL);
	vo_set(TrackVO, V_NAME, "TrackVO", NULL);

	VOPropAdd(TrackVO, "flightid", NTBSTRINGBIND, 9, VO_NO_ROW);
	VOPropAdd(TrackVO, "fromto", NTBSTRINGBIND, 10, VO_NO_ROW);
	VOPropAdd(TrackVO, "actype", NTBSTRINGBIND, 9, VO_NO_ROW);
	VOPropAdd(TrackVO, "src_radar", NTBSTRINGBIND, 5, VO_NO_ROW);
	VOPropAdd(TrackVO, "startsecs", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(TrackVO, "endsecs", INTBIND, -1, VO_NO_ROW);

	vo_rm_rows(TrackVO, 0, TrackVO->count);

	return(TrackVO);
}







void ClearEmptyHistoricalTracks(struct InstanceData* id)
{
	int i;
	VO *HistoricalTrackVO, *HistoricalHdrVO;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!HisVO){
		return;
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) starting count =%d\n", cdwThreadId, HisVO->count);

	for (i = 0; HisVO && i < HisVO->count; i++){

		HistoricalTrackVO = VV(HisVO, i, "HTrackVO", void *);
		HistoricalHdrVO = VV(HisVO, i, "HHdrVO", void *);

		if (HistoricalTrackVO && !HistoricalTrackVO->count){
			// empty, so clear out VO's 
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing flight %s\n", cdwThreadId, VP(HistoricalHdrVO, 0, "flightid", char));
			vo_free(HistoricalTrackVO);
			vo_free(HistoricalHdrVO);

			vo_rm_row(HisVO, i);
			i--;
		}

	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ending count =%d\n", cdwThreadId, HisVO->count);
}



#ifdef OLDWAY
if ( pflag ){  // verbose log stuff
	for ( i = 0; i < HistoricalCount; i++ ){ 
		HistoricalHdrVO = HistoricalHdrsVO[i];
		HistoricalTrackVO = HistoricalTracksVO[i];
		if ( ( !HistoricalTrackVO || !HistoricalTrackVO->count ) && HistoricalCount ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "flight id %s has no tracks, HistoricalCount=%d i=%d\n", 
				VP(HistoricalHdrVO, 0, "flightid", char) , HistoricalCount, i);
		} else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "flight id %s has %d tracks, HistoricalCount=%d i=%d\n", 
				VP(HistoricalHdrVO, 0, "flightid", char),
				HistoricalTrackVO->count , HistoricalCount, i );
		}
	}
}
#endif


#ifdef OLDWAY
for ( i = 0; i < HistoricalCount; i++ ){  // count - 1 since we need at least 2 

	HistoricalHdrVO = HistoricalHdrsVO[i];
	HistoricalTrackVO = HistoricalTracksVO[i];
	if ( ( !HistoricalTrackVO || !HistoricalTrackVO->count ) && HistoricalCount ){
		// no tracks, so delete the header and empty trackvo


		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "removing flight id %s , no tracks, HistoricalCount=%d i=%d\n", 
			VP(HistoricalHdrVO, 0, "flightid", char) , HistoricalCount, i);

		if ( HistoricalCount - i - 1 > 0 ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "copy %d records from %d to %d\n", HistoricalCount - i - 1 ,
				i + 1, i);
			memcpy( &HistoricalTracksVO[i], &HistoricalTracksVO[i + 1], sizeof(VO *) * (HistoricalCount - i - 1) );
			memcpy( &HistoricalHdrsVO[i], &HistoricalHdrsVO[i + 1], sizeof(VO *) * (HistoricalCount - i - 1) );
		} else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "skipping copy of flight id %s has no tracks, HistoricalCount=%d\n", 
				VP(HistoricalHdrVO, 0, "flightid", char) , HistoricalCount);
		}

		HistoricalCount--;
		i--;
	} else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "keeping flight id %s has %d tracks, HistoricalCount=%d i=%d\n", 
			VP(HistoricalHdrVO, 0, "flightid", char),
			HistoricalTrackVO->count , HistoricalCount, i );
	}
}

//  test -- print out results
for ( i = 0; i < HistoricalCount; i++ ){ 
	HistoricalHdrVO = HistoricalHdrsVO[i];
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "final flight id %s  HistoricalCount=%d i=%d\n", 
		VP(HistoricalHdrVO, 0, "flightid", char) , HistoricalCount, i);
}


#endif


VO *CreateHisVO()
{
	VO *HisVO;


	HisVO = (VO *)vo_create(0, NULL);
	vo_set(HisVO, V_NAME, "HisVO", NULL);


	VOPropAdd(HisVO, "HTrackVO", VOIDBIND, -1, VO_NO_ROW);
	VOPropAdd(HisVO, "HHdrVO", VOIDBIND, -1, VO_NO_ROW);

	vo_rm_rows(HisVO, 0, HisVO->count);
	return(HisVO);
}





int ProcessHistoricalTracks(struct InstanceData* id, char *text, int blockmode)
{
	// retrieve all the track data for the block in question
	// ported from ProcessHistoricalTracks in PI

	char linebuf[TMPBUF_SIZE];
	char flightid[128], fromto[128], actypebuf[128], src_radar[128],
		unixtimebuf[128], timebuf[128];
	// char tmpstr[TMPBUF_SIZE];
	char *str, *endstr;
	int len, nmatches, altitude;
	double lng, lat;
	int trackcount = 0;
	VO *HistoricalTrackVO = NULL; // index to the current track[]
	VO *HistoricalHdrVO = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();



	if (!text || !strlen(text)){
		return(FALSE);
	}


#ifdef OLDWAY
	if ( !HistoricalTracksVO[0] ){
		for (i = 0; i < MAX_HISTORICAL_TRACKS; i++ ){
			HistoricalTracksVO[i] = NewTrack();
			vo_set( HistoricalTracksVO[i], V_ORDER_COLS, "utc", NULL, NULL );
			HistoricalHdrsVO[i] = NewHdrTrack();
		}
	}
#endif

	// HistoricalCount = 0;

	src_radar[0] = '\0';

	str = text;
	do {
		if (!(endstr = strchr(str, '\n'))){
			break;
		}
		len = endstr - str;
		if (len < 128){
			strncpy_s(linebuf, sizeof(linebuf), str, len);
			linebuf[len] = '\0';
			str += len + 1; /* add one to length to skip over newline character */

			if (!strncmp(linebuf, "Flight", 6)){
				// new track
				//HistoricalCount++;
				//if ( HistoricalCount >= MAX_HISTORICAL_TRACKS ){
				//	HistoricalCount = MAX_HISTORICAL_TRACKS - 1;
				//	break; // too many tracks
				//}


				nmatches = sscanf_s(linebuf, "Flight: %s %s A/C Type: %s Source: %s",
					flightid, sizeof(flightid), fromto, sizeof(fromto), actypebuf, sizeof(actypebuf), src_radar, sizeof(src_radar));


				//HistoricalTrackVO = HistoricalTracksVO[HistoricalCount - 1];
				//HistoricalHdrVO = HistoricalHdrsVO[HistoricalCount - 1];

				if (!HisVO){
					HisVO = CreateHisVO();
				}
				if (HisVO->count < MAX_HISTORICAL_TRACKS - 2){
					vo_alloc_rows(HisVO, 1);
				} else {
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Too many tracks exceeding MAX_HISTORICAL_TRACKS =%d\n", 
						cdwThreadId, MAX_HISTORICAL_TRACKS);
					break;
				}
				VV(HisVO, HisVO->count - 1, "HTrackVO", void *) = NewTrack();
				VV(HisVO, HisVO->count - 1, "HHdrVO", void *) = NewHdrTrack();
				HistoricalTrackVO = VV(HisVO, HisVO->count - 1, "HTrackVO", void *);
				HistoricalHdrVO = VV(HisVO, HisVO->count - 1, "HHdrVO", void *);

				// clear out previous tracks
				//vo_rm_rows( HistoricalTrackVO, 0, HistoricalTrackVO->count );
				//vo_rm_rows( HistoricalHdrVO, 0, HistoricalHdrVO->count );

				// fill in hdr
				vo_alloc_rows(HistoricalHdrVO, 1);
				strncpy_s(VP(HistoricalHdrVO, HistoricalHdrVO->count - 1, "src_radar", char), 5, src_radar, 5);
				strncpy_s(VP(HistoricalHdrVO, HistoricalHdrVO->count - 1, "flightid", char), 9, flightid, 9);
				strncpy_s(VP(HistoricalHdrVO, HistoricalHdrVO->count - 1, "fromto", char), 10, fromto, 10);
				strncpy_s(VP(HistoricalHdrVO, HistoricalHdrVO->count - 1, "actype", char), 9, actypebuf, 9);

				//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flight id %s HistoricalCount-1=%d\n", 
				//    cdwThreadId, VP(HistoricalHdrVO, HistoricalHdrVO->count - 1, "flightid", char),  HistoricalCount - 1);


			} else if (HistoricalTrackVO) {

				if (!strncasecmp(linebuf, "No data found", 13)){
					// no data in range for this flight in specified time block range
				} else {

					if (blockmode){
						nmatches = sscanf_s(linebuf, "%s %lf %lf %d",
							unixtimebuf, sizeof(unixtimebuf), &lng, &lat, &altitude);
					} else {
						nmatches = sscanf_s(linebuf, "%s %s %lf %lf %d",
							timebuf, sizeof(timebuf), unixtimebuf, sizeof(unixtimebuf), &lng, &lat, &altitude);
					}

					if (nmatches == 4 || nmatches == 5){
						vo_alloc_rows(HistoricalTrackVO, 1);
						//strncpy( VP(HistoricalTrackVO, HistoricalTrackVO->count - 1, "src_radar", char ), src_radar, 5 );
						VV(HistoricalTrackVO, HistoricalTrackVO->count - 1, "utc", int) = atoi(unixtimebuf);
						VV(HistoricalTrackVO, HistoricalTrackVO->count - 1, "X", double) = lng;
						VV(HistoricalTrackVO, HistoricalTrackVO->count - 1, "Y", double) = lat;
					}
				}

			}

		} else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line too big, len =%d\n", cdwThreadId, len);
			break;
		}

	} while (*str != '\0');


	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) total  flights =%d\n", cdwThreadId, HistoricalCount );
	ClearEmptyHistoricalTracks(id);
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) total  flights after clearing empties=%d\n", cdwThreadId, HistoricalCount );

	/* sort rows into unixtime order */
	// vo_order( HistoricalTrackVO );
	//if ( HistoricalCount <= 0){
	//	sprintf_s(tmpstr, _countof(tmpstr), "Could not find valid tracks");
	// ShowMyMessage2(tmpstr, 50 );
	//} else if ( HistoricalCount == 0 ){

	//}


	// SmoothHistoricalTracks( );

	return(TRUE);

}




int ShowMessage(struct InstanceData* id, char *messagetext, int showsecs)
{

	//MyMessageStart = time(0);
	//MyMessageEnd = MyMessageStart + showsecs;
	if (!id->m_hDlgMessage){
		id->m_hDlgMessage = CreateDialogParam(id->m_hWTModule, MAKEINTRESOURCE(IDD_DIALOG1),
			NULL, MessageDlgCB, (LPARAM)id);
	}
	SetDlgItemText(id->m_hDlgMessage, IDC_MESSAGE_TEXT, messagetext);
	ShowWindow(id->m_hDlgMessage, SW_SHOW);
	return TRUE;
}



void GetBlockModeTracks(struct InstanceData* id, char *ArrDep, char *starttimestr, char *endtimestr, char *flightid, char *Arpt)
{
	struct MemoryStruct chunk, unzipped_chunk;
	static char stmonthbuf[256];
	static char styearbuf[5];
	static char stdaybuf[3];
	int stmonthnum = 0, stdaynum = 0;
	// static char flightid[12];
	char upperflight[16];
	char tmpstr[1024];
	int trycount = 0,allowed_tries;
	char StartDateTime[32], EndDateTime[32];
	time_t secs;
	int ret;
	int blockmode;
	char *servername;
	char message[80] = { 0 };
	// long timeout = 600L;
	long timeout = 1200L;   // make it 20 minutes since 10 minutes too little
	long starttime, endtime;
	const DWORD cdwThreadId = GetCurrentThreadId();


	// example url http://www3.passur.com/fcgi/FusedTracks.fcg?
	//     Action=BlockTracks&username=fwuser&pwd=rhino&Arpt=KJFK&StartDateTime=201212121130&EndDateTime=201212121200&ArrDep=Dep

	if (!id->m_pcurl_handle) {
		id->m_pcurl_handle = GetCurlHandle(id, SM_HTTPS);
	}
	if (flightid && strlen(flightid)){
		secs = DtStr2Secs(starttimestr, "%m/%d/%Y %H:%M %p");
		VOTimeFmt(StartDateTime, secs, "%Y%m%d");

		strcpy_s(upperflight, sizeof(upperflight), flightid);
		StrUpper(upperflight);
		blockmode = FALSE;
		sprintf_s(tmpstr, sizeof(tmpstr), "username=fwuser&ICAO=%s&format=xml&pwd=rhino&Action=TracksByFlightID"
			"&StartDate=%s", upperflight, StartDateTime);
	} else {
		blockmode = TRUE;
		// get all flights near airport during the time block
		if (!Arpt || strlen(Arpt) < 3){
			Arpt = "JFK";
		}
		secs = DtStr2Secs(starttimestr, "%m/%d/%Y %H:%M %p");
		VOTimeFmt(StartDateTime, secs, "%Y%m%d%H%M");

		secs = DtStr2Secs(endtimestr, "%m/%d/%Y %H:%M %p");
		VOTimeFmt(EndDateTime, secs, "%Y%m%d%H%M");

		sprintf_s(tmpstr, sizeof(tmpstr), "Action=BlockTracks&username=fwuser&pwd=rhino&Arpt=%s&StartDateTime=%s&EndDateTime=%s&ArrDep=%s",
			Arpt, StartDateTime, EndDateTime, ArrDep);
	}

	//Set  CrntFTrackSrvr to begining of the array for each user entry
	SetCrntFtrackSrvCnt0();
	//obatin the allowed number of tries
	allowed_tries = GetFTrackSrvCnt();

	starttime = time(0);

	while (trycount++ < allowed_tries){
		
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */

		//  matt cant use .net, so hardwire
		servername = GetFTrackSrvr(id);
		if (!strcmp(id->m_strUserName, "matt")){
			servername = "https://www3.passur.com/fcgi/FusedTracks.fcg";
		}

		// set longer timeout
		setCurlTimeout(id->m_pcurl_handle, timeout);
		if (!GetCurlFormGetResults_r(id, id->m_pcurl_handle, &chunk, servername, tmpstr, SM_HTTPS, TRUE)){
			GetNxtFTrackSrvr(id);
		}

		if (chunk.memory && chunk.size && (!strstr(chunk.memory, "Not Found")) && (!strstr(chunk.memory, "Error"))
			&& (!strstr(chunk.memory, "No data found"))){
			if (blockmode){
				// unzip the data
				if (chunk.memory) {
					unzipped_chunk.size = 0;
					unzipped_chunk.memory = NULL;
					ret = unzip_chunk(id, &chunk, &unzipped_chunk);
				}
				endtime = time(0);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "retrieved %d bytes in %d seconds\n", endtime - starttime, chunk.size);
				ProcessHistoricalTracks(id, unzipped_chunk.memory, blockmode);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "processed tracks\n");
				free(unzipped_chunk.memory);

			} else {
				ProcessHistoricalTracks(id, chunk.memory, blockmode);
			}
			free(chunk.memory);
			chunk.memory = NULL;
			break;
		} else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Historical Tracks from %s\n",
				cdwThreadId, GetFTrackSrvr(id));
			GetNxtFTrackSrvr(id);
			if (chunk.memory) {
				free(chunk.memory);
				chunk.memory = NULL;
			}
		}
	}
	endtime = time(0);

	if (!HisVO){
		// char message[80] = {0};
		endtime = time(0);
		if (endtime < starttime >= (timeout * allowed_tries)){
			ShowMessage(id, "Error Retrieving Tracks, timeout exceeded. Please Try Again", 300);
		} else {
			ShowMessage(id, "No Data Found", 30);
		}
		ReplayStop(id);
		id->m_bReplayStatus = REPLAY_STATUS_STOPPED;
		sprintf_s(message, _countof(message), "ReplayStatus:%s", "stopped");
		Callback2Javascript(id, message);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "Replay status set to \"Stopped\", no data\n");
	}
}




void LoadBlockFlights(HWND hwndList)
{
	VO *HistoricalHdrVO;
	char *flightid;
	int i, nItems;
	WPARAM wparam;


	// delete all list box items, if any
	nItems = SendMessage(hwndList, LB_GETCOUNT, 0, 0);
	for (i = nItems - 1; i >= 0; i--) {
		wparam = i;
		SendMessage(hwndList, LB_DELETESTRING, wparam, 0);
	}

	BlockSelectedBuffer[0] = -1;

	for (i = 0; HisVO && i < HisVO->count; i++){
		/* draw a line between all of the points */
		//HistoricalHdrVO = HistoricalHdrsVO[i];


		HistoricalHdrVO = VV(HisVO, i, "HHdrVO", void *);

		if (HistoricalHdrVO &&  HistoricalHdrVO->count){
			flightid = VP(HistoricalHdrVO, 0, "flightid", char);
			SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)flightid);
		}
		// default all flights to be selected
		BlockSelectedBuffer[i] = i;

	}
	if (HisVO && HisVO->count){
		SendMessage(hwndList, LB_SELITEMRANGEEX, 0, (short)HisVO->count - 1);
	}
}





int GoToArpt(struct InstanceData* id, char *srcarpt)
{
	char arpt[5];
	ARPT *Arpt;


	if (!srcarpt){
		return(FALSE);
	}
	strcpy_s(arpt, sizeof(arpt), srcarpt);
	StrUpper(arpt);

	if ((Arpt = FindArptRow(id, arpt, MATCH_ALL))){

		//  don't move if the user already has airport in view
		if (PtInRange(Arpt->lng, Arpt->lat)){
			// already in view of airport, so don't move or rescale
			return(FALSE);
		} else {

			if (id->m_sCurLayout.m_dWorldXSize > 10.0){
				ResizeWorld(id, Arpt->lng, Arpt->lat, 2.0f);
			} else {
				TranslateView(id, Arpt->lng, Arpt->lat);
			}

			ChangePassurAirport(id, arpt);

			/* NEW CHECK */
			strcpy_s(id->m_strAirportMap, ARPTNAME_SZ, arpt);
		}

	}

	return(SUCCEED);
}




VOID blockThread(void *parm)
{
	BLOCKPARMS *parms;
	const DWORD cdwThreadId = GetCurrentThreadId();


	parms = parm;

	/*
	parms.id = id;
	strcpy( parms.ArrDep, ArrDep );
	strcpy( parms.starttimestr, starttimestr );
	strcpy( parms.endtimestr, endtimestr );
	strcpy( parms.flightid, flightid );
	strcpy( parms.ReplayArpt, ReplayArpt );
	*/

	vo_log_info(parms->id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread Created\n", cdwThreadId, parms->id->m_nControlId);

	EnterCriticalSection(&parms->id->m_csBlock);
	ProcessingBlocks = TRUE;
	LeaveCriticalSection(&parms->id->m_csBlock);

	GetBlockModeTracks(parms->id, parms->ArrDep, parms->starttimestr, parms->endtimestr, parms->flightid, parms->ReplayArpt);

	EnterCriticalSection(&parms->id->m_csBlock);
	ProcessingBlocks = FALSE;
	ProcessLoadFlag = TRUE;
	LeaveCriticalSection(&parms->id->m_csBlock);


	/* _endthread given to terminate */
	vo_log_info(parms->id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread Terminated\n", cdwThreadId, parms->id->m_nControlId);
	_endthread();


}



ProcessBlockGUI(struct InstanceData* id)
{
	HWND hwndList;

	// close waiting window
	ShowWindow(id->m_hDlgMessage, SW_HIDE);


	// do not set replay parameters since we are going to draw these tracks in addition to existing tracks?
	// we should disable drawing of other tracks will block mode is in effect
	if (!id->m_hDlgBlockReplayDialog){
		id->m_hDlgBlockReplayDialog = CreateDialogParam(id->m_hWTModule, MAKEINTRESOURCE(IDD_BlockReplayDialog),
			/*id->m_hWnd*/NULL, Message2DlgBlockReplayCB, (LPARAM)id);
	}
	// load in flightid's into list box
	hwndList = GetDlgItem(id->m_hDlgBlockReplayDialog, IDC_BLOCK_FLIGHTS_LIST);
	//nSelItems = SendMessage(hwndList, LB_GETSELCOUNT, 0, 0); 
	//lword = 0;  // low order bits are for the start index
	//hword = (HistoricalCount - 1) << 16;  // last item to deselect
	//parval = hword + lword;
	//SendMessage( hwndList, LB_SELITEMRANGE, 0, parval);

	BlockSelectedBuffer[0] = -1;
	LoadBlockFlights(hwndList);

	ShowWindow(id->m_hDlgBlockReplayDialog, SW_SHOW);
	GoToArpt(id, ReplayArpt);

}




int ReplayCmd(struct InstanceData* id, char *linebuf)
{
	static BLOCKPARMS parms;
	char *str, *datestr, *endstr, *speedstr, *arptstr;
	time_t secs;
	char starttimestr[256] = { 0 };
	char endtimestr[256] = { 0 };
	int len, m, d, y, mn, h, count, speed;
	// int nSelItems, lword, hword, parval;
	char ampm[12];
	char *ArrDep;
	char * mode = NULL;


	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!linebuf){
		return(FALSE);
	}

	ReplayArpt[0] = '\0';
	if ((str = strstr(linebuf, "start=\""))){
		datestr = &str[7];
	} else {
		return(FALSE);
	}

	if (!(endstr = strchr(datestr, '"'))){
		return(FALSE);
	}


	if ((len = endstr - datestr) < sizeof(starttimestr)){
		strncpy_s(starttimestr, _countof(starttimestr), datestr, len);
		starttimestr[len] = '\0';
	} else {
		return(FALSE);
	}

	if ((str = strstr(linebuf, "end=\""))){
		datestr = &str[5];
		if (!(endstr = strchr(datestr, '"'))){
			return(FALSE);
		}
		if ((len = endstr - datestr) < sizeof(endtimestr)){
			strncpy_s(endtimestr, _countof(endtimestr), datestr, len);
			endtimestr[len] = '\0';
		}
	}
	if ((str = strstr(linebuf, "Arpt=\""))){
		arptstr = &str[6];
		if (!(endstr = strchr(arptstr, '"'))){
			return(FALSE);
		}
		if ((len = endstr - arptstr) < sizeof(ReplayArpt)){
			strncpy_s(ReplayArpt, _countof(ReplayArpt), arptstr, len);
			ReplayArpt[len] = '\0';
		}
	} else {
		strcpy_s(ReplayArpt, sizeof(ReplayArpt), id->m_strAirportMap);
	}


	if ((speedstr = strstr(linebuf, "speed=\""))){
		speedstr += 7;
		if ((count = sscanf_s(speedstr, "%dx", &speed))){
			if (speed == 1 || speed == 2 || speed == 5 || speed == 10){
				id->m_nReplaySpeed = speed;
			}
		} else {
			// In block mode

			char flightid[FLTNUM_SIZE + 1] = { 0 };

			// Always save current airport
			strncpy_s(SystemArpt, ARPTNAME_SZ, id->m_sCurLayout.m_strPassurArpt, _TRUNCATE);
			SystemArpt[ORIG_DES_SIZE - 1] = '\0';

			if ((mode = strstr(linebuf, "flight=\""))){
				endstr = strchr(mode + 8, '"');
				len = endstr - (mode + 8);// this len should never exceeded 8 characters
				strncpy_s(flightid, FLTNUM_SIZE + 1, mode + 8, len);
			}
			if ((mode = strstr(linebuf, "arrivals")) && (mode = strstr(linebuf, "departures"))){
				ArrDep = "Both";
			} else if (  (mode = strstr( linebuf, "arrivals" ) )){
				ArrDep = "Arr";
			} else if( (mode = strstr( linebuf, "departures" ) )){
				ArrDep = "Dep";
			} else {
				ArrDep = "Both";
			}

			parms.id = id;
			strcpy_s(parms.ArrDep, sizeof(parms.ArrDep), ArrDep);
			strcpy_s(parms.starttimestr, sizeof(parms.starttimestr), starttimestr);
			strcpy_s(parms.endtimestr, sizeof(parms.endtimestr), endtimestr);
			strcpy_s(parms.flightid, sizeof(parms.flightid), flightid);
			strcpy_s(parms.ReplayArpt, sizeof(parms.ReplayArpt), ReplayArpt);

			ShowMessage(id, "Loading Data, please wait", 20);
			_beginthread(blockThread, 0, (void *)&parms);

#ifdef OLDMOVED
			GetBlockModeTracks( id, ArrDep, starttimestr, endtimestr, flightid , ReplayArpt);
			// do not set replay parameters since we are going to draw these tracks in addition to existing tracks?
			// we should disable drawing of other tracks will block mode is in effect
			if( !id->m_hDlgBlockReplayDialog ){ 
				id->m_hDlgBlockReplayDialog = CreateDialogParam(id->m_hWTModule, MAKEINTRESOURCE (IDD_BlockReplayDialog), 
					/*id->m_hWnd*/NULL, Message2DlgBlockReplayCB, (LPARAM)id );
			}
			// load in flightid's into list box
			hwndList = GetDlgItem(id->m_hDlgBlockReplayDialog, IDC_BLOCK_FLIGHTS_LIST );
			//nSelItems = SendMessage(hwndList, LB_GETSELCOUNT, 0, 0); 
			//lword = 0;  // low order bits are for the start index
			//hword = (HistoricalCount - 1) << 16;  // last item to deselect
			//parval = hword + lword;
			//SendMessage( hwndList, LB_SELITEMRANGE, 0, parval);

			BlockSelectedBuffer[0] = -1;
			LoadBlockFlights( hwndList );
			ShowWindow(id->m_hDlgBlockReplayDialog, SW_SHOW );
			GoToArpt(id,  ReplayArpt );
#endif
			return(SUCCEED);
		}
	}

	// ADS-B Temp Code
	if ((str = strstr(linebuf, "adsb=\""))){
		char *adsbstr = NULL;
		adsbstr = &str[6];
		sscanf_s(adsbstr, "%d", &GUseADSB);
	}

	if ((count = sscanf_s(starttimestr, "%d/%d/%d %d:%d %s", &m, &d, &y, &h, &mn, ampm, _countof(ampm))) == 6){
		sprintf_s(starttimestr, _countof(starttimestr), "%02d/%02d/%d %02d:%02d%s",
			m, d, y, h, mn, ampm);
	}

	if ((secs = DtStr2Secs(starttimestr, "%m/%d/%Y %H:%M%p")) != -1){
		id->m_nDelaySecs = (int)(time(0) - secs + id->m_tServerAdjSecs);

		if (secs > 0){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New GDelaySecs=%d, time = %s\n",
				cdwThreadId, id->m_nDelaySecs, VOTimeFmt(starttimestr, (time(0) - id->m_nDelaySecs), "%Y-%m-%d %H:%M:%S"));
		}
		ExtrapolateMaxMSecs = 0;
	}
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Replay=%s\n", cdwThreadId, linebuf);

	id->m_bResetTracks = TRUE;
	id->m_bResetASDTracks = TRUE;
	SetEvent(id->m_evAirDataReset);

	id->m_tReplayStart = time(0);

	return(SUCCEED);
}

char *ReplayAction(char *buf)
{
	char *str, *endstr;
	int len;
	static char action[24];

	if (!buf){
		return(NULL);
	}

	if ((!strncmp(buf, "action=", 7))){
		str = &buf[8];
		if (!(endstr = strchr(str, '"'))){
			return(NULL);
		}
		if ((len = endstr - str) < sizeof(action)){
			strncpy_s(action, _countof(action), str, len);
			action[len] = '\0';
		} else {
			return(NULL);
		}
		return(action);
	}
	return(NULL);

}



void SetPassurDelaytime(struct InstanceData* id)
{
	struct timeb tb;

	ftime(&tb);
	id->m_tClientsTime = tb.time;

	if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from cl(%d), pl(%d): %d to %d\n;",
		GetCurrentThreadId(), id->m_tClientsTime, id->m_tPlotTime, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));
	id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
	id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;

}



// NAME: Replay - SendMessage callback, for "Play" 
// PURPOSE: Should start, stop or pause replay 
// INPUT: p - replay settings
// EXAMPLE(s): 
//	"action=\"play\"&start=\"1/11/2009 2:00 pm\"&speed=\"1x\""
//	"action=\"stop\""
int Replay(struct InstanceData* id, char* p)
{
	/* This function only has sample data */
	/* TODO: Extract message, perform action */
	char *data = NULL;
	char *action;
	int bReturn = TRUE;
	const DWORD cdwThreadId = GetCurrentThreadId();

	data = curl_unescape(p, strlen(p));

	if ((action = ReplayAction(data))){
		if (!strcasecmp(action, "play")){
			if (REPLAY_STATUS_PAUSED == id->m_bReplayStatus){
				id->m_nDelaySecs = (time(0) - id->m_tPlotTime);
				delaystartsecs = 0;
			} else {
				ReplayCmd(id, data);
				id->m_tPlotTime = id->m_tClientsTime - id->m_nDelaySecs + id->m_tServerAdjSecs;
			}
			id->m_bReplayStatus = REPLAY_STATUS_PLAYING;
			id->m_tlasttailsecs = 0;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Replay status set to \"Playing\"\n", cdwThreadId);
			if (id->m_sCurLayout.m_bShowPassurAircraft || id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowASDAircraft || id->m_sCurLayout.m_bShowADSBAircraft)
				SetPassurDelaytime(id);
		}
		if (!strcasecmp(action, "stop")){
			// return to live time
			ReplayStop(id);
			id->m_bReplayStatus = REPLAY_STATUS_STOPPED;
			id->m_tlasttailsecs = 0;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Replay status set to \"Stopped\"\n", cdwThreadId);

			if (strlen(SystemArpt)){
				GoToArpt(id, SystemArpt);
				memset(SystemArpt, 0, _countof(SystemArpt));
			}
		}
		if (!strcasecmp(action, "pause")){
			// return to live time
			id->m_bReplayStatus = REPLAY_STATUS_PAUSED;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Replay status set to \"Paused\"\n", cdwThreadId);
		}
	}else if(!strncmp("speed=", data, 6)){
		// Just change the Replay Speed value
		int speed = 1;
		if (sscanf_s(data + 7, "%dx", &speed)){
			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus && (speed == 1 || speed == 2 || speed == 5 || speed == 10)){
				id->m_nReplaySpeed = speed;
				delaystartsecs = 0;
				SetPassurDelaytime(id);
				id->m_nDelaySecs = (int)(time(0) - id->m_tPlotTime + id->m_tServerAdjSecs);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Replay Speed changed to %d\n", cdwThreadId, id->m_nReplaySpeed);
			}
		}
	}

	curl_free(data);
	return (bReturn);
}

// NAME: GetReplayStatus - GetData callback, for "ReplayStatus" 
// PURPOSE: Should return the status of Replay 
// INPUT: p - N/A
// OUTPUT: m, playing or stopped status
// EXAMPLE(S): 
//	status=\"playing\" - Replay is now playing
//  status=\"stopped\" - Replay is not playing
void GetReplayStatus(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	/* This function only has sample data */
	/* TODO: Using simple check for replay status */
	const char* samples[3] = {
		"status=\"stopped\"",
		"status=\"playing\"",
		"status=\"paused\""
	};

	if (-1 < id->m_bReplayStatus && 3 > id->m_bReplayStatus)
	{
		char* data = curl_escape(samples[id->m_bReplayStatus], strlen(samples[id->m_bReplayStatus]));
		memset(m, 0, sizeof(struct MemoryStruct));
		if (!m->size){
			m->size = strlen(data) + 1;
			m->memory = (char*)calloc(m->size, sizeof(char*));
			strcat_s(m->memory, m->size, data);
		}
		curl_free(data);
	}
}



FIX *FindFix(struct InstanceData* id, char *fixname)
{
	FIX key;
	FIX *curfix;

	//
	// Wait until fixes are loaded
	//

	if (g_bFixesLoaded){

		if (!fixname) return(NULL);
		strncpy_s(key.fixname, 7, fixname, _TRUNCATE);
		StrUpper(key.fixname);

		if ((curfix = (FIX *)bsearch(
			(char *)&key, (char *)g_pFixesPref, g_nFixCountPref, sizeof(FIX), (int(*)(const void*, const void*)) compareFix)) ||
			(curfix = (FIX *)bsearch(
			(char *)&key, (char *)g_pFixesLow, g_nFixCountLow, sizeof(FIX), (int(*)(const void*, const void*)) compareFix)) ||
			(curfix = (FIX *)bsearch((char *)&key, (char *)g_pFixesHigh, g_nFixCountHigh,
			sizeof(FIX), (int(*)(const void*, const void*)) compareFix)) ||
			(curfix = (FIX *)bsearch((char *)&key, (char *)g_pFixesTerm, g_nFixCountTerm,
			sizeof(FIX), (int(*)(const void*, const void*)) compareFix)))
		{

			return(curfix);
		}
	}
	return(NULL);
}


int FindFlightId( struct InstanceData* id, const char *flightnumtext )
{
	int i, j;
	const int feed = 9;
	AIR **airp;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// findflight was selected -- find flight in air, or show planned or past data
	if ( !flightnumtext ){
		return( FALSE );
	}
	
	for(i = 0; i < feed; i++){
		if( 0 == i )
			airp = GetASDAirP(id);
		else if( 1 == i && id->m_sCurLayout.m_bShowPassurAircraft )
			airp = GetAirP( id, 0 );
		else if( 2 == i && id->m_sCurLayout.m_bShowMLATAircraft )
			airp = GetMLATAirP(id);
		else if( 3 == i && id->m_sCurLayout.m_bShowASDEXAircraft )
			airp = GetASDEXAirP(id);
		else if( 4 == i && id->m_sCurLayout.m_bShowADSBAircraft )
			airp = GetADSBAirP(id);
		else if( 5 == i && id->m_sCurLayout.m_bShowNoiseAircraft )
			airp = GetNoiseAirP(id);
		else if( 6 == i && id->m_sCurLayout.m_bShowAirAsiaAircraft )
			airp = GetAirAsiaAirP(id);
		else if (7 == i && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowPassurAircraft))
			airp = GetGateAirP(id);
		else if( 8 == i && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowMLATAircraft) )
			airp = GetLMGAirP(id);
		else
			continue;
		
		for (j = 0; j < N_TRACK_ID; j++ ){
			if ( !(air = airp[j]) ){
				continue;
			}

			if ( !strcasecmp( flightnumtext, air->FltNum ) || 
				((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
				return( TRUE );
			}
		}
	}
	
	return( FALSE );
}



int FindUserFlight(struct InstanceData* id, char *flightnumtext)
{
	int i, flightindex = -1;
	float x, y;
	AIR **airp;
	AIR *air;
	FIX *curfix;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// findflight was selected -- find flight in air, or show planned or past data
	LastKnownTime = -1; // clear out any prior flights found via search
	if (!flightnumtext){
		return(-1);
	}

	if (IsBARRFlight(id, flightnumtext)){
		// flight is in BARR list
		if (!id->m_bDHSPerm){
			if (id->m_nDelaySecs < 1800){
				// not yet implemented   LastKnownLocation( flightnumtext );
				char warning[80];
				sprintf_s(warning, _countof(warning), "Flight %s not Found !", flightnumtext);

				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), warning);
				Callback2Javascript(id, warning);
				return(-1);   // do not show blocked from find tool
			} else {
				// flight is in replay mode so show it
			}
		} else {
			// DHS allowed to see flights
		}
	}

	airp = GetAirAsiaAirP(id);

	for (i = 0; i < N_ADSB_TRACK_ID; i++ ){

		// check AirAsia flights
		if ( !(air = airp[i]) ){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float) air->CurX;
			y = (float) air->CurY;

			if ( x ==0.0 && y == 0.0 ){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from AirAsia tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext );
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID =  air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView( id, x, y );
			id->m_nSelectedAircraftType = SAT_AIRASIA;
			Callback2Javascript( id, "UpdateSelected:" );

			return( i );
		}
	}

	airp = GetADSBAirP(id);

	for (i = 0; i < N_ADSB_TRACK_ID; i++){

		// check passur flights, Passur flight Override
		if (!(air = airp[i])){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float)air->CurX;
			y = (float)air->CurY;

			if (x == 0.0 && y == 0.0){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from ADSB tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext);
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView(id, x, y);
			id->m_nSelectedAircraftType = SAT_ADSB;
			Callback2Javascript(id, "UpdateSelected:");

			return(i);
		}
	}

	airp = GetGateAirP(id);

	for (i = 0; i < N_TRACK_ID; i++){

		// check passur flights, Passur flight Override
		if (!(air = airp[i])){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float)air->CurX;
			y = (float)air->CurY;

			if (x == 0.0 && y == 0.0){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from ASDEX tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext);
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView(id, x, y);
			id->m_nSelectedAircraftType = SAT_ASDEX;
			Callback2Javascript(id, "UpdateSelected:");

			return(i);
		}
	}


	airp = GetASDEXAirP(id);

	for (i = 0; i < N_PASSUR_TRACK_ID; i++){

		// check passur flights, Passur flight Override
		if (!(air = airp[i])){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float)air->CurX;
			y = (float)air->CurY;

			if (x == 0.0 && y == 0.0){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from ASDEX tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext);
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView(id, x, y);
			id->m_nSelectedAircraftType = SAT_ASDEX;
			Callback2Javascript(id, "UpdateSelected:");

			return(i);
		}
	}

	airp = GetLMGAirP(id);

	for (i = 0; i < N_TRACK_ID; i++ ){

		// check flight existance
		if ( !(air = airp[i]) ){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float) air->CurX;
			y = (float) air->CurY;

			if ( x ==0.0 && y == 0.0 ){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from LMG tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext );
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID =  air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView( id, x, y );
			id->m_nSelectedAircraftType = SAT_LMG;
			Callback2Javascript( id, "UpdateSelected:" );

			return( i );
		}
	}

	airp = GetMLATAirP(id);

	for (i = 0; i < N_MLAT_TRACK_ID; i++){

		// check passur flights, Passur flight Override
		if (!(air = airp[i])){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float)air->CurX;
			y = (float)air->CurY;

			if (x == 0.0 && y == 0.0){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from MLAT tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext);
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView(id, x, y);
			id->m_nSelectedAircraftType = SAT_MLAT;
			Callback2Javascript(id, "UpdateSelected:");

			return(i);
		}
	}

	airp = GetAirP(id, 0);

	for (i = 0; i < N_PASSUR_TRACK_ID; i++){
		// check passur flights, Passur flight Override
		if (!(air = airp[i])){
			continue;
		}

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float)air->CurX;
			y = (float)air->CurY;

			if (x == 0.0 && y == 0.0){
				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from PASSUR tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext);
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = i;
			TranslateView(id, x, y);
			id->m_nSelectedAircraftType = SAT_PASSUR;
			Callback2Javascript(id, "UpdateSelected:");

			return(i);
		}
	}


	airp = GetASDAirP(id);

	//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) looking for flight '%s'\n", GetCurrentThreadId(), flightnumtext );
	for (i = 0; i < N_TRACK_ID; i++){
		if (!(air = airp[i])){
			continue;
		}

		// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %d '%s'\n", GetCurrentThreadId(), i, air->FltNum );

		if ( !strcasecmp( flightnumtext, air->FltNum ) || !strcasecmp( flightnumtext, air->tail ) ||
			((0 == strlen(air->FltNum) || !strcasecmp( "UNKN", air->FltNum ) || !strcasecmp( "ANON", air->FltNum ) ) && !strcasecmp( flightnumtext, air->TmpFltNum )) ){
			x = (float)air->CurX;
			y = (float)air->CurY;

			if (x == 0.0 && y == 0.0){

				// bad location, probably landed
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Find Flight (%s) matched from ASDI tracks, but lat and lng values are 0, ignoring.\n", cdwThreadId, flightnumtext);
				continue;
			}
			id->m_pSelectedAirP = airp;
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = i;
			Callback2Javascript(id, "UpdateSelected:");


			id->m_nSelectedAircraftType = SAT_ASDI;
			TranslateView(id, x, y);
			flightindex = i;
		}
	}
	// check if user is looking for a fix
	// remove the fix code when we are able to get more than 4 characters in find airport input box
	if (!(curfix = FindFix(id, flightnumtext))){
	} else {
		// found a fix
		if (id->m_sCurLayout.m_dWorldXSize > 10.0){
			ResizeWorld(id, curfix->lng, curfix->lat, 2.0f);
		} else {	
			TranslateView(id, curfix->lng, curfix->lat);
		}
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found fix %s\n", GetCurrentThreadId(), flightnumtext);
		return(-1); // fix found instead of flight
	}
	if (flightindex < 0){
		// not yet implemented   LastKnownLocation( flightnumtext );
		char warning[80];
		sprintf_s(warning, _countof(warning), "Flight %s not Found !", flightnumtext);

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), warning);
		Callback2Javascript(id, warning);

		return(-1); // flight not in air, but still may be "found"
	}

	return(flightindex);
}



// NAME: Find - SendMessage callback, for "Find" 
// PURPOSE: Kickoff a find airport or find flight operation 
// INPUT: p - search parameters
// EXAMPLE(s): 
//	airport=\"JFK\"
//	flight=\"DAL1234\""
int Find(struct InstanceData* id, char* p)
{
	/* TODO: Extract message, perform action */
	char *data = NULL;
	char *str = NULL;
	ARPT *Arpt;
	FIX *curfix;
	int len;
	int bReturn = TRUE;

	//int temp;
	data = curl_unescape(p, strlen(p));
	if (!strncmp(data, "flight=", 7)){
		// FIND FLIGHT
		str = &data[8];
		StrUpper(str);
		// get rid of trailing "  
		if ((len = strlen(str))) {
			str[len - 1] = '\0';
		}
		FindUserFlight(id, str);
	} else if( !strncmp( data, "airport=", 8) ){
		char *context;
		char message[80];
		char* arpt = NULL;
		char* srcharpt = NULL;
		char* option1 = NULL;
		char* option2 = NULL;

		// Set str pointer to the beginning of the Airport Code and Option//
		str = &data[9];

		// get rid of trailing "  
		if ((len = strlen(str))) {
			str[len - 1] = '\0';
		}

		arpt = strtok_s(str, ",", &context);
		option1 = strtok_s(NULL, ",", &context);
		option2 = strtok_s(NULL, ",", &context);

		// Convert the airport code to Upper case
		StrUpper(arpt);

		// Exceptions (temp quick solution)
		if (!strcmp(arpt, "NAS")){
			srcharpt = "MYNN";
		} else if ( !strcmp(arpt, "NRT") ){
			srcharpt = "RJAA";
		} else if ( !strcmp(arpt, "KUL") ){
			srcharpt = "WMKK";
		} else {
			srcharpt = arpt;
		}
		if (!(Arpt = FindArptRow(id, srcharpt, MATCH_ALL))){
			// check if user is looking for a fix
			if (!(curfix = FindFix(id, srcharpt))){
				char warning[80];
				sprintf_s(warning, _countof(warning), "	Airport %s not Found !", srcharpt);

				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), warning);

				Callback2Javascript(id, warning);
				// could not find arpt or fix
				return (FALSE);
			} else {
				// found a fix
				if (id->m_sCurLayout.m_dWorldXSize > 10.0){
					ResizeWorld(id, curfix->lng, curfix->lat, 2.0f);
				} else {	
					TranslateView(id, curfix->lng, curfix->lat);
				}
				curl_free(data);
				return (bReturn);
			}
		}

		//
		// Airport was Found - Connect to the Passur Airport if requested
		//

		if (option1 && option1[0] == 'Y') {
			ChangePassurAirport(id, arpt);

			/* NEW CHECK */
			strcpy_s(id->m_strAirportMap, ARPTNAME_SZ, arpt);

			sprintf_s(message, _countof(message), "PassurAirport:%s", arpt);
			Callback2Javascript(id, message);
		}

		if (option2 && option2[0] == 'Y') {
			sprintf_s(message, _countof(message), "DisableFilters");
			Callback2Javascript(id, message);
		}

		//lat1 = Arpt->lat;
		//lng1 = Arpt->lng;
		if (id->m_sCurLayout.m_dWorldXSize > 10.0){
			ResizeWorld(id, Arpt->lng, Arpt->lat, 2.0f);
		} else {
			TranslateView(id, Arpt->lng, Arpt->lat);
		}
	}
	curl_free(data);
	return (bReturn);
}


//sy
int FindFlight(struct InstanceData* id, char* p)
{
	/* TODO: Extract message, perform action */
	char *data = NULL;
	char *str = NULL;
	ARPT *Arpt;
	FIX *curfix;
	int bReturn = TRUE;
	int strlength;

	data = &p[0];

	strlength = strlen(data);


	if (strlength > 3) {
		// FIND FLIGHT
		StrUpper(data);
		// get rid of trailing "  
		FindUserFlight(id, data);
	} else {
		char *context;
		char message[80];
		char* arpt = NULL;
		char* srcharpt = NULL;
		char* option1 = NULL;
		char* option2 = NULL;

		// Set str pointer to the beginning of the Airport Code and Option//
		data = &p[0];



		arpt = strtok_s(data, ",", &context);
		option1 = strtok_s(NULL, ",", &context);
		option2 = strtok_s(NULL, ",", &context);

		// Convert the airport code to Upper case
		StrUpper(arpt);

		// Exceptions (temp quick solution)
		if (!strcmp(arpt, "NAS")) {
			srcharpt = "MYNN";
		} else if (!strcmp(arpt, "NRT")) {
			srcharpt = "RJAA";
		} else {
			srcharpt = arpt;
		}
		if (!(Arpt = FindArptRow(id, srcharpt, MATCH_ALL))) {
			// check if user is looking for a fix
			if (!(curfix = FindFix(id, srcharpt))) {
				char warning[80];
				sprintf_s(warning, _countof(warning), "	Airport %s not Found !", srcharpt);

				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", GetCurrentThreadId(), warning);

				Callback2Javascript(id, warning);
				// could not find arpt or fix
				return (FALSE);
			} else {
				// found a fix
				if (id->m_sCurLayout.m_dWorldXSize > 10.0) {
					ResizeWorld(id, curfix->lng, curfix->lat, 2.0f);
				} else {
					TranslateView(id, curfix->lng, curfix->lat);
				}
				curl_free(data);
				return (bReturn);
			}
		}

		//
		// Airport was Found - Connect to the Passur Airport if requested
		//

		if (option1 && option1[0] == 'Y') {
			ChangePassurAirport(id, arpt);

			/* NEW CHECK */
			strcpy_s(id->m_strAirportMap, ARPTNAME_SZ, arpt);

			sprintf_s(message, _countof(message), "PassurAirport:%s", arpt);
			Callback2Javascript(id, message);
		}

		if (option2 && option2[0] == 'Y') {
			sprintf_s(message, _countof(message), "DisableFilters");
			Callback2Javascript(id, message);
		}

		//lat1 = Arpt->lat;
		//lng1 = Arpt->lng;
		if (id->m_sCurLayout.m_dWorldXSize > 10.0) {
			ResizeWorld(id, Arpt->lng, Arpt->lat, 2.0f);
		} else {
			TranslateView(id, Arpt->lng, Arpt->lat);
		}
	}

	return (bReturn);
}

// NAME: PassurETAs - SendMessage callback, for "Passur ETAs" 
// PURPOSE: Show Passur ETAs 
// INPUT: p - ?
// EXAMPLE(s): 
int PassurETAs(struct InstanceData* id, char* p)
{
	/* TODO: Extract message, perform action */
	char *data = NULL;
	int bReturn = FALSE;

	data = curl_unescape(p, strlen(p));

	// Show Passur ETA's

	curl_free(data);
	return (bReturn);
}

void PerformActions(struct InstanceData* id)
{
	char sessionid[100] = { 0 };
	char tmpstr[8192];
	char *data = NULL;
	char *context;
	struct MemoryStruct m;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
		// Ignore Actions while in Replaymode
		return;

	m.memory = NULL; /* we expect realloc(NULL, size) to work */
	m.size = 0;    /* no data at this point */

	if (!GetJavascriptValue(id, "username", id->m_strUserName, USERNAME_SZ)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Username not set, cannot retrieve Actions.\n", cdwThreadId);
		return;
	}

#ifdef _DEBUG
	// For debugging locally only, insert surf_action with your username and below sessionid into surf_actions.
	strcpy_s(sessionid, 100, "00000000000000000000000000000000");
#else
	if ( !GetJavascriptValue(id, "sessionid", sessionid, 100)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Session ID not set, cannot retrieve Actions.\n", cdwThreadId);
		return;	
	}
#endif

	_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "Action=GetSurfActions&username=%s&sessionid=%s", id->m_strUserName, sessionid);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
		cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

	if (!GetCurlFormPostResults(id, &m, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to retrieve actions\n", cdwThreadId);
		GetNxtSurfSrvr(id);
	}

	if (m.memory){
		data = curl_unescape(m.memory, strlen(m.memory));
		free(m.memory);
		m.memory = NULL;
		m.size = 0;

		if (!strncmp("failed", data, 6)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error while retrieving actions, \'%s\'.\n", cdwThreadId, data);
		}else{
			int findflight = FALSE, i = 0, count = 0; // process only once per call
			char *actions = data;
			char *token = strtok_s(actions, "&", &context);
			if (!strncmp("count=", token, 6)){
				count = atoi(data + 6);
			}
			for (i = 0; i < count; i++){
				char sessionid[65] = { 0 };
				char action[25] = { 0 };
				char value[25] = { 0 };
				char usrname[13] = { 0 };
				char status[25] = { 0 };
				char rowtime[50] = { 0 };
				char rowtime_full[50] = { 0 };
				while (token = strtok_s(NULL, "&", &context)){
					if (!strncmp(token, "usrname=", 8)){
						strcpy_s(usrname, _countof(usrname), token + 8);
					}else if(!strncmp(token, "action=", 7)){
						strcpy_s(action, _countof(action), token + 7);
					}else if(!strncmp(token, "value=", 6)){
						strcpy_s(value, _countof(value), token + 6);
					}else if(!strncmp(token, "status=", 7)){
						strcpy_s(status, _countof(status), token + 7);
					}else if(!strncmp(token, "sessionid=", 10)){
						strcpy_s(sessionid, _countof(sessionid), token + 10);
					}else if(!strncmp(token, "rowtime=", 8)){
						char *e = strchr(token, '.');
						strncpy_s(rowtime, _countof(rowtime), token + 8, e - (token + 8));
						strcpy_s(rowtime_full, _countof(rowtime_full), token + 8);
						// rowtime will always be last for each row
						// Contract with Surf.fcg
						break;
					}
				}

				if (!strcmp(action, "FindFlight")){
					// Check rowtime
					time_t secs = DtStr2Secs(rowtime, "%Y-%m-%d %H:%M:%S");
					time_t now = time(0);
					if ((now - secs) < 300 && !findflight) // 5 Mins ?
					{
						// Call Find Flight
						FindUserFlight(id, value);
						// Change status
						findflight = TRUE;
						strcpy_s(status, _countof(status), "completed");
					}else{
						strcpy_s(status, _countof(status), "ignored");
					}

				}else{
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unknown action \'%s\', ignoring\n", cdwThreadId, action);
					strcpy_s(status, _countof(status), "ignored");
				}

				// Update Action Status
				_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "Action=SetSurfAction&username=%s&sessionid=%s&action=%s&value=%s&rowtime=%s&status=%s", id->m_strUserName, sessionid, action, value, rowtime_full, status);

				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
					cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

				if (!GetCurlFormPostResults(id, &m, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to update actions\n", cdwThreadId);
					GetNxtSurfSrvr(id);
				}

				if (m.memory){
					if (!strncmp("failed", m.memory, 6)){
						vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error while retrieving actions, \'%s\'.\n", cdwThreadId, m.memory);
					}else{
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Action completed.\n", cdwThreadId);
					}
					free(m.memory);
					m.memory = NULL;
					m.size = 0;
				}
			}
		}

		curl_free(data);
	}
}

void GetComponentVersion(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char strVersion[100] = { 0 };
	DWORD dwMajor, dwMinor;
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GetComponentVersion Called\n", GetCurrentThreadId());
	GetDLLVersion(&dwMajor, &dwMinor);
	sprintf_s(strVersion, _countof(strVersion), "%d.%d.%d.%d", HIWORD(dwMajor), LOWORD(dwMajor),
		HIWORD(dwMinor), LOWORD(dwMinor));
	clear_chunk_memory(m);
	if (!m->size){
		m->size = strlen(strVersion) + 1;
		m->memory = (char*)calloc(m->size, sizeof(char*));
		strcat_s(m->memory, m->size, strVersion);
	}
}

void GetReleaseVersion(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char strVersion[100] = { 0 };
	DWORD dwMajor, dwMinor;
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GetReleaseVersion Called\n", GetCurrentThreadId());
	GetDLLVersion(&dwMajor, &dwMinor);
	sprintf_s(strVersion, _countof(strVersion), "Release: v%s,Build Date: %s", version, builddate);
	clear_chunk_memory(m);
	if (!m->size){
		m->size = strlen(strVersion) + 1;
		m->memory = (char*)calloc(m->size, sizeof(char*));
		strcat_s(m->memory, m->size, strVersion);
	}
}

int SetSubVersion(struct InstanceData* id, char* p)
{
	char* data = curl_unescape(p, strlen(p));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Sub Version %s\n", GetCurrentThreadId(), data);
	subversion = _strdup(data);
	curl_free(data);
	return (TRUE);
}

int SetCitrixUser(struct InstanceData* id, char* p)
{
	char* data = curl_unescape(p, strlen(p));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Citrix User: %s\n", GetCurrentThreadId(), data);
	id->m_bCitrixUser = !_stricmp(data, "true");
	curl_free(data);
	return (TRUE);
}

// RecordVideo WT2.3
int RecordVideo(struct InstanceData* id, char* p)
{
	int recFlag = 0;
	char * data = curl_unescape(p, strlen(p));
	AVILIB * avip = &id->avilib;
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Record Video %s\n",
		GetCurrentThreadId(), data);
	recFlag = (unsigned int)atoi(data);
	if (recFlag == TRUE)
	{
		if (avip->m_bRecordVideoButton != TRUE)
		{
			// Start recording button pressed
			avip->m_bRecordVideoButton = TRUE;

			// Allocate a buffer to save the screen during RenderScene()
			if (avip->m_pVideoBuffer != NULL)
				free(avip->m_pVideoBuffer);
			avip->m_pVideoBuffer = (unsigned char *)malloc(id->m_nWidth * id->m_nHeight * 4);

			// Save the current video height and width
			avip->m_nVideoHeight = (id->m_nHeight / 4) * 4;
			avip->m_nVideoWidth = (id->m_nWidth / 4) * 4;

			// Notify the thread to start recording
			ResetEvent(id->m_evRecVideoReset);
			id->m_hRecordVideoThread = _beginthreadex(NULL, 0, RecordVideoThread, id, 0, NULL);
			RegisterThreadHandle(id, id->m_hRecordVideoThread, "RecordVideoThread");
		}
	}
	else  // Stop recording
	{
		if (avip->m_bRecordVideoButton == TRUE)
		{
			// Tell RenderScene to stop recording video
			avip->m_bRecordVideo = FALSE;

			// Notify the thread to stop recording
			SetEvent(id->m_evRecVideoReset);
			if (id->m_hRecordVideoThread)
				UnregisterThreadHandle(id, id->m_hRecordVideoThread);
		}
	}

	curl_free(data);
	return (TRUE);
}

// RecordVideo WT2.3
// The user has changed the max recording timeout value
int RecordVideoDuration(struct InstanceData* id, char* p)
{
	int recDurMin = 0;
	char * data = curl_unescape(p, strlen(p));
	AVILIB * avip = &id->avilib;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Record Video Duration %s minutes\n",
		GetCurrentThreadId(), data);

	recDurMin = (unsigned int)atoi(data);
	avip->m_lRecDurSec = recDurMin * 60;  // convert from minutes to seconds

	curl_free(data);
	return (TRUE);
}

#define CLEAR_REGION_ALERTS			0x01
#define CLEAR_TARMAC_DELAY_ALERTS	0x02
int ChangeRegionAlertConfig(struct InstanceData* id, json_object* jObj)
{
	struct json_object* jfield = json_object_object_get(jObj, "enable");
	int nValue = 0;
	int nReset = 0;
	D_CONTROL("ALERTS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) REGION ALERT JSON:%s\n", GetCurrentThreadId(), json_object_to_json_string(jObj)));
	if (!strcmp("true", json_object_get_string(jfield)))
		id->m_nRegionAlertEnabled = TRUE;
	else{
		id->m_nRegionAlertEnabled = FALSE;
		nReset = CLEAR_REGION_ALERTS;
	}

	jfield = json_object_object_get(jObj, "oto_yellow");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (id->m_nRegionOTOYellow < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nRegionOTOYellow = nValue;
	}

	jfield = json_object_object_get(jObj, "oto_red");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (!nReset && id->m_nRegionOTORed < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nRegionOTORed = nValue;
	}

	jfield = json_object_object_get(jObj, "oti_yellow");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (!nReset && id->m_nRegionOTIYellow < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nRegionOTIYellow = nValue;
	}

	jfield = json_object_object_get(jObj, "oti_red");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (!nReset && id->m_nRegionOTIRed < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nRegionOTIRed = nValue;
	}

	return (nReset);
}

int ChangeTarmacDelayAlertConfig(struct InstanceData* id, json_object* jObj)
{
	struct json_object* jfield = json_object_object_get(jObj, "enable");
	int nValue = 0;
	int nReset = 0;
	D_CONTROL("ALERTS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TARMAC DELAY ALERT JSON:%s\n", GetCurrentThreadId(), json_object_to_json_string(jObj)));
	if (!strcmp("true", json_object_get_string(jfield)))
		id->m_nTarmacDelayEnabled = TRUE;
	else{
		id->m_nTarmacDelayEnabled = FALSE;
		nReset = CLEAR_TARMAC_DELAY_ALERTS;
	}

	jfield = json_object_object_get(jObj, "oto_yellow");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (id->m_nTarmacDelayOTOYellow < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nTarmacDelayOTOYellow = nValue;
	}

	jfield = json_object_object_get(jObj, "oto_red");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (!nReset && id->m_nTarmacDelayOTORed < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nTarmacDelayOTORed = nValue;
	}

	jfield = json_object_object_get(jObj, "oti_yellow");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (!nReset && id->m_nTarmacDelayOTIYellow < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nTarmacDelayOTIYellow = nValue;
	}

	jfield = json_object_object_get(jObj, "oti_red");
	if (jfield){
		nValue = 60 * atoi(json_object_get_string(jfield));
		if (!nReset && id->m_nTarmacDelayOTIRed < nValue)
			nReset = CLEAR_REGION_ALERTS;
		id->m_nTarmacDelayOTIRed = nValue;
	}

	return (nReset);
}

void ChangeAlertConfig(struct InstanceData* id, json_object* jObj)
{
	int nReset = FALSE;
	D_CONTROL("ALERTS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ALERTS JSON:%s\n", GetCurrentThreadId(), json_object_to_json_string(jObj)));
	if (jObj && json_object_is_type(jObj, json_type_array)){
		int c = 0, i = 0;
		c = json_object_array_length(jObj);
		for (i = 0; i < c; i++){
			struct json_object* jelem = json_object_array_get_idx(jObj, i);
			struct json_object* jfield = json_object_object_get(jelem, "alert_name");
			if (!strcmp("region", json_object_get_string(jfield))){
				nReset |= ChangeRegionAlertConfig(id, jelem);
			}else if (!strcmp("tarmac_delay",json_object_get_string(jfield))){
				nReset |= ChangeTarmacDelayAlertConfig(id, jelem);
			}else{
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid alert setting %s\n", GetCurrentThreadId(), json_object_to_json_string(jelem));
			}
		}
	}else{
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid or Empty alert configuration %s\n", GetCurrentThreadId(), json_object_to_json_string(jObj));
		nReset = TRUE; // This forces defaults to be in use
	}

	if (nReset)
	{
		// Run through all ASDEX and MLAT (if enabled) and temporarily unset the Alert's
		int i = 0, j = 0;
		for (j = 0; j < 2; j++){
			AIR** airp = NULL;
			AIR* air = NULL;
			if (j){
				if (id->m_sCurLayout.m_bShowMLATAircraft){
					airp = GetMLATAirP(id);
				}else{
					continue;
				}
			}else{
				if (id->m_sCurLayout.m_bShowASDEXAircraft){
					airp = GetASDEXAirP(id);
				}else{
					continue;
				}
			}

			for (i = 0; airp && i < N_TRACK_ID; i++)
			{
				if (air = airp[i])
				{
					if (nReset & CLEAR_REGION_ALERTS && (ALERT_RG_OTO == air->alert || ALERT_RG_OTI == air->alert)) {
						air->alert = ALERT_NONE;
						air->alert_level = ALERT_LEVEL_NONE;
					}else if(nReset & CLEAR_TARMAC_DELAY_ALERTS && ( ALERT_TD_OTO == air->alert || ALERT_TD_OTI == air->alert ) ) {
						air->alert = ALERT_NONE;
						air->alert_level = ALERT_LEVEL_NONE;
					}
				}
			}
		}
	}
}

json_object* CreateAlertsJSONObj(struct InstanceData* id)
{
	char buffer[100] = { 0 };
	struct json_object* jReg = json_object_new_object();
	struct json_object* jTd = json_object_new_object();
	struct json_object* jArr = json_object_new_array();

	// Create REGIONS Alert Object
	json_object_object_add(jReg, "_class", json_object_new_string("Alert"));
	json_object_object_add(jReg, "alert_name", json_object_new_string("region"));
	if (id->m_nRegionAlertEnabled)
		json_object_object_add(jReg, "enable", json_object_new_string("true"));
	else
		json_object_object_add(jReg, "enable", json_object_new_string("false"));
	sprintf_s(buffer, 100, "%d", id->m_nRegionOTOYellow / 60);
	json_object_object_add(jReg, "oto_yellow", json_object_new_string(buffer));
	sprintf_s(buffer, 100, "%d", id->m_nRegionOTORed / 60);
	json_object_object_add(jReg, "oto_red", json_object_new_string(buffer));
	sprintf_s(buffer, 100, "%d", id->m_nRegionOTIYellow / 60);
	json_object_object_add(jReg, "oti_yellow", json_object_new_string(buffer));
	sprintf_s(buffer, 100, "%d", id->m_nRegionOTIRed / 60);
	json_object_object_add(jReg, "oti_red", json_object_new_string(buffer));
	json_object_array_add(jArr, jReg);

	// Create TARMAC DELAY Alert Object
	json_object_object_add(jTd, "_class", json_object_new_string("Alert"));
	json_object_object_add(jTd, "alert_name", json_object_new_string("tarmac_delay"));
	if (id->m_nTarmacDelayEnabled)
		json_object_object_add(jTd, "enable", json_object_new_string("true"));
	else
		json_object_object_add(jTd, "enable", json_object_new_string("false"));
	sprintf_s(buffer, 100, "%d", id->m_nTarmacDelayOTOYellow / 60);
	json_object_object_add(jTd, "oto_yellow", json_object_new_string(buffer));
	sprintf_s(buffer, 100, "%d", id->m_nTarmacDelayOTORed / 60);
	json_object_object_add(jTd, "oto_red", json_object_new_string(buffer));
	sprintf_s(buffer, 100, "%d", id->m_nTarmacDelayOTIYellow / 60);
	json_object_object_add(jTd, "oti_yellow", json_object_new_string(buffer));
	sprintf_s(buffer, 100, "%d", id->m_nTarmacDelayOTIRed / 60);
	json_object_object_add(jTd, "oti_red", json_object_new_string(buffer));
	json_object_array_add(jArr, jTd);

	return jArr;
}

void GetDebugData(struct InstanceData* id, char* p, struct MemoryStruct* m)
{
	char *ctx = NULL;
	char *tok = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();
	char* input = curl_unescape(p, strlen(p));
	char* output = NULL, *data = NULL;

	tok = StrTok(&ctx, input, '=');
	if (strlen(tok)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Debug Data Request for %s\n", cdwThreadId, tok);
		if (!strcmp(tok, "ASDEX")){
			int nTrackId = 0;
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Track data request for %s\n", cdwThreadId, tok);
				nTrackId = GetIndex(id, id->m_pASDEXIndexMap, tok, 0, 0, ASDEX);
				if (-1 != nTrackId){
					AIR** airp = GetASDEXAirP(id);
					AIR* air = airp[nTrackId];
					data = FlightToJSON(id, air);
					if (data){
						output = curl_escape(data, strlen(data));
						free(data);
					}
				}
			}
		}else if(!strcmp(tok, "MLAT")){
			int nTrackId = 0;
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Track data request for %s\n", cdwThreadId, tok);
				nTrackId = GetIndex(id, id->m_pMLATIndexMap, tok, 0, 0, MLAT);
				if (-1 != nTrackId){
					AIR** airp = GetMLATAirP(id);
					AIR* air = airp[nTrackId];
					data = FlightToJSON(id, air);
					if (data){
						output = curl_escape(data, strlen(data));
						free(data);
					}
				}
			}
		}else if(!strcmp(tok, "UNKN")){
			int nTrackId = 0;
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Track data request for %s\n", cdwThreadId, tok);
				nTrackId = atoi(tok);
				if (-1 != nTrackId){
					AIR** airp = GetASDEXAirP(id);
					AIR* air = airp[nTrackId];
					data = FlightToJSON(id, air);
					if (data){
						output = curl_escape(data, strlen(data));
						free(data);
					}
				}
			}
		}else if(!strcmp(tok, "ADSB")){
			int nTrackId = 0;
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Track data request for %s\n", cdwThreadId, tok);
				nTrackId = GetIndex(id, id->m_pADSBIndexMap, tok, 0, 0, ADSB);
				if (-1 != nTrackId){
					AIR** airp = GetADSBAirP(id);
					AIR* air = airp[nTrackId];
					data = FlightToJSON(id, air);
					if (data){
						output = curl_escape(data, strlen(data));
						free(data);
					}
				}
			}
		}else if(!strcmp(tok, "PASSUR")){
			int nTrackId = 0;
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Track data request for %s\n", cdwThreadId, tok);
				nTrackId = GetIndex(id, id->m_pPassurIndexMap, tok, 0, 0, PASSUR);
				if (-1 != nTrackId){
					AIR** airp = GetAirP(id, 0);
					AIR* air = airp[nTrackId];
					data = FlightToJSON(id, air);
					if (data){
						output = curl_escape(data, strlen(data));
						free(data);
					}
				}
			}
		}else if(!strcmp(tok, "ASDI")){
			int nTrackId = 0;
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Track data request for %s\n", cdwThreadId, tok);
				nTrackId = GetIndex(id, id->m_pASDIndexMap, tok, 0, 0, ASDI);
				if (-1 != nTrackId){
					AIR** airp = GetASDAirP(id);
					AIR* air = airp[nTrackId];
					data = FlightToJSON(id, air);
					if (data){
						output = curl_escape(data, strlen(data));
						free(data);
					}
				}
			}
		}else if(!strcmp(tok, "FAILSERVER")){
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				if (!strcmp(tok, "INSIGHT") || !strcmp(tok, "PASSUR")){
					//id->m_strPassurFastUpdatesCGIName[35] = 'x';
					const char* Srvr = NULL;
					GetNxtPassurSrvr(id);
					Srvr = GetPassurSrvr(id);
					output = curl_escape(Srvr, strlen(Srvr));
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Forcing insight server to fail to next url.\n", cdwThreadId);
			}
		}
		}else if(!strcmp(tok, "REGIONS")){
			tok = StrTok(&ctx, NULL, '=');
			if (tok){
				if (!strcmp(tok, "HIST")){
					output = curl_escape(id->m_pGRegionsHistorical, strlen(id->m_pGRegionsHistorical));
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Historical Region Data Request.\n", cdwThreadId, tok);
				}else{
					// = CURR
					output = curl_escape(id->m_pGRegions, strlen(id->m_pGRegions));
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEBUG: Current Region Data Request.\n", cdwThreadId, tok);
				}
			}
		}
	}
	curl_free(input);

	clear_chunk_memory(m);
	if (output){
		m->size = strlen(output) + 1;
		m->memory = (char*)calloc(m->size, sizeof(char*));
		strcat_s(m->memory, m->size, output);
		curl_free(output);
	}
}



// InitActiveXCallbacks: used to initialize any callback into DLL
void InitActiveXCallbacks(struct InstanceData* id)
{
	// SendMessage callbacks
	RegisterSendMessageCallback(id, "SaveLayout", SaveLayout);
	RegisterSendMessageCallback(id, "DeleteLayout", DeleteLayout);
	RegisterSendMessageCallback(id, "ChangeLayout", ChangeLayout);
	RegisterSendMessageCallback(id, "Play", Replay);
	RegisterSendMessageCallback(id, "EnableFilters", EnableFilters);
	RegisterSendMessageCallback(id, "SaveFilter", SaveFilter);
	RegisterSendMessageCallback(id, "DeleteFilter", DeleteFilter);
	RegisterSendMessageCallback(id, "EnableTagFilters", EnableTagFilters);
	RegisterSendMessageCallback(id, "SaveTagFilter", SaveTagFilter);
	RegisterSendMessageCallback(id, "DeleteTagFilter", DeleteTagFilter);
	RegisterSendMessageCallback(id, "Find", Find);
	RegisterSendMessageCallback(id, "Grid", Grid);
	RegisterSendMessageCallback(id, "PassurETAs", PassurETAs);
	RegisterSendMessageCallback(id, "ChangePassurAirport", ChangePassurAirport);
	RegisterSendMessageCallback(id, "ROIColors", ROIColors);
	RegisterSendMessageCallback(id, "Log", HtmlLog);
	RegisterSendMessageCallback(id, "SubVersion", SetSubVersion);
	RegisterSendMessageCallback(id, "CitrixUser", SetCitrixUser);
	RegisterSendMessageCallback(id, "RecordVideo", RecordVideo);
	RegisterSendMessageCallback(id, "RecordVideoDuration", RecordVideoDuration);
	RegisterSendMessageCallback(id, "Selected", SetSelected);
	RegisterSendMessageCallback(id, "SelectedDetails", SetSelectedDetails);


	// GetData callbacks
	RegisterGetDataCallback(id, "ARTCC", GetARTCC);
	RegisterGetDataCallback(id, "SIDS", GetSIDs);
	RegisterGetDataCallback(id, "STARS", GetSTARs);
	RegisterGetDataCallback(id, "Layouts", GetLayouts);
	RegisterGetDataCallback(id, "Layout", GetLayoutData);
	RegisterGetDataCallback(id, "ReplayStatus", GetReplayStatus);
	RegisterGetDataCallback(id, "Filters", GetFilters);
	RegisterGetDataCallback(id, "Filter", GetFilterData);
	RegisterGetDataCallback(id, "MaxFilters", GetMaxFilters);
	RegisterGetDataCallback(id, "TagFilters", GetTagFilters);
	RegisterGetDataCallback(id, "TagFilter", GetTagFilterData);
	RegisterGetDataCallback(id, "MaxTagFilters", GetMaxTagFilters);
	RegisterGetDataCallback(id, "User", GetUser);
	RegisterGetDataCallback(id, "PassurAirports", GetPassurAirports);
	RegisterGetDataCallback(id, "GetROI", GetRegionOfInterest);
	RegisterGetDataCallback(id, "RegionList", GetRegionList);
	RegisterGetDataCallback(id, "Permission", GetPermission);
	RegisterGetDataCallback(id, "PostRequest", GetPostRequest);
	RegisterGetDataCallback(id, "GetComponentVersion", GetComponentVersion);
	RegisterGetDataCallback(id, "GetReleaseVersion", GetReleaseVersion);
	RegisterGetDataCallback(id, "Debug", GetDebugData);
	RegisterGetDataCallback(id, "AirlineCodeLookup", GetAirlineName);
	RegisterGetDataCallback(id, "Selected", GetSelected);
	RegisterGetDataCallback(id, "SelectedDetails", GetSelectedDetails);
	RegisterGetDataCallback(id, "HasFlightId", HasFlightId);
	RegisterGetDataCallback(id, "LaunchedLayout", GetLaunchedLayout);
	RegisterGetDataCallback(id, "HasConfigName", IsConfigDefined);

}

char *ShowTime(struct InstanceData* id, long secs)
{
	struct tm newtime;
	static char showtimebuf[256];

	if (!id->m_sUserSettings.TimeDisplayLocal){
		VOGMTime(showtimebuf, secs, "%H:%Mz");
	} else {
		localtime_s(&newtime, &secs); /* Convert to local time. */
		if (secs > 0){
			if (newtime.tm_hour < 12){
				VOTimeFmt(showtimebuf, secs, "%I:%Ma");
			} else {
				VOTimeFmt(showtimebuf, secs, "%I:%Mp");
			}
		} else {
			showtimebuf[0] = '\0';
		}

	}
	return(showtimebuf);

}


int ColorsSetup(struct InstanceData* id)
{
	int i;

	//Color Pallete//
	yellow1[0] = 255.0f / 255.0f;
	yellow1[1] = 255.0f / 255.0f;
	yellow1[2] = 153.0f / 255.0f;

	backf[0] = 255.0f / 255.0f;
	backf[1] = 255.0f / 255.0f;
	backf[2] = 0.0f / 255.0f;

	foref[0] = 255.0f / 255.0f;
	foref[1] = 255.0f / 255.0f;
	foref[2] = 0.0f / 255.0f;

	yellow2[0] = 255.0f / 255.0f;
	yellow2[1] = 255.0f / 255.0f;
	yellow2[2] = 0.0f / 255.0f;

	yellow3[0] = 255.0f / 255.0f;
	yellow3[1] = 204.0f / 255.0f;
	yellow3[2] = 0.0f / 255.0f;

	yellow4[0] = 255.0f / 255.0f;
	yellow4[1] = 153.0f / 255.0f;
	yellow4[2] = 0.0f / 255.0f;

	yellow5[0] = 153.0f / 255.0f;
	yellow5[1] = 102.0f / 255.0f;
	yellow5[2] = 0.0f / 255.0f;

	red1[0] = 255.0f / 255.0f;
	red1[1] = 219.0f / 255.0f;
	red1[2] = 157.0f / 255.0f;

	red2[0] = 255.0f / 255.0f;
	red2[1] = 204.0f / 255.0f;
	red2[2] = 102.0f / 255.0f;

	red3[0] = 255.0f / 255.0f;
	red3[1] = 153.0f / 255.0f;
	red3[2] = 51.0f / 255.0f;

	red4[0] = 255.0f / 255.0f;
	red4[1] = 121.0f / 255.0f;
	red4[2] = 75.0f / 255.0f;

	red5[0] = 255.0f / 255.0f;
	red5[1] = 51.0f / 255.0f;
	red5[2] = 0.0f / 255.0f;


	violet1[0] = 222.0f / 255.0f;
	violet1[1] = 255.0f / 255.0f;
	violet1[2] = 255.0f / 255.0f;

	violet2[0] = 255.0f / 255.0f;
	violet2[1] = 204.0f / 255.0f;
	violet2[2] = 255.0f / 255.0f;

	violet3[0] = 204.0f / 255.0f;
	violet3[1] = 204.0f / 255.0f;
	violet3[2] = 255.0f / 255.0f;

	violet4[0] = 153.0f / 255.0f;
	violet4[1] = 153.0f / 255.0f;
	violet4[2] = 255.0f / 255.0f;

	violet5[0] = 102.0f / 255.0f;
	violet5[1] = 102.0f / 255.0f;
	violet5[2] = 204.0f / 255.0f;

	blue1[0] = 62.0f / 255.0f;
	blue1[1] = 154.0f / 255.0f;
	blue1[2] = 222.0f / 255.0f;

	blue2[0] = 0.0f / 255.0f;
	blue2[1] = 154.0f / 255.0f;
	blue2[2] = 222.0f / 255.0f;

	blue3[0] = 0.0f / 255.0f;
	blue3[1] = 102.0f / 255.0f;
	blue3[2] = 204.0f / 255.0f;

	blue4[0] = 0.0f / 255.0f;
	blue4[1] = 51.0f / 255.0f;
	blue4[2] = 153.0f / 255.0f;

	blue5[0] = 51.0f / 255.0f;
	blue5[1] = 51.0f / 255.0f;
	blue5[2] = 102.0f / 255.0f;

	green1[0] = 204.0f / 255.0f;
	green1[1] = 255.0f / 255.0f;
	green1[2] = 204.0f / 255.0f;

	green2[0] = 153.0f / 255.0f;
	green2[1] = 255.0f / 255.0f;
	green2[2] = 102.0f / 255.0f;

	green3[0] = 102.0f / 255.0f;
	green3[1] = 204.0f / 255.0f;
	green3[2] = 51.0f / 255.0f;

	green4[0] = 0.0f / 255.0f;
	green4[1] = 153.0f / 255.0f;
	green4[2] = 0.0f / 255.0f;

	green5[0] = 0.0f / 255.0f;
	green5[1] = 102.0f / 255.0f;
	green5[2] = 0.0f / 255.0f;

	///////////////////////
	//Larry new GUI colors
	Grid_grey1[0] = 40.0f / 255.0f;
	Grid_grey1[1] = 40.0f / 255.0f;
	Grid_grey1[2] = 40.0f / 255.0f;

	Grid_grey2[0] = 69.0f / 255.0f;
	Grid_grey2[1] = 69.0f / 255.0f;
	Grid_grey2[2] = 69.0f / 255.0f;

	Grid_grey3[0] = 83.0f / 255.0f;
	Grid_grey3[1] = 83.0f / 255.0f;
	Grid_grey3[2] = 83.0f / 255.0f;

	Grid_grey4[0] = 160.0f / 255.0f;
	Grid_grey4[1] = 160.0f / 255.0f;
	Grid_grey4[2] = 160.0f / 255.0f;

	Grid_grey5[0] = 213.0f / 255.0f;
	Grid_grey5[1] = 213.0f / 255.0f;
	Grid_grey5[2] = 213.0f / 255.0f;

	SubGrid_grey1[0] = 123.0f / 255.0f;
	SubGrid_grey1[1] = 123.0f / 255.0f;
	SubGrid_grey1[2] = 123.0f / 255.0f;

	SubGrid_grey2[0] = 192.0f / 255.0f;
	SubGrid_grey2[1] = 192.0f / 255.0f;
	SubGrid_grey2[2] = 192.0f / 255.0f;

	Text_yellow[0] = 247.0f / 255.0f;
	Text_yellow[1] = 207.0f / 255.0f;
	Text_yellow[2] = 84.0f / 255.0f;

	//mtm new tab colors

	Blue_tab[0] = 69.0f / 255.0f;
	Blue_tab[1] = 69.0f / 255.0f;
	Blue_tab[2] = 69.0f / 255.0f;


	//icon matrix colors
	Iconcolor0[0] = 00.0f / 255.0f;
	Iconcolor0[1] = 00.0f / 255.0f;
	Iconcolor0[2] = 255.0f / 255.0f;

	Iconcolor1[0] = 153.0f / 255.0f;
	Iconcolor1[1] = 153.0f / 255.0f;
	Iconcolor1[2] = 153.0f / 255.0f;

	Iconcolor2[0] = 157.0f / 255.0f;
	Iconcolor2[1] = 123.0f / 255.0f;
	Iconcolor2[2] = 1.0f / 255.0f;

	Iconcolor3[0] = 191.0f / 255.0f;
	Iconcolor3[1] = 47.0f / 255.0f;
	Iconcolor3[2] = 55.0f / 255.0f;

	Iconcolor4[0] = 234.0f / 255.0f;
	Iconcolor4[1] = 30.0f / 255.0f;
	Iconcolor4[2] = 30.0f / 255.0f;

	Iconcolor5[0] = 244.0f / 255.0f;
	Iconcolor5[1] = 146.0f / 255.0f;
	Iconcolor5[2] = 31.0f / 255.0f;

	Iconcolor6[0] = 234.0f / 255.0f;
	Iconcolor6[1] = 186.0f / 255.0f;
	Iconcolor6[2] = 34.0f / 255.0f;

	Iconcolor7[0] = 191.0f / 255.0f;
	Iconcolor7[1] = 205.0f / 255.0f;
	Iconcolor7[2] = 13.0f / 255.0f;

	Iconcolor8[0] = 15.0f / 255.0f;
	Iconcolor8[1] = 204.0f / 255.0f;
	Iconcolor8[2] = 32.0f / 255.0f;

	Iconcolor9[0] = 35.0f / 255.0f;
	Iconcolor9[1] = 154.0f / 255.0f;
	Iconcolor9[2] = 23.0f / 255.0f;

	Iconcolor10[0] = 29.0f / 255.0f;
	Iconcolor10[1] = 189.0f / 255.0f;
	Iconcolor10[2] = 187.0f / 255.0f;

	Iconcolor11[0] = 52.0f / 255.0f;
	Iconcolor11[1] = 164.0f / 255.0f;
	Iconcolor11[2] = 204.0f / 255.0f;

	Iconcolor12[0] = 45.0f / 255.0f;
	Iconcolor12[1] = 106.0f / 255.0f;
	Iconcolor12[2] = 176.0f / 255.0f;

	Iconcolor13[0] = 197.0f / 255.0f;
	Iconcolor13[1] = 122.0f / 255.0f;
	Iconcolor13[2] = 239.0f / 255.0f;

	Iconcolor14[0] = 157.0f / 255.0f;
	Iconcolor14[1] = 55.0f / 255.0f;
	Iconcolor14[2] = 187.0f / 255.0f;

	Iconcolor15[0] = 220.0f / 255.0f;
	Iconcolor15[1] = 22.0f / 255.0f;
	Iconcolor15[2] = 167.0f / 255.0f;

	//Larry GUI colors
	GridBg[0] = 69.0f / 255.0f;
	GridBg[1] = 69.0f / 255.0f;
	GridBg[2] = 69.0f / 255.0f;

	YellowFg[0] = 247.0f / 255.0f;
	YellowFg[1] = 207.0f / 255.0f;
	YellowFg[2] = 84.0f / 255.0f;
	//mtm title
	Blue_title[0] = 164.0f / 255.0f;
	Blue_title[1] = 163.0f / 255.0f;
	Blue_title[2] = 132.0f / 255.0f;

	Blue_fg[0] = 0.0f / 255.0f;
	Blue_fg[1] = 0.0f / 255.0f;
	Blue_fg[2] = 102.0f / 255.0f;

	grey_Tab_bg[0] = 150.0f / 255.0f;
	grey_Tab_bg[1] = 150.0f / 255.0f;
	grey_Tab_bg[2] = 150.0f / 255.0f;


	lightblue[0] = 0xb6 / 255.0f;
	lightblue[1] = 0xe0 / 255.0f;
	lightblue[2] = 0xf1 / 255.0f;

	buttonblue[0] = 204.0f / 255.0f;
	buttonblue[1] = 255.0f / 255.0f;
	buttonblue[2] = 255.0f / 255.0f;

	id->m_sCurLayout.m_glfWaterColor[0] = 204.0f / 255.0f;
	id->m_sCurLayout.m_glfWaterColor[1] = 230.0f / 255.0f;
	id->m_sCurLayout.m_glfWaterColor[2] = 255.0f / 255.0f;

	silver[0] = 153.0f / 255.0f;
	silver[1] = 153.0f / 255.0f;
	silver[2] = 153.0f / 255.0f;

	gold[0] = 157.0f / 255.0f;
	gold[1] = 123.0f / 255.0f;
	gold[2] = 1.0f / 255.0f;

	maroon[0] = 191.0f / 255.0f;
	maroon[1] = 47.0f / 255.0f;
	maroon[2] = 55.0f / 255.0f;

	larry_red[0] = 234.0f / 255.0f;
	larry_red[1] = 30.0f / 255.0f;
	larry_red[2] = 30.0f / 255.0f;

	orange[0] = 244.0f / 255.0f;
	orange[1] = 146.0f / 255.0f;
	orange[2] = 31.0f / 255.0f;

	kumquat[0] = 235.0f / 255.0f;
	kumquat[1] = 186.0f / 255.0f;
	kumquat[2] = 34.0f / 255.0f;


	olive[0] = 191.0f / 255.0f;
	olive[1] = 205.0f / 255.0f;
	olive[2] = 13.0f / 255.0f;

	lime[0] = 15.0f / 255.0f;
	lime[1] = 204.0f / 255.0f;
	lime[2] = 32.0f / 255.0f;

	forest[0] = 35.0f / 255.0f;
	forest[1] = 154.0f / 255.0f;
	forest[2] = 23.0f / 255.0f;

	teal[0] = 29.0f / 255.0f;
	teal[1] = 189.0f / 255.0f;
	teal[2] = 187.0f / 255.0f;

	lightblue[0] = 52.0f / 255.0f;
	lightblue[1] = 164.0f / 255.0f;
	lightblue[2] = 206.0f / 255.0f;

	darkblue[0] = 45.0f / 255.0f;
	darkblue[1] = 106.0f / 255.0f;
	darkblue[2] = 176.0f / 255.0f;

	lightpurple[0] = 197.0f / 255.0f;
	lightpurple[1] = 122.0f / 255.0f;
	lightpurple[2] = 239.0f / 255.0f;

	darkpurple[0] = 157.0f / 255.0f;
	darkpurple[1] = 55.0f / 255.0f;
	darkpurple[2] = 187.0f / 255.0f;

	Thistle[0] = HexStrtod("D8", 2) / 255.0f;
	Thistle[1] = HexStrtod("BF", 2) / 255.0f;
	Thistle[2] = HexStrtod("D8", 2) / 255.0f;

	DarkThistle[0] = HexStrtod("A6", 2) / 255.0f;
	DarkThistle[1] = HexStrtod("92", 2) / 255.0f;
	DarkThistle[2] = HexStrtod("A6", 2) / 255.0f;

	DarkSlateGray[0] = 47.0f / 255.0f;
	DarkSlateGray[1] = 79.0f / 255.0f;
	DarkSlateGray[2] = 79.0f / 255.0f;

	DarkSlateBlue[0] = 72.0f / 255.0f;
	DarkSlateBlue[1] = 61.0f / 255.0f;
	DarkSlateBlue[2] = 139.0f / 255.0f;

	passion[0] = 220.0f / 255.0f;
	passion[1] = 22.0f / 255.0f;
	passion[2] = 167.0f / 255.0f;

	FIDSBarColor[0] = 211.0f / 255.0f;
	FIDSBarColor[1] = 215.0f / 255.0f;
	FIDSBarColor[2] = 201.0f / 255.0f;

	// map colors
	LightUS[0] = 236.0f / 255.0f;
	LightUS[1] = 217.0f / 255.0f;
	LightUS[2] = 194.0f / 255.0f;
	LightCM[0] = 213.0f / 255.0f;
	LightCM[1] = 197.0f / 255.0f;
	LightCM[2] = 177.0f / 255.0f;
	LightWater[0] = 212.0f / 255.0f;
	LightWater[1] = 227.0f / 255.0f;
	LightWater[2] = 245.0f / 255.0f;

	MedUS[0] = 179.0f / 255.0f;
	MedUS[1] = 169.0f / 255.0f;
	MedUS[2] = 140.0f / 255.0f;
	MedCM[0] = 165.0f / 255.0f;
	MedCM[1] = 156.0f / 255.0f;
	MedCM[2] = 129.0f / 255.0f;
	MedWater[0] = 131.0f / 255.0f;
	MedWater[1] = 169.0f / 255.0f;
	MedWater[2] = 200.0f / 255.0f;

	DarkUS[0] = 128.0f / 255.0f;
	DarkUS[1] = 110.0f / 255.0f;
	DarkUS[2] = 100.0f / 255.0f;
	DarkCM[0] = 142.0f / 255.0f;
	DarkCM[1] = 130.0f / 255.0f;
	DarkCM[2] = 115.0f / 255.0f;
	DarkWater[0] = 68.0f / 255.0f;
	DarkWater[1] = 97.0f / 255.0f;
	DarkWater[2] = 117.0f / 255.0f;

	if (UseMapColors == 0){
		for (i = 0; i < 3; i++){
			id->m_sCurLayout.m_glfWaterColor[i] = LightWater[i];
			id->m_sCurLayout.m_glfWaterFillColor[i] = LightWater[i];
			CMColor[i] = LightCM[i];
			id->m_sCurLayout.m_glfUSColor[i] = LightUS[i];
		}
	} else if ( UseMapColors == 1 ){
		for (i = 0; i < 3; i++){
			id->m_sCurLayout.m_glfWaterColor[i] = MedWater[i];
			id->m_sCurLayout.m_glfWaterFillColor[i] = MedWater[i];
			CMColor[i] = MedCM[i];
			id->m_sCurLayout.m_glfUSColor[i] = MedUS[i];
		}
	} else {
		for (i = 0; i < 3; i++){
			id->m_sCurLayout.m_glfWaterColor[i] = DarkWater[i];
			id->m_sCurLayout.m_glfWaterFillColor[i] = DarkWater[i];
			CMColor[i] = DarkCM[i];
			id->m_sCurLayout.m_glfUSColor[i] = DarkUS[i];
		}
	}

	return(TRUE);
}




CalcRGB(short sval, PColor rgb)
{
	PColor hsv;

	if (sval > 500){  // dummy code
		sval++;
		sval--;
	} else if ( sval > 1000 ){ // dummy code
		sval++;
		sval--;
	}
	if (sval < 0.0) sval = 0;
	hsv[HUE] = 89.0 - (88.0 * (sval / 3000.0));
	if (hsv[HUE] < 1.0) hsv[HUE] = 1.0;
	hsv[SATURATION] = 253.0 - (252.0 * (sval / 3000));
	// hsv[SATURATION] = 252.0 * (sval/3000.0);  // invert saturation
	if (hsv[SATURATION] < 1.0) hsv[SATURATION] = 1.0;

	hsv[VALUE] = 100.0 + (120.0 * sval / 2000.0);
	hsv[VALUE] = Min(210.0, hsv[VALUE]);

	/* Hue degree between 0.0 and 360.0 */
	/* Saturation between 0.0 (gray) and 1.0 */
	/* Value between 0.0 (black) and 1.0 */

	// hsv hue convert from 0 to 360;
	hsv[HUE] = 360.0 * (hsv[HUE] / 255.0);
	// hsv value ranges from 0 to 1.0
	hsv[VALUE] = 1.0 * (hsv[VALUE] / 255.0);
	hsv[SATURATION] = 1.0 * (hsv[SATURATION] / 255.0);

	Color_HSVtoRGB(hsv, rgb);



	rgb[RED] = rgb[RED] * 255;
	rgb[GREEN] = rgb[GREEN] * 255;
	rgb[BLUE] = rgb[BLUE] * 255;

	// test
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) sval=%d h=%g s=%g v=%g r=%g g=%g b=%g\n", GetCurrentThreadId(), sval, hsv[HUE], hsv[SATURATION], hsv[VALUE],
	//  rgb[RED], rgb[GREEN], rgb[BLUE] );



}





void DispTexture(struct InstanceData* id, GLfloat x, GLfloat y, GLfloat rot)
{
	GL_ASSERT(glLoadIdentity());
	GL_ASSERT(glTranslatef(x, y, (float)trans[2]));
	GL_ASSERT(glRotatef(rot, 0.0f, 0.0f, 1.0f));
	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0, (GLfloat) 64.0, 0.0f);
	glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0, (GLfloat) 0.0, 0.0f);
	glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat) 64.0, (GLfloat) 0.0, 0.0f);
	glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat) 64.0, (GLfloat) 64.0, 0.0f);
	GL_ASSERT(glEnd());
}


drawTexMap(struct InstanceData* id, GLuint maptexture, double xloc, double yloc, double xloc2, double yloc2)
{
	// static VO *AirVO, *DataVO;
	double XSize, YSize;
	GLfloat params[4];
	int map_square_pixels = 0;

	/* reset the color to white so textures will appear */
	GL_ASSERT(glColor3f(1.0, 1.0, 1.0));

	GL_ASSERT(glMatrixMode(GL_PROJECTION));
	GL_ASSERT(glLoadIdentity());

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	GL_ASSERT(glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f));

	GL_ASSERT(glMatrixMode(GL_MODELVIEW));
	GL_ASSERT(glLoadIdentity());


	GL_ASSERT(glEnable(GL_TEXTURE_2D));
	GL_ASSERT(glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT));
	GL_ASSERT(glBindTexture(GL_TEXTURE_2D, maptexture));

	if (map_square_pixels){
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
	} else {
		/* Linear Filtering */
		/* produces a smoothed image, more accurate and realistic? */
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
	}
	GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP));
	GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP));


	/* solid with alpha masking */
	//glEnable(GL_DEPTH_TEST);


	// glDepthFunc(GL_LEQUAL);
	// glDepthFunc(GL_NOTEQUAL);
	//glDepthFunc(GL_EQUAL);
	// glDepthFunc(GL_GREATER);


	GL_ASSERT(glPushMatrix());
	GL_ASSERT(glLoadIdentity());


	// glTranslatef( (GLfloat) -140.0f,  (GLfloat) -10.0f, (GLfloat) trans[2] );
	GL_ASSERT(glTranslatef((GLfloat)xloc, (GLfloat)yloc, (GLfloat)trans[2]));
	XSize = xloc2 - xloc;
	YSize = yloc2 - yloc;

	map_square_pixels = 1;
	params[0] = 1.0f;
	params[1] = 1.0f;
	params[2] = 1.0f;
	params[3] = 1.0f;

	GL_ASSERT(glEnable(GL_BLEND));
	GL_ASSERT(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
	GL_ASSERT(glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params));
	GL_ASSERT(glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND));
	GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP));
	GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP));
	GL_ASSERT(glEnable(GL_TEXTURE_2D));


	// for future, add control over terrain intensity to user
	GL_ASSERT(glColor4f(MapIntensity, MapIntensity, MapIntensity, 1.0f));
	//glColor4f(0.0f, 0.0f, 0.0f, 1.0f);

	if (map_square_pixels){
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST));
	} else {
		/* Linear Filtering */
		/* produces a smoothed image, more accurate and realistic? */
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
		GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
	}
	GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP));
	GL_ASSERT(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP));



	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat)YSize, 0.0);
	glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)XSize, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)XSize, (GLfloat)YSize, 0.0);

	//glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) YSize + overlap, 0.0);
	//glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0, 0.0);
	//glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat) XSize + overlap, (GLfloat) 0.0, 0.0);
	//glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat) XSize + overlap, (GLfloat) YSize + overlap, 0.0);

	GL_ASSERT(glEnd());

	GL_ASSERT(glFlush());

	GL_ASSERT(glPopMatrix());

	GL_ASSERT(glDisable(GL_TEXTURE_ENV));
	GL_ASSERT(glDisable(GL_TEXTURE_2D));
	GL_ASSERT(glDisable(GL_ALPHA_TEST));
	GL_ASSERT(glEnable(GL_BLEND));
	GL_ASSERT(glDisable(GL_DEPTH_TEST));
	GL_ASSERT(glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE));
	return(SUCCEED);
}


void PNG2Image(struct InstanceData* id, GLubyte *Gmapimage, int dst_map_tex_size, gdImagePtr im)
{
	int x, y;
	unsigned char redval, greenval, blueval;
	int index, truecolor, c, alpha, mapsize;
	int pflag = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// copy the gdimage into a texture. gdimage size must be greater or equal to tex size
	if (!im){
		return;
	}

	mapsize = dst_map_tex_size * dst_map_tex_size * 4;
	if (gdImageTrueColor(im)){
		// true color
		truecolor = 1;
	} else {
		truecolor = 0;
	}


	for (y = 0; y < dst_map_tex_size; y++){

		for (x = 0; x < dst_map_tex_size; x++){

			if (x >= im->sx || y >= im->sy){
				// beyong png range, fill with 0
				// fill in transparent pix with alpha = 0;
				index = ((im->sy - y - 1) * dst_map_tex_size * 4) + (x * 4);
				if (index < 0 || index > mapsize - 3){
					if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad index=%d\n", cdwThreadId, index);
					continue;
				}
				Gmapimage[index] = 0;
				Gmapimage[index + 1] = 0;
				Gmapimage[index + 2] = 0;
				Gmapimage[index + 3] = 0; // alpha
				continue;
			}

			c = gdImageGetPixel(im, x, y);
			if (truecolor){
				alpha = 255;
				redval = gdImageRed(im, c);
				greenval = gdImageGreen(im, c);
				blueval = gdImageBlue(im, c);
			} else if ( !truecolor && (c < 0 || c > 255) ){
				alpha = 0;
				redval = greenval = blueval = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if (alpha > 255) alpha = 255;

				redval = im->red[c];
				greenval = im->green[c];
				blueval = im->blue[c];
			}
			// write the rgb values into the texture
			index = ((im->sy - y - 1) * dst_map_tex_size * 4) + (x * 4);
			if (index < 0 || index > mapsize - 3){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad index=%d\n", cdwThreadId, index);
				continue;
			}

			if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) x=%d y=%d rgb=%d %d %d\n", cdwThreadId, x, y, redval, greenval, blueval);
			Gmapimage[index] = redval;
			Gmapimage[index + 1] = greenval;
			Gmapimage[index + 2] = blueval;
			Gmapimage[index + 3] = alpha; // alpha
		}
	}

}



void PNG2Texture(struct InstanceData* id, GLubyte *Gmapimage, int dst_map_tex_size, gdImagePtr im)
{
	double colscale, rowscale;
	int x, y, pngx, pngy;
	unsigned char redval, greenval, blueval;
	int index, truecolor, c, alpha, mapsize;
	int pflag = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// copy the gdimage into a texture. gdimage size must be greater or equal to tex size
	if (!im){
		return;
	}

	mapsize = dst_map_tex_size * dst_map_tex_size * 4;
	if (gdImageTrueColor(im)){
		// true color
		truecolor = 1;
	} else {
		truecolor = 0;
	}
	colscale = (double)im->sx / dst_map_tex_size;
	rowscale = (double)im->sy / dst_map_tex_size;

	for (y = 0; y < dst_map_tex_size; y++){
		pngy = (int)rint(y * rowscale);
		for (x = 0; x < dst_map_tex_size; x++){
			pngx = (int)rint(x * colscale);

			if (pngx >= im->sx || pngy >= im->sy){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) BAD x=%d y=%d pngx=%d pngy=%d rgb=%d %d %d\n",
					cdwThreadId, x, y, pngx, pngy, redval, greenval, blueval);
				continue;
			}

			c = gdImageGetPixel(im, pngx, pngy);
			if (truecolor){
				alpha = 255;
				redval = gdImageRed(im, c);
				greenval = gdImageGreen(im, c);
				blueval = gdImageBlue(im, c);
			} else if ( !truecolor && (c < 0 || c > 255) ){
				alpha = 0;
				redval = greenval = blueval = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if (alpha > 255) alpha = 255;

				redval = im->red[c];
				greenval = im->green[c];
				blueval = im->blue[c];
			}
			// write the rgb values into the texture
			index = (y * dst_map_tex_size * 4) + (x * 4);
			if (index < 0 || index > mapsize - 3){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad index=%d\n", cdwThreadId, index);
				continue;
			}

			if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) x=%d y=%d pngx=%d pngy=%d rgb=%d %d %d\n",
				cdwThreadId, x, y, pngx, pngy, redval, greenval, blueval);
			Gmapimage[index] = redval;
			Gmapimage[index + 1] = greenval;
			Gmapimage[index + 2] = blueval;
			Gmapimage[index + 3] = alpha; // alpha
		}
	}

}

// This is similar to PNG2Texture except it allows for rectangular textures (instead of squares).
void PNGRect2Texture(struct InstanceData* id, GLubyte *Gmapimage, gdImagePtr im, int alpha_mode)
{
	double colscale, rowscale;
	int x, y, pngx, pngy;
	unsigned char redval, greenval, blueval;
	int index, truecolor, c, alpha, mapsize;
	int pflag = 0;
	int width = im->sx;
	int height = im->sy;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// copy the gdimage into a texture. gdimage size must be greater or equal to tex size
	if (!im){
		return;
	}

	mapsize = width * height * 4;
	if (gdImageTrueColor(im)){
		// true color
		truecolor = 1;
	} else {
		truecolor = 0;
	}
	colscale = (double)im->sx / width;
	rowscale = (double)im->sy / height;

	for (y = 0; y < height; y++){
		pngy = (int)rint(y * rowscale);
		for (x = 0; x < width; x++){
			pngx = (int)rint(x * colscale);

			if (pngx >= im->sx || pngy >= im->sy){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) BAD x=%d y=%d pngx=%d pngy=%d rgb=%d %d %d\n",
					cdwThreadId, x, y, pngx, pngy, redval, greenval, blueval);
				continue;
			}

			c = gdImageGetPixel(im, pngx, pngy);
			if (truecolor){
				// alpha = 255;
				// gd uses max alpha of 127, so scale to opengl value of 255
				alpha = 255 - (gdImageAlpha(im, c) * 2);

				redval = gdImageRed(im, c);
				greenval = gdImageGreen(im, c);
				blueval = gdImageBlue(im, c);
				if (alpha_mode == ALPHA_MODE_BLACK){
					if (redval == 0 && greenval == 0 && blueval == 0){
						alpha = 0;
					}
				}
#ifdef OLDWAY
				alpha = 255;
				redval = gdImageRed(im, c);
				greenval = gdImageGreen(im, c);
				blueval = gdImageBlue(im, c);
#endif
			} else if ( !truecolor && (c < 0 || c > 255) ){
				alpha = 0;
				redval = greenval = blueval = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if (alpha > 255) alpha = 255;

				redval = im->red[c];
				greenval = im->green[c];
				blueval = im->blue[c];
			}
			// write the rgb values into the texture
			index = (y * width * 4) + (x * 4);
			if (index < 0 || index > mapsize - 3){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad index=%d\n", cdwThreadId, index);
				continue;
			}

			if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) x=%d y=%d pngx=%d pngy=%d rgb=%d %d %d\n",
				cdwThreadId, x, y, pngx, pngy, redval, greenval, blueval);
			Gmapimage[index] = redval;
			Gmapimage[index + 1] = greenval;
			Gmapimage[index + 2] = blueval;
			Gmapimage[index + 3] = alpha; // alpha
		}
	}

}



void AddTexImage(struct InstanceData* id, GLubyte *mapimage, GLubyte *demimage, double longitude, double latitude, int src_map_x_pixels,
	int src_map_y_pixels, double XSize, double YSize, int dst_map_tex_size)
{
	double end_long, end_lat, lat, lng, xpixsize_dest, ypixsize_dest;
	int y, x, xpix_src, ypix_src, sourceindex, index, row_offset;
	int sourcesize, mapsize;
	int pflag = 1;
	const DWORD cdwThreadId = GetCurrentThreadId();


	/* find out what part of this image is in the main image map */

	end_long = longitude + XSize;
	end_lat = latitude + YSize;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) long=%g latitude=%g end_long=%g end_lat=%g",
			cdwThreadId, longitude, latitude, end_long, end_lat);
	}


	xpixsize_dest = (id->m_sCurLayout.m_dWorldXSize / dst_map_tex_size);
	ypixsize_dest = (id->m_sCurLayout.m_dWorldYSize / dst_map_tex_size);


	sourcesize = src_map_x_pixels * src_map_y_pixels * 4;
	mapsize = dst_map_tex_size * dst_map_tex_size * 4;

	// go through each pixel in the output image mapimage[][], and place appropriate value from dem source demimage

	for (y = 0; y < dst_map_tex_size; y++){

		lat = (id->m_sCurLayout.m_dWorldYmin + (y * ypixsize_dest));

		if (lat < latitude){
			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) before y range of source lat=%g end_lat=%g startlatitude=%g\n",
					cdwThreadId, lat, end_lat, latitude);
			}
			// not in y range of the source image yet
			continue;
		}

		if (lat - end_lat > ypixsize_dest){
			lat = end_lat;
			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) beyond y range of source lat=%g end_lat=%g startlatitude=%g\n",
					cdwThreadId, lat, end_lat, latitude);
			}
			break; // beyond y range of source
			// row_offset = 0; // largest value in inverted array
		} else {
			ypix_src = (int)rint(((lat - latitude) / YSize)  * src_map_y_pixels);
			// ypix_src = src_map_y_pixels - y - 1;

			row_offset = ((src_map_y_pixels - ypix_src - 1) * src_map_x_pixels * 4);
			// row_offset = ypix_src * src_map_x_pixels * 4;
			if (row_offset < 0){
				row_offset = 0;
			}
		}

		for (x = 0; x < dst_map_tex_size; x++){
			lng = (id->m_sCurLayout.m_dWorldXmin + (x * xpixsize_dest));

			if (longitude - lng > xpixsize_dest){
				// long not in range of source yet
				continue;
			}
			if (lng - end_long > xpixsize_dest){
				break;
			}

			xpix_src = (int)rint(((lng - longitude) / XSize) * src_map_x_pixels);


			if (xpix_src < 0){
				xpix_src = 0;
			}
			if (xpix_src >= src_map_x_pixels){
				xpix_src = src_map_x_pixels - 1;
			}


			sourceindex = row_offset + (xpix_src * 4);
			if (sourceindex < 0 || sourceindex > sourcesize){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad sourceindex=%d\n", cdwThreadId, sourceindex);
				break;
			}
			index = (y * dst_map_tex_size * 4) + (x * 4);
			if (index < 0 || index > mapsize - 3){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad index=%d\n", cdwThreadId, index);
				continue;
			}
			mapimage[index] = demimage[sourceindex];
			mapimage[index + 1] = demimage[sourceindex + 1];
			mapimage[index + 2] = demimage[sourceindex + 2];
			mapimage[index + 3] = demimage[sourceindex + 3]; // alpha

			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) map[%d][%d] src[%d][%d] (i=%d) si=%d lat=%g lng=%g r=%d g=%d b=%d a=%d\n",
					cdwThreadId, x, y, xpix_src, ypix_src, index, sourceindex,
					lat, lng, mapimage[index], mapimage[index + 1], mapimage[index + 2], mapimage[index + 3]);
			}

		}
	}


}




int SaveTexture(GLubyte *LayerImage, int gmap_texture_pixels, char *tilename,
	int layer, double lng1, double lng2, double lat1, double lat2)
{
	int cnt, len;
	FILE *out;

	if (!tilename){
		return(FAIL);
	}

	if (!fopen_s(&out, tilename, "wb")){
		cnt = fwrite(LayerImage, 1, gmap_texture_pixels * gmap_texture_pixels * 4, out);
	}
	fclose(out);


	// now write out the image coordinates in a text file
	len = strlen(tilename);
	len -= 3;
	strcpy_s(&tilename[len], 4, "txt");

	if (!fopen_s(&out, tilename, "wb")){
		fprintf(out, "%s\n%g %g %g %g\n", tilename, lng1, lng2, lat1, lat2);
	}
	fclose(out);


	return(SUCCEED);
}



ImgInRange(struct InstanceData* id, int layer, int xt, int yt, int maptexnum, char *imagedir)
{
	char tilename[256];
	FILE *f;
	char linebuf[LINEBUF_SIZE];
	double lngst, lngend, latst, latend;
	struct MemoryStruct chunk;
	char url[256];
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();

	// this routine loads in the txt header files for an image tile
	//  if not on disk, it will retrieve from web server and store locally
	//    this may change later if applet cannot save to disk
	// read in image coordinates

	sprintf_s(tilename, _countof(tilename), "%slayer%dlarge%02d_%02d.txt", imagedir, layer, xt, yt);

	if (fopen_s(&f, tilename, "r")){
		//fclose(f);
		//FileToStr(tilename);
	} else {
		// get image from server
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */
		// sprintf(tilename, "%slayer%dlarge%02d_%02d.txt", imagedir, layer, xt, yt );
		sprintf_s(url, _countof(url), "%s/%s/layer%dlarge%02d_%02d.txt", id->m_strHttpActiveXservername, id->m_strHttpImagePath, layer, xt, yt);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlPage id <%x> url <%s>.\n", cdwThreadId, id, url);
		if (GetCurlPage(id, &chunk, url, SM_HTTPS, 3, 30L)){
			// write the file to disk
			sprintf_s(tilename, _countof(tilename), "%slayer%dlarge%02d_%02d.txt", imagedir, layer, xt, yt);
			if (fopen_s(&f, tilename, "wb")){
				sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", tilename);
				free_chunk_memory(&chunk);
				return(FALSE);
			}
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) writing chunk.size=%d\n", cdwThreadId, chunk.size);
			fwrite(chunk.memory, 1, chunk.size, f);
			fclose(f);
			if (chunk.memory){
				free(chunk.memory);
			}
			if (fopen_s(&f, tilename, "rb")){
				sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", tilename);
				return(FALSE);
			}
		}
	}
	if (!fgets(linebuf, LINEBUF_SIZE, f)){
		fclose(f);
		return(FALSE);
	}
	sscanf_s(linebuf, "%s", tilename, _countof(tilename));
	if (!fgets(linebuf, LINEBUF_SIZE, f)){
		fclose(f);
		return(FALSE);
	}
	sscanf_s(linebuf, "%lg %lg %lg %lg", &lngst, &lngend, &latst, &latend);
	fclose(f);

	if (RectanglesOverlap(lngst, latst, lngend, latend,
		id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmax)) {
		//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Inrange, tex=%d\txt=%d\tyt=%d\t%g\t%g\t%g\t%g\n",
		//	cdwThreadId, maptexnum, xt, yt, lngst, lngend, latst, latend );
		lng1[maptexnum] = lngst;
		lng2[maptexnum] = lngend;
		lat1[maptexnum] = latst;
		lat2[maptexnum] = latend;
		return(TRUE);
	}
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) OUT of range, tex=%d\txt=%d\tyt=%d\t%g\t%g\t%g\t%g\n",
	//			cdwThreadId, maptexnum, xt, yt, lngst, lngend, latst, latend );
	return(FALSE);
}




int LoadImageTile(struct InstanceData* id, int layer, int xt, int yt, int gmap_texture_pixels, int maptexnum, char *imagedir)
{
	char tilename[256];
	int imgsize, nbytes;
	GLubyte *LayerImage;
	FILE *f;
	char tmpstr[TMPBUF_SIZE];

	if (!ImgInRange(id, layer, xt, yt, maptexnum, imagedir)){
		return(FALSE);
	}

	sprintf_s(tilename, _countof(tilename), "layer%dlarge%02d_%02d.img", layer, xt, yt);
	if (!GetLocalFile(id, imagedir, tilename, id->m_strHttpImagePath, SM_HTTPS)){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", tilename);
		return (FALSE);
	}

	// load the file into LayerImage
	imgsize = gmap_texture_pixels * gmap_texture_pixels * 4;
	LayerImage = (GLubyte *)calloc(1, imgsize);

	sprintf_s(tilename, _countof(tilename), "%slayer%dlarge%02d_%02d.img", imagedir, layer, xt, yt);
	if (fopen_s(&f, tilename, "rb")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", tilename);
		return(FALSE);
	}
	if (!(nbytes = fread(LayerImage, 1, imgsize, f))){
		return(FALSE);
	}
	fclose(f);

	// create the texture index
	glGenTextures(1, &maptexture[maptexnum]);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", GetCurrentThreadId(), tilename, maptexture[maptexnum]);

	glBindTexture(GL_TEXTURE_2D, maptexture[maptexnum]);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, gmap_texture_pixels, gmap_texture_pixels, 0, GL_RGBA,
		GL_UNSIGNED_BYTE, LayerImage);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

	free(LayerImage);

	return(TRUE);
}





void BuildMapLayers(struct InstanceData* id, int layer, char *pathname, char *imagename, int gmap_texture_pixels, int xtiles, int ytiles,
	double pnglng1, double pnglat1, double pnglng2, double pnglat2)
{
	char pngname[TMPBUF_SIZE];
	int map_square_pixels = 0;
	int modify_colors = 0;
	static int pflag = 0;
	gdImagePtr im_in, im_out;
	FILE *in, *out;
	char tmpstr[TMPBUF_SIZE], tilename[256];
	int new_xsize, new_ysize, xt, yt, xstart, ystart;
	int create_test_pngs = FALSE;
	GLubyte *LayerImage;
	int maptexnum = 0;
	double latsize, lngsize;
	char filename[256];
	FILE *f;
	//struct MemoryStruct chunk;
	//char url[256];

	// load in the PNG
	sprintf_s(pngname, TMPBUF_SIZE, "%s%s.png", pathname, imagename);
	if (fopen_s(&in, pngname, "rb")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", pngname);
		return;
	}
	if (!(im_in = gdImageCreateFromPng(in))){
		fclose(in);
		return;
	}
	fclose(in);


	// write out the layer info to disk
	sprintf_s(filename, _countof(filename), "%slayer%d.txt", pathname, layer);
	if (!fopen_s(&f, filename, "w")){
		fprintf(f, "%d %d\n", xtiles, ytiles);
		fprintf(f, "%d\n", gmap_texture_pixels);
	}
	fclose(f);


	latsize = pnglat2 - pnglat1;
	lngsize = pnglng2 - pnglng1;

	/* Make the output image four times as small on both axes. Use
	a true color image so that we can interpolate colors. */

	new_xsize = im_in->sx / xtiles;
	new_ysize = im_in->sy / ytiles;

	// create an opengl format image in RGBA format -- 4 bytes for each pixel
	LayerImage = (GLubyte *)calloc(1, gmap_texture_pixels * gmap_texture_pixels * 4);



	for (xt = 0; xt < xtiles; xt++){
		for (yt = 0; yt < ytiles; yt++){

			xstart = xt * new_xsize; // xstart is starting pixel number
			ystart = yt * new_ysize;

			im_out = gdImageCreateTrueColor(new_xsize, new_ysize);
			/* Now copy the large image, but four times smaller */
			// void gdImageCopyResampled(gdImagePtr dst, gdImagePtr src, 
			//  int dstX, int dstY, int srcX, int srcY, int destW, int destH, int srcW, int srcH) (FUNCTION)
			gdImageCopyResampled(im_out, im_in, 0, 0, xstart, ystart,
				im_out->sx, im_out->sy,
				im_out->sx, im_out->sy); // same size as output file

			if (create_test_pngs){
				sprintf_s(tilename, _countof(tilename), "%slayer%dlarge%02d_%02d.png", pathname, layer, xt, yt);
				if (!fopen_s(&out, tilename, "wb")){
					gdImagePng(im_out, out);
					fclose(out);
				}
			}

			PNG2Texture(id, LayerImage, gmap_texture_pixels, im_out);

			// save texture coordinates
			// must reverse y coordinates for opengl
			lat1[maptexnum] = pnglat1 + ((ytiles - yt - 1) * latsize / ytiles);
			lat2[maptexnum] = lat1[maptexnum] + (latsize / ytiles);
			lng1[maptexnum] = pnglng1 + (xt * lngsize / xtiles);
			lng2[maptexnum] = lng1[maptexnum] + (lngsize / xtiles);


			sprintf_s(tilename, _countof(tilename), "%slayer%dlarge%02d_%02d.img", pathname, layer, xt, yt);
			SaveTexture(LayerImage, gmap_texture_pixels, tilename, layer, lng1[maptexnum], lng2[maptexnum],
				lat1[maptexnum], lat2[maptexnum]);

			// create the texture index
			glGenTextures(1, &maptexture[maptexnum]);
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", GetCurrentThreadId(), tilename, maptexture[maptexnum]);

			glBindTexture(GL_TEXTURE_2D, maptexture[maptexnum]);

			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, gmap_texture_pixels, gmap_texture_pixels, 0, GL_RGBA,
				GL_UNSIGNED_BYTE, LayerImage);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
			gdImageDestroy(im_out);

			maptexnum++;
		}
	}

	num_tex_maps[layer] = maptexnum;

	free(LayerImage);
	// PNG2Texture( id, LayerImage, gmap_texture_pixels, im );
	gdImageDestroy(im_in);

}

int LoadControlTexture(struct InstanceData* id, char* filename)
{
	char pngname[TMPBUF_SIZE];
	FILE* in;
	gdImagePtr im;
	GLuint texture = 0;
	GLubyte *textureImage;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!GetLocalFile(id, id->m_strImageDir, filename, id->m_strHttpImagePath, SM_HTTPS))
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s).", cdwThreadId, filename);
		return texture;
	}
	sprintf_s(pngname, TMPBUF_SIZE, "%s%s", id->m_strImageDir, filename);
	if (fopen_s(&in, pngname, "rb"))
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local texture(%s).", cdwThreadId, filename);
		return texture;
	}
	im = gdImageCreateFromPng(in);
	fclose(in);

	// create an opengl format image in RGBA format -- 4 bytes for each pixel
	textureImage = (GLubyte *)calloc(1, im->sx * im->sy * 4);
	PNGRect2Texture(id, textureImage, im, ALPHA_MODE_NONE);
	// create the texture index

	glGenTextures(1, &texture);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", cdwThreadId, pngname, texture);

	glBindTexture(GL_TEXTURE_2D, texture);
	//glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, im->sx, im->sy, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureImage);

	gdImageDestroy(im);

	return texture;
}

int LoadOverlayMapTexture(struct InstanceData* id, char* filename)
{
	char pngname[TMPBUF_SIZE];
	FILE* in;
	gdImagePtr im;
	GLuint texture = 0;
	GLubyte *textureImage;
	int npixels, i, index;
	const DWORD cdwThreadId = GetCurrentThreadId();


	if (!GetLocalFile(id, id->m_strImageDir, filename, id->m_strHttpImagePath, SM_HTTPS))
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s).", cdwThreadId, filename);
		return texture;
	}
	sprintf_s(pngname, TMPBUF_SIZE, "%s%s", id->m_strImageDir, filename);
	if (fopen_s(&in, pngname, "rb"))
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local texture(%s).", cdwThreadId, filename);
		return texture;
	}
	im = gdImageCreateFromPng(in);
	fclose(in);

	// create an opengl format image in RGBA format -- 4 bytes for each pixel
	textureImage = (GLubyte *)calloc(1, im->sx * im->sy * 4);
	PNGRect2Texture(id, textureImage, im, ALPHA_MODE_NONE);

	// Convert White to Fully Transparent
	ImgChangeColorAlpha(textureImage, im->sx, im->sy, 255, 255, 255, 0, 255, 255, 255);

	// Convert All other Colors to 50% Transparency
	npixels = im->sx * im->sy;
	for (i = 0; i < npixels; i++){
		index = i * 4;
		if (0 != textureImage[index + 3]){
			textureImage[index + 3] = 127;
		}
	}

	// create the texture index	
	glGenTextures(1, &texture);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", cdwThreadId, pngname, texture);

	glBindTexture(GL_TEXTURE_2D, texture);
	//glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, im->sx, im->sy, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureImage);

	gdImageDestroy(im);

	return texture;
}

void makeRasterFont(void)
{
	GLuint i;

	/* see red book chapter 8 for explanation */


	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	fontOffset = glGenLists(128);
	for (i = 32; i < 127; i++) {
		glNewList(i + fontOffset, GL_COMPILE);
		/* glBitmap(width,height, xorig, yorig,xmove, ymove, *bitmap) */
		/* xmove and ymove is how many bits to move cursor after rendering */
		/* width and height are in pixels of the image, may be different than
		the number of bytes in raster bytes */
		glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, rasters[i - 32]);
		glEndList();
	}
}


void DrawCachedPNG(struct InstanceData* id, char *imagename, int gmap_texture_pixels, MRECT *wrld, MRECT *ploc)
{
	// differs from DisplayCachedPNG only because it allows any size PNG image
	int map_square_pixels = 0;
	GLubyte *mapimage;
	MAPLL *png = NULL;
	GLfloat params[4], XSize, YSize;
	char tmpstr[TMPBUF_SIZE];
	FILE *in;
	gdImagePtr im;
	char pngname[128];
	const DWORD cdwThreadId = GetCurrentThreadId();

	// this routine will load in a png image, create a texture, and draw it on the screen. 
	//  This routine will cache the texture so it will not load into memory on subsequent calls
	D_CONTROL("NEW2_DBG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filename=%s, tsize=%d\n", cdwThreadId, imagename, gmap_texture_pixels));

	// see if we have this file loaded into a texture already
	for (png = id->m_pPngLL; png; png = png->np){
		if (!strcmp(png->mapfilename, imagename)){
			// already have this processed
			break;
		}
	}

	if (!png){
		mapimage = (GLubyte *)calloc(1, gmap_texture_pixels * gmap_texture_pixels * 4);

		// load in the PNG

		if (!GetLocalFile(id, id->m_strImageDir, imagename, id->m_strHttpImagePath, SM_HTTPS))
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s).", cdwThreadId, imagename);
			return;
		}
		_snprintf_s(pngname, TMPBUF_SIZE, 128, "%s%s", id->m_strImageDir, imagename);


		if (fopen_s(&in, pngname, "rb")){
			sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", imagename);
			return;
		}
		im = gdImageCreateFromPng(in);
		fclose(in);

		// copy the gdimage into the opengl image format (mapimage)
		PNG2Image(id, mapimage, gmap_texture_pixels, im);

		// Added to Change make white "see thru"
		ImgChangeColorAlpha(mapimage, gmap_texture_pixels, gmap_texture_pixels, 255, 255, 255, 0, 255, 255, 255);

		gdImageDestroy(im);

		if (!id->m_pPngLL){
			id->m_pPngLL = calloc(1, sizeof(MAPLL));
			id->m_pPngCurp = id->m_pPngLL;
		} else {
			(id->m_pPngCurp)->np = calloc(1, sizeof(MAPLL));
			id->m_pPngCurp = (id->m_pPngCurp)->np;
		}

		strncpy_s((id->m_pPngCurp)->mapfilename, NAMESIZE, imagename, _TRUNCATE);
		(id->m_pPngCurp)->x1 = (GLfloat)ploc->x1;
		(id->m_pPngCurp)->y1 = (GLfloat)ploc->y1;
		(id->m_pPngCurp)->x2 = (GLfloat)ploc->x1 + gmap_texture_pixels;
		(id->m_pPngCurp)->y2 = (GLfloat)ploc->y1 + gmap_texture_pixels;


		glGenTextures(1, &(id->m_pPngCurp)->maptexture);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", cdwThreadId, (id->m_pPngCurp)->mapfilename, (id->m_pPngCurp)->maptexture);
		png = id->m_pPngCurp;

		glBindTexture(GL_TEXTURE_2D, png->maptexture);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, gmap_texture_pixels, gmap_texture_pixels, 0, GL_RGBA,
			GL_UNSIGNED_BYTE, mapimage);
		if (map_square_pixels){
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		} else {
			/* Linear Filtering */
			/* produces a smoothed image, more accurate and realistic? */
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		}
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);


		free(mapimage);
		mapimage = NULL;

	}

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	glOrtho(wrld->x1, wrld->x2, wrld->y1, wrld->y2, 0.0f, 1.0f);
	//glOrtho(WorldXmin, WorldXmax, WorldYmin, WorldYmax, 0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);
	glBindTexture(GL_TEXTURE_2D, png->maptexture);

	glPushMatrix();
	glLoadIdentity();

	glTranslatef((GLfloat)ploc->x1, (GLfloat)ploc->y1, (GLfloat)trans[2]);

	params[0] = 1.0f;
	params[1] = 1.0f;
	params[2] = 1.0f;
	params[3] = 1.0f;

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

	glEnable(GL_TEXTURE_2D);
	glColor4f(MapIntensity, MapIntensity, MapIntensity, 1.0f);

	XSize = (GLfloat)gmap_texture_pixels; // use size of texture, not png image
	YSize = (GLfloat)gmap_texture_pixels;

	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0f, 0.0f);
	glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat)YSize, 0.0f);
	glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)XSize, (GLfloat)YSize, 0.0f);
	glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)XSize, (GLfloat) 0.0f, 0.0f);

	glEnd();

	glFlush();

	glPopMatrix();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

}

void DrawCachedPNG2(struct InstanceData* id, char *imagename, MRECT *ploc, int alpha_mode, int blendflag, int ChangeColorAlpha, int filtertype,
	GLfloat angle)
{
	// differs from DrawCachedPNG because it allows any size PNG image and any size texture area
	int map_square_pixels = 0;
	int width, height, imgxsize, imgysize;
	GLubyte *mapimage;
	MAPLL *png = NULL;
	GLfloat params[4];
	char tmpstr[TMPBUF_SIZE];
	FILE *in;
	gdImagePtr im;
	char pngname[128];
	const DWORD cdwThreadId = GetCurrentThreadId();



	// this routine will load in a png image, create a texture, and draw it on the screen. 
	//  This routine will cache the texture so it will not load into memory on subsequent calls
	D_CONTROL("NEW22_DBG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filename=%s\n", cdwThreadId, imagename));

	// see if we have this file loaded into a texture already
	for (png = id->m_pPngLL; png; png = png->np){
		if (!strcmp(png->mapfilename, imagename)){
			// already have this processed
			break;
		}
	}

	if (!png){
		// load in the PNG
		if (!GetLocalFile(id, id->m_strImageDir, imagename, id->m_strHttpImagePath, SM_HTTPS))
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s).", cdwThreadId, imagename);
			return;
		}
		_snprintf_s(pngname, _countof(pngname), _TRUNCATE, "%s%s", id->m_strImageDir, imagename);

		if (fopen_s(&in, pngname, "rb")){
			sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", imagename);
			return;
		}
		im = gdImageCreateFromPng(in);
		fclose(in);

		width = im->sx;
		height = im->sy;

		mapimage = (GLubyte *)calloc(1, width * height * 4);

		// copy the gdimage into the opengl image format (mapimage)
		PNGRect2Texture(id, mapimage, im, alpha_mode);

		if (ChangeColorAlpha){
			// Added to Change make white "see thru"
			ImgChangeColorAlpha(mapimage, width, height, 255, 255, 255, 0, 255, 255, 255);
		}

		gdImageDestroy(im);

		if (!id->m_pPngLL){
			id->m_pPngLL = calloc(1, sizeof(MAPLL));
			id->m_pPngCurp = id->m_pPngLL;
		} else {
			(id->m_pPngCurp)->np = calloc(1, sizeof(MAPLL));
			id->m_pPngCurp = (id->m_pPngCurp)->np;
		}

		strncpy_s((id->m_pPngCurp)->mapfilename, NAMESIZE, imagename, _TRUNCATE);
		(id->m_pPngCurp)->x1 = (GLfloat)ploc->x1;
		(id->m_pPngCurp)->y1 = (GLfloat)ploc->y1;
		(id->m_pPngCurp)->x2 = (GLfloat)ploc->x2;
		(id->m_pPngCurp)->y2 = (GLfloat)ploc->y2;

		glGenTextures(1, &(id->m_pPngCurp)->maptexture);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", cdwThreadId, (id->m_pPngCurp)->mapfilename, (id->m_pPngCurp)->maptexture);
		png = id->m_pPngCurp;

		glBindTexture(GL_TEXTURE_2D, png->maptexture);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA,
			GL_UNSIGNED_BYTE, mapimage);

		/* Linear Filtering produces a smoothed image, more accurate and realistic for many uses */
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filtertype); // filter type is GL_NEAREST or GL_LINEAR
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filtertype);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);


		free(mapimage);
		mapimage = NULL;

	}

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);
	glBindTexture(GL_TEXTURE_2D, png->maptexture);

	params[0] = 1.0f;
	params[1] = 1.0f;
	params[2] = 1.0f;
	params[3] = 1.0f;

	if (blendflag){
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
	} else {
		glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);
		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
	}


	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

	glEnable(GL_TEXTURE_2D);
	glColor4f(MapIntensity, MapIntensity, MapIntensity, 1.0f);

	if (fabs(angle) > 0.0001){
		// first translate to the location we want to rotate about
		glPushMatrix();
		glTranslatef((GLfloat)(ploc->x1 + ((ploc->x2 - ploc->x1) / 2)), (GLfloat)(ploc->y1 + ((ploc->y2 - ploc->y1) / 2)), (GLfloat)trans[2]);
		glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);
		glBegin(GL_QUADS);

		imgxsize = 10 / 2;
		imgysize = 8 / 2;
		//glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0f, 0.0f);
		//glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) (ploc->y2 - ploc->y1), 0.0f);
		//glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat) (ploc->x2 - ploc->x1), (GLfloat) (ploc->y2 - ploc->y1), 0.0f);
		//glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat) (ploc->x2 - ploc->x1), (GLfloat) 0.0f, 0.0f);


		glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-imgxsize, (GLfloat)-imgysize, 0.0f);
		glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-imgxsize, (GLfloat)imgysize, 0.0f);
		glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)imgxsize, (GLfloat)imgysize, 0.0f);
		glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)imgxsize, (GLfloat)-imgysize, 0.0f);


		glEnd();
		glPopMatrix();
	} else {
		glBegin(GL_QUADS);
		glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)ploc->x1, (GLfloat)ploc->y2, 0.0f);
		glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)ploc->x1, (GLfloat)ploc->y1, 0.0f);
		glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)ploc->x2, (GLfloat)ploc->y1, 0.0f);
		glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)ploc->x2, (GLfloat)ploc->y2, 0.0f);
		glEnd();
	}

	glFlush();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

}



void BuildMapImage(struct InstanceData* id, char *pathname, char *imagename, GLubyte *Gmapimage, int gmap_texture_pixels)
{
	char pngname[TMPBUF_SIZE];
	int map_square_pixels = 0;
	int modify_colors = 0;
	static int pflag = 0;
	gdImagePtr im;
	FILE *in;
	char tmpstr[TMPBUF_SIZE];


	// load in the PNG
	sprintf_s(pngname, TMPBUF_SIZE, "%s%s.png", pathname, imagename);
	if (fopen_s(&in, pngname, "rb")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", pngname);
		return;
	}
	im = gdImageCreateFromPng(in);
	fclose(in);

	PNG2Texture(id, Gmapimage, gmap_texture_pixels, im);
	gdImageDestroy(im);


}

int LoadDiskImages(struct InstanceData* id, int layer, char *imagedir, char *pngname)
{
	char filename[256];
	FILE *f;
	char linebuf[LINEBUF_SIZE];
	int maptexnum = 0;
	int xtiles, ytiles, xt, yt, gmap_texture_pixels;
	char tmpstr[TMPBUF_SIZE];

	// read in txt file for the layer
	sprintf_s(filename, _countof(filename), "layer%d.txt", layer);
	if (!GetLocalFile(id, imagedir, filename, id->m_strHttpImagePath, SM_HTTPS)){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename);
		return (FALSE);
	}

	sprintf_s(filename, _countof(filename), "%slayer%d.txt", imagedir, layer);
	fopen_s(&f, filename, "r");
	if (!f || !fgets(linebuf, LINEBUF_SIZE, f)){
		return(FALSE);
	}
	sscanf_s(linebuf, "%d %d", &xtiles, &ytiles);
	if (feof(f) || !fgets(linebuf, LINEBUF_SIZE, f)){
		return(FALSE);
	}
	sscanf_s(linebuf, "%d %d", &gmap_texture_pixels);
	fclose(f);

	for (xt = 0; xt < xtiles; xt++){
		for (yt = 0; yt < ytiles; yt++){
			if (LoadImageTile(id, layer, xt, yt, gmap_texture_pixels, maptexnum, imagedir)){ // similar to buildmapimage
				maptexnum++; // only increment if image was inrange and loaded into a texture
			}
		}
	}
	num_tex_maps[layer] = maptexnum;
	return(TRUE);
}

int DrawOverlayMap(struct InstanceData* id, char* pngname, double pnglng1, double pnglat1, double pnglng2, double pnglat2)
{
	static GLuint texture = 0;
	if (!texture)
		texture = LoadOverlayMapTexture(id, pngname);

	drawTexMap(id, texture, pnglng1, pnglat1, pnglng2, pnglat2);
	return 0;
}

int	DrawSatMap(struct InstanceData* id, char *pngname, double pnglng1, double pnglat1,
	double pnglng2, double pnglat2)
{
	int map_square_pixels = 0;
	static double PrevXmin, PrevYmin, PrevXmax, PrevYmax;
	int i, layer;


	if (id->m_sCurLayout.m_dWorldXSize > 0.03){
		layer = 1;
	} else if ( id->m_sCurLayout.m_dWorldXSize > 0.01 ){
		layer = 2;
	} else if ( id->m_sCurLayout.m_dWorldXSize > 0.003 ){
		layer = 3;
	} else {
		layer = 4;
	}


	if (id->m_bOnRefresh || !maptexture[0] || id->m_sCurLayout.m_dWorldXmax != PrevXmax || id->m_sCurLayout.m_dWorldXmin != PrevXmin ||
		id->m_sCurLayout.m_dWorldYmax != PrevYmax || id->m_sCurLayout.m_dWorldYmin != PrevYmin)
	{
		// maps moved
		PrevYmax = id->m_sCurLayout.m_dWorldYmax;
		PrevYmin = id->m_sCurLayout.m_dWorldYmin;
		PrevXmin = id->m_sCurLayout.m_dWorldXmin;
		PrevXmax = id->m_sCurLayout.m_dWorldXmax;

		if (maptexture[0]){
			// clear out old textures
			glDeleteTextures(num_tex_maps[layer], &maptexture[0]);
			for (i = 0; i < NUM_TEX_MAPS; i++){
				maptexture[i] = 0;
			}
		}

		if (!LoadDiskImages(id, layer, id->m_strImageDir, pngname)){
			if (layer == 1){
				BuildMapLayers(id, 1, id->m_strImageDir, pngname, 512, 2, 2, pnglng1, pnglat1, pnglng2, pnglat2);
			} else if ( layer == 2 ){
				BuildMapLayers(id, 2, id->m_strImageDir, pngname, 512, 4, 4, pnglng1, pnglat1, pnglng2, pnglat2);
			} else if ( layer == 3 ){
				BuildMapLayers(id, 3, id->m_strImageDir, pngname, 512, 8, 8, pnglng1, pnglat1, pnglng2, pnglat2);
			} else if ( layer == 4 ){
				BuildMapLayers(id, 4, id->m_strImageDir, pngname, 512, 16, 16, pnglng1, pnglat1, pnglng2, pnglat2);
			}
		}
	}

	for (i = 0; i < num_tex_maps[layer]; i++){
		drawTexMap(id, maptexture[i], lng1[i], lat1[i], lng2[i], lat2[i]);
	}


	// BuildMapImage( id, id->m_strImageDir, pngname, Gmapimage, gmapsize );

	// BindMapLayers( 1 );

#ifdef OLDWAY

#endif

	// draw the global texture 
	//drawTexMap(id, maptexture[0], (GLfloat) WorldXmin, (GLfloat) WorldYmin, (GLfloat) WorldXmax, 
	//	(GLfloat) WorldYmax );

	// drawTexMap(id, maptexture[0], -73.82094497, 40.64583812, -73.78516804, 40.67050178 );
	return(TRUE);
}


int GetRand(int min, int max)
{
	static int Init = 0;
	int rc;

	if (Init == 0)
	{
		/*
		*  As Init is static, it will remember it's value between
		*  function calls.  We only want srand() run once, so this
		*  is a simple way to ensure that happens.
		*/
		srand((int)time(NULL));
		Init = 1;
	}

	/*
	* Formula:
	*    rand() % N   <- To get a number between 0 - N-1
	*    Then add the result to min, giving you
	*    a random number between min - max.
	*/
	rc = (rand() % (max - min + 1) + min);

	return (rc);
}




GLuint CreateConstructionList(polylist *ConstructionPolyList)
{
	poly *newpoly;
	points *np;
	int count, pc, totcount = 0;
	polylist *nextpoly;
	static int FreePolyPointsFlag = FALSE;
	GLfloat red, green, blue;
	GLfloat x, y;
	GLuint newlistindex;
	constrc *constrcp;

	newlistindex = glGenLists(1);
	glNewList(newlistindex, GL_COMPILE);

	for (pc = 0, nextpoly = ConstructionPolyList; nextpoly; nextpoly = nextpoly->np, pc++){
		newpoly = nextpoly->poly;

		/* draw a line between all of the points */
		newpoly->linelistcount = pc;

		if (!(constrcp = (constrc *)newpoly->datastruct)){
			continue;
		}

		if (constrcp && constrcp->status && !(strcasecmp(constrcp->status, POLY_CLOSED))){
			red = 1.0f;
			green = 0.0f;
			blue = 0.0f;
		} else if (constrcp && constrcp->status && !(strcasecmp(constrcp->status, POLY_SELECTED))) {
			red = 0.0f;
			green = 0.9f;
			blue = 0.9f;
		} else {
			red = 0.0f;
			green = 0.0f;
			blue = 0.9f;
		}
		glBegin(GL_LINE_STRIP);
		glColor3f(red, green, blue); /* line */

		for (np = newpoly->ppoints, count = 0; np; np = np->np, count++){
			/* printf("polyid='%s', point[%d] x=%1.9f, y=%1.9f\n", newpoly->polyname, count, np->x, np->y ); */
			//x = (float) np->x;
			//y = (float) np->y;
			x = (float)np->vt[0];
			y = (float)np->vt[1];

			glVertex3f(x, y, 0.0);
			/* printf("x=%g y=%g\n", x, y ); */
		}
		totcount += count;
		glEnd();

	}
	glEndList();

	return(newlistindex);
}



polylist *LoadShp(struct InstanceData* id, char *shapefilename, double red, double green, double blue)
{
	SHPHandle	hSHP;
	int nShapeType, nEntities, i, iPart, polycount = 0, pointcount = 0;
	const char 	*pszPlus;
	double adfMinBound[4], adfMaxBound[4];
	poly *newpoly = NULL;
	points *np;
	polylist *nextpoly = NULL, *ShpPolylist = NULL;
	char tmpstr[TMPBUF_SIZE];
	float lng, lat, prevlng = 999.999f, prevlat = 999.999f;
	float xmin, xmax, ymin, ymax, deltalng, realdelta;
	static int pflag = 0;
	int StartNewPoly;
	int innerflag = TRUE;


	xmax = -9.9E20f;
	xmin = 9.9E20f;
	ymax = -9.9E20f;
	ymin = 9.9E20f;
	/* -------------------------------------------------------------------- */
	/*      Open the passed shapefile.                                      */
	/* -------------------------------------------------------------------- */
	D_CONTROL("LOADSHP", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Loading shapes from shapefile '%s'\n", GetCurrentThreadId(), shapefilename));

	if (!(hSHP = SHPOpen(shapefilename, "rb")))
	{
		//printf( "Unable to open:%s\n", shapefilename );
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to open shapefile '%s'\n", GetCurrentThreadId(), shapefilename);
		return(NULL);
	}

	SHPGetInfo(hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound);

	/* printf( "Shapefile Type: %s   # of Shapes: %d\n\n",
	SHPTypeName( nShapeType ), nEntities ); */
	/* printf( "File Bounds: (%12.3f,%12.3f,%g,%g)\n"
	"         to  (%12.3f,%12.3f,%g,%g)\n",
	adfMinBound[0],
	adfMinBound[1],
	adfMinBound[2],
	adfMinBound[3],
	adfMaxBound[0],
	adfMaxBound[1],
	adfMaxBound[2],
	adfMaxBound[3] ); */

	/* -------------------------------------------------------------------- */
	/*	iterate over the list of shapes	*/
	/* -------------------------------------------------------------------- */
	for (i = 0; i < nEntities; i++)
	{
		int		j;
		SHPObject	*psShape;

		psShape = SHPReadObject(hSHP, i);

		/* printf( "\nShape:%d (%s)  nVertices=%d, nParts=%d\n"
		"  Bounds:(%12.3f,%12.3f, %g, %g)\n"
		"      to (%12.3f,%12.3f, %g, %g)\n",
		i, SHPTypeName(psShape->nSHPType),
		psShape->nVertices, psShape->nParts,
		psShape->dfXMin, psShape->dfYMin,
		psShape->dfZMin, psShape->dfMMin,
		psShape->dfXMax, psShape->dfYMax,
		psShape->dfZMax, psShape->dfMMax ); */


		if (psShape->nSHPType == SHPT_POLYGON ||
			psShape->nSHPType == SHPT_POLYGONZ || psShape->nSHPType == SHPT_ARC){

			StartNewPoly = 1;
			for (j = 0, iPart = 1; j < psShape->nVertices; j++){
				const char	*pszPartType = "";

				if (j == 0 && psShape->nParts > 0)
					pszPartType = SHPPartTypeName(psShape->panPartType[0]);

				if (iPart < psShape->nParts
					&& psShape->panPartStart[iPart] == j){
					pszPartType = SHPPartTypeName(psShape->panPartType[iPart]);

					if (!innerflag){
						/* IGNORE INNER POLYGONS??? */
						break;
					}
					StartNewPoly = 1;
					iPart++;
					pszPlus = "+";
					} else {
					pszPlus = " ";
				}

				if (StartNewPoly){
					if (newpoly){
						/* close out prev poly */
						pointcount += newpoly->count;

						newpoly->xmin = xmin;
						newpoly->ymin = ymin;
						newpoly->xmax = xmax;
						newpoly->ymax = ymax;
						newpoly->width = newpoly->xmax - newpoly->xmin;
						newpoly->height = newpoly->ymax - newpoly->ymin;

						if (newpoly->xmin < ShpPolylist->xmin) ShpPolylist->xmin = newpoly->xmin;
						if (newpoly->ymin < ShpPolylist->ymin) ShpPolylist->ymin = newpoly->ymin;
						if (newpoly->xmax > ShpPolylist->xmax) ShpPolylist->xmax = newpoly->xmax;
						if (newpoly->ymax > ShpPolylist->ymax) ShpPolylist->ymax = newpoly->ymax;
						ShpPolylist->width = ShpPolylist->xmax - ShpPolylist->xmin;
						ShpPolylist->height = ShpPolylist->ymax - ShpPolylist->ymin;

					}

					StartNewPoly = FALSE;
					newpoly = (poly *)vo_malloc(sizeof(poly));
					xmax = -9.9E20f;
					xmin = 9.9E20f;
					ymax = -9.9E20f;
					ymin = 9.9E20f;

					sprintf_s(tmpstr, TMPBUF_SIZE, "%s poly%d", shapefilename, polycount++);
					newpoly->polyname = str_falloc(tmpstr);

					newpoly->red = (double)red;
					newpoly->green = (double)green;
					newpoly->blue = (double)blue;
					newpoly->index = i;

					if (pflag){
						printf("\nShape:%d (%s)  nVertices=%d, nParts=%d\n"
							"  Bounds:(%12.3f,%12.3f, %g, %g)\n"
							"      to (%12.3f,%12.3f, %g, %g)\n",
							i, SHPTypeName(psShape->nSHPType),
							psShape->nVertices, psShape->nParts,
							psShape->dfXMin, psShape->dfYMin,
							psShape->dfZMin, psShape->dfMMin,
							psShape->dfXMax, psShape->dfYMax,
							psShape->dfZMax, psShape->dfMMax);
					}
					if (!ShpPolylist){
						ShpPolylist = (polylist *)vo_malloc(sizeof(polylist));
						ShpPolylist->poly = newpoly;
						ShpPolylist->xmax = -9.9E20f;
						ShpPolylist->ymax = -9.9E20f;
						ShpPolylist->xmin = 9.9E20f;
						ShpPolylist->ymin = 9.9E20f;
						nextpoly = ShpPolylist;
						ShpPolylist->lastpoly = ShpPolylist;
						} else {
						nextpoly->np = (polylist *)vo_malloc(sizeof(polylist));
						nextpoly = nextpoly->np;
						nextpoly->poly = newpoly;
						ShpPolylist->lastpoly = nextpoly;
					}
				}

				lng = (float)psShape->padfX[j];
				lat = (float)psShape->padfY[j];

				if (projflag){
					/* convert to equal area projection centered at
					98.0W and 40N */
					/* get distance from central point */
					deltalng = lng - (float)LngOrig;
					realdelta = deltalng * (float)cos(lat * M_PI / 180.0);
					lng = (float)LngOrig + realdelta;
				}

				prevlng = lng;
				prevlat = lat;

				if (!newpoly->ppoints){
					/* first poly */
					newpoly->ppoints = (points *)vo_malloc(sizeof(points));
					np = newpoly->ppoints;
					} else {
					np->np = (points *)vo_malloc(sizeof(points));
					np = np->np;
				}
				np->vt[0] = lng;
				np->vt[1] = lat;
				np->vt[2] = 0.0;
				// np->x = lng;
				// np->y = lat;
				if (lng > xmax) xmax = lng;
				if (lng < xmin) xmin = lng;
				if (lat > ymax) ymax = lat;
				if (lat < ymin) ymin = lat;
				newpoly->count++;
			}
			pointcount += newpoly->count;

			newpoly->xmin = xmin;
			newpoly->ymin = ymin;
			newpoly->xmax = xmax;
			newpoly->ymax = ymax;
			newpoly->width = newpoly->xmax - newpoly->xmin;
			newpoly->height = newpoly->ymax - newpoly->ymin;

			if (newpoly->xmin < ShpPolylist->xmin) ShpPolylist->xmin = newpoly->xmin;
			if (newpoly->ymin < ShpPolylist->ymin) ShpPolylist->ymin = newpoly->ymin;
			if (newpoly->xmax > ShpPolylist->xmax) ShpPolylist->xmax = newpoly->xmax;
			if (newpoly->ymax > ShpPolylist->ymax) ShpPolylist->ymax = newpoly->ymax;
			ShpPolylist->width = ShpPolylist->xmax - ShpPolylist->xmin;
			ShpPolylist->height = ShpPolylist->ymax - ShpPolylist->ymin;

		}
		SHPDestroyObject(psShape);
	}

	SHPClose(hSHP);

	return(ShpPolylist);
}



VO *ProcessRegions(char *outbuf, struct InstanceData* id)
{
	int row;
	char *str, *eolstr;
	char linebuf[256];
	int len, matches, i, seqnum, idval;
	char region[256], arpt[256];
	double latitude, longitude;

	VO *ROIVO;  // get a new one every time so the thread can create a new one w/o affecting existing one
	int pflag = 0;

	region[0] = '\0';
	arpt[0] = '\0';


	ROIVO = (VO *)vo_create(0, NULL);
	vo_set(ROIVO, V_NAME, "ROIVO", NULL);
	VOPropAdd(ROIVO, "Region", NTBSTRINGBIND, 33, VO_NO_ROW);
	VOPropAdd(ROIVO, "arpt", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
	VOPropAdd(ROIVO, "id", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(ROIVO, "seqnum", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(ROIVO, "longitude", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(ROIVO, "latitude", FLT8BIND, -1, VO_NO_ROW);
	vo_rm_rows(ROIVO, 0, ROIVO->count);

	vo_set(ROIVO, V_ORDER_COLS, "arpt", "id", "Region", "seqnum", NULL, NULL);


	row = 0;
	str = outbuf;

	// skip first row if titles
	if ((eolstr = strchr(str, '\n'))){
		str = eolstr;
		str++; /* skip over eol char */
	}

	while (str){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > 250){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}
			str = eolstr;
			str++; /* skip over eol char */

			if (len > 3){  // skip over the EOD string
				// find all text up to first \t char, that will be the region name, which can have spaces
				if ((eolstr = strchr(linebuf, '\t'))){
					len = eolstr - linebuf;
					strncpy_s(region, _countof(region), linebuf, len);
					memcpy(linebuf, &linebuf[len], strlen(linebuf) - len);
				} else {  // bad data
					break;
				}


				matches = sscanf_s(linebuf, "%s\t%d\t%d\t%lf\t%lf", arpt, _countof(arpt), &idval, &seqnum, &longitude, &latitude);
				if (matches == 5){
					vo_alloc_rows(ROIVO, 1);
					strcpy_s(VP(ROIVO, ROIVO->count - 1, "Region", char), 33, region);
					strcpy_s(VP(ROIVO, ROIVO->count - 1, "arpt", char), ARPT_CODE_SIZE, arpt);
					VV(ROIVO, ROIVO->count - 1, "id", int) = idval;
					VV(ROIVO, ROIVO->count - 1, "seqnum", int) = seqnum;
					VV(ROIVO, ROIVO->count - 1, "longitude", double) = longitude;
					VV(ROIVO, ROIVO->count - 1, "latitude", double) = latitude;
				}
			}
		} else {
			str = NULL;
		}
	}

	vo_order(ROIVO);

	if (pflag){
		for (i = 0; ROIVO && i < ROIVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) row %d %s %s id=%d seq=%d %g %g\n",
				GetCurrentThreadId(), i,
				VP(ROIVO, i, "arpt", char),
				VP(ROIVO, i, "Region", char),
				VV(ROIVO, i, "id", int),
				VV(ROIVO, i, "seqnum", int),
				VV(ROIVO, i, "longitude", double),
				VV(ROIVO, i, "latitude", double));
		}
	}
	if (!ROIVO->count){
		vo_free(ROIVO);
		ROIVO = NULL;
		return(NULL);
	}
	return(ROIVO);
}

void LoadROI(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	int pflag = 0;
	VO *vo;
	int tries = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(&chunk);

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=Regions");

	while (tries < 3){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (GetCurlFormPostResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
			if (chunk.memory){
				D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) REGIONS = %s\n",
					cdwThreadId, chunk.memory));
				vo = ProcessRegions(chunk.memory, id);
				free_chunk_memory(&chunk);
				if (vo){
					EnterCriticalSection(&id->m_csROI);
					vo_free(id->m_pROIVO);
					id->m_pROIVO = vo;
					id->m_bROILoaded = TRUE;
					LeaveCriticalSection(&id->m_csROI);
					return;
				}
			}
		}else{
			GetNxtSurfSrvr(id);
		}
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to get region data attempt #%d.\n", cdwThreadId, (++tries));
	}
	// Disable since we never got the Region Data
	vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to get region data, disabling ActiveX Region of Interest functionality!\n", cdwThreadId);
}


void DrawGLText(struct InstanceData* id, int xpixel, int ypixel, char *str, GLfloat *color, GLuint fontbase, int bRotate)
{
	static int pflag = 0;

	//PrintFreeType( id, id->m_nCustFontIdx, (float)xpixel, (float)ypixel, color, str );
	//return;

	GL_ASSERT(glPushMatrix());
	GL_ASSERT(glDisable(GL_DITHER));
	GL_ASSERT(glDisable(GL_TEXTURE_2D));
	GL_ASSERT(glDisable(GL_DEPTH_TEST));
	GL_ASSERT(glDisable(GL_BLEND));
	GL_ASSERT(glShadeModel(GL_FLAT));

	GL_ASSERT(glLoadIdentity());

	GL_ASSERT(glColor3f(1.0, 1.0, 1.0)); /* white line */

	GL_ASSERT(glMatrixMode(GL_PROJECTION));
	GL_ASSERT(glLoadIdentity());

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	GL_ASSERT(glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f));

	if (bRotate){
		RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);
	}

	GL_ASSERT(glMatrixMode(GL_MODELVIEW));
	GL_ASSERT(glLoadIdentity());

	GL_ASSERT(glTranslatef(trans[0], trans[1], trans[2]));
	GL_ASSERT(glLineWidth(1));

	GL_ASSERT(glColor3fv(color));
	GL_ASSERT(glRasterPos2i(xpixel, ypixel));
	
	glPrintCustom(id, fontbase, str);

	GL_ASSERT(glFlush());
	GL_ASSERT(glPopMatrix());
	GL_ASSERT(glColor3fv(white));

	GL_ASSERT(glMatrixMode(GL_PROJECTION));
	GL_ASSERT(glPopMatrix());
}



void DrawMeasure(struct InstanceData* id)
{
	static time_t x2_time;
	time_t nowsecs;
	int xpix2, ypix2;
	double lat1, lng1, lat2, lng2, tmprads, dis;
	char tmpstr[256];

	if (id->m_nMeasureX1 == -1){
		x2_time = 0;
		id->m_strHeader[0] = '\0';
		//sprintf(tmpstr, "DrawMeasure, measure_x1 == -1\n", id->m_nMeasureX1, measure_y1 );
		//OutputDebugString( tmpstr );
		return;
	}

	nowsecs = time(0);
	if (x2_time && (nowsecs - x2_time) > 10){
		// remove points after 10 seconds
		id->m_nMeasureX1 = -1;
		id->m_strHeader[0] = '\0';
		sprintf_s(tmpstr, _countof(tmpstr), "DrawMeasure, remove points after 10 seconds\n");
		OutputDebugString(tmpstr);
		return;
	}

	//sprintf(tmpstr, "DrawMeasure,draw line\n" );
	//OutputDebugString( tmpstr );
	glPushMatrix();
	glLoadIdentity();

	glColor3f(1.0f, 0.0f, 0.0f); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	//glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
	// 0.0f, 1.0f);
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glBegin(GL_LINE_LOOP);


	glVertex3f((float)id->m_nMeasureX1, (float)measure_y1, 0.0f);

	if (measure_x2 == -1){
		// use current mouse position
		glVertex3f((float)id->m_nMouseX, (float)id->m_nMouseY, 0.0f);
		x2_time = nowsecs;
	} else {
		glVertex3f((float)measure_x2, (float)measure_y2, 0.0f);
		if (!x2_time){
			x2_time = nowsecs;
		}
	}

	glEnd();



	lat1 = (((double)measure_y1 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
	lng1 = (((double)id->m_nMeasureX1 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;

	if (measure_x2 == -1){
		ypix2 = id->m_nMouseY;
		xpix2 = id->m_nMouseX;
	} else {
		ypix2 = measure_y2;
		xpix2 = measure_x2;
	}

	lat2 = (((double)ypix2 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
	lng2 = (((double)xpix2 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;

	tmprads = acos(sin(RADS(lat1)) * sin(RADS(lat2)) + cos(RADS(lat1)) * cos(RADS(lat2)) * cos(RADS(lng2 - lng1)));
	dis = 60.0 * DEGS(tmprads); // NM

	sprintf_s(tmpstr, _countof(tmpstr), "D = %1.2f NM", dis);
	strncpy_s(id->m_strHeader, 128, tmpstr, _TRUNCATE);

	// make sure text does not go off screen
	if (ypix2 > id->m_nHeight - 50){
		ypix2 -= 20;
	} else {
		ypix2 += 20;
	}
	if (xpix2 > id->m_nWidth - 100){
		xpix2 -= 70;
	} else {
		xpix2 += 10;
	}
	DrawGLText(id, xpix2, ypix2, tmpstr, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorASDI, id->m_gluCustomBase, TRUE); //@@MCT Check


	glFlush();
	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0f, 1.0f, 1.0f);
}


REGION_OUTLINE_COLOR * getROIColorElement(struct InstanceData* id, char * region)
{
	REGION_OUTLINE_COLOR * rocp = id->m_pROIColors;
	int i;

	for (i = 0; rocp && (i < id->m_nROIColors); i++, rocp++)
	{
		if (!_stricmp(region, rocp->region))
		{
			return rocp;
		}
	}

	return NULL;
}

void DrawROILabels(struct InstanceData* id)
{
	VO *ROIVO;
	double latmin = 0.0;
	double latmax = 0.0;
	double lngmin = 0.0;
	double lngmax = 0.0;
	float lat, lng;
	PFLOAT fontWidth = (float *)malloc(sizeof (float) * 256);
	float finalWidth = 0.;

	int i, regionid;
	char region[64] = { 0 };
	double x, y;
	char airport[ARPTNAME_SZ] = { 0 };
	char airportMap[ARPTNAME_SZ] = { 0 };
	if (!(ROIVO = id->m_pROIVO)){
		return;
	}

	region[0] = '\0';

	/* draw box around rectangle that fits screen */
	strcpy_s(airportMap, ARPTNAME_SZ, id->m_strAirportMap);
	StrUpper(airportMap);
	regionid = -1;

	SelectObject(id->m_hDC, id->m_arFonts[id->m_sCurLayout.m_nROISFontIndex].m_hFont);			// Selects The Font We Want
	GetTextMetrics(id->m_hDC, &id->m_arFonts[id->m_sCurLayout.m_nROISFontIndex].m_tmCustom);	// Load The TextMetrics for the font

	if (!wglUseFontBitmaps(id->m_hDC, 0, 255, id->m_arFonts[id->m_sCurLayout.m_nROISFontIndex].m_glListBase)){		// Builds 223 Characters Starting At Character 32
		// Retrieve font widths and save in array "fontWidths":
		GetCharWidthFloat(id->m_hDC, 0, 255, fontWidth);
	}

	for (i = 0; i < ROIVO->count; i++)
	{
		if (VV(ROIVO, i, "lbl", int)){
			// We only care about regions at the current airport
			strcpy_s(airport, ARPTNAME_SZ, VP(ROIVO, i, "arpt", char));
			StrUpper(airport);
			lat = VV(ROIVO, i, "latg", float);
			lng = VV(ROIVO, i, "lngg", float);

			if (!strcmp(airport, airportMap))
			{
				// Check for a new region
				if (strcmp(VP(ROIVO, i, "Region", char), region) || VV(ROIVO, i, "id", int) != regionid)
				{
					// Output text from old Region
					if (-1 != regionid && strlen(region))
					{

						for (int j = 0; j < (int)strlen(region); j++) {
							int ch = (int)region[j];
							finalWidth += fontWidth[ch];
						}
						int maxwidth = 0;
						CalcTagWidth(&maxwidth, region);


						x = lngmin + (lngmax - lngmin) / 2.0;
						// code to center the ROIs text
						GLdouble modelview[16];
						GLdouble projection[16];
						GLint viewport[4];

						glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
						glGetDoublev(GL_PROJECTION_MATRIX, projection);
						glGetIntegerv(GL_VIEWPORT, viewport);

						GLdouble realX1[4], realY1[4], realZ1[4];
						GLdouble realX2[4], realY2[4], realZ2[4];

						gluUnProject(1000., 1000., 1., modelview, projection, viewport, realX1, realY1, realZ1);
						gluUnProject(1000. - finalWidth, 1000., 1., modelview, projection, viewport, realX2, realY2, realZ2);

						double x2_x1 = (realX2[0] - realX1[0]);
						if (x2_x1 > 0)
							x -= (x2_x1 / 2);
						else
							x += (x2_x1 / 2);
						y = (latmin + (latmax - latmin) / 2.0);
						DrawGLTextXY(id, x, y, region, id->m_sCurLayout.m_glfROISColor, id->m_arFonts[id->m_sCurLayout.m_nROISFontIndex].m_glListBase, TRUE);

						// Now reset region paramaters
						lngmin = lngmax = latmin = latmax = 0.0;
					}

					strcpy_s(region, _countof(region), VP(ROIVO, i, "Region", char));
					regionid = VV(ROIVO, i, "id", int);


				}

				x = VV(ROIVO, i, "longitude", double);
				y = VV(ROIVO, i, "latitude", double);

				if (0.0 == latmin){
					lngmin = x;
					lngmax = x;
					latmin = y;
					latmax = y;
				}
				else{
					if (x < lngmin) lngmin = x;
					if (x > lngmax) lngmax = x;
					if (y < latmin) latmin = y;
					if (y > latmax) latmax = y;
				}
			}
		}
	}
}

void DrawROI(struct InstanceData* id)
{
	VO *ROIVO;
	REGION_OUTLINE_COLOR * rocp = NULL;
	int i, regionid;
	int drawOutline = FALSE;
	char region[64];
	float x, y;
	char airport[ARPTNAME_SZ];
	char airportMap[ARPTNAME_SZ];
	static int c = 0;
	int bLog = FALSE;
	int glError = GL_NO_ERROR;

	if (!(ROIVO = id->m_pROIVO)){
		return;
	}

	if (0 == (c % 10))
		bLog = TRUE;

	// Clear all OpenGL Errors
	while (GL_NO_ERROR != glGetError());

	glPushMatrix();
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glPushMatrix error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	glLoadIdentity();
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glLoadIdentity error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);

	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glColor3f error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);

	glMatrixMode(GL_PROJECTION);
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glMatrixMode error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	glLoadIdentity();
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glLoadIdentity error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glMatrixMode error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	glLoadIdentity();
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glLoadIdentity error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);

	glTranslatef(trans[0], trans[1], trans[2]);
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glTranslatef error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	glLineWidth(1);
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glLineWidth error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);

	/* printf("BoxX1=%d BoxY1=%d BoxX2=%d BoxY2=%d\n",
	BoxX1, BoxY1, BoxX2, BoxY2); */
	/* draw a line between all of the points */

	region[0] = '\0';

	/* draw box around rectangle that fits screen */
	drawOutline = FALSE;
	strcpy_s(airportMap, ARPTNAME_SZ, id->m_strAirportMap);
	StrUpper(airportMap);
	regionid = -1;
	//bLog = TRUE;
	if (bLog){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Start ROI Draw\n", GetCurrentThreadId());
	}

	for (i = 0; i < ROIVO->count; i++)
	{
		// We only care about regions at the current airport
		strcpy_s(airport, ARPTNAME_SZ, VP(ROIVO, i, "arpt", char));
		StrUpper(airport);

		if (!strcmp(airport, airportMap))
		{
			// Check for a new region
			if (strcmp(VP(ROIVO, i, "Region", char), region) || VV(ROIVO, i, "id", int) != regionid)
			{
				// Stop drawing if we had a previous region
				if (strlen(region) && drawOutline){
					if (bLog)
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region <%s> ... glEnd.\n", GetCurrentThreadId(), region);
					drawOutline = FALSE;
					glEnd();
					if (GL_NO_ERROR != (glError = glGetError())){
						vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glEnd error <0x%x> for Region <%s> \n", GetCurrentThreadId(), __LINE__, glError, region);
					}
				}

				strcpy_s(region, _countof(region), VP(ROIVO, i, "Region", char));
				regionid = VV(ROIVO, i, "id", int);

				// Do we want to draw this region and if so, what color?
				if (rocp = getROIColorElement(id, region))
				{
					drawOutline = TRUE;
					glColor3f(rocp->glColor[0], rocp->glColor[1], rocp->glColor[2]);
					if (GL_NO_ERROR != (glError = glGetError()))
						vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glColor3f error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
					if (bLog){
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing Region <%s> for Airport <%s> in Color <%s> glBegin:...\n", GetCurrentThreadId(), rocp->region, airport, rocp->color);
					}
					glBegin(GL_LINE_LOOP);
					//if(GL_NO_ERROR != (glError = glGetError()))
					//	vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glBegin error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
				}
			}

			if (drawOutline == TRUE)
			{
				x = (float)VV(ROIVO, i, "longitude", double);
				y = (float)VV(ROIVO, i, "latitude", double);
				glVertex3f(x, y, 0.0f);
				//if(GL_NO_ERROR != (glError = glGetError()))
				//	vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glVertex3f error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
				if (bLog)
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region <%s> at <%f, %f>\n", GetCurrentThreadId(), region, x, y);
			}
		}
	}

	if (bLog)
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) End ROI Draw\n", GetCurrentThreadId());

	if (drawOutline){
		glEnd();
		if (GL_NO_ERROR != (glError = glGetError()))
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glEnd error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	}
	glFlush();
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glFlush error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	/*printf("xplotmin =%g, max=%g, ymin=%g ymax=%g\n",
	xplotmin, xplotmax, yplotmin, yplotmax ); */

	glPopMatrix();
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glPopMatrix error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);

	/* reset the color to white so textures will appear */
	glColor3f(1.0f, 1.0f, 1.0f);
	if (GL_NO_ERROR != (glError = glGetError()))
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)[%d] OpenGL glColor3f error <0x%x>\n", GetCurrentThreadId(), __LINE__, glError);
	c += 1;
	if (c > 100) c = 0;
}


int drawBox(struct InstanceData* id)
{
	if (!id->m_nBox) return(TRUE);
	if ((id->m_nBoxX1 == id->m_nBoxX2) || (id->m_nBoxY1 == id->m_nBoxY2)) return(TRUE);

	glPushMatrix();
	glLoadIdentity();

	glColor3f(1.0f, 1.0f, 1.0f); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	/* printf("BoxX1=%d BoxY1=%d BoxX2=%d BoxY2=%d\n",
	BoxX1, BoxY1, BoxX2, BoxY2); */
	/* draw a line between all of the points */


	/* draw white box around rectangle that fits screen */
	glBegin(GL_LINE_LOOP);
	glVertex3f((float)id->m_nBoxX1, (float)id->m_nBoxY1, 0.0f);
	glVertex3f((float)id->m_nBoxX2, (float)id->m_nBoxY1, 0.0f);
	glVertex3f((float)id->m_nBoxX2, (float)id->m_nBoxY2, 0.0f);
	glVertex3f((float)id->m_nBoxX1, (float)id->m_nBoxY2, 0.0f);
	glEnd();

#ifdef RED_BOX
	/* draw box from anchor point to cursor position in RED */
	glColor3f(1.0f, 0.0f, 0.0f );
	glBegin(GL_LINE_LOOP);
	glVertex3f( (float)id->m_nBoxX1, (float)id->m_nBoxY1, 0.0f );
	glVertex3f( (float)BoxRealX2, (float)id->m_nBoxY1, 0.0f );
	glVertex3f( (float)BoxRealX2, (float)BoxRealY2, 0.0f );
	glVertex3f( (float)id->m_nBoxX1, (float)BoxRealY2, 0.0f );
	glEnd();
#endif


	glFlush();
	/*printf("xplotmin =%g, max=%g, ymin=%g ymax=%g\n",
	xplotmin, xplotmax, yplotmin, yplotmax ); */

	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0f, 1.0f, 1.0f);
	return(TRUE);
}


void DrawGLTextXY(struct InstanceData* id, double x, double y, char *mystr, GLfloat *color, GLuint fontbase, int bRotate)
{
	int xpixel, ypixel;

	ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
	xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

	DrawGLText(id, xpixel, ypixel, mystr, (GLfloat *)color, fontbase, bRotate);

}



GLuint CreatePolyGLList(char *shapefilename, int gl_typeval, VO* DBFVO, int status)
{
	SHPHandle	hSHP;
	int nShapeType, nEntities, i, iPart, polycount = 0, pointcount = 0, startedpoly;
	const char 	*pszPlus;
	double adfMinBound[4], adfMaxBound[4];
	float lng, lat, prevlng = 999.999f, prevlat = 999.999f;
	static int pflag = 0;
	int StartNewPoly;
	int innerflag = TRUE;  //  inner polygons???
	GLuint newlistindex;
	// char *shptypename;

	// check for valid VO and valid column named STATUS
	if (!DBFVO)
		status = -1;
	else {
		// Treat files with no "STATUS" col as all Open
		if (!VPROP(DBFVO, "STATUS")) {
			if (1 == status)
				// Force Process to ignore non-existent "STATUS" col
				status = -1;
			else
				// Just return unprocessed
				return(FALSE);
		}
	}

	/*      Open the passed shapefile.                                */
	hSHP = SHPOpen(shapefilename, "rb");


	if (hSHP == NULL)
	{
		//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to open shapefile '%s'\n", GetCurrentThreadId(), shapefilename );
		return(FALSE);
	}

	newlistindex = glGenLists(1);
	glNewList(newlistindex, GL_COMPILE);

	/*      Print out the file bounds.                                      */
	SHPGetInfo(hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound);

	/*	Skim over the list of shapes, printing all the vertices.	*/
	for (i = 0; i < nEntities; i++)
	{
		int		j;
		SHPObject	*psShape;

		if (-1 != status) {
			// We skip over records that have a status not equal to the value passed in
			if (status != VV(DBFVO, i, "STATUS", int))
				continue;
		}

		psShape = SHPReadObject(hSHP, i);
		// shptypename = SHPTypeName( psShape->nSHPType );

		if (psShape->nSHPType == SHPT_POLYGON ||
			psShape->nSHPType == SHPT_POLYGONZ || psShape->nSHPType == SHPT_ARC ||
			psShape->nSHPType == SHPT_ARCZ){

			StartNewPoly = 1;
			startedpoly = FALSE;
			for (j = 0, iPart = 1; j < psShape->nVertices; j++){
				const char	*pszPartType = "";

				if (j == 0 && psShape->nParts > 0)
					pszPartType = SHPPartTypeName(psShape->panPartType[0]);

				if (iPart < psShape->nParts && psShape->panPartStart[iPart] == j){
					pszPartType = SHPPartTypeName(psShape->panPartType[iPart]);

					if (!innerflag){
						/* IGNORE INNER POLYGONS??? */
						break;
					}
					StartNewPoly = 1;
					iPart++;
					pszPlus = "+";
					} else {
					pszPlus = " ";
				}

				if (StartNewPoly){
					if (startedpoly){
						glEnd(); // end previous line strip if we hve inner polys
					}

					glBegin(gl_typeval);
					startedpoly = TRUE;
					StartNewPoly = FALSE;
				}

				lng = (float)psShape->padfX[j];
				lat = (float)psShape->padfY[j];
				glVertex3f(lng, lat, 0.0);


			}
			if (startedpoly){
				glEnd();
			}
			SHPDestroyObject(psShape);
		}
	}
	SHPClose(hSHP);

	glEndList();
	return(newlistindex);
}



void CALLBACK vertexCallback(GLvoid *vertex)
{
	GLdouble *ptr;


	ptr = (GLdouble *)vertex;
	glVertex3dv((GLdouble *)vertex);

	if (savemapflag){
		// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %g %g %g\n", GetCurrentThreadId(), ptr[0], ptr[1], ptr[2] );

		fprintf(savemapfile, "%g %g\n", ptr[0], ptr[1]);

		// fwrite(vertex, 1, sizeof(double) * 3, savemapfile);

	}

}


void CALLBACK vertexglEnd(void)
{
	// dump the poly to the map file
	if (savemapflag){
		fprintf(savemapfile, "glEnd()\n");
		// fwrite(tesscount, 1, sizeof(tesscount), savemapfile);
	}
	glEnd();
}


void CALLBACK vertexglBegin(GLenum mode)
{

	// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tesscount=%d\n", GetCurrentThreadId(), tesscount++);
	if (savemapflag){
		fprintf(savemapfile, "tesscount=%d\n", tesscount);
		tesscount++;
	}

	glBegin(mode);
}


void CALLBACK errorCallback(GLenum errorCode)
{

	const GLubyte *estring;

	estring = gluErrorString(errorCode);
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tesselation error: %s\n", GetCurrentThreadId(), estring);

}


void CALLBACK vertexglCombineData(GLdouble coords[3], GLdouble *vertex_data[4], GLfloat weight[4], GLdouble **outData, void* p)
{
	GLdouble *vertex;
	struct InstanceData* id = (struct InstanceData*)p;
	scl* vlist = id->m_pVertexData;

	vertex = (GLdouble *)calloc(6, sizeof(GLdouble));
	if (vlist)
	{
		clist_add(vlist, vertex);
	}
	vertex[0] = coords[0];
	vertex[1] = coords[1];
	vertex[2] = coords[2];
	/* Not using, colors are added prior to drawing, values are NULL!
	for (i = 3; i < 7; i++)
	vertex[i] = weight[0] * vertex_data[0][i]
	+ weight[1] * vertex_data[1][i]
	+ weight[2] * vertex_data[2][i]
	+ weight[3] * vertex_data[3][i];
	*/
	*outData = vertex;
}



GLuint CreateTessPolyList(struct InstanceData* id, polylist *cnstrpolylist, VO* DBFVO, int status)
{
	static GLUtriangulatorObj *tobj;
	int pc;
	polylist *nextpoly;
	poly *newpoly;
	points *np;
	int count;
	int i;
	static int pflag = 0;
	GLuint startList;

	// check for valid VO and valid column named STATUS
	if (!DBFVO)
		status = -1;
	else {
		// Treat files with no "STATUS" col as all Open
		if (!VPROP(DBFVO, "STATUS")) {
			if (1 == status)
				// Force Process to ignore non-existent "STATUS" col
				status = -1;
			else
				// Just return unprocessed
				return(FALSE);
		}
	}

	// Allocate clist struct for dynamic vertices in combine callback
	id->m_pVertexData = clist_alloc();

	startList = glGenLists(1);
	glNewList(startList, GL_COMPILE);


	for (i = 0, pc = 0, nextpoly = cnstrpolylist; nextpoly; nextpoly = nextpoly->np, pc++, i++){

		if (-1 != status) {
			// We skip over records that have a status not equal to the value passed in
			if (status != VV(DBFVO, i, "STATUS", int))
				continue;
		}

		newpoly = nextpoly->poly;
		tobj = gluNewTess();

		pcount = 0;

		gluTessCallback(tobj, GLU_TESS_VERTEX, vertexCallback);
		gluTessCallback(tobj, GLU_TESS_BEGIN, vertexglBegin);
		gluTessCallback(tobj, GLU_TESS_END, vertexglEnd);
		gluTessCallback(tobj, GLU_TESS_COMBINE_DATA, vertexglCombineData);
		gluTessCallback(tobj, GLU_TESS_ERROR, (void *)errorCallback);

		newpoly->polylistcount = pcount;

		gluTessBeginPolygon(tobj, id);

		for (np = newpoly->ppoints, count = 0; np; np = np->np, count++){
			gluTessVertex(tobj, np->vt, np->vt);
		}

		gluTessEndPolygon(tobj);

		pcount++;

		gluDeleteTess(tobj);
	}

	glEndList();

	// Release alloc'ed vertices and free clist structure
	if (id->m_pVertexData){
		scl* vlist = id->m_pVertexData;
		clist_tail(vlist);
		do{
			free(vlist->data);
		} while (clist_del(vlist));
		clist_free(vlist);
		id->m_pVertexData = NULL;
	}

	return startList;
}

GLuint CreateTessPoly(poly *SrcPoly)
{
	static GLUtriangulatorObj *tobj;
	poly *newpoly;
	points *np;
	int count;
	static int pflag = 0;
	GLuint startList;


	if (!SrcPoly){
		return(0);
	}
	tobj = gluNewTess();

	startList = glGenLists(1);
	glNewList(startList, GL_COMPILE);


	pcount = 0;
	newpoly = SrcPoly;

	gluTessCallback(tobj, GLU_TESS_VERTEX, vertexCallback);
	gluTessCallback(tobj, GLU_TESS_BEGIN, vertexglBegin);
	gluTessCallback(tobj, GLU_TESS_END, vertexglEnd);
	gluTessCallback(tobj, GLU_TESS_ERROR, (void *)errorCallback);

	newpoly->polylistcount = pcount;

	gluBeginPolygon(tobj);

	for (np = newpoly->ppoints, count = 0; np; np = np->np, count++){
		gluTessVertex(tobj, np->vt, np->vt);
	}
	gluEndPolygon(tobj);
	glEndList();
	pcount++;

	gluDeleteTess(tobj);

	return startList;
}


char *GetMatchingProject(poly *poly)
{
	static char projecttext[256];
	int rownum;
	char *category, *area, *segment;
	char *context;
	char tmpstr[TMPBUF_SIZE];

	if (!poly || !poly->polyname){
		return(NULL);
	}
	strncpy_s(tmpstr, TMPBUF_SIZE, poly->polyname, sizeof(tmpstr));

	do {
		if (!(category = strtok_s(tmpstr, "::", &context))) break;
		if (!(area = strtok_s(NULL, "::", &context))) break;
		if (!(segment = strtok_s(NULL, "::", &context))) break;
	} while (0);


	// see if this poly matches any projects
	if ((rownum = VOQryRow(ProjectsVO,
		"category", category,
		"area", area,
		"segment", segment,
		NULL)) != -1)
	{
		// found matching project
		sprintf_s(projecttext, _countof(projecttext), "Project: %s %s %s", VP(ProjectsVO, rownum, "name", char),
			VP(ProjectsVO, rownum, "status", char),
			VP(ProjectsVO, rownum, "notes", char));
		return(projecttext);
	}

	return(NULL);

}



DrawSelectedPolyText(struct InstanceData* id)
{
	char tmpstr[TMPBUF_SIZE];
	char *projectstr;

	// draw transparent panel bg for the text	glColor3fv( oglgui->bg );


	if (prevselectedpoly && prevselectedpoly->polyname){
		glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glColor3fv(blue);
		glRecti(18, 428, 560, 444);
		if (projectstr = GetMatchingProject(prevselectedpoly)){
			sprintf_s(tmpstr, TMPBUF_SIZE, "%s %s", projectstr, prevselectedpoly->polyname);
			DrawGLText(id, 20, 430, tmpstr, (GLfloat *)white, id->m_gluCustomBase, FALSE); //@@@MCT Check
		} else {
			DrawGLText(id, 20, 430, prevselectedpoly->polyname, (GLfloat *)white, id->m_gluCustomBase, FALSE); //@@@MCT Check
		}
	}
}

GLuint InitMapTessPolys(struct InstanceData* id, polylist *SrcPolyList)
{
	static GLUtriangulatorObj *tobj;
	poly *newpoly;
	points *np;
	polylist *nextpoly;
	int count;
	static int pflag = 0;
	GLuint startList;
	const DWORD cdwThreadId = GetCurrentThreadId();

	tobj = gluNewTess();

	startList = glGenLists(N_GEN_POLY_LISTS);

	pcount = 0;
	for (nextpoly = SrcPolyList; nextpoly; nextpoly = nextpoly->np){

		newpoly = nextpoly->poly;
		if (newpoly->polyflag == NO_POLYS){
			continue;
		}
		newpoly->showflag = TRUE;

		gluTessCallback(tobj, GLU_TESS_VERTEX, vertexCallback);
		/* gluTessCallback(tobj, GLU_TESS_BEGIN, beginCallback ); */
		gluTessCallback(tobj, GLU_TESS_BEGIN, vertexglBegin);
		/* gluTessCallback(tobj, GLU_TESS_COMBINE, (void *) combineCallback); */
		gluTessCallback(tobj, GLU_TESS_END, vertexglEnd);
		gluTessCallback(tobj, GLU_TESS_ERROR, (void *)errorCallback);

		if (pcount >= N_GEN_POLY_LISTS - 1){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ran out of lists in '%s'\n", cdwThreadId, newpoly->polyname);
			//printf("InitMapPolys, Ran out of lists\n");
			break;
		}

		newpoly->polylistcount = pcount;
		glNewList(startList + pcount, GL_COMPILE);
		gluBeginPolygon(tobj);

		for (np = newpoly->ppoints, count = 0; np; np = np->np, count++){
			gluTessVertex(tobj, np->vt, np->vt);
		}
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s: count=%d\n", cdwThreadId, newpoly->polyname, count);
		}
		gluEndPolygon(tobj);
		glEndList();
		pcount++;

	}
	gluDeleteTess(tobj);

	return startList;
}





int IsInRange(struct InstanceData* id, poly *poly)
{
	float x, y;
	/* test for corners of bounding rectangle to see if any are in the
	current screen */
	x = poly->xmin;
	y = poly->ymin;
	if (PtInRange(x, y)){
		return(TRUE);
	}

	x = poly->xmin;
	y = poly->ymax;
	if (PtInRange(x, y)){
		return(TRUE);
	}
	x = poly->xmax;
	y = poly->ymax;
	if (PtInRange(x, y)){
		return(TRUE);
	}
	x = poly->xmax;
	y = poly->ymin;
	if (PtInRange(x, y)){
		return(TRUE);
	}

	return(FALSE);
}




LoadCurrentConstructionStatus(polylist *ConstructionPolyList)
{
	static int firsttime = 1;
	poly *newpoly;
	polylist *nextpoly;

	// query the server for latest status

	if (firsttime){
		firsttime = FALSE;
		for (nextpoly = ConstructionPolyList; nextpoly; nextpoly = nextpoly->np){
			newpoly = nextpoly->poly;
			// create the datastruct to store contruction info in the poly
			newpoly->datastruct = calloc(1, sizeof(constrc));
		}
	}

}



void ShowConstructionPopup(polylist *ConstructionPolyList)
{
	// show text from dbf file for selected features
	poly *newpoly;
	int pc;
	polylist *nextpoly;
	GLfloat red, green, blue;
	static int textloaded = FALSE;
	extern LoadConstructionText();
	constrc *constrcp;
	int index;

	if (textloaded == FALSE){
		// LoadConstructionText(ConstructionPolyList);
		textloaded = TRUE;
	}

	for (pc = 0, nextpoly = ConstructionPolyList; nextpoly; nextpoly = nextpoly->np, pc++){
		newpoly = nextpoly->poly;

		/* draw a line between all of the points */
		newpoly->linelistcount = pc;

		if ((constrcp = (constrc *)newpoly->datastruct) && constrcp->status &&
			!(strcmp(constrcp->status, POLY_CLOSED))){
			red = 1.0f;
			green = 0.0f;
			blue = 0.0f;
			// write text from poly directly onto screen ala insight flight labels
			index = newpoly->index; // index into dbf file
			// now index into the poly struct to get the data struct for this poly

			// label = constrcp->streetname;

		} else {
			red = 0.0f;
			green = 0.0f;
			blue = 0.9f;
		}


	}

}



DrawSplashScreen(struct InstanceData* id)
{
	char tmpstr[TMPBUF_SIZE];
	int xPos = 0;

	// Clear the window
	glClear(GL_COLOR_BUFFER_BIT);
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
	glLoadIdentity();
	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();


	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	if (id->m_nNetworkTest){
		EnterCriticalSection(&id->m_csStatusSync);
		if (strlen(id->m_strStatusString))
			strncpy_s(tmpstr, TMPBUF_SIZE, id->m_strStatusString, 100);
		else
			sprintf_s(tmpstr, TMPBUF_SIZE, "Loading Images, please wait.......");
		LeaveCriticalSection(&id->m_csStatusSync);
		xPos = id->m_nWidth / 2 - 125;
		xPos = xPos > 5 ? xPos : 5;

		DrawGLText(id, xPos, id->m_nHeight / 2, tmpstr, (GLfloat *)white, id->m_gluCustomBase, FALSE);
	}else{
		// Display Network Failure Message
		int yPos = id->m_nHeight / 2 + 20;
		xPos = id->m_nWidth / 2 - 125;
		xPos = xPos > 5 ? xPos : 5;
		sprintf_s(tmpstr, TMPBUF_SIZE, "Web Tracker failed to establish required PASSUR communications.");
		DrawGLText(id, xPos, yPos, tmpstr, (GLfloat *)white, id->m_gluCustomBase, FALSE);
		sprintf_s(tmpstr, TMPBUF_SIZE, "Refresh page after network failures are corrected.");
		DrawGLText(id, xPos, yPos - 20, tmpstr, (GLfloat *)white, id->m_gluCustomBase, FALSE);
	}

	glFlush();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);



}

void ResizeGUI(struct InstanceData* id, gui *oglgui,int buffer_y)
{
	extern void CreateTopGUI(struct InstanceData* id);
	extern void CreateOverlaysSubNav(struct InstanceData* id);
	extern void CreateRightBar(struct InstanceData* id);
	static int drawopenglGUI = TRUE;
	char *AppName;

	// Resize  or move widgets as needed
	if (!oglgui){
		return;
	}

	// these widgets dynamically move if user resizes window
	// reposition all the widgets

	// resize the gui to fit the new screen dimensions


	////Setting void pointers to MGLGRID struct
	
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	MGLGRID* DataAppCreater = (MGLGRID*)id->DataAppCreater;
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;

	id->DataAppGrid = DataAppGrid;
	id->DataAppCreater = DataAppCreater;

	if (drawopenglGUI){
		//CreateTopGUI(id);
		//CreateOverlaysSubNav(id);
		//CreateRightBar(id);
		SetFontIndex(id, id->m_nCustFontIdx);  // reset so the large tags will have a good box
	}

	if (SecondTabGrid->parent_w->visible==TRUE)
	{
		SecondTabGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->BuildSummaryGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->to_open_details = 0;
		SecondTabGrid->childgrid->ActionsGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->ParametersGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->AlertsColorGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->SortAvailableGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->RowColumn->parent_w->visible = FALSE;

		if (SecondTabGrid->childgrid->AlertsColorGrid->BackgroundColorGrid)
		{
			SecondTabGrid->childgrid->AlertsColorGrid->BackgroundColorGrid->parent_w->visible = FALSE;
		}
		if (SecondTabGrid->childgrid->AlertsColorGrid->ForegroundColorGrid)
		{
			SecondTabGrid->childgrid->AlertsColorGrid->ForegroundColorGrid->parent_w->visible = FALSE;
		}
		if (SecondTabGrid->childgrid->AlertsColorGrid->IconColorGrid)
		{
			SecondTabGrid->childgrid->AlertsColorGrid->IconColorGrid->parent_w->visible = FALSE;
		}
		if (SecondTabGrid->childgrid->AlertsColorGrid->EMailGrid)
		{
			SecondTabGrid->childgrid->AlertsColorGrid->EMailGrid->parent_w->visible = FALSE;
		}
		if (SecondTabGrid->childgrid->AlertsColorGrid->SubjectGrid)
		{
			SecondTabGrid->childgrid->AlertsColorGrid->SubjectGrid->parent_w->visible = FALSE;
		}
		for (int xx = 0; xx < 100; xx++){
			AppName = VP(DataAppGrid->vo, xx, "AppName", char);
			if (AppName == NULL)
				goto next;
			if (strcmp(AppName, SecondTabGrid->childgrid->name) == 0){
				DataAppGrid->row_checkbox[xx] = 0;
				goto next;
			}
		}
	}

	else if (SecondTabGrid->parent_w->visible == FALSE)
	{
	DataAppGrid->callback = 0;
	if (SecondTabGrid->childgrid)
	{
		SecondTabGrid->childgrid->BuildSummaryGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->TitleGrid->parent_w->visible = FALSE;
		SecondTabGrid->childgrid->to_open_build = 0;

		for (int xx = 0; xx < 100; xx++){
			AppName = VP(DataAppGrid->vo, xx, "AppName", char);
			if (AppName == NULL)
				goto next;
			if (strcmp(AppName, SecondTabGrid->childgrid->name) == 0){
				DataAppGrid->row_checkbox[xx] = 0;
				//strncpy_s(DataAppGrid->gridcols[8].pngfilename, sizeof(DataAppGrid->gridcols[8].pngfilename), "zoom-arrow-off.png", _TRUNCATE);
				goto next;
			}
		}
	}
	}

next:if (DataAppGrid->check_firstopen != 1)
	{
		MGLGridMove(id, DataAppGrid, DataAppGrid->gridrect.x1, id->m_nHeight - (buffer_y - DataAppGrid->gridrect.y1));
		MGLGridMove(id, DataAppCreater, DataAppGrid->gridrect.x1, DataAppGrid->gridrect.y2 - ((DataAppGrid->nrows + 1) * DataAppGrid->gridrows[0].height) - (2 * DataAppGrid->gridrows[0].height));
	}

}






int sort_submit_cb(struct InstanceData* id, widgets *w, int x, int y, struct guistruct* g)
{
	MGLGRID *grid, *parentgrid;
	char *fieldname, *valstr;
	int i, filtercount;
	char tmpbuf[128];


	//   fill in config structure, field_name, and select_value[2048], comman separated values 

	// which column does this filter pertain to???

	// get data from list from FilterGrid->vo, columns "valstr" and "CalActive"

	grid = w->grid;

	// we want the parent grid
	parentgrid = grid->parentgrid;  // top level grid that contains the data


	// the column name that this FilterGrid->vo refers to is stored in FilterGrid->vo->name 
	fieldname = parentgrid->FilterGrid->vo->name;

	for (i = 0, filtercount = -1; i < parentgrid->Actions[parentgrid->CurActionNum].gridconfig->nFilters; i++){
		if (!strncmp(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[i].field_name, fieldname, 16)){
			// found the column name for the values in FilterGrid that we will filter with
			filtercount = i;
			break;
		}
	}

	if (filtercount == -1){
		// this is a new filter column to add
		if (parentgrid->Actions[parentgrid->CurActionNum].gridconfig->nFilters < 7){
			(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->nFilters)++;
		}
		filtercount = parentgrid->Actions[parentgrid->CurActionNum].gridconfig->nFilters - 1;
	}

	// now create the select_value buffer with the comma separated values
	if (filtercount >= 0 && filtercount < 7){
		strncpy_s(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].field_name,
			sizeof(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].field_name), fieldname, _TRUNCATE);


		parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].select_value[0] = '\0';
		for (i = 0; i < parentgrid->FilterGrid->vo->count; i++){
			if (VV(parentgrid->FilterGrid->vo, i, "ValActive", int) == TRUE){
				valstr = VP(parentgrid->FilterGrid->vo, i, "valstr", char);
				_snprintf_s(tmpbuf, _countof(tmpbuf), _TRUNCATE, "%s,", valstr);
				strncat_s(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].select_value,
					sizeof(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].select_value),
					tmpbuf, _TRUNCATE);
			}
		}


		// recalculate the searchvo
		if (parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].searchvo){
			vo_free(parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].searchvo);
		}
		parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].searchvo = NULL;
		parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].searchvo =
			MGLCrSearchVO((char *)&parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].select_value);
		parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].filter_type = FTYPE_LIST;

	}

	strncpy_s(parentgrid->FilterGrid->vo->name, sizeof(parentgrid->FilterGrid->vo->name),
		parentgrid->Actions[parentgrid->CurActionNum].gridconfig->filters[filtercount].field_name, _TRUNCATE);


	return ProcessKeydown(id, VK_UP, 0);
}



PREGION **CreateRegionStructs(struct InstanceData* id)
{
	int rcount, i, vcount, regionid;
	PREGION *reg;
	char region[33];
	VO *ROIVO;
	char *arpt;

	// Moved up becuase the ROI needs to be loaded from DB before we can create the region structs.
	if (!(ROIVO = id->m_pROIVO)){
		return(NULL);
	}

	if (!strcasecmp(id->m_strRegionArpt, id->m_sCurLayout.m_strPassurArpt)){
		// same airport as before
		if (id->m_pRegions){
			return(id->m_pRegions);
		}
		if (id->m_nQuitRegionCount++ > 5){
			// don't query anymore for this airport
			return(NULL);
		}
	} else {
		// different airport
		id->m_nQuitRegionCount = 0;

		// Update REGION Airport if changed from PASSUR
		strcpy_s(id->m_strRegionArpt, 6, id->m_sCurLayout.m_strPassurArpt); // set airport
		StrUpper(id->m_strRegionArpt);

		// clear out data also
		if (id->m_pROIDataVO){
			vo_rm_rows(id->m_pROIDataVO, 0, ((VO*)(id->m_pROIDataVO))->count);
		}
	}

	// initialize region
	region[0] = '\0';
	regionid = -1;  // we must support multiple regions with same name for complex polygons too difficult to combine

	FreeRegions(id);


	if (id->m_pRegions)
		id->m_pRegions[0] = '\0';
	rcount = 0;

	for (i = 0; ROIVO && i < ROIVO->count; i++){
		// only load regions for the current airport
		arpt = VP(ROIVO, i, "arpt", char);
		if (strlen(arpt) == 4 && strlen(id->m_sCurLayout.m_strPassurArpt) == 3){
			arpt++;
		}
		if (strcasecmp(arpt, id->m_sCurLayout.m_strPassurArpt)){
			continue;
		}
		if (strcmp(VP(ROIVO, i, "Region", char), region) || VV(ROIVO, i, "id", int) != regionid){
			// new region
			if (strlen(region)){
				// first name
			}
			rcount++;
			strncpy_s(region, _countof(region), VP(ROIVO, i, "Region", char), _TRUNCATE);
			region[sizeof(region) - 1] = '\0';
			regionid = VV(ROIVO, i, "id", int);
		}
	}
	if (!rcount){
		return(NULL);
	}

	id->m_pRegions = (PREGION **)calloc(rcount, sizeof(PREGION *));
	for (i = 0; i < rcount; i++){
		id->m_pRegions[i] = (PREGION *)calloc(1, sizeof(PREGION));
	}

	// count how many verts in this poly
	region[0] = '\0';
	rcount = 0;
	regionid = -1;  // we must support multiple regions with same name for complex polygons too difficult to combine
	for (i = 0; ROIVO && i < ROIVO->count; i++){
		arpt = VP(ROIVO, i, "arpt", char);
		if (strlen(arpt) == 4 && strlen(id->m_sCurLayout.m_strPassurArpt) == 3){
			arpt++;
		}
		if (strcasecmp(arpt, id->m_sCurLayout.m_strPassurArpt)){
			continue;
		}
		if (strcmp(VP(ROIVO, i, "Region", char), region) || VV(ROIVO, i, "id", int) != regionid){
			// new region
			vcount = 0;
			if (strlen(region)){
				// first name
			}
			reg = id->m_pRegions[rcount];
			rcount++;
			strncpy_s(region, _countof(region), VP(ROIVO, i, "Region", char), _TRUNCATE);
			strncpy_s(reg->name, 33, region, _TRUNCATE);
			regionid = VV(ROIVO, i, "id", int);
		}
		//reg->vertx[vcount] = (float) VV(ROIVO, i, "longitude", double);
		//reg->verty[vcount] = (float) VV(ROIVO, i, "latitude", double);
		vcount++;
		reg->nvert = vcount;
	}

	for (i = 0; i < rcount; i++){
		reg = id->m_pRegions[i];
		reg->vertx = (float *)calloc(reg->nvert, sizeof(float));
		reg->verty = (float *)calloc(reg->nvert, sizeof(float));
	}

	//  now fill in vert values
	region[0] = '\0';
	rcount = 0;
	regionid = -1;
	for (i = 0; ROIVO && i < ROIVO->count; i++){
		arpt = VP(ROIVO, i, "arpt", char);
		if (strlen(arpt) == 4 && strlen(id->m_sCurLayout.m_strPassurArpt) == 3){
			arpt++;
		}
		if (strcasecmp(arpt, id->m_sCurLayout.m_strPassurArpt)){
			continue;
		}
		if (strcmp(VP(ROIVO, i, "Region", char), region) || VV(ROIVO, i, "id", int) != regionid){
			// new region
			vcount = 0;
			if (strlen(region)){
				// first name
			}
			reg = id->m_pRegions[rcount];
			rcount++;
			strncpy_s(region, _countof(region), VP(ROIVO, i, "Region", char), _TRUNCATE);
			//already have this   strncpy( reg->name, region, sizeof( reg->name ));
			regionid = VV(ROIVO, i, "id", int);
		}
		reg->vertx[vcount] = (float)VV(ROIVO, i, "longitude", double);
		reg->verty[vcount] = (float)VV(ROIVO, i, "latitude", double);
		vcount++;
		//  reg->nvert = vcount;
	}

	id->m_nRegions = rcount;
	return(id->m_pRegions);
}

void FreeGUI(struct InstanceData* id)
{
	widgets *w = NULL, *wr = NULL;
	gui* oglgui = (gui*)id->m_poglgui;
	if (oglgui){
		for (w = oglgui->widgets; w; w = w->np){
			if (wr){
				vp_free(wr);
				wr = NULL;
			}
			wr = w;
		}
		if (wr){
			vp_free(wr);
			wr = NULL;
		}
		vp_free(oglgui);
		oglgui = NULL;
	}
	id->m_poglgui = oglgui;
}


VO *CrFDOVO()
{
	VO *FDOVO;

	FDOVO = (VO *)vo_create(0, NULL);
	vo_set(FDOVO, V_NAME, "FDOVO", NULL);


	VOPropAdd(FDOVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(FDOVO, "Origin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(FDOVO, "Destin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);


	VOPropAdd(FDOVO, "actype", NTBSTRINGBIND, ACTYPE_SIZE, VO_NO_ROW);
	VOPropAdd(FDOVO, "eta", INTBIND, -1, VO_NO_ROW);  // in unix time
	VOPropAdd(FDOVO, "ata", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "std", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "etd", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "atd", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "sta", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "speed", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "DestDis", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "beacon", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "altitude", INTBIND, -1, VO_NO_ROW);

	VOPropAdd(FDOVO, "outtime", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "offtime", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "ontime", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "intime", INTBIND, -1, VO_NO_ROW);
	
	VOPropAdd(FDOVO, "d_actype", NTBSTRINGBIND, ACTYPE_SIZE, VO_NO_ROW); // delta actype

	
	VOPropAdd(FDOVO, "psgr_clseout", INTBIND, -1, VO_NO_ROW);

	VOPropAdd(FDOVO, "intdprtgate", NTBSTRINGBIND, GATE_SIZE, VO_NO_ROW);
	
	VOPropAdd(FDOVO, "int_arr_gate", NTBSTRINGBIND, GATE_SIZE, VO_NO_ROW);

	

	VOPropAdd(FDOVO, "tbfm_offtime", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "tbfm_ontime", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "tbfm_freezetime", INTBIND, -1, VO_NO_ROW);

	// add fields for UAL
	/*cargo_door_clsd | timestamp with time zone |
	cargo_door_open | timestamp with time zone |
	pax_door_clsd | timestamp with time zone |
	pax_door_open | timestamp with time zone |
	*/


	VOPropAdd(FDOVO, "cargo_door_clsd", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "cargo_door_open", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "pax_door_clsd", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "pax_door_open", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "bridge_on_time", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "crew_out_time", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "brake_released", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "brake_set", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "dep_gate", NTBSTRINGBIND, GATE_SIZE, VO_NO_ROW);
	VOPropAdd(FDOVO, "arr_gate", NTBSTRINGBIND, GATE_SIZE, VO_NO_ROW);

	VOPropAdd(FDOVO, "acars_init", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "first_msg", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "old_fid", NTBSTRINGBIND, 9, VO_NO_ROW);
	VOPropAdd(FDOVO, "fps", NTBSTRINGBIND, 25, VO_NO_ROW);
	VOPropAdd(FDOVO, "acs", NTBSTRINGBIND, 25, VO_NO_ROW);
	VOPropAdd(FDOVO, "sfzflag", NTBSTRINGBIND, 25, VO_NO_ROW);
	VOPropAdd(FDOVO, "rfzflag", NTBSTRINGBIND, 25, VO_NO_ROW);
	VOPropAdd(FDOVO, "rwy_freeze", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "tbfm_actype", NTBSTRINGBIND, 13, VO_NO_ROW);
	VOPropAdd(FDOVO, "tracon_rwy", NTBSTRINGBIND, 7, VO_NO_ROW);
	VOPropAdd(FDOVO, "arr_rwy", NTBSTRINGBIND, 7, VO_NO_ROW);
	VOPropAdd(FDOVO, "edc_status", NTBSTRINGBIND, 7, VO_NO_ROW);
	VOPropAdd(FDOVO, "edc_time", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "tbfm_etd", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "sta_at_rwy", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "eta_at_rwy", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "Assigned Gate Status", NTBSTRINGBIND, 32, VO_NO_ROW);


	//10/12/2016
	VOPropAdd(FDOVO, "estdprtctrlgmtts", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "estdprtctrlgmttssrc", NTBSTRINGBIND, 33, VO_NO_ROW);
	VOPropAdd(FDOVO, "brdngstrtdgmtts", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "paxdrclsgmtts", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "readytodprtgmtts", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "onlinetsgmt", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(FDOVO, "draggateid", NTBSTRINGBIND, 17, VO_NO_ROW);

	//11/1/2016
	VOPropAdd(FDOVO, "Flt_at_Gate", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(FDOVO, "Gt_Exp_Clr_Time", INTBIND, -1, VO_NO_ROW);

	vo_rm_rows(FDOVO, 0, FDOVO->count);

	vo_set(FDOVO, V_ORDER_COLS, "FltNum", "Origin", NULL, NULL);

	return(FDOVO);
}




VO *CrSAVO()
{
	VO *SAVO;

	SAVO = (VO *)vo_create(0, NULL);
	vo_set(SAVO, V_NAME, "SAVO", NULL);

	VOPropAdd(SAVO, "seqnum", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(SAVO, "appname", NTBSTRINGBIND, APPNAME_SIZE, VO_NO_ROW);
	VOPropAdd(SAVO, "username", NTBSTRINGBIND, USERNAME_SIZE, VO_NO_ROW);
	VOPropAdd(SAVO, "alertname", NTBSTRINGBIND, ALERTNAME_SIZE, VO_NO_ROW);


	VOPropAdd(SAVO, "priority", NTBSTRINGBIND, PRIORITY_SIZE, VO_NO_ROW);
	VOPropAdd(SAVO, "starttime", INTBIND, -1, VO_NO_ROW);  // in unix time
	VOPropAdd(SAVO, "endtime", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(SAVO, "comments", NTBSTRINGBIND, COMMENTS_SIZE, VO_NO_ROW); // comments
	VOPropAdd(SAVO, "alertsource", NTBSTRINGBIND, ALERTSOURCE_SIZE, VO_NO_ROW);
	//VOPropAdd(SAVO, "keyvalues", NTBSTRINGBIND, KEYVALUES_SIZE, VO_NO_ROW);

	vo_rm_rows(SAVO, 0, SAVO->count);

	//vo_set(FDOVO, V_ORDER_COLS, "FltNum", "Origin", NULL, NULL);

	return(SAVO);
}


DrawGUIPanel(struct InstanceData* id, gui *oglgui)
{

	if (!oglgui->visible)
		return (TRUE);

	glPushMatrix();
	glLoadIdentity();

	glColor3f(1.0f, 1.0f, 1.0f); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);


	/* draw white box around rectangle that fits screen */

	glBegin(GL_LINE_LOOP);
	glVertex3f((float)oglgui->gregion.x1, (float)oglgui->gregion.y1, 0.0f);
	glVertex3f((float)oglgui->gregion.x2, (float)oglgui->gregion.y1, 0.0f);
	glVertex3f((float)oglgui->gregion.x2, (float)oglgui->gregion.y2, 0.0f);
	glVertex3f((float)oglgui->gregion.x1, (float)oglgui->gregion.y2, 0.0f);
	glEnd();

	glColor3fv(oglgui->bg);
	// glColor3fv( blue );

	glRecti(oglgui->gregion.x1, oglgui->gregion.y1, oglgui->gregion.x2, oglgui->gregion.y2);



	glFlush();

	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0f, 1.0f, 1.0f);
	return(TRUE);
}



void StripLeading0(char *src, char *des, int deslen)
{
	int fltnum;

	// strip off leading 0's from Flight ID's. so AFR006 becomes AFR6

	strncpy_s(des, deslen, src, _TRUNCATE);

	if (strlen(src) > 3 && isalpha(src[0]) && isalpha(src[1]) && isalpha(src[2])
		&& src[3] == '0')
	{
		fltnum = atoi(&src[3]);
		_snprintf_s(des, FLTNUM_SIZE, _TRUNCATE, "%.3s%d", src, fltnum);
	}

}

int compareArpt(const void *arg1, const void *arg2)
{
	ARPT *Arpt1, *Arpt2;

	//char *str1, *str2;
	/* Compare all of both strings: */
	//str1 = *arg1;
	//str2 = *arg2;

	Arpt1 = (ARPT *)arg1;
	Arpt2 = (ARPT *)arg2;

	return _strcmpi(Arpt1->icao, Arpt2->icao);
}


VO *ProcessAirports(struct InstanceData* id, char *membuf)
{
	double lat, lng;
	int matches, len;
	char linebuf[256];
	char *eolstr;
	char arptcode[256];
	VO *AirportVO = NULL;
	int pflag = 0;
	int i;

	while (membuf && strlen(membuf)){
		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);

			membuf = eolstr;
			membuf++; /* skip over eol char */

			matches = sscanf_s(linebuf, "%s %lf %lf", arptcode, _countof(arptcode), &lat, &lng);
			if (matches == 3){
				if (!AirportVO){
					AirportVO = (VO *)vo_create(0, NULL);
					vo_set(AirportVO, V_NAME, "AirportVO", NULL);

					VOPropAdd(AirportVO, "lat", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "lng", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					vo_rm_rows(AirportVO, 0, AirportVO->count);
				}
				vo_alloc_rows(AirportVO, 1);
#ifdef OLDWAY
				if ( AirportVO->count % 1000 == 0 ){
					UpdateSplashWin((GLfloat) (AirportVO->count / 100 * 300.0f) / SPLASH_XSIZE, (GLfloat) 60.0f,
						(GLfloat) 0.0f, 16.0f);
				}
#endif


				strncpy_s(VP(AirportVO, AirportVO->count - 1, "code", char), ARPT_CODE_SIZE, arptcode, _TRUNCATE);
				VV(AirportVO, AirportVO->count - 1, "lat", double) = lat;
				VV(AirportVO, AirportVO->count - 1, "lng", double) = lng;
			}
		} else {
			membuf = NULL;
		}
	}

	/* sort the array by code */
	vo_set(AirportVO, V_ORDER_COLS, "code", NULL, NULL);
	vo_order(AirportVO);
	if (pflag){
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", GetCurrentThreadId(), i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "code", char));
		}
	}
	return(AirportVO);
}

VO *ProcessAirports2(struct InstanceData* id, char *membuf)
{
	double lat, lng;
	int matches, len, alt;
	char linebuf[256];
	char *eolstr;
	char arptcode[256];
	VO *AirportVO = NULL;
	int pflag = 0;
	int i;

	while (membuf && strlen(membuf)){
		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);

			membuf = eolstr;
			membuf++; /* skip over eol char */

			matches = sscanf_s(linebuf, "%s %lf %lf %d", arptcode, _countof(arptcode), &lat, &lng, &alt);
			if (matches == 4){
				if (!AirportVO){
					AirportVO = (VO *)vo_create(0, NULL);
					vo_set(AirportVO, V_NAME, "AirportVO", NULL);

					VOPropAdd(AirportVO, "alt", INTBIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "lat", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "lng", FLT8BIND, -1, VO_NO_ROW);
					VOPropAdd(AirportVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					vo_rm_rows(AirportVO, 0, AirportVO->count);
				}
				vo_alloc_rows(AirportVO, 1);
#ifdef OLDWAY
				if ( AirportVO->count % 1000 == 0 ){
					UpdateSplashWin((GLfloat) (AirportVO->count / 100 * 300.0f) / SPLASH_XSIZE, (GLfloat) 60.0f,
						(GLfloat) 0.0f, 16.0f);
				}
#endif


				strncpy_s(VP(AirportVO, AirportVO->count - 1, "code", char), ARPT_CODE_SIZE, arptcode, _TRUNCATE);
				VV(AirportVO, AirportVO->count - 1, "lat", double) = lat;
				VV(AirportVO, AirportVO->count - 1, "lng", double) = lng;
				VV(AirportVO, AirportVO->count - 1, "alt", int) = alt;
			}
		} else {
			membuf = NULL;
		}
	}

	/* sort the array by code */
	vo_set(AirportVO, V_ORDER_COLS, "code", NULL, NULL);
	vo_order(AirportVO);
	if (pflag){
		for (i = 0; AirportVO && i < AirportVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] rowindex=%d, =%s\n", GetCurrentThreadId(), i, AirportVO->row_index[i].rownum,
				VP(AirportVO, i, "code", char));
		}
	}
	return(AirportVO);
}


VO *LoadAirports(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char outbuf[TMPBUF_SIZE];
	static int firsttime = 1;
	int pflag = 0;
	struct timeb start_time, done_time;
	VO *AirportsVO;
	int trycount = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(&chunk);

	if (firsttime){
		VOTimeFmt(lastcmdtime, time(0), "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	while (trycount++ < 3){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=RdArptLatLons");
		if (pflag){
			printf("GetCommands, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
		}
		if (timeflag){ ftime(&start_time); }

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
			cdwThreadId, GetPulseSrvr(id), tmpstr);

		if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Call to %s failed, switching srvrs to %s and trying again.\n",
				cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		}

		if (timeflag) {
			ftime(&done_time);
		}

		if (chunk.memory){
			strncpy_s(outbuf, TMPBUF_SIZE, chunk.memory, 255);
			AirportsVO = ProcessAirports(id, chunk.memory);
			free(chunk.memory);
			chunk.memory = NULL;
			return(AirportsVO);
		} else {
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Airport data retrieved from server, switching srvrs from %s to %s and trying again.\n",
				cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		}
	}

	vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to retrieve airport information.\n",
		cdwThreadId);
	// should never get here, unless error
	return(NULL);
}

VO *LoadAirports2(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char outbuf[TMPBUF_SIZE];
	static int firsttime = 1;
	int pflag = 0;
	struct timeb start_time, done_time;
	static VO *AirportsVO = NULL;
	int trycount = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(&chunk);

	if (firsttime){
		VOTimeFmt(lastcmdtime, time(0), "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	if (AirportsVO)
		return AirportsVO;

	while (trycount++ < 3){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=RdArptLatLons");
		if (pflag){
			printf("GetCommands, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
		}
		if (timeflag){ ftime(&start_time); }

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - <%s> tmpstr <%s>.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

		if (!GetCurlFormGetResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Call to %s failed, switching srvrs to %s and trying again.\n",
				cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		}

		if (timeflag) {
			ftime(&done_time);
		}

		if (chunk.memory){
			strncpy_s(outbuf, TMPBUF_SIZE, chunk.memory, 255);
			AirportsVO = ProcessAirports2(id, chunk.memory);
			free(chunk.memory);
			chunk.memory = NULL;
			return(AirportsVO);
		} else {
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Airport data retrieved from server, switching srvrs from %s to %s and trying again.\n",
				cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		}
	}

	vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to retrieve airport information.\n",
		cdwThreadId);
	// should never get here, unless error
	return(NULL);
}

void LoadAirportGroundAltitude(struct InstanceData* id)
{
	int i = 0;
	VO *AirportsVO = LoadAirports2(id);
	char arpt[4] = { 0 };
	for (i = 0; i < 3; i++){
		arpt[i] = id->m_strAsdexArpt[i];
	}
	for (i = 0; AirportsVO && i < AirportsVO->count; i++){
		if (!strcasecmp(VP(AirportsVO, i, "code", char), arpt)){
			id->m_nArptAlt = VV(AirportsVO, i, "alt", int);
			break;
		}
	}
}


void SmoothPassurTracks(struct InstanceData* id, AIR *air, int AI)
{
	PTRACK *trackarr;
	RL_PNT smoothTrack[RL_MAX_POINTS];	// NS
	RL_PNT roughTrack[RL_MAX_POINTS];	// NS
	RL_PNT *Fpoint;
	int i, j, tcount;
	VO* PassurArptsVO = NULL;
	static int pflag = TRUE;
	static int n2smooth = 5;


	if ((trackarr = air->TrackPtr) && air->tcount > n2smooth)
	{
		memset(roughTrack, 0, sizeof roughTrack);
		memset(smoothTrack, 0, sizeof smoothTrack);

		for (i = air->tcount - 1, tcount = 0; tcount < n2smooth; i--, tcount++)
		{
			roughTrack[tcount].x = trackarr[i].x;
			roughTrack[tcount].y = trackarr[i].y;
			roughTrack[tcount].t = trackarr[i].utc;	// NS
		}

		EnterCriticalSection(&id->m_csAirportsVO);
		PassurArptsVO = (VO*)id->m_pAirportsVO;
		if (PassurArptsVO) {
			j = passurSmooth(roughTrack, smoothTrack, &Fpoint, id->m_sCurLayout.m_strPassurArpt, n2smooth, (void *)PassurArptsVO);
		}
		LeaveCriticalSection(&id->m_csAirportsVO);
		if (j != n2smooth)
		{
			for (i = 0; i < tcount; i++)
			{
				smoothTrack[i].x = roughTrack[i].x;
				smoothTrack[i].y = roughTrack[i].y;
				smoothTrack[i].z = roughTrack[i].z;
				smoothTrack[i].t = roughTrack[i].t;
			}
		} else {
			for (i = air->tcount - 1, tcount = 0; tcount < n2smooth; i--, tcount++)
			{
				trackarr[i].x = (GLfloat)smoothTrack[tcount].x;
				trackarr[i].y = (GLfloat)smoothTrack[tcount].y;
				trackarr[i].utc = (int)smoothTrack[tcount].t;
			}
		}
	}
}




void SmoothAsdexTracks(struct InstanceData* id, AIR *air, int AI)
{
	//	Call to this function has been commented out until/if asdex tracks
	//	smoothing needs to be implemented.  This function is currently a copy
	//	of SmoothPassurTracks() except that it smoothes based on the last 3
	//	points (instead of the usual 5).  If implemented, this function would
	//	ideally need additional code to add limits to smoothing so that sharp
	//	turns (on intersecting taxiways for example) would not get smoothed.

	PTRACK *trackarr;
	RL_PNT smoothTrack[RL_MAX_POINTS];	// NS
	RL_PNT roughTrack[RL_MAX_POINTS];	// NS
	RL_PNT *Fpoint;
	int i, j, tcount;
	VO* PassurArptsVO = NULL;
	static int pflag = TRUE;
	static int n2smooth = 3;


	if ((trackarr = air->TrackPtr) && air->tcount > n2smooth)
	{
		memset(roughTrack, 0, sizeof roughTrack);
		memset(smoothTrack, 0, sizeof smoothTrack);

		for (i = air->tcount - 1, tcount = 0; tcount < n2smooth; i--, tcount++)
		{
			roughTrack[tcount].x = trackarr[i].x;
			roughTrack[tcount].y = trackarr[i].y;
			roughTrack[tcount].t = trackarr[i].utc;	// NS
		}

		EnterCriticalSection(&id->m_csAirportsVO);
		PassurArptsVO = (VO*)id->m_pAirportsVO;
		if (PassurArptsVO) {
			j = passurSmooth(roughTrack, smoothTrack, &Fpoint, id->m_sCurLayout.m_strPassurArpt, n2smooth, (void *)PassurArptsVO);
		}
		LeaveCriticalSection(&id->m_csAirportsVO);

		if (j != n2smooth)
		{
			for (i = 0; i < tcount; i++)
			{
				smoothTrack[i].x = roughTrack[i].x;
				smoothTrack[i].y = roughTrack[i].y;
				smoothTrack[i].z = roughTrack[i].z;
				smoothTrack[i].t = roughTrack[i].t;
			}
		} else {
			for (i = air->tcount - 1, tcount = 0; tcount < n2smooth; i--, tcount++)
			{
				trackarr[i].x = (GLfloat)smoothTrack[tcount].x;
				trackarr[i].y = (GLfloat)smoothTrack[tcount].y;
				trackarr[i].utc = (int)smoothTrack[tcount].t;
			}
		}
	}
}

int UpdLMGVehicles( struct InstanceData* id, struct feedstruct *record)
{
	int AI;
	AIR **airp;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (  record->TrackID >= N_PASSUR_TRACK_ID ||  record->TrackID < 0 ){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID );
		return(SUCCEED);
	}
	airp = GetLMGAirP(id);

	if ( !(air = airp[record->TrackID]) ) {
		// New aircraft track
		AI = record->TrackID;
		// Check gate airp first, to pull from gate out
		if(air = AirpFromGateFlights( id, record->FltNum )){
			airp[AI] = air;
		}else{
			air = GetAir( airp, AI ); // creates the new struct for tracking
		}
		air->trackid = record->TrackID;
		air->vehicle = record->vehicle;
		//air->icao24 = record->icao24;

		D_CONTROL("LMG",vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new vehicle id=%s AirIndex[%d] = %d\n",
				cdwThreadId, record->FltNum, record->TrackID, AI ));
		if( !strlen(air->FltNum) ){
			strncpy_s( air->FltNum, FLTNUM_SIZE + 1, record->FltNum,  FLTNUM_SIZE);		
		}
		if(!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new vehicle id=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI ) ); 
		//CkNewASDEXOverlap( id, air, record );
	} else {
		// track already exists
		AI = record->TrackID;
		air->vehicle = record->vehicle;
		air->icao24 = record->icao24;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft id=%s Index[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked ) );
		if( !strlen(air->FltNum) ){
			strncpy_s( air->FltNum, FLTNUM_SIZE + 1, record->FltNum,  FLTNUM_SIZE);		
		}		
	}

	if(1 == air->vehicle && air->icao24){
		VINFO vInfo;
		memset(&vInfo, 0, sizeof(VINFO));
		if(GetVehicleData(id, air->icao24, air->trackid, &vInfo)){
			air->VInfoPtr = (VINFO*)calloc(1, sizeof(VINFO));
			memcpy(air->VInfoPtr, &vInfo, sizeof(VINFO));
			if(strcmp(vInfo.Id, record->FltNum)){
				D_CONTROL("VEH", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLTNUM<%s>, VEHID<%s>\n", cdwThreadId, record->FltNum, vInfo.Id));
				if(!strlen(record->FltNum) || !strcmp(record->FltNum, "UNKN")) 
					strcpy_s(record->FltNum, FLTNUM_SIZE + 1, vInfo.Id);
				else
					D_CONTROL("VEH", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring VEHID<%s> for existing FLTNUM<%s>\n", cdwThreadId, vInfo.Id, record->FltNum));
			}
		}
	}

	air->CurX = (GLfloat) record->lng;
	air->CurY = (GLfloat) record->lat;
	air->utc = (int) record->eventtime;	
	air->altitude = record->altitude;
	air->heading = record->heading;

	D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, TIME:%d:%d\n", 
		cdwThreadId, record->FltNum, record->TrackID, record->lat, record->lng, record->eventtime, air->utc));

	/* 0.00054 NM = 1 meter */
	if( record->speed ){
		air->speed = record->speed;
	} 

	if(!AddTrail( id, air, AI, record , FALSE, MAX( MIN( ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), ASDEX_TRACK_MODIFIER(MAX_ASDEX_TRACK_POINTS)) , 3 ) )){
		// Update last track point to utc, but not for UNKN's
		if(strcmp(air->FltNum, "UNKN") && air->tcount && air->TrackPtr){
			D_CONTROL("TRACK_TIME_MOD", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Adjusting UTC time for ASDEX aircraft track[%d] from %d to %d for fltnum=%s.\n",
				cdwThreadId, air->tcount - 1, air->TrackPtr[air->tcount - 1].utc, record->eventtime, air->FltNum) );
			air->TrackPtr[air->tcount - 1].utc = record->eventtime;
		}
	}
	return( SUCCEED );
}


int UpdASDEXAircraft(struct InstanceData* id, struct feedstruct *record)
{
	double x, y; /* screen position */
	int AI;
	AIR **airp;
	AIR *air, *air2;
	struct timeb tb;
	double velocity_meters_per_sec;
	char tmpstr[TMPBUF_SIZE];
	int pflag = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (record->rectype == 0){
		return(SUCCEED);
	}

	if (record->TrackID >= N_PASSUR_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		return(SUCCEED);
	}
	airp = GetASDEXAirP(id);

	if (!(air = airp[record->TrackID])) {
		// New aircraft track
		AI = record->TrackID;
		// Check gate airp first, to pull from gate out
		if (air = AirpFromGateFlights(id, record->FltNum)){
			airp[AI] = air;
		}else{
			air = GetAir(airp, AI); // creates the new struct for tracking
		}
		air->trackid = record->TrackID;
		air->vehicle = record->vehicle;
		air->icao24 = record->icao24;

		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
				cdwThreadId, record->FltNum, record->TrackID, AI);
		}
		if (!strlen(air->FltNum)){
			strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		}
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI));
		CkNewASDEXOverlap(id, air, record);
	} else {
		// track already exists
		if (air2 = AirpFromGateFlights(id, record->FltNum)){
			AIR** gate_air = GetGateAirP(id);
			strcpy_s(air->gate, GATE_SIZE, air2->gate);
			strcpy_s(air->Origin, ORIG_DES_SIZE, air2->Origin);
			strcpy_s(air->Destin, ORIG_DES_SIZE, air2->Destin);
			gate_air[air2->trackid] = air2;
			RemoveTrack(id, gate_air, air2->trackid, GATE, TRUE);
		}
		AI = record->TrackID;
		air->vehicle = record->vehicle;
		air->icao24 = record->icao24;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
		if (!strlen(air->FltNum)){
			strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		}else{
			// Check if Flight Id's are different
			if (strcmp(air->FltNum, record->FltNum)){
				// If the old data is "UNKN" and the new is a not, Update to the new
				if (!strcmp(air->FltNum, "UNKN") && strcmp(record->FltNum, "UNKN")){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX Aircraft trackid %d has changed it's fltnum from %s to %s\n",
						cdwThreadId, AI, air->FltNum, record->FltNum);
					strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
				}
				// If the old is being converted to UNKN, use the old one.
				else if (!strcmp(record->FltNum, "UNKN") && strcmp(air->FltNum, "UNKN")){
					vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX Aircraft trackid %d has changed it's fltnum from %s to %s but is being ignored!\n",
						cdwThreadId, AI, air->FltNum, record->FltNum);
					strncpy_s(record->FltNum, FLTNUM_SIZE + 1, air->FltNum, FLTNUM_SIZE);
				}
				// Changing Flight Id's, I guess we had the wrong Flight ID
				else{
					if (!air->icao24 && record->icao24)
						air->icao24 = record->icao24;
					if (!air->beacon && record->beacon)
						air->beacon = record->beacon;
					// Remove the Old Index
					vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX Aircraft trackid %d has changed it's fltnum from %s to %s\n",
						cdwThreadId, AI, air->FltNum, record->FltNum);
					RemoveIndex(id, id->m_pASDEXIndexMap, air->FltNum, air->icao24, air->beacon, ASDEX);
					strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
					AddIndex(id, id->m_pASDEXIndexMap, air->FltNum, record->icao24, AI, record->beacon, ASDEX);
				}
			}
		}
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		if (!air->beacon && record->beacon)
			air->beacon = record->beacon;
		CkNewASDEXOverlap(id, air, record);
	}

	if (!air->icao24 && record->icao24)
		air->icao24 = record->icao24;
	if (!air->beacon && record->beacon)
		air->beacon = record->beacon;

	if (IsBARRFlight(id, record->FltNum)){
		// flight is in BARR list
		if (!id->m_bDHSPerm){
			if (id->m_nDelaySecs < 1800){
				// we are allowed to show ASDEX tails according to TG, since users have MOA to see asdex
				//air->IsBARR = TRUE;
				//D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) aircraft fltnum=%s marked as blocked from BARR.\n",
				//	cdwThreadId, record->FltNum) );
			} else {
				// flight is in replay mode so show it
			}
		} else {
			// DHS allowed to see flights
		}
	}

	if (1 == air->vehicle && air->icao24){
		VINFO vInfo;
		memset(&vInfo, 0, sizeof(VINFO));
		if (GetVehicleData(id, air->icao24, air->trackid, &vInfo)){
			air->VInfoPtr = (VINFO*)calloc(1, sizeof(VINFO));
			memcpy(air->VInfoPtr, &vInfo, sizeof(VINFO));
			if (strcmp(vInfo.Id, record->FltNum)){
				D_CONTROL("VEH", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLTNUM<%s>, VEHID<%s>\n", cdwThreadId, record->FltNum, vInfo.Id));
				if (!strlen(record->FltNum) || !strcmp(record->FltNum, "UNKN"))
					strcpy_s(record->FltNum, FLTNUM_SIZE + 1, vInfo.Id);
				else
					D_CONTROL("VEH", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring VEHID<%s> for existing FLTNUM<%s>\n", cdwThreadId, vInfo.Id, record->FltNum));
			}
		}
	}

	air->heading = record->heading;
	strncpy_s(air->src_radar, 6, record->src_radar, _TRUNCATE);
	if (strlen(record->actype)){
		if (!HasPrintStr(record->actype)){
			// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
		} else {
			strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
		}
	}
	if (strlen(record->FltNum))
		strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);

	if (!id->m_tPlotTime){
		id->m_tPlotTime = record->eventtime;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Setting initial plottime to %d\n", cdwThreadId, id->m_tPlotTime);
		ftime(&tb);
		id->m_tClientsTime = tb.time;
		if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

		id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
		id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
		SetPassurDelaytime(id);
		MGLGridText(id, statusgrid, 24, 0, "plottime");
		VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
		MGLGridText(id, statusgrid, 24, 1, tmpstr);
	} else if ( id->m_nDelaySecs == 0 ){
		/* we are in live mode so make sure we keep clock up to date */
		if (id->m_tPlotTime < record->eventtime){

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, record->eventtime);

			id->m_tPlotTime = record->eventtime;
			ftime(&tb);
			id->m_tClientsTime = tb.time;

			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

			id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
			id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
			SetPassurDelaytime(id);
			MGLGridText(id, statusgrid, 24, 0, "plottime");
			VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
			MGLGridText(id, statusgrid, 24, 1, tmpstr);
		}
	}

	if (record->eventtime < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, record->eventtime);
		return(FAIL);
	}

	CalcLatLon(id, record->feedx, record->feedy, &x, &y, 0);

	air->CurX = (GLfloat)x;
	air->CurY = (GLfloat)y;
	air->utc = (int)record->eventtime;
	air->altitude = record->altitude;

	D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, TIME:%d:%d\n",
		cdwThreadId, record->FltNum, record->TrackID, y, x, record->eventtime, air->utc));

	/* 0.00054 NM = 1 meter */
	if (record->speed){
		air->speed = record->speed;
	} else {
		velocity_meters_per_sec = (double)sqrt((double)(record->velocity_x * record->velocity_x) +
			(record->velocity_y * record->velocity_y));
		// calculate in knots (Nautical miles per hour)
		if (velocity_meters_per_sec > 0.0){
			air->speed = (int)rint(velocity_meters_per_sec * 3600.0 * 0.00054);
		}
	}

	if (!AddTrail(id, air, AI, record, FALSE, MAX(MIN(ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), ASDEX_TRACK_MODIFIER(MAX_ASDEX_TRACK_POINTS)), 3))){
		// Update last track point to utc, but not for UNKN's
		if (strcmp(air->FltNum, "UNKN") && air->tcount && air->TrackPtr){
			D_CONTROL("TRACK_TIME_MOD", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Adjusting UTC time for ASDEX aircraft track[%d] from %d to %d for fltnum=%s.\n",
				cdwThreadId, air->tcount - 1, air->TrackPtr[air->tcount - 1].utc, record->eventtime, air->FltNum));
			air->TrackPtr[air->tcount - 1].utc = record->eventtime;
		}
	}
	// uncomment if/when asdex smoothing needs to be implemented
	// see comments on top of SmoothAsdexTracks()
	//SmoothAsdexTracks( id, air, AI );

	return(SUCCEED);
}



int UpdADSBAircraft(struct InstanceData* id, struct feedstruct *record)
{
	double x, y; /* screen position */
	int AI;
	AIR **airp;
	AIR *air;
	struct timeb tb;
	double velocity_meters_per_sec;
	char tmpstr[TMPBUF_SIZE];
	int pflag = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (record->rectype == 0){
		return(SUCCEED);
	}

	if (record->TrackID >= N_ADSB_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		return(SUCCEED);
	}
	airp = GetADSBAirP(id);

	AdjustADSBTrackId(id, record);
	if (!(air = airp[record->TrackID])) {
		// New aircraft track
		AI = record->TrackID;
		air = GetAir(airp, AI); // creates the new struct for tracking
		air->trackid = record->TrackID;
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
				cdwThreadId, record->FltNum, record->TrackID, AI);
		}
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI))
			if (!strlen(air->FltNum)){
				strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
				if (!air->icao24 && record->icao24)
					air->icao24 = record->icao24;
				CkNewADSBOverlap(id, air);
			}
	} else {
		// track already exists		
		AI = record->TrackID;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
		if (!strlen(air->FltNum)){
			strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		}
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		CkNewADSBOverlap(id, air);
	}

	if (IsBARRFlight(id, record->FltNum)){
		// flight is in BARR list
		if (!id->m_bDHSPerm){
			if (id->m_nDelaySecs < 1800){
				// we are allowed to show ASDEX tails according to TG, since users have MOA to see asdex/adsb
				//air->IsBARR = TRUE;
				//D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) aircraft fltnum=%s marked as blocked from BARR.\n",
				//	cdwThreadId, record->FltNum) );
			} else {
				// flight is in replay mode so show it
			}
		} else {
			// DHS allowed to see flights
		}
	}

	air->icao24 = record->icao24;

	strncpy_s(air->src_radar, 6, record->src_radar, _TRUNCATE);
	if (strlen(record->actype)){
		if (!HasPrintStr(record->actype)){
			// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
		} else {
			strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
		}
	}
	if (strlen(record->FltNum))
		strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);

	if (strlen(record->tail))
		strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);

	if (!id->m_tPlotTime){
		id->m_tPlotTime = record->eventtime;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Setting initial plottime to %d\n", cdwThreadId, id->m_tPlotTime);
		ftime(&tb);
		id->m_tClientsTime = tb.time;
		if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

		id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
		id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
		SetPassurDelaytime(id);
		MGLGridText(id, statusgrid, 24, 0, "plottime");
		VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
		MGLGridText(id, statusgrid, 24, 1, tmpstr);
	} else if ( id->m_nDelaySecs == 0 ){
		/* we are in live mode so make sure we keep clock up to date */
		if (id->m_tPlotTime < record->eventtime){

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, record->eventtime);

			id->m_tPlotTime = record->eventtime;
			ftime(&tb);
			id->m_tClientsTime = tb.time;

			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

			id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
			id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
			SetPassurDelaytime(id);
			MGLGridText(id, statusgrid, 24, 0, "plottime");
			VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
			MGLGridText(id, statusgrid, 24, 1, tmpstr);
		}
	}

	if (record->eventtime < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, record->eventtime);
		return(FAIL);
	}

	CalcLatLon(id, record->feedx, record->feedy, &x, &y, 0);

	air->CurX = (GLfloat)x;
	air->CurY = (GLfloat)y;
	air->utc = (int)record->eventtime;
	air->beacon = record->beacon;
	air->altitude = record->altitude;

	D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, TIME:%d:%d\n",
		cdwThreadId, record->FltNum, record->TrackID, y, x, record->eventtime, air->utc));

	/* 0.00054 NM = 1 meter */
	if (record->speed){
		air->speed = record->speed;
	} else {
		velocity_meters_per_sec = (double)sqrt((double)(record->velocity_x * record->velocity_x) +
			(record->velocity_y * record->velocity_y));
		// calculate in knots (Nautical miles per hour)
		if (velocity_meters_per_sec > 0.0){
			air->speed = (int)rint(velocity_meters_per_sec * 3600.0 * 0.00054);
		}
	}

	AddTrail(id, air, AI, record, FALSE, MAX(MIN(ADSB_TRACK_MODIFIER(id->m_sCurLayout.m_dAdsbTrailCount), ADSB_TRACK_MODIFIER(MAX_ADSB_TRACK_POINTS)), 3));
	// uncomment if/when asdex smoothing needs to be implemented
	// see comments on top of SmoothAsdexTracks()
	//SmoothAsdexTracks( id, air, AI );

	return(SUCCEED);
}

int UpdAirAsiaAircraft(struct InstanceData* id, struct feedstruct *record)
{
	double x = 0.0, y = 0.0; /* screen position */
	int AI;
	AIR **airp;
	AIR *air;
	struct timeb tb;
	//char tmpstr[ TMPBUF_SIZE ];
	int pflag = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (record->rectype == 0){
		return(SUCCEED);
	}

	if (record->TrackID >= N_AIRASIA_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		return(SUCCEED);
	}
	airp = GetAirAsiaAirP(id);

	//AdjustADSBTrackId(id, record);
	if (!(air = airp[record->TrackID])) {
		// New aircraft track
		AI = record->TrackID;
		air = GetAir(airp, AI); // creates the new struct for tracking
		air->trackid = record->TrackID;
		air->FltRouteOrig = _strdup("N/A");
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
				cdwThreadId, record->FltNum, record->TrackID, AI);
		}
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI))
		
	} else {
		// track already exists		
		AI = record->TrackID;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
	}

	if(strlen(record->FltNum))
		strncpy_s( air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE );

	if(strlen(record->tail))
		strncpy_s( air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE );

	// Record Type 70 is Flight Plan
	if( 70 == record->rectype )
	{
		if(record->waypoints && strlen(record->waypoints)){
			if(air->FltRouteWaypoints)
				free(air->FltRouteWaypoints);
			air->FltRouteWaypoints = _strdup(record->waypoints);
			free(record->waypoints);
			record->waypoints = NULL;
		}
		if(strlen(record->route)){
			if(air->FltRoute)
				free(air->FltRoute);
			air->FltRoute = _strdup(record->route);
		}
		if(strlen(record->origin)){
			if(air->FltRouteOrig)
				free(air->FltRouteOrig);
			air->FltRouteOrig = _strdup(record->origin);
			strncpy_s( air->Origin, ORIG_DES_SIZE, record->origin, _TRUNCATE );
		}
		if(strlen(record->destin))
			strncpy_s( air->Destin, ORIG_DES_SIZE, record->destin, _TRUNCATE );
	if (strlen(record->actype)){
		if (!HasPrintStr(record->actype)){
			// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
			} else {
			strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
		}
	}
		air->eta = record->eta;
		air->etd = record->etd;
	}
	// Record Type 71 is POS Record
	else if( 71 == record->rectype )
	{
		air->utc = (int) record->eventtime;
		CalcLatLon( id, record->feedx, record->feedy, &x, &y, 0 );

		air->CurX = (GLfloat) x;
		air->CurY = (GLfloat) y;
		air->altitude = record->altitude;
		air->fob = record->fob;

	if (!id->m_tPlotTime){
		id->m_tPlotTime = record->eventtime;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Setting initial plottime to %d\n", cdwThreadId, id->m_tPlotTime);
		ftime(&tb);
		id->m_tClientsTime = tb.time;
		if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

		id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
		id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
		SetPassurDelaytime(id);
			//MGLGridText(id, statusgrid, 24, 0, "plottime");
			//VOTimeFmt( tmpstr, id->m_tPlotTime, "%H:%M:%S" );
			//MGLGridText(id, statusgrid, 24, 1, tmpstr);
		} else if ( id->m_nDelaySecs == 0 ){
		/* we are in live mode so make sure we keep clock up to date */
		if (id->m_tPlotTime < record->eventtime){

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, record->eventtime);

			id->m_tPlotTime = record->eventtime;
			ftime(&tb);
			id->m_tClientsTime = tb.time;

			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

			id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
			id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
			SetPassurDelaytime(id);
				//MGLGridText(id, statusgrid, 24, 0, "plottime");
				//VOTimeFmt( tmpstr, id->m_tPlotTime, "%H:%M:%S" );
				//MGLGridText(id, statusgrid, 24, 1, tmpstr);
		}
	}
		AddTrail( id, air, AI, record , FALSE, MAX( MIN( AIRASIA_TRACK_MODIFIER(id->m_sCurLayout.m_nAirAsiaTrailCount), AIRASIA_TRACK_MODIFIER(MAX_AIRASIA_TRACK_POINTS)) , 3 ) );
	}

	D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, TIME:%d:%d\n",
		cdwThreadId, record->FltNum, record->TrackID, y, x, record->eventtime, air->utc));

	return(SUCCEED);
}

int UpdMLATAircraft(struct InstanceData* id, struct feedstruct *record)
{
	double x, y; /* screen position */
	int AI;
	AIR **airp;
	AIR *air, *air2;
	struct timeb tb;
	double velocity_meters_per_sec;
	char tmpstr[TMPBUF_SIZE];
	int pflag = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (record->rectype == 0){
		return(SUCCEED);
	}

	if (record->TrackID >= N_MLAT_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		return(SUCCEED);
	}
	airp = GetMLATAirP(id);

	AdjustMLATTrackId(id, record);
	if (!(air = airp[record->TrackID])) {
		// New aircraft track
		AI = record->TrackID;
		// Check gate airp first, to pull from gate out
		if (air = AirpFromGateFlights(id, record->FltNum)){
			airp[AI] = air;
		}else{
			air = GetAir(airp, AI); // creates the new struct for tracking
		}
		air->trackid = record->TrackID;
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
				cdwThreadId, record->FltNum, record->TrackID, AI);
		}
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI))
			if (!strlen(air->FltNum)){
				strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
			}
	} else {
		// track already exists
		if (air2 = AirpFromGateFlights(id, record->FltNum)){
			AIR** gate_air = GetGateAirP(id);
			strcpy_s(air->gate, GATE_SIZE, air2->gate);
			strcpy_s(air->Origin, ORIG_DES_SIZE, air2->Origin);
			strcpy_s(air->Destin, ORIG_DES_SIZE, air2->Destin);
			gate_air[air2->trackid] = air2;
			RemoveTrack(id, gate_air, air2->trackid, GATE, TRUE);
		}
		AI = record->TrackID;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
		if (!strlen(air->FltNum)){
			strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		}
		// If FltNum's differ, remove Old one, it will be rebuilt
		if (strcmp(air->FltNum, record->FltNum) && strlen(record->FltNum)) {
			RemoveIndex(id, id->m_pMLATIndexMap, air->FltNum, air->icao24, air->beacon, MLAT);
			strncpy_s(air->FltNum, FLTNUM_SIZE + 1, record->FltNum, FLTNUM_SIZE);
		}
	}
	air->icao24 = record->icao24;
	air->beacon = record->beacon;
	air->evnoddc = record->evnoddc;

	CkNewMLATOverlap(id, air, record);

	if (IsBARRFlight(id, record->FltNum)){
		// flight is in BARR list
		if (!id->m_bDHSPerm){
			if (id->m_nDelaySecs < 1800){
				// we are allowed to show ASDEX tails according to TG, since users have MOA to see asdex/adsb
				//air->IsBARR = TRUE;
				//D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) aircraft fltnum=%s marked as blocked from BARR.\n",
				//	cdwThreadId, record->FltNum) );
			} else {
				// flight is in replay mode so show it
			}
		} else {
			// DHS allowed to see flights
		}
	}

	strncpy_s(air->src_radar, 6, record->src_radar, _TRUNCATE);
	if (strlen(record->actype)){
		if (!HasPrintStr(record->actype)){
			// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
		} else {
			strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
		}
	}
	if (strlen(record->FltNum))
		strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);

	if (strlen(record->tail))
		strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);

	if (!id->m_tPlotTime){
		id->m_tPlotTime = record->eventtime;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Setting initial plottime to %d\n", cdwThreadId, id->m_tPlotTime);
		ftime(&tb);
		id->m_tClientsTime = tb.time;
		if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

		id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
		id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
		SetPassurDelaytime(id);
		MGLGridText(id, statusgrid, 24, 0, "plottime");
		VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
		MGLGridText(id, statusgrid, 24, 1, tmpstr);
	} else if ( id->m_nDelaySecs == 0 ){
		/* we are in live mode so make sure we keep clock up to date */
		if (id->m_tPlotTime < record->eventtime){

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, record->eventtime);

			id->m_tPlotTime = record->eventtime;
			ftime(&tb);
			id->m_tClientsTime = tb.time;

			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));

			id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
			id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
			SetPassurDelaytime(id);
			MGLGridText(id, statusgrid, 24, 0, "plottime");
			VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
			MGLGridText(id, statusgrid, 24, 1, tmpstr);
		}
	}

	if (record->eventtime < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, record->eventtime);
		return(FAIL);
	}

	air->altitude = record->altitude;

	// Handle RecType 60 where lat and long are null
	if (!(0 == record->feedx && 0 == record->feedy)){
		CalcLatLon(id, record->feedx, record->feedy, &x, &y, 0);

		air->CurX = (GLfloat)x;
		air->CurY = (GLfloat)y;
		air->utc = (int)record->eventtime;
		D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, TIME:%d:%d\n",
			cdwThreadId, record->FltNum, record->TrackID, y, x, record->eventtime, air->utc));

		AddTrail(id, air, AI, record, FALSE, MAX(MIN(MLAT_TRACK_MODIFIER(id->m_sCurLayout.m_dMlatTrailCount), MLAT_TRACK_MODIFIER(MAX_MLAT_TRACK_POINTS)), 3));
	}else{
		D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, TIME:%d:%d\n",
			cdwThreadId, record->FltNum, record->TrackID, record->eventtime, air->utc));
	}

	/* 0.00054 NM = 1 meter */
	if (record->speed){
		air->speed = record->speed;
	} else {
		velocity_meters_per_sec = (double)sqrt((double)(record->velocity_x * record->velocity_x) +
			(record->velocity_y * record->velocity_y));
		// calculate in knots (Nautical miles per hour)
		if (velocity_meters_per_sec > 0.0){
			air->speed = (int)rint(velocity_meters_per_sec * 3600.0 * 0.00054);
		}
	}

	// uncomment if/when asdex smoothing needs to be implemented
	// see comments on top of SmoothAsdexTracks()
	//SmoothAsdexTracks( id, air, AI );

	return(SUCCEED);
}

int SimilarFlightNum(const char* f1, const char* f2)
{
	int n1 = 0;
	int n2 = 0;
	const char* p1 = f1;
	const char* p2 = f2;
	int s = 0;
	// Check Individual start alphbetical characters
	while (p1 && p2 && *p1 == *p2){
		p1++;
		p2++;
		s = 1;
	}

	// Check digits
	if (s){
		s = 0;
		p1 = f1;
		p2 = f2;
		// Move to numerics
		while (p1 && !isdigit(*p1)) p1++;
		while (p2 && !isdigit(*p2)) p2++;
		n1 = atoi(p1);
		n2 = atoi(p2);
		if (n1 == n2)
			s = 1;
	}
	return s;

}

int UpdNoiseAircraft(struct InstanceData* id, struct feedstruct *record)
{
	double x = 0, y = 0; /* screen position */
	int AI;
	AIR **airp;
	AIR *air;
	//struct timeb tb;
	//double velocity_meters_per_sec;
	//char tmpstr[ TMPBUF_SIZE ];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (record->rectype == 0){
		return(SUCCEED);
	}

	if (record->TrackID >= N_NOISE_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		return(SUCCEED);
	}
	airp = GetNoiseAirP(id);

	//AdjustADSBTrackId(id, record);
	if (!(air = airp[record->TrackID])) {
		// New aircraft track
		AI = record->TrackID;
		air = GetAir(airp, AI); // creates the new struct for tracking
		air->trackid = record->TrackID;
		if (IS_D_CONTROL(__FUNCTION__)){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
				cdwThreadId, record->FltNum, record->TrackID, AI);
		}
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI));
	} else {
		// track already exists		
		AI = record->TrackID;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
	}

	if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5){
		if (record->feedx && record->feedy){
			CalcLatLon(id, record->feedx, record->feedy, &x, &y, 0);
			air->CurX = (GLfloat)x;
			air->CurY = (GLfloat)y;
		}
		if (record->altitude)
			air->altitude = record->altitude;

	} else if ( record->rectype == 2 || record->rectype == 6 || record->rectype == 7 ){
		if (!strlen(air->FltNum) && strlen(record->FltNum))
			strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
		else if (strlen(air->FltNum) && strlen(record->FltNum) && strcmp(air->FltNum, record->FltNum)){
			if (!strcmp(air->FltNum, ".") && strcmp(record->FltNum, "."))
				strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
			else if (SimilarFlightNum(air->FltNum, record->FltNum)){
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New Record flight number <%s> does not exactly match track id's <%d> flight number <%s>, using record.\n", cdwThreadId, record->FltNum, AI, air->FltNum);
			}
			else{
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New Record flight number <%s> does not match track id's <%d> flight number <%s>, ignoring record.\n", cdwThreadId, record->FltNum, AI, air->FltNum);
				return (FAIL);
			}
		}
		if (!strlen(air->Origin) && strlen(record->origin))
			strncpy_s(air->Origin, ORIG_DES_SIZE + 1, record->origin, _TRUNCATE);
		if (!strlen(air->Destin) && strlen(record->destin))
			strncpy_s(air->Destin, ORIG_DES_SIZE + 1, record->destin, _TRUNCATE);
		if (!strlen(air->actype) && strlen(record->actype)){
			strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
		}
	} else if ( record->rectype == 3 ){
		/* turn off tracks */
		if (AI >= 0){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track(%d) for flight(%s), Reason: Record Type 3 received.\n", cdwThreadId, AI, air->FltNum);
			RemoveTrack(id, airp, AI, NOISE, TRUE);
		}
		return(SUCCEED);
	}


	if (record->eventtime < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, record->eventtime);
		return(FAIL);
	}

	air->utc = (int)record->eventtime;
	if (!air->beacon && record->beacon) air->beacon = record->beacon;
	if (!air->icao24 && record->icao24)
		air->icao24 = record->icao24;
	if (!strlen(air->tail) && strlen(record->tail))
		strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);

	D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHT:%s, TRACK:%d, LAT:%f, LON:%f, TIME:%d:%d\n",
		cdwThreadId, record->FltNum, record->TrackID, y, x, record->eventtime, air->utc));

	if (record->rectype == 1 || record->rectype == 4 || record->rectype == 5)
		AddNoiseTrail(id, air, AI, record, MAX(MIN(NOISE_TRACK_MODIFIER(id->m_sCurLayout.m_dNoiseTrailCount), NOISE_TRACK_MODIFIER(MAX_NOISE_TRACK_POINTS)), 3));

	return(SUCCEED);
}

int SaveASDModeS(struct InstanceData* id, struct feedstruct *record, AIR **airp, VO *ASDSearchVO)
{
	AIR *air;
	int i;
	struct row_index *row_index;

	// match this mode s data to an existing flight in air struct, if possible
	// for ASD flights we must match up flights via flightid
	TIME_TRACE_DBG("START - SaveASDModeS");
	if (ASDSearchVO && strlen(record->FltNum)){
		if ((row_index = (struct row_index *)
			vo_search(ASDSearchVO, "FltNum", record->FltNum, NULL)))
		{
			i = VV(ASDSearchVO, row_index->rownum, "Index", int);
			if (IS_D_CONTROL("ASD_DBG_SEARCH_CMP")) {
				//@@@ MCT DEBUG Comparison to using GetIndex instead of SearchVO
				int i2 = GetIndex(id, id->m_pASDIndexMap, record->FltNum, record->icao24, record->beacon, ASD);
				if (i2 != i) {
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Index mis-match for %s, ASDSearchVO=%d, GetIndex=%d\n", GetCurrentThreadId(), record->FltNum, i, i2);
					if (air = airp[i])
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDSearchVO[%d]=%s\n", GetCurrentThreadId(), i, air->FltNum);
					if (i2 > -1) {
						if (air = airp[i2])
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GetIndex[%d]=%s\n", GetCurrentThreadId(), i2, air->FltNum);
					}
				}
			}
			air = airp[i];
			if (air) {
				// for asd assume flight number match is valid
				air->icao24 = record->icao24;
				strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);
				air->beacon = record->beacon; // no beacon in asd feed, so fill it
			}
			// for asd assume flight number match is valid
			air->icao24 = record->icao24;
			strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);
			air->beacon = record->beacon; // no beacon in asd feed, so fill it
		}
	}
	TIME_TRACE_DBG("END - SaveASDModeS");
	return(FALSE);
}



int SaveModeS(struct InstanceData *id, struct feedstruct *record)
{
	AIR *air;
	AIR** airp;
	int i;
	int result = FALSE;

	// match this mode s data to an existing flight in air struct, if possible
	// if the beacon exists, use that to find the record in the airp structure
	// if icao24 exits in airp, that must match also. Fill it if empty

	if (record->beacon == 01200){ // octal 1200, decimal 640, leading 'O', not zero
		// ignore 1200 beacon codes
		return(result);
	}

	TIME_TRACE_DBG("START - SaveModeS");
	i = GetIndex(id, id->m_pPassurIndexMap, record->FltNum, record->icao24, record->beacon, PASSUR);
	if ( i > -1 ){
		airp = GetAirP(id, 0);
		air = airp[i];
		if (air) {
			if (air->beacon == record->beacon) {
				if (strcmp(record->airport, id->m_strPassurArpts[0])) {
					// not record for currently displayed passur
					// do not use data from another passur unless we don't have any other data yet
					// found possible match, check for icao24
					if (!air->icao24) {
						// assume match, fill records
						air->icao24 = record->icao24;
					}
					if (air->icao24 == record->icao24) {
						// found match, update records
						// if this is not the passur being displayed, then ignore, since further away passurs
						//   often have different results

						if (!strlen(air->tail)) {
							strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);
						} 
					}
				} else { // data if from currently active passur, always update with latest
					if (strcmp(air->FltNum, record->FltNum)) {
						// flight id does NOT match
						//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tail flightid mis match air->Fltnum=%s record->FltNum=%s\n", GetCurrentThreadId(), air->FltNum, record->FltNum);
					}
					air->icao24 = record->icao24;
					strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);
					result = TRUE;
				}
			}
		}
	}
	TIME_TRACE_DBG("END - SaveModeS");
	return(result);
}

int MergeModeSTails(struct InstanceData *id, struct feedstruct *record, int type)
{
	AIR *air = NULL;
	AIR	**airp = NULL;
	int i = -1;
	int result = FALSE;

	// match this mode s data to an existing flight in air struct, if possible
	// if the beacon exists, use that to find the record in the airp structure
	// if icao24 exits in airp, that must match also. Fill it if empty

	if (record->beacon == 01200){ // octal 1200, decimal 640, leading 'O', not zero
		// ignore 1200 beacon codes
		return(result);
	}

	// Ignore those not from our airport
	if (strcmp(id->m_strPassurArpts[0], record->airport))
	{
		return(result);
	}

	TIME_TRACE_DBG("START - MergeModeSTails");
	
	if (MLAT == type) {
		i = GetIndex(id, id->m_pMLATIndexMap, record->FltNum, record->icao24, record->beacon, MLAT);
		airp = GetMLATAirP(id);
	} else if (ASDEX == type) {
		i = GetIndex(id, id->m_pASDEXIndexMap, record->FltNum, record->icao24, record->beacon, ASDEX);
		airp = GetASDEXAirP(id);
	}

	if(i  > -1){
		air = airp[i];
		if (air) {
			if (air->beacon == record->beacon ||
				air->icao24 == record->icao24 ||
				!strcmp(air->FltNum, record->FltNum)) {

				if (!strlen(air->tail)) {
					strncpy_s(air->tail, N_TAIL_SIZE, record->tail, _TRUNCATE);
					result = TRUE;
				} 
			}
		}
	}
	TIME_TRACE_DBG("END - MergeModeSTails");
	return( result);
}

// Moves the track to an open slot at the end of the AIRP array
void QuickMove(struct InstanceData* id, AIR** airp, AIR* air, int AI, const char* reason)
{
	// Move to last available trackid position for timeout or until we get our next/new trackid position
	const DWORD cdwThreadId = GetCurrentThreadId();
	int oAI = AI;
	RemoveIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, PASSUR);
	airp[AI] = NULL;
	AI = N_PASSUR_TRACK_ID;
	while (airp[--AI]);
	air->trackid = AI;
	airp[AI] = air;
	AddIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, air->trackid, PASSUR);
	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Moving PASSUR track<%s[%d]> to [%d], Reason:%s\n", cdwThreadId, air->FltNum, oAI, air->trackid, reason));
}

// Merges data from one air struct to another due to track id changes
void QuickMerge(struct InstanceData* id, AIR* des, AIR* src)
{
	if (des && src){
		// Merge in old Track for Passur
		des->TrackPtr = src->TrackPtr;
		des->tcount = src->tcount;
		des->TrackStart = src->TrackStart;
		des->IsTracked = src->IsTracked;
		des->FltRoute = src->FltRoute;
		des->FltRouteOrig = src->FltRouteOrig;
		des->FltRouteWaypoints = src->FltRouteWaypoints;
		des->FFTInfoPtr = src->FFTInfoPtr;

		// Clear old pointers since it has shifted to new air
		src->TrackPtr = NULL;
		src->FltRoute = NULL;
		src->FltRouteOrig = NULL;
		src->FltRouteWaypoints = NULL;
		src->FFTInfoPtr = NULL;
	}
}

int UpdAircraft(struct InstanceData* id, struct feedstruct *record, int passurindex)
{
	double x, y; /* screen position */
	int AI;
	int nIndex = -1;
	AIR **airp;
	AIR *air;
	struct timeb tb;
	double velocity_meters_per_sec;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int first_time = TRUE;
	static int passur_smoothing = FALSE;

	if (record->rectype == 0){
		return(SUCCEED);
	}
	//@@@ mct DEBUG, dump all rctype 3's
	/*if (record->rectype == 3){
		airp = GetAirP(id, passurindex);
		if (air = airp[record->TrackID]){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Received RCTYPE 3 for TrackID(%d) FlightId(%s) Beacon(%d)\n", cdwThreadId, air->trackid, air->FltNum, air->beacon);
		} else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Received RCTYPE 3 for TrackID(%d) Beacon(%d)\n", cdwThreadId, record->TrackID, record->beacon);
		}
		return(SUCCEED);
	}*/
	if (record->TrackID >= N_PASSUR_TRACK_ID || record->TrackID < 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID code out of range=%d\n", cdwThreadId, record->TrackID);
		//MyStop();
		return(SUCCEED);
	}
	
	if (record->rectype == 20){
		// mode s tail information
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating MODES aircraft fltnum=%s AirIndex[%d]\n",
			cdwThreadId, record->FltNum, record->TrackID));
		return(SaveModeS(id, record));
	}
	
	airp = GetAirP(id, passurindex);
	if (!(air = airp[record->TrackID])) {
		// New aircraft track
		AI = record->TrackID;
		air = GetAir(airp, AI); // creates the new struct for tracking
		air->trackid = record->TrackID;
		strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new aircraft fltnum=%s AirIndex[%d] = %d\n",
			cdwThreadId, record->FltNum, record->TrackID, AI));
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		nIndex = GetIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, PASSUR);
		if (-1 != nIndex && air->trackid != nIndex)
		{
			AIR *air2 = airp[nIndex];
			if (air2)
			{
				QuickMerge(id, air, air2);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: Track Id Changed to %d \n", cdwThreadId, air2->FltNum, air2->trackid, air->trackid);
				RemoveTrack(id, airp, nIndex, PASSUR, TRUE);
				AddIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, AI, PASSUR);
			}
		}
		CkNewPassurOverlap(id, air);
	} else {
		// track already exists
		AI = record->TrackID;
		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updating aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
			cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));
		nIndex = GetIndex(id, id->m_pPassurIndexMap, record->FltNum, record->icao24, record->beacon, PASSUR);
		if (-1 != nIndex && air->trackid != nIndex)
		{
			AIR *air2 = airp[nIndex];
			if (air2)
			{
				// Check if the current air and new record are the same flight using flight id, icao24 or beacon 
				if ( (strlen(air->FltNum) && strlen(record->FltNum) && strcmp(air->FltNum, record->FltNum)) ||
					 (air->icao24 && record->icao24 && air->icao24 != record->icao24) ||
					 (air->beacon && record->beacon && air->beacon != record->beacon) ){
					// These are different Flights, may have missed RCTYPE 3 for previous track id
					// Move old track (different flight to end if airp), like rctype 3 occurred
					QuickMove(id, airp, air, AI, "Flight Id In use");

					// Move air2 from old Index to new Index
					airp[nIndex] = NULL;
					RemoveIndex(id, id->m_pPassurIndexMap, air2->FltNum, air2->icao24, air2->beacon, PASSUR);

					air2->trackid = AI;
					airp[AI] = air = air2;
					AddIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, AI, PASSUR);
				} else {
					// Same flight, different trackid, merge data into new air
					if (!strlen(air->FltNum) && strlen(record->FltNum)){
						strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
					}
					if (!air->icao24 && record->icao24)
						air->icao24 = record->icao24;
					if (!air->beacon && record->beacon)
						air->beacon = record->beacon;
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Merging track<%s[%d]>, Reason: Track Id Changed to %d \n", cdwThreadId, air2->FltNum, air2->trackid, air->trackid);
					QuickMerge(id, air, air2);
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: Track Id Changed to %d \n", cdwThreadId, air2->FltNum, air2->trackid, air->trackid);
					RemoveTrack(id, airp, nIndex, PASSUR, TRUE);
					AddIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, AI, PASSUR);
				}
			}
		}
		if (!strlen(air->FltNum) && strlen(record->FltNum)){
				strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
		}
		if (!air->icao24 && record->icao24)
			air->icao24 = record->icao24;
		CkNewPassurOverlap(id, air);
	}

	if (IsBARRFlight(id, record->FltNum)){
		// flight is in BARR list
		if (!id->m_bDHSPerm){
			if (id->m_nDelaySecs < 1800){
				air->IsBARR = TRUE;
				D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) aircraft fltnum=%s marked as blocked from BARR.\n",
					cdwThreadId, record->FltNum));
			} else {
				// flight is in replay mode so show it
			}
		} else {
			// DHS allowed to see flights
		}
	}

	strncpy_s(air->src_radar, 6, record->src_radar, _TRUNCATE);
	if (!strlen(air->FltNum) && strlen(record->FltNum)){
		strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
	}

	if (record->rectype == 2){
		if (strlen(record->FltNum)){
			strncpy_s(air->FltNum, FLTNUM_SIZE, record->FltNum, _TRUNCATE);
		}
		strncpy_s(air->Origin, ORIG_DES_SIZE, record->origin, _TRUNCATE);
		strncpy_s(air->Destin, ORIG_DES_SIZE, record->destin, _TRUNCATE);

		if (record->TrackID != air->trackid){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad trackid for fltnum=%s record->trackid=%d airvo trackid=%d\n",
				cdwThreadId, record->FltNum, record->TrackID, air->trackid);
			//MyStop();
		}
		air->trackid = record->TrackID;

		if (strlen(record->actype)){
			if (!HasPrintStr(record->actype)){
				// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Blank actype found for %s\n", cdwThreadId, record->FltNum);
			} else {
				strncpy_s(air->actype, ACTYPE_SIZE, record->actype, _TRUNCATE);
			}
		}

		return(SUCCEED);
	} else if ( record->rectype == 3 ){
		if (air){
			// Move to last available trackid position for timeout or until we get our next/new trackid position
			QuickMove(id, airp, air, AI, "Record Type 3 Event");			
		}
		return(SUCCEED);
	} else if ( record->rectype != 1 ){
		return(SUCCEED);
	}
	/* type1 records only */

	if (!id->m_tPlotTime){
		id->m_tPlotTime = record->eventtime;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Setting intial plottime to %d\n", cdwThreadId, id->m_tPlotTime);
		ftime(&tb);
		id->m_tClientsTime = tb.time;
		if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));
		id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
		id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
		SetPassurDelaytime(id);
		MGLGridText(id, statusgrid, 24, 0, "plottime");
		VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
		MGLGridText(id, statusgrid, 24, 1, tmpstr);
	} else if ( id->m_nDelaySecs == 0 ){
		/* we are in live mode so make sure we keep clock up to date */
		if (id->m_tPlotTime < record->eventtime){

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, record->eventtime);

			id->m_tPlotTime = record->eventtime;
			ftime(&tb);
			id->m_tClientsTime = tb.time;
			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));
			id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
			id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
			SetPassurDelaytime(id);
			MGLGridText(id, statusgrid, 24, 0, "plottime");
			VOTimeFmt(tmpstr, id->m_tPlotTime, "%H:%M:%S");
			MGLGridText(id, statusgrid, 24, 1, tmpstr);
		}
	}

	if (record->eventtime < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, record->eventtime);
		return(FAIL);
	}
	//if ( record->beacon >= 01270 && record->beacon < 01277 ){
	//  vo_log_info(id->m_pfVoLogFile,__FUNCTION__, "(0x%X) beacon code ='%04o'\n", cdwThreadId, record->beacon );
	//}	
	CalcLatLon(id, record->feedx, record->feedy, &x, &y, passurindex);

	air->CurX = (GLfloat)x;
	air->CurY = (GLfloat)y;
	air->utc = (int)record->eventtime;
	air->beacon = record->beacon;
	air->altitude = record->altitude;

	/* 0.00054 NM = 1 meter */

	velocity_meters_per_sec = (double)sqrt((double)(record->velocity_x * record->velocity_x) +
		(record->velocity_y * record->velocity_y));
	// calculate in knots (Nautical miles per hour)
	if (velocity_meters_per_sec > 0.0){
		air->speed = (int)rint(velocity_meters_per_sec * 3600.0 * 0.00054);
	}

	AddTrail(id, air, AI, record, FALSE, MAX(MIN(PASSUR_TRACK_MODIFIER(id->m_sCurLayout.m_nPassurTrailCount), PASSUR_TRACK_MODIFIER(MAX_PASSUR_TRACK_POINTS)), 5));
	
	if (!id->m_bIsPassurTais)
		SmoothPassurTracks( id, air, AI );

	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Updated aircraft fltnum=%s AirIndex[%d] = %d, Tracked=%d\n",
		cdwThreadId, air->FltNum, record->TrackID, AI, air->IsTracked));

	return(SUCCEED);
}


PTRACK *NewTrackArr(struct InstanceData* id, int max_tracks, AIR *air)
{
	PTRACK *trackarr = NULL;
	int psize;

	psize = sizeof(struct trackstruct);
	if (!(trackarr = (PTRACK *)calloc(max_tracks, psize)) || errno == ENOMEM){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not calloc trackarr\n", GetCurrentThreadId());
		return(NULL);
	}

	air->TrackPtr = trackarr;
	air->tcount = 0;
	air->max_tracks = max_tracks;

	return(trackarr);
}



char* FlightToJSON(struct InstanceData* id, AIR *air)
{
	int trk;
	double x2, y2;
	int endutc;
	PTRACK *trackarr;
	int tcount;
	char timestr[256];
	struct json_object* jobj = NULL;
	struct json_object* jarr = NULL;
	char* result = NULL;
	if (air){
		jobj = json_object_new_object();
		json_object_object_add(jobj, "TrackID", json_object_new_int(air->trackid));
		json_object_object_add(jobj, "Flight", json_object_new_string(air->FltNum));
		json_object_object_add(jobj, "Beacon", json_object_new_int(air->beacon));
		json_object_object_add(jobj, "Alt", json_object_new_int(air->altitude));
		json_object_object_add(jobj, "Orig", json_object_new_string(air->Origin));
		json_object_object_add(jobj, "Dest", json_object_new_string(air->Destin));
		json_object_object_add(jobj, "CurX", json_object_new_double(air->CurX));
		json_object_object_add(jobj, "CurY", json_object_new_double(air->CurY));

		jarr = json_object_new_array();
		if ((trackarr = air->TrackPtr)){
			tcount = air->tcount;
			for (trk = 0; trk < tcount; trk++){
				struct json_object* jtrk = json_object_new_object();
				endutc = trackarr[trk].utc;
				x2 = trackarr[trk].x;
				y2 = trackarr[trk].y;
				VOTimeFmt(timestr, endutc, "%Y-%m-%d %H:%M:%S");
				json_object_object_add(jtrk, "n", json_object_new_int(trk));
				json_object_object_add(jtrk, "lat", json_object_new_double(y2));
				json_object_object_add(jtrk, "lng", json_object_new_double(x2));
				json_object_object_add(jtrk, "utc", json_object_new_int(endutc));
				json_object_object_add(jtrk, "time", json_object_new_string(timestr));
				json_object_array_add(jarr, jtrk);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Debug flight %s, trk[%d], utc=%d time=%s, x=%g y=%g\n",
					GetCurrentThreadId(), air->FltNum, trk, endutc, timestr, x2, y2);
			}
		}
		json_object_object_add(jobj, "TRACKS", jarr);
		result = _strdup(json_object_to_json_string(jobj));
		json_object_put(jobj);
	}
	return result;
}


void PrintTracks(struct InstanceData* id, AIR *air, int nFeedType)
{
	int trk;
	double x2, y2;
	int endutc;
	PTRACK *trackarr;
	int tcount;
	char timestr[256];


	if ((trackarr = air->TrackPtr)){
		tcount = air->tcount;
		for (trk = 0; trk < tcount; trk++){
			endutc = trackarr[trk].utc;
			x2 = trackarr[trk].x;
			y2 = trackarr[trk].y;
			VOTimeFmt(timestr, endutc, "%Y-%m-%d %H:%M:%S");
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s Selected flight %s, trk[%d], utc=%d time=%s, y=%lf x=%lf\n",
				GetCurrentThreadId(), g_arFeedTypes[nFeedType], air->FltNum, trk, endutc, timestr, y2, x2);
		}
	}

}



double CkSpeed(double x1, double y1, time_t utc1, double x2, double y2, time_t utc2)
{
	double dis, tmprads, speed;

	tmprads = acos(sin(RADS(y2)) * sin(RADS(y1)) + cos(RADS(y2)) * cos(RADS(y1)) * cos(RADS(x1 - x2)));

	dis = 60.0 * DEGS(tmprads); // NM

	speed = dis * 3600 / (utc2 - utc1); // rough nmph

	return(speed);

}


double CkDis(double x1, double y1, double x2, double y2)
{
	double dis, tmprads;

	tmprads = acos(sin(RADS(y2)) * sin(RADS(y1)) + cos(RADS(y2)) * cos(RADS(y1)) * cos(RADS(x1 - x2)));

	dis = 60.0 * DEGS(tmprads); // NM

	return(dis);

}



int AddTrail(struct InstanceData* id, AIR *air, int AI, struct feedstruct *record, int isASD, int max_tracks)
{
	PTRACK *trackarr, *oldtrackarr;
	int tcount;
	GLfloat xlast, ylast;
	int i, utc, psize, oldtracksize, msize;
	char tmpstr[TMPBUF_SIZE];
	double speed;
	const DWORD cdwThreadId = GetCurrentThreadId();

	time_t utclast;
	max_tracks = 500;
	/* add the latest point to the VO of all points for this aircraft */
	D_CONTROL("AddTrail", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TrackID='%d', flightid='%s'\n", cdwThreadId, AI, air->FltNum));
	if (!(trackarr = air->TrackPtr)){
		/* first point */

		if (!(trackarr = NewTrackArr(id, max_tracks, air))){
			return(FALSE);
		}
		if (isASD){
			ASDtrackcount++;
		}
	}
	tcount = air->tcount;

	if (max_tracks > air->max_tracks){
		// user changed number of tracks to larger amount
		oldtrackarr = trackarr;
		if (!(trackarr = NewTrackArr(id, max_tracks, air))){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not get trackarr\n", cdwThreadId);
			return(FALSE);
		}
		// copy old values
		air->tcount = tcount;
		memmove(trackarr, oldtrackarr, tcount * sizeof(PTRACK));
		free(oldtrackarr);
	} else if ( max_tracks < air->max_tracks ){
		// user changed number of tracks to smaller amount

		oldtrackarr = trackarr;
		oldtracksize = air->max_tracks;

		if (!(trackarr = NewTrackArr(id, max_tracks, air))){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not get trackarr\n", cdwThreadId);
			return(FALSE);
		}
		// copy old tracks
		if (tcount <= max_tracks){
			air->tcount = tcount;
			psize = sizeof(PTRACK);
			memmove(trackarr, oldtrackarr, tcount * psize);
			D_CONTROL("AddTrail", PrintTracks(id, air, NONE));
		} else {
			// tcount > max_tracks,  so keep only last few tracks
			air->tcount = max_tracks;

			psize = sizeof(PTRACK);
			if ((msize = tcount - max_tracks - 1) < 0 || ((max_tracks + msize) > oldtracksize)){
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad array size\n", cdwThreadId);
				D_CONTROL("AddTrail", PrintTracks(id, air, NONE));
			} else {
				memmove(trackarr, &oldtrackarr[msize], max_tracks * psize);
				D_CONTROL("AddTrail", PrintTracks(id, air, NONE));
			}
			// tcount was altered, so reset it
			tcount = air->tcount;
		}
		free(oldtrackarr);
	}

	/* make sure the new point is different than previous,
	mainly for asd tracks */
	if (tcount){
		ylast = trackarr[tcount - 1].y;
		xlast = trackarr[tcount - 1].x;
		utclast = trackarr[tcount - 1].utc;
		trackarr[tcount - 1].altitude = air->altitude;
		if (tcount && ylast == air->CurY &&
			xlast == air->CurX){
			/* same as prev, do not add to trail */
			return(TRUE);
		}

		// until we find out why , get rid of bad points near MSP
		if (fabs(air->CurX - -95.0833) < 0.1 && fabs(air->CurY - 43.3333) < 0.1){
			return(TRUE);
		}
		// do a speed test to get rid of any ridiculous points that we get from ASD


		if (isASD && (speed = CkSpeed(xlast, ylast, utclast, air->CurX, air->CurY, air->utc)) > 5000.0 && (air->utc - utclast > 10)){
			// bad speed 
			// keep only latest point
			tcount = 1;
			trackarr[tcount - 1].x = air->CurX;
			trackarr[tcount - 1].y = air->CurY;
			trackarr[tcount - 1].utc = air->utc;
			trackarr[tcount - 1].altitude = air->altitude;
			air->tcount = tcount;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing bad trail for flight %s, speed=%g\n", cdwThreadId, air->FltNum, speed);
			return(TRUE);
		}


	}
	//if ( TrackVO->count && VV(TrackVO, TrackVO->count - 1, "utc", int ) > record->eventtime){
	// new time is older than previous, so ignore, must be from older hdr record
	// vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) new record older than previous, rectype=%d utc=%d prev=%d\n",
	// cdwThreadId, record->rectype, record->eventtime, VV(TrackVO, TrackVO->count - 1, "utc", int ));
	// }
	if (air->utc < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, air->utc);
		return(FALSE);
	}

	// until we find out why , get rid of bad points near MSP
	if (fabs(air->CurX - -95.0833) < 0.1 && fabs(air->CurY - 43.3333) < 0.1){
		return(TRUE);
	}
	/* make sure utc does not go back in time */
	//if ( !isASD ){
	utc = air->utc;
	for (i = 0; i < tcount; i++){
		if (utc < trackarr[i].utc){
			/* out of order track */
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) out of order utc=%d before %d, for flight %s from '%s'\n", cdwThreadId, utc ,
			//  VV(TrackVO, i, "utc", int ), VP(AirVO, AI, "FltNum", char) , VP(TrackVO, i, "src_radar", char ));
			//LogTracks( TrackVO );
			return(FALSE);
		}
		// also make sure point is not identical, this can happen when old points update with diff asdi message type
		if ( /*isASD &&*/ fabs(trackarr[i].x - air->CurX) < 0.0001 && fabs(trackarr[i].y - air->CurY) < 0.0001){
			// ignoring duplicate point
			return(FALSE);
		}
	}
	//}


	if (tcount < max_tracks){
		tcount++;
		air->tcount = tcount;
	} else if ( tcount == max_tracks ){
		// get rid of the first row
		memmove(trackarr, &trackarr[1], (tcount - 1) * sizeof(PTRACK));
	}


	if (tcount <= air->max_tracks){
		trackarr[tcount - 1].x = air->CurX;
		trackarr[tcount - 1].y = air->CurY;
		trackarr[tcount - 1].utc = air->utc;
		trackarr[tcount - 1].altitude = air->altitude;
		trackarr[tcount - 1].speed = air->speed;
		if (!isASD)
			D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Added Track:%s TrackID:%d Track[%d] [LAT:%f LNG:%f T:%d]\n",
			cdwThreadId, air->FltNum, AI, tcount - 1, air->CurY, air->CurX, air->utc));
	} else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad tcount > max_tracks\n", cdwThreadId);
	}

	GNPoints++;
	if (ShowStatusWin){
		MGLGridText(id, statusgrid, 10, 0, "gridpoints");
		sprintf_s(tmpstr, TMPBUF_SIZE, "%d", GNPoints);
		MGLGridText(id, statusgrid, 10, 1, tmpstr);
	}
	D_CONTROL("AddTrail", PrintTracks( id, air, NONE ));
	return(TRUE);
}

int AddNoiseTrail(struct InstanceData* id, AIR *air, int AI, struct feedstruct *record, int max_tracks)
{
	PTRACK *trackarr, *oldtrackarr;
	int tcount;
	GLfloat xlast, ylast;
	int i, utc, psize, oldtracksize, msize;
	//char tmpstr[ TMPBUF_SIZE ];
	//double speed;
	const DWORD cdwThreadId = GetCurrentThreadId();

	time_t utclast;

	/* add the latest point to the VO of all points for this aircraft */
	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flightid='%s'\n", cdwThreadId, air->FltNum));
	if (!(trackarr = air->TrackPtr)){
		/* first point */

		if (!(trackarr = NewTrackArr(id, max_tracks, air))){
			return(FALSE);
		}
	}
	tcount = air->tcount;

	if (max_tracks > air->max_tracks){
		// user changed number of tracks to larger amount
		oldtrackarr = trackarr;
		if (!(trackarr = NewTrackArr(id, max_tracks, air))){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not get trackarr\n", cdwThreadId);
			return(FALSE);
		}
		// copy old values
		air->tcount = tcount;
		memmove(trackarr, oldtrackarr, tcount * sizeof(PTRACK));
		free(oldtrackarr);
	} else if ( max_tracks < air->max_tracks ){
		// user changed number of tracks to smaller amount

		oldtrackarr = trackarr;
		oldtracksize = air->max_tracks;

		if (!(trackarr = NewTrackArr(id, max_tracks, air))){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not get trackarr\n", cdwThreadId);
			return(FALSE);
		}
		// copy old tracks
		if (tcount <= max_tracks){
			air->tcount = tcount;
			psize = sizeof(PTRACK);
			memmove(trackarr, oldtrackarr, tcount * psize);
			D_CONTROL(__FUNCTION__, PrintTracks(id, air, NOISE));
		} else {
			// tcount > max_tracks,  so keep only last few tracks
			air->tcount = max_tracks;

			psize = sizeof(PTRACK);
			if ((msize = tcount - max_tracks - 1) < 0 || ((max_tracks + msize) > oldtracksize)){
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad array size\n", cdwThreadId);
				D_CONTROL(__FUNCTION__, PrintTracks(id, air, NOISE));
			} else {
				memmove(trackarr, &oldtrackarr[msize], max_tracks * psize);
				D_CONTROL(__FUNCTION__, PrintTracks(id, air, NOISE));
			}
			// tcount was altered, so reset it
			tcount = air->tcount;
		}
		free(oldtrackarr);
	}

	/* make sure the new point is different than previous,
	mainly for asd tracks */
	if (tcount){
		ylast = trackarr[tcount - 1].y;
		xlast = trackarr[tcount - 1].x;
		utclast = trackarr[tcount - 1].utc;
		trackarr[tcount - 1].altitude = air->altitude;
		if (tcount && ylast == air->CurY &&
			xlast == air->CurX){
			/* same as prev, do not add to trail */
			return(SUCCEED);
		}
	}

	if (air->utc < 0){
		// bad data point
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad utc=%d\n", cdwThreadId, air->utc);
		return(FAIL);
	}

	// until we find out why , get rid of bad points near MSP
	//if ( fabs(air->CurX - -95.0833) < 0.1 && fabs(  air->CurY - 43.3333) < 0.1 ){
	//	return( SUCCEED );
	//}
	utc = air->utc;
	for (i = 0; i < tcount; i++){
		if (utc < trackarr[i].utc){
			/* out of order track */
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) out of order utc=%d before %d, for flight %s from '%s'\n", cdwThreadId, utc ,
			//  VV(TrackVO, i, "utc", int ), VP(AirVO, AI, "FltNum", char) , VP(TrackVO, i, "src_radar", char ));
			//LogTracks( TrackVO );
			return(FAIL);
		}
		// also make sure point is not identical, this can happen when old points update with diff asdi message type
		//if ( /*isASD &&*/ fabs( trackarr[i].x - air->CurX ) < 0.0001 && fabs( trackarr[i].y - air->CurY ) < 0.0001 ){
		//	// ignoring duplicate point
		//	return( FAIL );
		//}
	}
	//}


	if (tcount < max_tracks){
		tcount++;
		air->tcount = tcount;
	} else if ( tcount == max_tracks ){
		// get rid of the first row
		memmove(trackarr, &trackarr[1], (tcount - 1) * sizeof(PTRACK));
	}


	if (tcount <= air->max_tracks){
		trackarr[tcount - 1].x = air->CurX;
		trackarr[tcount - 1].y = air->CurY;
		trackarr[tcount - 1].utc = air->utc;
		trackarr[tcount - 1].altitude = air->altitude;
		trackarr[tcount - 1].speed = air->speed;
	} else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad tcount > max_tracks\n", cdwThreadId);
	}

	//GNPoints++;
	//if ( ShowStatusWin ){
	//	MGLGridText(id, statusgrid, 10, 0, "gridpoints");
	//	sprintf_s(tmpstr, TMPBUF_SIZE, "%d", GNPoints);
	//	MGLGridText(id, statusgrid, 10, 1, tmpstr);
	//}
	return(SUCCEED);
}



int CalcLatLon(struct InstanceData* id, int feedx, int feedy, double *xptr, double *yptr, int passurindex)
{

	/* 0.621371 miles per km, so 8.6 miles * 1/0.621371 * 1000 */
	/* from jfk apdata file lonlat=-73.75,40.666666 of center of passur
	coordinate system */
	int yoffset, xoffset;
	double rads, degree_long, xmiles, ymiles, newlat, newlng, deltalng,
		realdelta;

	yoffset = (int)id->m_dZeroY[passurindex] + feedy; /* offset in meters from origin at center of map */
	xoffset = (int)id->m_dZeroX[passurindex] + feedx;

	/* calulate lat lon of this point using simple equations for
	lat/lon */
	/* To convert radians into degrees you should multiply by 180/pi.
	To convert degrees into radians you should multiply by pi/180. */

	rads = id->m_dLatitudes[passurindex] * M_PI / 180.0;
	degree_long = 69.172 * cos(rads);

	/* convert offset in meters into miles */
	/* 1 meter = .00062 miles */
	xmiles = xoffset * 0.00062;
	ymiles = yoffset * 0.00062;

	/* convert into degrees */
	newlat = id->m_dLatitudes[passurindex] + (ymiles / 69.172);
	newlng = id->m_dLongitudes[passurindex] + (xmiles / degree_long);

	/* printf("newlat=%g newlng = %g\n", newlat, newlng ); */

	/* project coordinates using square projection method */

	if (projflag){
		deltalng = newlng - LngOrig;
		realdelta = deltalng * cos(newlat * M_PI / 180.0);
		newlng = LngOrig + realdelta;
	}

	*xptr = newlng;
	*yptr = newlat;
	return(SUCCEED);
}


int RemoveTrack(struct InstanceData* id, AIR **airp, int AI, int nFeedType, int reset_flag)
{
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track for %s[%d] \n", cdwThreadId, g_arFeedTypes[nFeedType], AI));

	// Check for Valid Indice Range
	if ((ADSB == nFeedType && AI >= N_ADSB_TRACK_ID) ||
		(ASDEX == nFeedType && AI >= N_ASDEX_TRACK_ID) ||
		(MLAT == nFeedType && AI >= N_MLAT_TRACK_ID) ||
		(PASSUR == nFeedType && AI >= N_PASSUR_TRACK_ID) ||
		(NOISE == nFeedType && AI >= N_NOISE_TRACK_ID) ||
		(GATE == nFeedType && AI >= N_GATE_TRACK_ID) ||
		(ASDI == nFeedType && AI >= N_ASDI_TRACK_ID)) {

		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad index = %d, skipping remove from feed %s\n", cdwThreadId, AI, g_arFeedTypes[nFeedType]);
		return(FAIL);
	}

	if ((air = airp[AI])){

		if (ADSB == nFeedType){
			ClearASDEXTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			ClearMLATTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			ClearPASSURTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			ClearASDTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			RemoveIndex(id, id->m_pADSBIndexMap, air->FltNum, air->icao24, air->beacon, ADSB);
		}else if( ASDEX == nFeedType ) {
			ClearMLATTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			ClearPASSURTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			ClearASDTracked(id, air->FltNum, air->icao24, 0, nFeedType);
			RemoveIndex(id, id->m_pASDEXIndexMap, air->FltNum, air->icao24, air->beacon, ASDEX);
		}else if( MLAT == nFeedType ) {
			ClearPASSURTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			ClearASDTracked(id, air->FltNum, air->icao24, 0, nFeedType);
			RemoveIndex(id, id->m_pMLATIndexMap, air->FltNum, air->icao24, air->beacon, MLAT);
		}else if( PASSUR == nFeedType ) {
			ClearASDTracked(id, air->FltNum, air->icao24, air->beacon, nFeedType);
			RemoveIndex(id, id->m_pPassurIndexMap, air->FltNum, air->icao24, air->beacon, PASSUR);
		}else if( ASDI == nFeedType ) {
			RemoveIndex(id, id->m_pASDIndexMap, air->FltNum, air->icao24, air->beacon, ASDI);
		}else if( NOISE == nFeedType || GATE == nFeedType){
			// DO NOTHING, Noise tracks are not prioritized
		}

		ClearAirFields(air);

		free(air);
		airp[AI] = NULL;
	}

	return(SUCCEED);
}


void PassurProcess(struct InstanceData* id, int passurindex)
{
	char *str, *passurstr;
	time_t starttime;
	char *endstr;
	int linelen, passurlen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) starting\n", cdwThreadId);

#ifdef SAVEDATA
	if ( SaveLocalData ){
		if ( PassurBufFlags[passurindex] != PASSUR_FILLED ){
			// buffer being filled
		} else {
			FusePassurs();  //signify which passurs should be used for each aircraft
			// index 0 is passur selected by user, DCA for DHS
			SavePassurData( Passurfilebufs[passurindex], PassurFileNBytes[passurindex],
				id->m_strPassurZipFilename[passurindex], passurindex );
		}
	}
#endif


	if (TryEnterCriticalSection(&id->m_csPassurSync)){
		if (!id->m_pPassurfilebufs[passurindex]){
			// buffer being filled
			LeaveCriticalSection(&id->m_csPassurSync);
			return;
		}

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) processing buffer for passurindex %d (0x%lX, %ld)\n",
			cdwThreadId, passurindex, id->m_pPassurfilebufs[passurindex], id->m_lPassurFileNBytes[passurindex]);

		starttime = 0;
		passurstr = id->m_pPassurfilebufs[passurindex];
		passurlen = id->m_lPassurFileNBytes[passurindex];
		id->m_pPassurfilebufs[passurindex] = NULL;
		id->m_lPassurFileNBytes[passurindex] = 0;
		LeaveCriticalSection(&id->m_csPassurSync);

		str = passurstr;
		for (;;){
			if (!(endstr = strchr(str, '\n'))){
				/* end of file */
				break;
			}
			linelen = endstr - str;
			if (linelen < LINE_BUFSIZE){
				strncpy_s(buf, LINE_BUFSIZE, str, linelen);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
				str += linelen + 1;
				continue;
			}
			str += linelen + 1; // skip over line and newline character
			if (str - passurstr >= passurlen){
				// at end of buffer
				break;
			}

			if (record = RdRecord(id, &record_local, buf)){
				if (!starttime){
					starttime = record->eventtime;
				}
				UpdAircraft(id, record, passurindex);
				record = NULL;
			}
		}
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Processed buffer for passurindex %d (0x%lX, %ld)\n", cdwThreadId, passurindex, passurstr, passurlen);
		free(passurstr);
	}
}

void LMGProcess( struct InstanceData* id )
{
	char *str, *lmgstr;
	time_t starttime;
	char *endstr;
	int linelen, lmglen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if(TryEnterCriticalSection(&id->m_csLMGSync)){
		if(!id->m_pLMGFileBuf){
			// If no asdex data, release critical section and do nothing 
			LeaveCriticalSection(&id->m_csLMGSync);
		}else{
			starttime = 0;

			// Copy asdex data, release critical section and process
			lmglen = id->m_lLMGFileNBytes;
			lmgstr = id->m_pLMGFileBuf;
			id->m_lLMGFileNBytes = 0;
			id->m_pLMGFileBuf = NULL;	  
			LeaveCriticalSection(&id->m_csLMGSync);	

			str = lmgstr;

			for (;;){
				if ( !(endstr = strchr(str, '\n'))){
					/* end of file */
					break;
				}
				linelen = endstr - str;
				if ( linelen < LINE_BUFSIZE ){
					strncpy_s(buf, LINE_BUFSIZE, str, linelen );
				} else {
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen );
					break;
				}
				str += linelen + 1; // skip over line and newline character
				if ( str - lmgstr >= lmglen ){
					// at end of buffer
					break;
				}

				if ( !(record = RdRecord( id, &record_local, buf ))){
					continue;
				}
				if ( !starttime ){
					starttime = record->eventtime;
				}
				UpdLMGVehicles( id, record );
				record = NULL;
			}
			free(lmgstr);
		}
	}
}



void ASDEXProcess(struct InstanceData* id)
{
	char *str, *asdexstr;
	time_t starttime;
	char *endstr;
	int linelen, asdexlen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (TryEnterCriticalSection(&id->m_csASDEXSync)){
		if (!id->m_pASDEXFileBuf){
			// If no asdex data, release critical section and do nothing 
			LeaveCriticalSection(&id->m_csASDEXSync);
		}else{
			starttime = 0;

			// Copy asdex data, release critical section and process
			asdexlen = id->m_lASDEXFileNBytes;
			asdexstr = id->m_pASDEXFileBuf;
			id->m_lASDEXFileNBytes = 0;
			id->m_pASDEXFileBuf = NULL;
			LeaveCriticalSection(&id->m_csASDEXSync);

			str = asdexstr;

			for (;;){
				if (!(endstr = strchr(str, '\n'))){
					/* end of file */
					break;
				}
				linelen = endstr - str;
				if (linelen < LINE_BUFSIZE){
					strncpy_s(buf, LINE_BUFSIZE, str, linelen);
				} else {
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
					break;
				}
				str += linelen + 1; // skip over line and newline character
				if (str - asdexstr >= asdexlen){
					// at end of buffer
					break;
				}

				if (!(record = RdRecord(id, &record_local, buf))){
					continue;
				}
				if (!starttime){
					starttime = record->eventtime;
				}
				UpdASDEXAircraft(id, record);
				record = NULL;
			}
			free(asdexstr);
		}
	}

	LMGProcess(id);
}

void ADSBProcess(struct InstanceData* id)
{
	char *str, *adsbstr;
	time_t starttime;
	char *endstr;
	int linelen, adsblen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (TryEnterCriticalSection(&id->m_csADSBSync)){
		if (!id->m_pADSBFileBuf){
			// If no asdex data, release critical section and do nothing 
			LeaveCriticalSection(&id->m_csADSBSync);
		}else{
			starttime = 0;

			// Copy adsb data, release critical section and process
			adsblen = id->m_lADSBFileNBytes;
			adsbstr = id->m_pADSBFileBuf;
			id->m_lADSBFileNBytes = 0;
			id->m_pADSBFileBuf = NULL;
			LeaveCriticalSection(&id->m_csADSBSync);

			str = adsbstr;

			for (;;){
				if (!(endstr = strchr(str, '\n'))){
					/* end of file */
					break;
				}
				linelen = endstr - str;
				if (linelen < LINE_BUFSIZE){
					strncpy_s(buf, LINE_BUFSIZE, str, linelen);
				} else {
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
					break;
				}
				str += linelen + 1; // skip over line and newline character
				if (str - adsbstr >= adsblen){
					// at end of buffer
					break;
				}

				if (!(record = RdRecord(id, &record_local, buf))){
					continue;
				}
				if (!starttime){
					starttime = record->eventtime;
				}
				UpdADSBAircraft(id, record);
				record = NULL;
			}
			free(adsbstr);
		}
	}
}

void AirAsiaProcess(struct InstanceData* id)
{
	char *str, *airasiastr;
	time_t starttime;
	char *endstr;
	int linelen, airasialen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (TryEnterCriticalSection(&id->m_csAirAsiaSync)){
		if (!id->m_pAirAsiaFileBuf){
			// If no asdex data, release critical section and do nothing 
			LeaveCriticalSection(&id->m_csAirAsiaSync);
		}else{
			D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Processing Air Asia Data (len=%d)\n%s\n", cdwThreadId, id->m_lAirAsiaFileNBytes, id->m_pAirAsiaFileBuf ));
			starttime = 0;

			// Copy adsb data, release critical section and process
			airasialen = id->m_lAirAsiaFileNBytes;
			airasiastr = id->m_pAirAsiaFileBuf;
			id->m_lAirAsiaFileNBytes = 0;
			id->m_pAirAsiaFileBuf = NULL;
			LeaveCriticalSection(&id->m_csAirAsiaSync);

			str = airasiastr;

			for (;;){
				if (!(endstr = strchr(str, '\n'))){
					/* end of file */
					break;
				}
				linelen = endstr - str;
				if (linelen < LINE_BUFSIZE){
					strncpy_s(buf, LINE_BUFSIZE, str, linelen);
				} else {
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
					break;
				}

				if (!(record = RdRecord(id, &record_local, buf))){
					str += linelen + 1; // skip over line and newline character
					if (str - airasiastr >= airasialen){
						// at end of buffer
						break;
					}
					continue;
				}
				if (!starttime){
					starttime = record->eventtime;
				}
				UpdAirAsiaAircraft(id, record);
				record = NULL;

				str += linelen + 1; // skip over line and newline character
				if ( str - airasiastr >= airasialen ){
					// at end of buffer
					break;
				}
			}
			free(airasiastr);
		}
	}
}

void MLATProcess(struct InstanceData* id)
{
	char *str, *mlatstr;
	time_t starttime;
	char *endstr;
	int linelen, mlatlen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (TryEnterCriticalSection(&id->m_csMLATSync)){
		if (!id->m_pMLATFileBuf){
			// If no MLAT data, release critical section and do nothing 
			LeaveCriticalSection(&id->m_csMLATSync);
		}else{
			starttime = 0;

			// Copy MLAT data, release critical section and process
			mlatlen = id->m_lMLATFileNBytes;
			mlatstr = id->m_pMLATFileBuf;
			id->m_lMLATFileNBytes = 0;
			id->m_pMLATFileBuf = NULL;
			LeaveCriticalSection(&id->m_csMLATSync);

			str = mlatstr;

			for (;;){
				if (!(endstr = strchr(str, '\n'))){
					/* end of file */
					break;
				}
				linelen = endstr - str;
				if (linelen < LINE_BUFSIZE){
					strncpy_s(buf, LINE_BUFSIZE, str, linelen);
				} else {
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
					break;
				}
				str += linelen + 1; // skip over line and newline character
				if (str - mlatstr >= mlatlen){
					// at end of buffer
					break;
				}

				if (!(record = RdRecord(id, &record_local, buf))){
					continue;
				}
				if (!starttime){
					starttime = record->eventtime;
				}
				UpdMLATAircraft(id, record);
				record = NULL;
			}
			free(mlatstr);
		}
	}
}

void NoiseProcess(struct InstanceData* id)
{
	char *str, *noisestr;
	time_t starttime;
	char *endstr;
	int linelen, noiselen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (TryEnterCriticalSection(&id->m_csNoiseSync)){
		if (!id->m_pNoiseFileBuf){
			// If no asdex data, release critical section and do nothing 
			LeaveCriticalSection(&id->m_csNoiseSync);
		}else{
			starttime = 0;

			// Copy asdex data, release critical section and process
			noiselen = id->m_lNoiseFileNBytes;
			noisestr = id->m_pNoiseFileBuf;
			id->m_lNoiseFileNBytes = 0;
			id->m_pNoiseFileBuf = NULL;
			LeaveCriticalSection(&id->m_csNoiseSync);

			str = noisestr;

			for (;;){
				if (!(endstr = strchr(str, '\n'))){
					/* end of file */
					break;
				}
				linelen = endstr - str;
				if (linelen < LINE_BUFSIZE){
					strncpy_s(buf, LINE_BUFSIZE, str, linelen);
				} else {
					vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
					break;
				}
				str += linelen + 1; // skip over line and newline character
				if (str - noisestr >= noiselen){
					// at end of buffer
					break;
				}

				if (!(record = RdNoiseRecord(id, &record_local, buf))){
					continue;
				}
				//if ( !starttime ){
				//	starttime = record->eventtime;
				//}
				UpdNoiseAircraft(id, record);
				record = NULL;
			}
			free(noisestr);
		}
	}
}


double Updplottime(struct InstanceData* id)
{
	struct timeb tb;
	double clientmsecs;
	time_t replaysecs;
	const DWORD cdwThreadId = GetCurrentThreadId();

	ftime(&tb);
	id->m_tClientsTime = tb.time;
	clientmsecs = (id->m_tClientsTime * 1000.0) + tb.millitm;

	if (id->m_nDelaySecs >= 600){
		//  4 apr 2008 -- add in fast replay factor xfaster

		if (!delaystartsecs){
			delaystartsecs = id->m_tClientsTime; // initialize
		}

		if (id->m_tPlotTime < (id->m_tClientsTime - id->m_nDelaySecs)){
			id->m_tPlotTime = id->m_tClientsTime - id->m_nDelaySecs; // UpdASDplottime(), set to replay , since GDelaySecs >= 600

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, id->m_tClientsTime - id->m_nDelaySecs);
		}
		if (id->m_nReplaySpeed){
			replaysecs = (id->m_tClientsTime - delaystartsecs) * (id->m_nReplaySpeed - 1);
			id->m_tPlotTime = id->m_tClientsTime - id->m_nDelaySecs + replaysecs;
			if (id->m_tPlotTime > id->m_tClientsTime && replaysecs > 100){
				// replay has caught up to current time, so remove delay
				id->m_nDelaySecs = 0;

				// is this needed??? ResetTracks(TRUE);
				if (id->m_tPlotTime < (id->m_tClientsTime - id->m_tDelayTime)){
					id->m_tPlotTime = id->m_tClientsTime - id->m_tDelayTime;
					id->m_dPlotMSecs = clientmsecs - id->m_dDelayMSecs;

					if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, id->m_tClientsTime - id->m_tDelayTime);
				}
			}
		}
		if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing delaytime from %d to %d\n", cdwThreadId, id->m_tDelayTime, (id->m_tClientsTime - id->m_tPlotTime));
		id->m_tDelayTime = id->m_tClientsTime - id->m_tPlotTime;
		id->m_dDelayMSecs = (id->m_tDelayTime * 1000.0) + tb.millitm;
		id->m_dPlotMSecs = clientmsecs - id->m_dDelayMSecs;
	} else {
		// this moves the clock every second so the time appears reasonable

		id->m_tPlotTime = id->m_tClientsTime - id->m_tDelayTime; // UpdASDplottime(),, using time from ASD, not passur, no replay
		id->m_dPlotMSecs = clientmsecs - id->m_dDelayMSecs;

		if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, id->m_tClientsTime - id->m_tDelayTime);
	}

	return(clientmsecs);
}

int AirScreenPos(struct InstanceData* id, AIR **airp, int AI, int bInterpolate)
{
	double x1, y1, x2, y2, a, b, t, curx, cury;
	int i, tcount;
	PTRACK *trackarr;
	time_t endutc, startutc;
	struct timeb tb;
	double clientmsecs, endmsecs, startmsecs;
	double dis;
	int distest = TRUE;
	char stime[256], etime[256];
	static int pflag = 0;
	time_t replaysecs;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!(air = airp[AI])){
		return(FALSE);
	}

	if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
		ftime(&tb);
		id->m_tClientsTime = tb.time;
		clientmsecs = (id->m_tClientsTime * 1000.0) + tb.millitm;

		if (id->m_tPlotTime < (id->m_tClientsTime - id->m_tDelayTime)){

			if (REPLAY_STATUS_PLAYING == id->m_bReplayStatus)
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, id->m_tClientsTime - id->m_tDelayTime);

			id->m_tPlotTime = id->m_tClientsTime - id->m_tDelayTime;
			id->m_dPlotMSecs = clientmsecs - id->m_dDelayMSecs;


		}

		// Only do this code if ASD is not on, handled by ASD code otherwise
		if (!id->m_sCurLayout.m_bShowASDAircraft && id->m_nDelaySecs){
			if (!delaystartsecs){
				delaystartsecs = id->m_tClientsTime;
			}

			replaysecs = (id->m_tClientsTime - delaystartsecs) * (id->m_nReplaySpeed - 1);
			if ((id->m_tClientsTime - id->m_tDelayTime + replaysecs) > id->m_tPlotTime){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Changing plottime from %d to %d\n", cdwThreadId, id->m_tPlotTime, id->m_tPlotTime + replaysecs);
				id->m_tPlotTime = id->m_tClientsTime - id->m_tDelayTime + replaysecs;
				id->m_dPlotMSecs = clientmsecs - id->m_dDelayMSecs + (1000 * replaysecs);
			}
		}
	}
	if (id->m_sUserSettings.Extrapolation == TRUE){
		ExtrapolateMaxMSecs = PASSUR_EXTRAPOLATE_MAX_MSECS;
	} else {
		ExtrapolateMaxMSecs = 0;
	}

	/* go through tracks to find 2 points that contain plottime */

	/* interpolate position based on position at plottime */
	if (!(trackarr = air->TrackPtr)){
		return(FALSE);
	}


	if (id->m_nDelaySecs == 0){
		/* live mode, so smooth extrapolation */
		//Marquardt( AirVO , AI );
		//return( TRUE );
	}

	air->TrackStart = 0;
	tcount = air->tcount;
	for (i = air->tcount - 1; i >= 1; i--){
		endutc = trackarr[i].utc;

		startutc = trackarr[i - 1].utc;

		endmsecs = endutc * 1000.0;
		startmsecs = startutc * 1000.0;

		if ((id->m_tPlotTime >= startutc && id->m_tPlotTime <= endutc) || id->m_tPlotTime >= endutc || i == 1){
			//if ( (plottime >= startutc && plottime <= endutc) || plottime >= endutc  ||
			//  i == TrackVO->count - 1 ){

			air->TrackStart = i - 1;

			/* found correct 2 points */
			x1 = trackarr[i - 1].x;
			x2 = trackarr[i].x;
			y1 = trackarr[i - 1].y;
			y2 = trackarr[i].y;

			if (bInterpolate){
				/*:  Find parametric equations of the line through (-1,3) and (1,1)
				1. Choose one of the endpoints as the starting point.  We'll select (-1,3).
				2. Consider the x values.  How far does -1 have to move to get to 1?  Obviously, 1 - (-1) or 2 units.  So x = -1 + 2t.
				3. Consider the y values.  How far does 3 have to move to get to 1?  Obviously, 1 - 3 or -2 units.  So y = 3 - 2t */
				/* x = x1 + at
				a = (x2 - x1);
				y = y1 + bt
				b = (y2 - y1) */
				a = x2 - x1;
				b = y2 - y1;

				if (distest && !id->m_bIsPassurTais){
					dis = sqrt((a*a) + (b*b));
					if (dis > 0.1){
						int nFeedType = NONE;
						VOTimeFmt(stime, startutc, "%Y-%m-%d %H:%M:%S");
						VOTimeFmt(etime, endutc, "%Y-%m-%d %H:%M:%S");
						/* printf("skipping large delta dis=%g plottime=%s, startutc=%s endutc=%s "
						" diffsecs = %d\n",
						dis,
						VOTimeFmt( plottime, "%Y-%m-%d %H:%M:%S" ),
						stime, etime, endutc - startutc);	*/
						/* printf("removing track for flight '%s', trackid='%d'\n",
						air->FltNum,
						air->trackid ); */
						// Determine Feed Type
						if (airp == GetADSBAirP(id))
							nFeedType = ADSB;
						else if (airp == GetASDEXAirP(id))
							nFeedType = ASDEX;
						else if (airp == GetAirP(id, 0))
							nFeedType = PASSUR;
						else if (airp == GetASDAirP(id))
							nFeedType = ASDI;

						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track, Reason: Distance\n", cdwThreadId);
						RemoveTrack(id, airp, AI, nFeedType, TRUE);
						return(FALSE);
					}
				}
				/* t = (double) (plottime - startutc) / (double) (endutc - startutc ); */
				t = (double)(id->m_dPlotMSecs - startmsecs) / (double)(endmsecs - startmsecs);

				curx = x1 + (a * t);
				cury = y1 + (b * t);
			}else{
				curx = x2;
				cury = y2;
			}

			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) track %d, flight %s , curx=%g cury=%g x1=%g y1=%g\n",
					cdwThreadId, air->trackid, air->FltNum, curx, cury, x1, y1);
			}


			if (i == tcount - 1 && id->m_dPlotMSecs > (endmsecs + PASSUR_EXTRAPOLATE_MAX_MSECS)){
				// last track and we are past the endpoint by more than allowed seconds, so use last point
				curx = x2;
				cury = y2;
				if (pflag){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Setting cur to last for track %d, flight %s , curx=%g cury=%g x1=%g y1=%g\n",
						cdwThreadId, air->trackid, air->FltNum, curx, cury, x1, y1);
				}
			}

			if (i == tcount - 1 && id->m_dPlotMSecs > ((endutc * 1000.0) + ExtrapolateMaxMSecs)){
				// last track and we are past the endpoint by more than ExtrapolateMaxMSecs
				//   seconds, so use last point
				curx = trackarr[i].x;
				cury = trackarr[i].y;

				air->X1 = trackarr[i - 1].x;
				air->X2 = trackarr[i].x;
				air->Y1 = trackarr[i - 1].y;
				air->Y2 = trackarr[i].y;
				air->Y = (GLfloat)cury;
				air->X = (GLfloat)curx;

				if (pflag){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s past end, keep static,  curx=%g cury=%g plottime=%d plotmsecs=%1.3f\n",
						cdwThreadId, air->FltNum, curx, cury, id->m_tPlotTime, air->PlotMSECS / 1000.0);
				}
				// do not update since we are not moving it VV(AirVO, AI, "PlotMSECS", double ) = ASDplotmsecs;
			} else {
				//air->CurY = (GLfloat) cury;
				//air->CurX = (GLfloat) curx;
				air->Y = (GLfloat)cury;
				air->X = (GLfloat)curx;
				air->PlotMSECS = (GLfloat)id->m_dPlotMSecs;
				if (pflag){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s curx=%g cury=%g plottime=%d plotmsecs=%1.3f\n",
						cdwThreadId, air->FltNum, curx, cury, id->m_tPlotTime, air->PlotMSECS / 1000.0);
				}
			}
			return(TRUE);
		}
	}

	if (tcount == 1){
		// only one point for this passur, so display it
		curx = trackarr[0].x;
		cury = trackarr[0].y;
		air->X1 = trackarr[0].x;
		air->X2 = trackarr[0].x;
		air->Y1 = trackarr[0].y;
		air->Y2 = trackarr[0].y;
		air->Y = (float)cury;
		air->X = (float)curx;
		return(TRUE);
	}

	if (pflag){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No track found for '%s'\n",
			cdwThreadId, air->FltNum);
	}
	missedP++;
	return(TRUE);
}



void drawTrailLabel(struct InstanceData* id, double x, double y, time_t endutc)
{
	int xpixel, ypixel;
	static int pflag = 0;
	char stdtime[V_DATE_SIZE] = { 0 };

	/* convert X and Y from world to pixel coordinates */
	ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
	xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

	if (xpixel < 0 || xpixel > id->m_nWidth ||
		ypixel < 0 || ypixel > id->m_nHeight){
		return; // clipped
	}

	glColor3fv(black);
	glRecti(xpixel - 1, ypixel - 1, xpixel + 1, ypixel + 1);

	if (id->m_sCurLayout.m_dWorldXSize < TRAIL_LABEL_WORLD_SIZE && id->m_sCurLayout.m_bShowTrailTimes){
		glColor3fv(TrailLabelColor);
		glRasterPos2i(xpixel + 4, ypixel + 4);
		if (endutc > 0){  // will core dump if endutc < 0 
			//  display time, speed, altitude for compression measurements by users
			// .... see FindAircraft and mymouse() --  we should display alt and speed only for selected point???
			glPrintCustom(id, id->m_gluCustomBase , VOTimeFmt(stdtime, endutc, "%H:%M:%S"));
			glColor3fv(darkpurple);
		} else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad time=%d\n", GetCurrentThreadId(), endutc);
		}
	}

}

int CkDepFixMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{

	if (!pFilters)
		return(FALSE);

	if (!strlen(pFilters[f].fixes)){
		// Departure fix field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}
	// TO DO: Match to Departure fix, return TRUE

	return(FALSE);
}

int CkDestGateMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	if (!pFilters)
		return(FALSE);

	if (!strlen(pFilters[f].gates)){
		// Destination gate field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}
	// TO DO: Match to Known Destination Gates, return TRUE

	return(FALSE);
}

int CkOut2OffMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	if (!pFilters)
		return(FALSE);

	if (-1 == pFilters[f].out2off){
		// Out to Off field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}
	// TO DO: Out to Off > threshold?, return TRUE

	return(FALSE);
}

int CkOn2InMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	if (!pFilters)
		return(FALSE);
	if (-1 == pFilters[f].on2in){
		// On to in field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}
	// TO DO: On to In > threshold?, return TRUE

	return(FALSE);
}

int CkDelayedMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	if (!pFilters)
		return(FALSE);

	if (-1 == pFilters[f].delayed){
		// Delayed field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}
	// TO DO: Delayed > threshold?, return TRUE

	return(FALSE);
}

int CkStrandedMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	if (!pFilters)
		return(FALSE);
	if (-1 == pFilters[f].stranded){
		// Stranded field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}
	// TO DO: Stranded > threshold?, return TRUE

	return(FALSE);
}

int CkAcTypeMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	char tokstr[256];
	char *str;
	char	*sprtr = ",";
	char *tptr;
	char *actype;
	char *context;

	if (!pFilters)
		return(FALSE);

	if (!strlen(pFilters[f].actypes)){
		// ac types field is not active
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}

	actype = air->actype;


	strncpy_s(tokstr, _countof(tokstr), pFilters[f].actypes, _TRUNCATE);

	tptr = tokstr;
	while ((str = strtok_s(tptr, sprtr, &context))){

		tptr = NULL; // next call to strtok must be null
		if (!_stricmp(str, actype)){
			// matches this filter
			return(TRUE);
		}
	}


	return(FALSE);
}

int CkFlightNumberMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	char *matchstr, *fltnum; //, *endstr, *endstr1, *endstr2;
	int len, start, end, flight;
	char *context;
	char flightnumbers[512] = { 0 };
	const char delim[] = " ,";
	char prefix[10] = { 0 };

	if (!pFilters)
		return(FALSE);

	if (strlen(pFilters[f].flightnumbers)){
		// Airlines filter field is active
		fltnum = air->FltNum;
		if (strlen(fltnum) < 3){
			return(FALSE);
		} else {
			strncpy_s(flightnumbers, _countof(flightnumbers), pFilters[f].flightnumbers, 512);
			if (!strcmp(fltnum, "LN837MA")){
				// test, found it
				fltnum = "LN837MA";
			}

			matchstr = strtok_s(flightnumbers, delim, &context);
			do
			{
				// Checks for range pattern
				char* r = strchr(matchstr, '-');
				if (r){
					len = 0;
					// build flight id prefix
					while (isalpha(matchstr[len])){
						prefix[len] = matchstr[len];
						len++;
					}
					// test for flghtid prefix
					if (!strncasecmp(prefix, fltnum, len)){
						start = atoi(matchstr + len);
						flight = atoi(fltnum + len);
						if (strlen(r) > 1){
							// Supports standard range
							end = atoi(r + 1);
							if (start <= flight && end >= flight)
								return (TRUE);
						}else if(flight >= start){
							// Supports empty value range, AAL100-, or >= 100
							return (TRUE);
						}
					}
				}
				else {
					len = strlen(matchstr);
					if (len == strlen(fltnum) && !strncasecmp(matchstr, fltnum, len)){
						// matches this filter exactly
						return(TRUE);
					}
				}
		}
			while(matchstr = strtok_s(NULL, delim, &context));
			return( FALSE );
	}
	} else if ( pFilters[f].matchall ){
		/* user wanted to match all activated filters, but ignore this one */
		return(TRUE);
	}
	return(FALSE);
}


int CkAirlinesFilter(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	char airline[AIRLINE_NAME_SIZE];
	if (!pFilters)
		return(FALSE);

	if (strlen(pFilters[f].airlines)){
		// Airlines filter field is active
		if (strlen(air->FltNum) < 3){
			return(FALSE);
		} else {
			strncpy_s(airline, AIRLINE_NAME_SIZE, air->FltNum, 3);
			airline[3] = '\0';
			if (strstr(pFilters[f].airlines, airline)){
				// matches this filter
				return(TRUE);
			} else {
				return(FALSE);
			}
		}
	} else if ( pFilters[f].matchall ){
		/* user wanted to match all activated filters, but ignore this one */
		return(TRUE);
	}
	return(FALSE);
}



int CkAltitudeMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	int altitude;
	int opr;

	if (!pFilters)
		return(FALSE);

	if (!pFilters[f].altitude){
		// filter setting is inactive
		if (pFilters[f].matchall){
			/* user wanted to match all activated filters, but ignore this one */
			return(TRUE);
		}
		return(FALSE);
	}

	altitude = air->altitude;

	opr = pFilters[f].AltRadio; // 0 = GT, 1 = LT, 2 = all altitudes

	switch (opr)
	{
	case 0:  // GT
		if (altitude > pFilters[f].altitude){
			return(TRUE);
		} else {
			return(FALSE);
		}
		break;
	case 1: // LT
		if (altitude < pFilters[f].altitude){
			return(TRUE);
		} else {
			return(FALSE);
		}
		break;
	case 2:
		return(TRUE);
	}

	return(FALSE);
}



int CkOriginsMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	char *origin;
	char tokstr[256];
	char *str;
	char	*sprtr = ",";
	char *tptr;
	char *context;

	if (!pFilters)
		return(FALSE);

	// check originination
	if (strlen(pFilters[f].origins)){
		// Origins filter is active
		if (strlen(air->Origin) < 3){
			return(FALSE);
		}

		strncpy_s(tokstr, _countof(tokstr), pFilters[f].origins, _TRUNCATE);

		tptr = tokstr;
		while ((str = strtok_s(tptr, sprtr, &context))){
			tptr = NULL; // next call to strtok must be null
			// look for Internation flights with 'K', or "C" canadian or 'P' pacific regions
			origin = air->Origin;
			if (strlen(origin) > 3 && (origin[0] == 'K' || origin[0] == 'C' || origin[0] == 'P')){
				// convert into 3 letter code
				// better way is to use international airport codes conversion from iata into icao
				origin++; /* skip over 'K' or 'C', only works for US and Canada, and Pacific 'P' */
			}

			if (strlen(str) > 3 && (str[0] == 'K' || str[0] == 'C' || str[0] == 'P')){
				// convert into 3 letter code
				// better way is to use international airport codes conversion from iata into icao
				str++; /* skip over 'K' or 'C', only works for US and Canada, and Pacific 'P' */
			}

			if (!strcasecmp(str, origin)){
				// matches this filter
				return(TRUE);
			}
		}
	} else if ( pFilters[f].matchall ){
		/* user wanted to match all activated filters, but ignore this one */
		return(TRUE);
	}
	return(FALSE);
}



int CkDestinationsMatch(struct InstanceData* id, int f, FILTERS* pFilters, AIR *air)
{
	char *dest;
	char tokstr[256];
	char *str;
	char	*sprtr = ",";
	char *tptr;
	char *context;

	if (!pFilters)
		return(FALSE);

	// check destination
	if (strlen(pFilters[f].destinations)){
		// destinations filter is active
		if (strlen(air->Destin) < 3){
			return(FALSE);
		}

		strncpy_s(tokstr, _countof(tokstr), pFilters[f].destinations, 255);

		tptr = tokstr;
		while ((str = strtok_s(tptr, sprtr, &context))){

			tptr = NULL; // next call to strtok must be null
			// look for Internation flights with 'K', or "C" canadian or 'P' pacific regions
			dest = air->Destin;
			if (strlen(dest) > 3 && (dest[0] == 'K' || dest[0] == 'C' || dest[0] == 'P')){
				// convert into 3 letter code

				// better way is to use international airport codes conversion from iata into icao
				dest++; /* skip over 'K' or 'C', only works for US and Canada, and Pacific 'P' */

			}

			if (strlen(str) > 3 && (str[0] == 'K' || str[0] == 'C' || str[0] == 'P')){
				// convert into 3 letter code
				// better way is to use international airport codes conversion from iata into icao
				str++; /* skip over 'K' or 'C', only works for US and Canada, and Pacific 'P' */
			}

			if (!strcasecmp(str, dest)){
				// matches this filter
				return(TRUE);
			}
		}
	} else if ( pFilters[f].matchall ){
		/* user wanted to match all activated filters, but ignore this one */
		return(TRUE);
	}
	return(FALSE);
}


int filtermatch(struct InstanceData* id, AIR *air)
{	
	if (id->filter_check == 1) {
		return 3;  //default color
	}
	
	int pflag = 0;
	int f, i;
	int OriginMatch, DestinationMatch, AirlinesMatch, AltitudeMatch, FlightNumberMatch,
		ActypeMatch, DepFixMatch, DestGateMatch, Out2OffMatch, On2InMatch, DelayedMatch, StrandedMatch;
	int AreActiveFilters = 0;
	char *filtername;
	static int* filterval = NULL;
	static int nPrevMaxFilters = 0;
	FILTERS* pFilters = (FILTERS*)id->m_pFilters;
	const DWORD cdwThreadId = GetCurrentThreadId();

	//sy
	int color_temp;

	if (!filterval){
		filterval = calloc(id->m_nMaxFilters, sizeof(int));
		nPrevMaxFilters = id->m_nMaxFilters;
	}else if ( nPrevMaxFilters < id->m_nMaxFilters ) {
		filterval = (int*)realloc(filterval, id->m_nMaxFilters * sizeof(int));
		nPrevMaxFilters = id->m_nMaxFilters;
	}

	if (!pFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Filter list not allocated!\n", cdwThreadId);
		return (3);
	}

	// Initializing all match flags
	OriginMatch = DestinationMatch = AltitudeMatch = AirlinesMatch = FlightNumberMatch = ActypeMatch =
		DepFixMatch = DestGateMatch = Out2OffMatch = On2InMatch = DelayedMatch = StrandedMatch = 0;

	// initialize entire array 
	//MAX_FILTERS
	memset(filterval, 0, id->m_nMaxFilters * sizeof(int));

	if (!id->m_nFilterCount || !id->m_nActiveFilters){
		return(3); // default color is 3
	}
	/* this aircraft must pass all activated filters */

	for (f = 0; f < id->m_nFilterCount; f++){


		if (!pFilters[f].IsActive){
			continue;  // filter is inactive, so skip
		}
		filtername = pFilters[f].filtername;

		/* check airlines */
		AirlinesMatch = CkAirlinesFilter(id, f, pFilters, air);
		OriginMatch = CkOriginsMatch(id, f, pFilters, air);
		DestinationMatch = CkDestinationsMatch(id, f, pFilters, air);
		AltitudeMatch = CkAltitudeMatch(id, f, pFilters, air);
		FlightNumberMatch = CkFlightNumberMatch(id, f, pFilters, air);
		DepFixMatch = CkDepFixMatch(id, f, pFilters, air);
		DestGateMatch = CkDestGateMatch(id, f, pFilters, air);
		Out2OffMatch = CkOut2OffMatch(id, f, pFilters, air);
		On2InMatch = CkOn2InMatch(id, f, pFilters, air);
		DelayedMatch = CkDelayedMatch(id, f, pFilters, air);
		StrandedMatch = CkStrandedMatch(id, f, pFilters, air);

#ifdef AVITAT
		if ( FlightNumberMatch == AVITAT_COLOR_BLUE ){
			return( 12 );
		} else if ( FlightNumberMatch == AVITAT_COLOR_GREEN ){
			return( 8 );
		}
#endif

		ActypeMatch = CkAcTypeMatch(id, f, pFilters, air);

		if ((pFilters[f].matchall == TRUE &&
			AirlinesMatch && OriginMatch && DestinationMatch && AltitudeMatch && FlightNumberMatch && ActypeMatch &&
			DepFixMatch && DestGateMatch && Out2OffMatch && On2InMatch && DelayedMatch && StrandedMatch) ||
			(pFilters[f].matchall != TRUE &&
			(AirlinesMatch || OriginMatch || DestinationMatch || AltitudeMatch || FlightNumberMatch || ActypeMatch ||
			DepFixMatch || DestGateMatch || Out2OffMatch || On2InMatch || DelayedMatch || StrandedMatch))){
			// flight matches this filter
			if (pFilters[f].IsIncludeFilter){
				filterval[f] = INCLUDE_MATCH;
				// DO NOT return color here, since a later exclude filter may turn this one off
				// return( GFilters[f].colorindex );
				} else {
				// filter matched, but since this is an exclude filter, then return failed value -1
				filterval[f] = EXCLUDE_MATCH;
				// return( -1 );
			}
		} else {
			// try next filter
		}
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filtername='%s'\n", cdwThreadId, filtername);
		}
	}

	/* go through all exclude filters */
	for (f = 0; f < id->m_nFilterCount; f++){
		if (filterval[f] == EXCLUDE_MATCH){
			// exclude the flight, even if ShowAllAircraft is set
			
			//sy return(-1);
			color_temp = showflightscheck(id,air);
			return color_temp;

		}
	}
	/* go through all include filters in priority order*/
	i = 0;
	while (-1 != id->m_pActiveFilterPriorityIndices[i]){
		f = id->m_pActiveFilterPriorityIndices[i++];
		if (filterval[f] == INCLUDE_MATCH){
			if (pFilters[f].colorindex >= 0){
				return(pFilters[f].colorindex);
			} else {
				return(0); // default color if user did not pick a color
			}
		}
	}

	if (id->m_nActiveFilters){
		// did not match any filters
		if (id->m_sCurLayout.m_bShowAllAircraft){
			// do not filter since user wants to show all aircraft
			return(3);
		}
		color_temp = showflightscheck(id,air);
		return color_temp;
		//sy	return(-1);
	} else {
		// no active filters, so pass all aircraft
		return(3);
	}

}

int tagfiltermatch(struct InstanceData* id, AIR *air)
{
	int f;//, i;
	int OriginMatch, DestinationMatch, AirlinesMatch, AltitudeMatch, FlightNumberMatch,
		ActypeMatch, DepFixMatch, DestGateMatch, Out2OffMatch, On2InMatch, DelayedMatch, StrandedMatch;
	int AreActiveFilters = 0;
	char *filtername;
	FILTERS* pTagFilters = (FILTERS*)id->m_pTagFilters;
	int bMatch = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!pTagFilters){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tag Filter list not allocated!\n", cdwThreadId);
		return (TRUE);
	}

	// Initializing all match flags
	OriginMatch = DestinationMatch = AltitudeMatch = AirlinesMatch = FlightNumberMatch = ActypeMatch =
		DepFixMatch = DestGateMatch = Out2OffMatch = On2InMatch = DelayedMatch = StrandedMatch = 0;

	if (!id->m_nTagFilterCount || !id->m_nActiveTagFilters){
		return(TRUE); // default is to display if enabled
	}
	/* this aircraft must pass all activated filters */
	for (f = 0; f < id->m_nTagFilterCount; f++){

		if (!pTagFilters[f].IsActive){
			continue;  // filter is inactive, so skip
		}
		filtername = pTagFilters[f].filtername;

		/* check airlines */
		AirlinesMatch = CkAirlinesFilter(id, f, pTagFilters, air);
		OriginMatch = CkOriginsMatch(id, f, pTagFilters, air);
		DestinationMatch = CkDestinationsMatch(id, f, pTagFilters, air);
		AltitudeMatch = CkAltitudeMatch(id, f, pTagFilters, air);
		FlightNumberMatch = CkFlightNumberMatch(id, f, pTagFilters, air);
		DepFixMatch = CkDepFixMatch(id, f, pTagFilters, air);
		DestGateMatch = CkDestGateMatch(id, f, pTagFilters, air);
		Out2OffMatch = CkOut2OffMatch(id, f, pTagFilters, air);
		On2InMatch = CkOn2InMatch(id, f, pTagFilters, air);
		DelayedMatch = CkDelayedMatch(id, f, pTagFilters, air);
		StrandedMatch = CkStrandedMatch(id, f, pTagFilters, air);
		ActypeMatch = CkAcTypeMatch(id, f, pTagFilters, air);

		// Test for matching all elements of filter
		if (pTagFilters[f].matchall == TRUE)
		{
			// flight matches all elements of this filter
			if (pTagFilters[f].IsIncludeFilter){
				if (AirlinesMatch && OriginMatch && DestinationMatch && AltitudeMatch && FlightNumberMatch && ActypeMatch &&
					DepFixMatch && DestGateMatch && Out2OffMatch && On2InMatch && DelayedMatch && StrandedMatch){
					bMatch = TRUE;
				}
			}else{
				// If exclude filter
				if (AirlinesMatch && OriginMatch && DestinationMatch && AltitudeMatch && FlightNumberMatch && ActypeMatch &&
					DepFixMatch && DestGateMatch && Out2OffMatch && On2InMatch && DelayedMatch && StrandedMatch){
					return(FALSE);
				}
			}
		} else {
			// Testing Match any elements of filter
			// Check if Include or exclude first
			if (pTagFilters[f].IsIncludeFilter){
				if (AirlinesMatch || OriginMatch || DestinationMatch || AltitudeMatch || FlightNumberMatch || ActypeMatch ||
					DepFixMatch || DestGateMatch || Out2OffMatch || On2InMatch || DelayedMatch || StrandedMatch){
					// flight matches an element of this filter				
					bMatch = TRUE;
				}
			}else{
				// Exclude filter test
				if (AirlinesMatch || OriginMatch || DestinationMatch || AltitudeMatch || FlightNumberMatch || ActypeMatch ||
					DepFixMatch || DestGateMatch || Out2OffMatch || On2InMatch || DelayedMatch || StrandedMatch){
					// flight matches an element of this filter so flight must be dropped
					return(FALSE);
				}
			}
		}
		D_CONTROL("TAGFILTERS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filtername='%s'\n", cdwThreadId, filtername));
	}

	return (bMatch);
}


ShowMyMessage2(char *messagetext, int showsecs)
{
	////@@@@REPAIR
	//SetDlgItemText(hDlgDialog1, IDC_MESSAGE_DLG,  messagetext );
	//if ( !IsWindowVisible( hDlgDialog1 ) ){
	//	ShowWindow( hDlgDialog1 , SW_SHOW );
	//}


	return TRUE;
}




int IsLanding(struct InstanceData* id, AIR *air)
{
	double x1, y1, dis;
	char *dest;
	int tcount;
	PTRACK *trackarr;
	ARPT *Arpt;


	if (!strlen(air->Destin)){
		return(FALSE);
	}

	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return(FALSE);
	}

	dest = air->Destin;

	if (!(Arpt = FindArptRow(id, dest, MATCH_ALL))){
		// could not find arpt
		return(FALSE);
	}


	// see if we are near the departure airport

	if ((tcount = air->tcount)){

		// always use lat point in trail
		x1 = trackarr[tcount - 1].x;
		y1 = trackarr[tcount - 1].y;

		if ((dis = CkDis(x1, y1, Arpt->lng, Arpt->lat)) < 5.0){
			// to close to arrival airport
			return(TRUE);
		}

	}

	return(FALSE);
}




int IsDeparting(struct InstanceData* id, AIR *air)
{
	double x1, y1, dis;
	char *origin;
	int tcount;
	PTRACK *trackarr;
	ARPT *Arpt;

	if (!strlen(air->Origin)){
		return(FALSE);
	}

	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return(FALSE);
	}

	origin = air->Origin;
	if (!(Arpt = FindArptRow(id, origin, MATCH_ALL))){
		// could not find arpt
		return(FALSE);
	}

	// see if we are near the departure airport

	if ((tcount = air->tcount)){

		// always use first point remaining in trail
		x1 = trackarr[0].x;
		y1 = trackarr[0].y;


		if ((dis = CkDis(x1, y1, Arpt->lng, Arpt->lat)) < 10.0){
			// to close to departure airport
			return(TRUE);
		}

	}

	return(FALSE);
}





int LineSegmentsIntersect(struct InstanceData* id, double lat1, double lng1, double lat2, double lng2, double lat3, double lng3,
	double lat4, double lng4)
{
	double dx1, dy1, dx2, dy2, s, t, xintersect, yintersect, pcheck;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// see if the line segments intersect
	/*
	dx = X2 - X1
	dy = Y2 - Y1
	da = A2 - A1
	db = B2 - B1
	If (da * dy - db * dx) = 0 Then
	' The segments are parallel.
	SegmentsIntersect = False
	Exit Function
	End If

	s = (dx * (B1 - Y1) + dy * (X1 - A1)) / (da * dy - db * _
	dx)
	t = (da * (Y1 - B1) + db * (A1 - X1)) / (db * dx - da * _
	dy)
	SegmentsIntersect = (s >= 0# And s <= 1# And _
	t >= 0# And t <= 1#)

	' If it exists, the point of intersection is:
	' (x1 + t * dx, y1 + t * dy)
	*/

	dx1 = lng2 - lng1;
	dy1 = lat2 - lat1;
	dx2 = lng4 - lng3;
	dy2 = lat4 - lat3;

	//printf("dx2=%1.6f dy1=%1.8f dy2=%1.8f dx1=%1.8f\n",
	//dx2, dy1, dy2, dx1 );

	pcheck = (dx2 * dy1) - (dy2 * dx1);
	if (fabs(pcheck) < 0.000001){
		// line segments are parallel
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found parallel dx2=%1.6f dy1=%1.8f dy2=%1.8f dx1=%1.8f\n",
			cdwThreadId, dx2, dy1, dy2, dx1);
		return(FALSE);
	}

	s = (dx1 * (lat3 - lat1) + dy1 * (lng1 - lng3)) / (dx2 * dy1 - dy2 * dx1);

	t = (dx2 * (lat1 - lat3) + dy2 * (lng3 - lng1)) / (dy2 * dx1 - dx2 * dy1);


	// vo_log_info(id->m_pfVoLogFile, "LineSegmentsIntersect", "s=%1.6f t=%1.6f %1.6f %1.6f %1.6f %1.6f\n", s, t,
	//  lat3, lng3, lat4, lng4 );
	if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0){
		// intersects
		xintersect = lng1 + (t * dx1);
		yintersect = lat1 + (t * dy1);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found intersection, flight \n", cdwThreadId);

		return(TRUE);
	}

	return(FALSE);
}



int CkTrailWraps(struct InstanceData* id, AIR *air, int *startp, int *endp)
{
	PTRACK *trackarr;
	int i, j;
	double lng1, lat1, lng2, lat2, lat3, lng3, lat4, lng4;
	int tcount;

	// go through pair of points in the trail and see if we intersected this gate

	if (!air || !(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return(FALSE);
	}

	// start at last track and move backward
	tcount = air->tcount;
	for (i = 0; i < tcount - 1; i++){
		lng1 = trackarr[i].x;
		lat1 = trackarr[i].y;
		lng2 = trackarr[i + 1].x;
		lat2 = trackarr[i + 1].y;

		// start and end and work backwards so we get last endpoint of intersection in case of 2 wraps
		// make sure points are at least 2 points ahead due to crappy asd data
		for (j = tcount - 1; j > i + 3; j--){
			lng3 = trackarr[j - 1].x;
			lat3 = trackarr[j - 1].y;
			lng4 = trackarr[j].x;

			lat4 = trackarr[j].y;

			if (LineSegmentsIntersect(id, lat1, lng1, lat2, lng2, lat3, lng3, lat4, lng4)){
				*startp = i;
				*endp = j;
				printf("CkTrailWraps, trail intersects for '%s',  lat1 = %g lat2=%g lat3=%g lat4=%g\n", air->FltNum,
					lat1, lat2, lat3, lat4);
				printf("CkTrailWraps, lng1 = %g lng2=%g lng3=%g lng4=%g\n", lng1, lng2, lng3, lng4);
				return(TRUE);
			}
#ifdef DIS_TEST
			DistanceFromLine(lng4,lat4,lng1,lat1,lng2,lat2,&distanceSegment,&distanceLine);
			gateid =  VV( ArrGatesVO, dg, "gateid", int );
			runway = VP( ArrGatesVO, dg, "runway", char );
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flight %s, distance to gate %d %s = %1.6f\n",
				GetCurrentThreadId(), VP(AirVO, AI, "FltNum", char ), gateid, runway, distanceSegment );
#endif
		}

	}

	return(FALSE);
}



ClearOldHolds(struct InstanceData* id)
{

	int i, startsecs;


	for (i = 0; HoldVO && i < HoldVO->count; i++){

		// if Hold startsecs if very old (no longer valid), or in the future if we went back into replay mode, then remove hold
		startsecs = VV(HoldVO, i, "startsecs", int);
		if (abs(id->m_tPlotTime - startsecs) > 3600 * 1){
			vo_rm_row(HoldVO, i);
		}
	}


}




int CkInHoldArea(struct InstanceData* id, AIR *air, int *startp, int *endp)
{
	PTRACK *trackarr;
	int tcount, i;
	double xc, yc;
	char stime[256];
	time_t holdsecs;

	if (!air){
		return(-1);
	}
	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return(-1);
	}
	if ((tcount = air->tcount) <= 0){
		return(-1);
	}

	for (i = 0; HoldFixVO && i < HoldFixVO->count; i++){
		if (!VV(HoldFixVO, i, "IsActive", int) ||
			strcmp(air->Destin, VP(HoldFixVO, i, "Destin", char))){
			// invalid hold
			continue;
		}
		holdsecs = VV(HoldFixVO, i, "ActiveSecs", int);
		if (id->m_tASDFileTime - holdsecs > 60){
			// hold inactive for more than 5 minutes, ignore
			continue;
		}
		xc = VV(HoldFixVO, i, "X", double);
		yc = VV(HoldFixVO, i, "Y", double);

		if (CkDis(air->CurX, air->CurY, xc, yc) < 12.0){
			// is in hold range
			// make only last segment in holds
			if (tcount > 1){
				*startp = tcount - 2;
				*endp = tcount - 1;
			} else {
				*startp = tcount - 1;
				*endp = tcount - 1;
			}
			VOTimeFmt(stime, VV(HoldFixVO, i, "ActiveSecs", int), "%Y-%m-%d %H:%M:%S");
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found hold for '%s', Fix=%s dest='%s' activesec=%s\n",
				GetCurrentThreadId(), air->FltNum, VP(HoldFixVO, i, "Fixname", char),
				VP(HoldFixVO, i, "Destin", char), stime);
			printf("CkInHoldArea, Found hold for '%s', Fix=%s dest='%s' activesec=%s\n",
				air->FltNum, VP(HoldFixVO, i, "Fixname", char),
				VP(HoldFixVO, i, "Destin", char), stime);
			return(*startp);
		}
	}

	// not in any holds
	return(-1);
}



int CkHold(struct InstanceData* id, AIR *air, int *startp, int *endp, int *holdtype)
{
	double x1, y1, x2, y2;
	PTRACK *trackarr;
	int strk, etrk, tcount, minstarttrack, maxendtrack;
	double dis, speed, tmprads, minvel, mindis;
	time_t endutc;
	time_t sutc;
	char dbuf[256];
	char *FltNum;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int SelectedOnlyHolds = FALSE;
	static time_t prevtime;
	static int verboselogs = TRUE;


	if (SelectedOnlyHolds){
		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)){
		} else {
			return(-1);
		}
	}

	if (IsDeparting(id, air) || IsLanding(id, air)){
		// ignore departing flights since the departure is just doing a circular departure
		return(-1);
	}

	FltNum = air->FltNum;
	if (strlen(FltNum) > 3 && isalpha(FltNum[0]) && isalpha(FltNum[1]) && isalpha(FltNum[2]) && isdigit(FltNum[3])){
		// commericial flights, process
	} else {
		// not commercial, skip
		return(-1);
	}
	tcount = air->tcount;
	if (tcount < 4 || tcount > MAX_ASD_TRACK_POINTS){
		// too few points
		return(-1);
	}

	if (CkTrailWraps(id, air, startp, endp)){
		if (*endp < tcount - 1){
			// hold has ended, but still check if it is in hold area
			if ((minstarttrack = CkInHoldArea(id, air, startp, endp)) < 0){
				// not in hold area, but still return data from velocity hold
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) trail wrap found , but not in hold area flight '%s'\n",
					cdwThreadId, air->FltNum);
				return(-1);
			} else {
				*holdtype = HOLD_SEGMENT_WRAP;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) trail wrap found , VALID HOLD_IN_AREA for '%s'\n",
					cdwThreadId, air->FltNum);
				return(minstarttrack);
			}
		}
		*holdtype = HOLD_SEGMENT_WRAP;
		return(*startp);
	}

	minstarttrack = -1;
	maxendtrack = -1;
	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return(minstarttrack);
	}

	minvel = 9.9e99;

	// find the minuimum velocity between any 2 points, That will determine if we are in a hold, along with altitude
	for (strk = 0; strk < tcount - 1; strk++){
		x1 = trackarr[strk].x;
		y1 = trackarr[strk].y;
		sutc = trackarr[strk].utc;

		if (trackarr[strk].altitude != 0 && trackarr[strk].altitude < 50){
			continue; // skip points too low to be in a hold
		}

		// second track must be at least 3 point apart , otherwise pt-pt noise may yield slow velocity
		for (etrk = strk + 3; etrk < tcount && etrk < strk + 15; etrk++){
			x2 = trackarr[etrk].x;
			y2 = trackarr[etrk].y;
			endutc = trackarr[etrk].utc;
			tmprads = acos(sin(RADS(y2)) * sin(RADS(y1)) + cos(RADS(y2)) * cos(RADS(y1)) * cos(RADS(x1 - x2)));
			dis = 60.0 * DEGS(tmprads); // NM
			speed = dis * 3600 / (endutc - sutc); // rough nmph

			if (speed < 45.0){
				// in hold
				if (minstarttrack < 0){
					minstarttrack = strk;
				}
				if (speed < minvel){
					minvel = speed;
					mindis = dis;
				}
				//  keep only the greatest end track found for any starting strk
				if (etrk > maxendtrack){
					maxendtrack = etrk;
				}
			}
		}
	}
	if (minvel < 45.0){
		// ShowMyMessage2( "test hold\ntest hold\n", 10 );
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found hold for %s st=%d end=%d minvel=%g dis=%g\n",
			cdwThreadId, air->FltNum, minstarttrack, maxendtrack, minvel, mindis);
		if (verboselogs){
			for (strk = 0; strk < tcount; strk++){
				x1 = trackarr[strk].x;
				y1 = trackarr[strk].y;
				sutc = trackarr[strk].utc;
				VOTimeFmt(dbuf, sutc, "%H:%M:%S");
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %d\t%2.5f\t%2.5f\t%s\n", cdwThreadId, strk, x1, y1, dbuf);
			}
		}
		*startp = minstarttrack;
		*endp = maxendtrack;
		*holdtype = HOLD_VELOCITY;
		if (*endp < tcount - 1){
			// hold has ended, but still check if it is in hold area
			if ((minstarttrack = CkInHoldArea(id, air, startp, endp)) < 0){
				*holdtype = HOLD_NO;
				return(minstarttrack);
			} else {
				*holdtype = HOLD_IN_AREA;
				return(minstarttrack);
			}
		}
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) HOLD_VELOCITY for '%s' start=%d end=%d tcount=%d\n",
			cdwThreadId, air->FltNum, *startp, *endp, air->tcount);
		return(minstarttrack);
	} else {
		if ((minstarttrack = CkInHoldArea(id, air, startp, endp)) < 0){
			*holdtype = HOLD_IN_AREA;
			return(minstarttrack);
		} else {
			*holdtype = HOLD_IN_AREA;
			return(minstarttrack);
		}
	}
	// should not get here
	return(-1);
}



void CalcHoldCentroid(struct InstanceData* id, VO *HoldVO, int i, AIR *air)
{
	int strk;
	double x1, y1, xtot = 0.0, ytot = 0.0, xc, yc, distot, dis;
	int tot = 0;
	int startsecs, endsecs, sutc, tcount;
	PTRACK *trackarr;


	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return;
	}
	// find utc of start and end points. NOTE: some of the start points may have scrolled off already
	startsecs = VV(HoldVO, i, "startsecs", int);
	endsecs = VV(HoldVO, i, "endsecs", int);

	tcount = air->tcount;
	// calculate the centroid of valid hold points for this aircraft
	for (strk = 0; strk < tcount; strk++){
		sutc = trackarr[strk].utc;

		if (sutc >= startsecs && sutc <= endsecs){
			x1 = trackarr[strk].x;
			y1 = trackarr[strk].y;
			xtot += x1;
			ytot += y1;
			tot++;
		}
	}
	if (tot){
		xc = xtot / tot;
		yc = ytot / tot;
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) x=%g y=%g tot = %d\n", GetCurrentThreadId(), xc, yc, tot);
		VV(HoldVO, i, "centroidX", double) = xc;
		VV(HoldVO, i, "centroidY", double) = yc;
	}

	// find the average radius to this point
	for (strk = 0, tot = 0, distot = 0.0; strk < tcount; strk++){
		sutc = trackarr[strk].utc;

		if (sutc >= startsecs && sutc <= endsecs){
			x1 = trackarr[strk].x;
			y1 = trackarr[strk].y;
			dis = CkDis(x1, y1, xc, yc);
			distot += dis;
			tot++;
		}
	}
	VV(HoldVO, i, "radiusavg", double) = distot / tot;


}


int FindFltNum(struct InstanceData* id, char *FltNum)
{
	AIR **airp;
	int i;
	AIR *air;

	if (!(airp = GetASDAirP(id))){
		return(FALSE);
	}
	for (i = 0; i < N_PASSUR_TRACK_ID; i++){
		if (!(air = airp[i])){
			// not a valid track
			continue;
		}
		if (!strcmp(air->FltNum, FltNum)){
			// found it
			return(i);
		}
	}

	return(-1);
}





char *FindClosestFix(struct InstanceData* id, char *FltNum, int startsecs, int endsecs, FIX *Fixes, int fixcount)
{
	int i, AI, tcount, strk, sutc;
	AIR *air;
	AIR **airp;
	PTRACK *trackarr;
	int bestfix;
	float x1, y1, x, y;
	double mindis, dis;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// find closest point to any fix in list
	if (!g_bFixesLoaded){
		return (NULL);
	}

	if (!(airp = GetASDAirP(id))){
		return(NULL);
	}
	AI = FindFltNum(id, FltNum);
	if (AI < 0 || AI >= N_TRACK_ID){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not find AI for '%s'\n", cdwThreadId, FltNum);
		return(NULL);
	}

	if (!(air = airp[AI])){
		// not a valid track
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad air struct using AI index\n", cdwThreadId);
		return(NULL);
	}

	if (strcmp(FltNum, air->FltNum)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "\n(0x%X) Bad AI index\n\n", cdwThreadId);
		return(NULL);
	}

	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return(NULL);
	}
	tcount = air->tcount;


	mindis = 9.9e9;
	bestfix = -1;
	for (strk = 0; strk < tcount; strk++){
		sutc = trackarr[strk].utc;

		if (sutc >= startsecs && sutc <= endsecs){
			x1 = trackarr[strk].x;
			y1 = trackarr[strk].y;

			for (i = 0; i < g_nFixCount; i++){
				y = Fixes[i].lat;
				x = Fixes[i].lng;
				if ((dis = CkDis(x1, y1, x, y)) < mindis){
					mindis = dis;
					bestfix = i;
				}
			}
		}
	}

	if (mindis < 5.0 && bestfix >= 0 && bestfix < g_nFixCount){
		// found valid fix
		return(Fixes[bestfix].fixname);
	} else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not find close fix\n", cdwThreadId);
	}
	return(NULL);
}


void LoadRunways(struct InstanceData* id)
{
	char tmpstr[_MAX_PATH] = { 0 };
	const DWORD cdwThreadId = GetCurrentThreadId();
	if (id->m_bOnRefresh || !id->m_gluRunwayList){
		if (!GetLocalFile(id, id->m_strMapDir, "runways.shp", id->m_strHttpMapPath, SM_HTTPS))
		{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).\n", cdwThreadId, id->m_strMapDir, "runways.shp");
		} else if (!GetLocalFile(id, id->m_strMapDir, "runways.shx", id->m_strHttpMapPath, SM_HTTPS)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).\n", cdwThreadId, id->m_strMapDir, "runways.shx");
		} else {
			_snprintf_s(tmpstr, _MAX_PATH, _TRUNCATE, "%s%s", id->m_strMapDir, "runways.shp");
			id->m_gluRunwayList = CreatePolyGLList(tmpstr, GL_POLYGON, NULL, -1);
		}
	}

	if (id->m_bOnRefresh || !id->m_gluRunwayLines){
		if (!GetLocalFile(id, id->m_strMapDir, "runways.shp", id->m_strHttpMapPath, SM_HTTPS))
		{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).\n", cdwThreadId, id->m_strMapDir, "runways.shp");
		} else {
			sprintf_s(tmpstr, _MAX_PATH, "%s%s", id->m_strMapDir, "runways.shp");
			id->m_gluRunwayLines = CreatePolyGLList(tmpstr, GL_LINE_STRIP, NULL, -1);
		}
	}
}


void ClearOldHoldFixes(struct InstanceData* id)
{
	int i, endsecs;

	// need to get rid of holds that no longer received any updates

	for (i = 0; HoldFixVO && i < HoldFixVO->count; i++){

		// if Hold "ActiveSecs" is very old (no longer valid), or in the future if we went back into replay mode, then remove hold
		endsecs = VV(HoldFixVO, i, "ActiveSecs", int);
		if (abs(id->m_tASDFileTime - endsecs) > 120){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found old holdfix = '%s'\n", GetCurrentThreadId(), VP(HoldFixVO, i, "Fixname", char));
			VV(HoldFixVO, i, "IsActive", int) = FALSE;
		}
	}

}


void InactivateOldHolds(struct InstanceData* id)
{
	int i, endsecs, AI;
	AIR **airp;
	AIR *air;
	char *FltNum;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// same as ClearOldHolds , except don't remove from Hold VO, and time is much shorter to inactivate
	// need to get rid of holds that no longer received any updates
	if (!(airp = GetASDAirP(id))){
		return;
	}

	for (i = 0; HoldVO && i < HoldVO->count; i++){

		// if Hold startsecs if very old (no longer valid), or in the future if we went back into replay mode, then remove hold
		endsecs = VV(HoldVO, i, "endsecs", int);
		if (abs(id->m_tASDFileTime - endsecs) > 300){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found old hold = '%s'\n", cdwThreadId, VP(HoldVO, i, "FltNum", char));

			FltNum = VP(HoldVO, i, "FltNum", char);
			AI = FindFltNum(id, FltNum);
			if (AI >= 0 && AI < N_TRACK_ID){
				if (!(air = airp[AI])){
					// not a valid track
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) invalid track for '%s'\n", cdwThreadId, FltNum);
					continue;

				}
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing old hold = '%s' AI=%d\n", cdwThreadId, air->FltNum, AI);
				VV(HoldVO, i, "IsHolding", int) = FALSE;
				vo_rm_row(HoldVO, i);
				vo_order(HoldVO);
			} else {
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not find flight for '%s'\n", cdwThreadId, FltNum);
			}
		}
	}


}




void UpdateHold(VO *HoldVO, int hcount)
{
	// stub
}




void InsertHold(VO *HoldVO, int hcount)
{
	// stub , no db writes
}



void CreateHoldFixVO()
{

	HoldFixVO = vo_create(0, NULL);
	vo_set(HoldFixVO, V_NAME, "HoldFixVO", NULL);
	VOPropAdd(HoldFixVO, "Fixname", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);  // name of fix for the hold
	VOPropAdd(HoldFixVO, "Destin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);  // destination of aircraft in this fix.
	// Fixname may be shared with other destinations
	/// but aircraft going to another destination are stored in separate fix
	VOPropAdd(HoldFixVO, "ExpectedDuration", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(HoldFixVO, "IsActive", INTBIND, -1, VO_NO_ROW);  // an active holding area. Any aircraft to same location
	VOPropAdd(HoldFixVO, "ActiveSecs", INTBIND, -1, VO_NO_ROW);  // time of last active point found
	//  coming into area are assumed in HOLD
	VOPropAdd(HoldFixVO, "X", FLT8BIND, -1, VO_NO_ROW);                               // longitude of fix
	VOPropAdd(HoldFixVO, "Y", FLT8BIND, -1, VO_NO_ROW);                       // latitude
	VOPropAdd(HoldFixVO, "Radius", FLT8BIND, -1, VO_NO_ROW);
	vo_set(HoldFixVO, V_ORDER_COLS, "Fixname", NULL, NULL); // we change the sort columns during printing, so reset here
	vo_rm_rows(HoldFixVO, 0, HoldFixVO->count);

}



void UpdFix(struct InstanceData* id, VO *HoldVO, int hcount, int fix_rownum, char *Fixname)
{
	char stime[256];

	vo_set_int_value(id, HoldFixVO, fix_rownum, "IsActive", TRUE);
	vo_set_int_value(id, HoldFixVO, fix_rownum, "ActiveSecs", VV(HoldVO, hcount, "endsecs", int));
	strcpy_s(VP(HoldFixVO, fix_rownum, "Destin", char), ORIG_DES_SIZE, VP(HoldVO, hcount, "Destin", char));
	VOTimeFmt(stime, VV(HoldFixVO, fix_rownum, "ActiveSecs", int), "%Y-%m-%d %H:%M:%S");
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) update fix HoldFixVO for '%s', ActiveSecs = '%s' Dest=%s\n",
		GetCurrentThreadId(), Fixname, stime, VP(HoldFixVO, HoldFixVO->count - 1, "Destin", char));

}



void AddFix(struct InstanceData* id, VO *HoldVO, int hcount, char *Fixname)
{
	char stime[256];

	vo_alloc_rows(HoldFixVO, 1);
	// figure out when hold started, don't update the start time
	strcpy_s(VP(HoldFixVO, HoldFixVO->count - 1, "Fixname", char), FLTNUM_SIZE, Fixname);
	strcpy_s(VP(HoldFixVO, HoldFixVO->count - 1, "Destin", char), ORIG_DES_SIZE, VP(HoldVO, hcount, "Destin", char));
	vo_set_int_value(id, HoldFixVO, HoldFixVO->count - 1, "IsActive", TRUE);
	vo_set_double_value(id, HoldFixVO, HoldFixVO->count - 1, "Radius", VV(HoldVO, hcount, "radiusavg", double));
	vo_set_double_value(id, HoldFixVO, HoldFixVO->count - 1, "X", VV(HoldVO, hcount, "centroidX", double));
	vo_set_double_value(id, HoldFixVO, HoldFixVO->count - 1, "Y", VV(HoldVO, hcount, "centroidY", double));
	vo_set_int_value(id, HoldFixVO, HoldFixVO->count - 1, "ActiveSecs", VV(HoldVO, hcount, "endsecs", int));

	VOTimeFmt(stime, VV(HoldFixVO, HoldFixVO->count - 1, "ActiveSecs", int), "%Y-%m-%d %H:%M:%S");
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Added fix HoldFixVO for '%s', ActiveSecs = '%s' Dest=%s\n",
		GetCurrentThreadId(), Fixname, stime, VP(HoldFixVO, HoldFixVO->count - 1, "Destin", char));
	vo_order(HoldFixVO);

}




int UpdateFix(struct InstanceData* id, VO *HoldVO, int hcount, char *Fixname, int holdtype)
{
	struct row_index *row_index;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// go through each holding aircraft and find common hold locations
	//    determine fix of aircraft in group
	// get bounding area of fix to use for new aircraft coming into fix, or leaving
	// each fix has a destination airport, so shared fixes for different airports will create 2 records

	if (!HoldFixVO){
		CreateHoldFixVO();
	}

	if (!g_bFixesLoaded){
		return (FALSE);
	}

	if (holdtype == HOLD_IN_AREA){
		// dont update fix since this aircraft is just going through an active fix
		// if we update in area fixes, then they may not stop even if aircraft just go straight through
		return(FALSE);
	}


	if (VV(HoldVO, hcount, "IsHolding", int)) {
		if (!strlen(VP(HoldVO, hcount, "Fixname", char))){
			// active hold aircraft , find it's fix
			if (Fixname){
				//if ( InhibitFix( Fixname ) ){
				//	 vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring fix in inhibit list = %s\n", cdwThreadId, Fixname );
				//   return( FALSE );
				//}
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found fixname = '%s'\n", cdwThreadId, Fixname);
				// found preferred fix
				strcpy_s(VP(HoldVO, hcount, "Fixname", char), FLTNUM_SIZE, Fixname);
			} else {
				// no fix
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) error could not find fixname\n", cdwThreadId);
				return(FALSE);
			}
		} else {
			// use current fix already stored in hold
			Fixname = VP(HoldVO, hcount, "Fixname", char);
		}
		// see if we have that fix in HoldFixVO
		if ((row_index = vo_search(HoldFixVO, "Fixname", (char *)Fixname, NULL))){
			// we already have this fix
			UpdFix(id, HoldVO, hcount, row_index->rownum, Fixname);
		} else {
			// need to add this fix
			AddFix(id, HoldVO, hcount, Fixname);
		}
		return(TRUE);
	}
	return(FALSE);
}



char *HasValidFix(struct InstanceData* id, char *FltNum, time_t startsecs, time_t endsecs)
{
	char *Fixname;


	if (g_bFixesLoaded){

		if ((Fixname = FindClosestFix(id, FltNum, startsecs, endsecs, g_pFixesPref, g_nFixCountPref)) ||
			(Fixname = FindClosestFix(id, FltNum, startsecs, endsecs, g_pFixesLow, g_nFixCountLow)) ||
			(Fixname = FindClosestFix(id, FltNum, startsecs, endsecs, g_pFixesHigh, g_nFixCountHigh))){
			//if ( InhibitFix( Fixname ) ){
			//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring fix in inhibit list = %s\n", GetCurrentThreadId(), Fixname );
			//  return( NULL );
			//}

			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found fixname = '%s'\n", GetCurrentThreadId(), Fixname);
			return(Fixname);
		}
	}
	return(NULL);
}



void CkAllHolds(struct InstanceData* id, AIR **airp, int aircount)
{
	int i, tcount;
	AIR *air;
	PTRACK *trackarr;
	int starttrack, endtrack;
	struct row_index *row_index;
	char *Dest, *Origin, *holdflt, *Fixname;
	time_t nowsecs;
	static time_t lastclear;
	int holdtype;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!HoldVO){
		HoldVO = vo_create(0, NULL);
		vo_set(HoldVO, V_NAME, "HoldVO", NULL);
		VOPropAdd(HoldVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
		VOPropAdd(HoldVO, "Fixname", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);  // name of fix for the hold
		VOPropAdd(HoldVO, "IsHolding", INTBIND, -1, VO_NO_ROW);  // non-zero if aircraft is still in hold
		VOPropAdd(HoldVO, "startsecs", INTBIND, -1, VO_NO_ROW);  // earliest time aircraft started hold. Time may precede current tracks due to circular buffer
		VOPropAdd(HoldVO, "endsecs", INTBIND, -1, VO_NO_ROW);    // time aircraft left hold. Hold duration should be endsecs - startsecs
		VOPropAdd(HoldVO, "eta", INTBIND, -1, VO_NO_ROW);    // estimate time of arrival from asd sources
		VOPropAdd(HoldVO, "Origin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);  // Origin airport
		VOPropAdd(HoldVO, "Destin", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);  // Destination airport
		VOPropAdd(HoldVO, "altitude", INTBIND, -1, VO_NO_ROW);  // altitude

		VOPropAdd(HoldVO, "centroidX", FLT8BIND, -1, VO_NO_ROW); // centroid of valid holding points
		VOPropAdd(HoldVO, "centroidY", FLT8BIND, -1, VO_NO_ROW);
		VOPropAdd(HoldVO, "radiusavg", FLT8BIND, -1, VO_NO_ROW);
		vo_set(HoldVO, V_ORDER_COLS, "FltNum", NULL, NULL); // we change the sort columns during printing, so reset here
		vo_rm_rows(HoldVO, 0, HoldVO->count);
	}



	nowsecs = time(0);
	if (!lastclear || nowsecs - lastclear > 60){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Need to reactivate clears\n", cdwThreadId);
		InactivateOldHolds(id);
		ClearOldHolds(id);
		ClearOldHoldFixes(id);
		lastclear = nowsecs;
	}

	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			// not a valid track
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}
		tcount = air->tcount;

		if (tcount < 2){
			/* first point */
			/* do not plot yet */
			continue;
		}

		if (!strcmp(air->FltNum, "AAL1256")){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found it\n", cdwThreadId);
		}
		if (air->altitude < 60){
			// too low to be holding
			continue;
		}
		if (CkHold(id, air, &starttrack, &endtrack, &holdtype) < 0){
			// not holding
			// if in a hold, remove the hold
			if ((row_index = vo_search(HoldVO, "FltNum", (char *)air->FltNum, NULL))){
				// already have this aircraft
				vo_set_int_value(id, HoldVO, row_index->rownum, "IsHolding", FALSE);
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) no longer in a hold, remove '%s'\n", cdwThreadId, air->FltNum);
				UpdateHold(HoldVO, row_index->rownum);
			}
			continue;
		} else {

			if ((row_index = vo_search(HoldVO, "FltNum", (char *)air->FltNum, NULL))){
				// already have this aircraft

				holdflt = VP(HoldVO, row_index->rownum, "FltNum", char);
				if (strcmp(air->FltNum, holdflt)){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) mismatch in search hold='%s' air->FltNum='%s' row=%d\n", cdwThreadId, holdflt, air->FltNum, row_index->rownum);
					printf("mismatch in search hold='%s' air->FltNum='%s' row=%d\n", holdflt, air->FltNum, row_index->rownum);
				} else {
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) good match in search hold='%s' air->FltNum='%s' row=%d\n", cdwThreadId, holdflt, air->FltNum, row_index->rownum);
					printf("good match in search hold='%s' air->FltNum='%s' row=%d\n", holdflt, air->FltNum, row_index->rownum);
				}

				vo_set_int_value(id, HoldVO, row_index->rownum, "endsecs", trackarr[endtrack].utc);
				vo_set_int_value(id, HoldVO, row_index->rownum, "eta", air->eta);
				vo_set_int_value(id, HoldVO, row_index->rownum, "altitude", air->altitude);
				CalcHoldCentroid(id, HoldVO, row_index->rownum, air);
				if (endtrack < tcount - 1){
					// hold has ended, but still return minstarttrack so the hold is display and used in calcs
					// make hold inactive in local structure
					vo_set_int_value(id, HoldVO, row_index->rownum, "IsHolding", FALSE);
					UpdateHold(HoldVO, row_index->rownum);
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Hold ENDED for flight %s, duration=%d endtrack=%d tcount=%d IsHolding=%d\n", cdwThreadId, air->FltNum,
						VV(HoldVO, row_index->rownum, "endsecs", int) - VV(HoldVO, row_index->rownum, "startsecs", int),
						endtrack, tcount, VV(HoldVO, row_index->rownum, "IsHolding", int));
				} else {
					vo_set_int_value(id, HoldVO, row_index->rownum, "IsHolding", TRUE);
					CalcHoldCentroid(id, HoldVO, row_index->rownum, air);
					UpdateHold(HoldVO, row_index->rownum);
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Hold found for flight %s, duration=%d endtrack=%d tcount=%d IsHolding=%d\n", cdwThreadId, air->FltNum,
						VV(HoldVO, row_index->rownum, "endsecs", int) - VV(HoldVO, row_index->rownum, "startsecs", int),
						endtrack, tcount, VV(HoldVO, row_index->rownum, "IsHolding", int));
				}
				UpdateFix(id, HoldVO, row_index->rownum, VP(HoldVO, row_index->rownum, "Fixname", char), holdtype);
			} else {
				// first time for this aircraft, or flight was old
				// only allow holds that are from CkTrailWrap HOLD_SEGMENT_WRAP
				if (holdtype == HOLD_VELOCITY){
					// perhaps we should allow if the fix is at a preferred fix location??????
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Ignoring velocity hold for first time aircraft '%s'\n", cdwThreadId, air->FltNum);
					return;
				}
				if (endtrack < tcount - 1){
					// hold has ended, but still return minstarttrack so the hold is display and used in calcs
				} else {
					if ((Fixname = HasValidFix(id, air->FltNum, trackarr[starttrack].utc, trackarr[endtrack].utc))){
						// activate hold
						vo_alloc_rows(HoldVO, 1);
						// figure out when hold started, don't update the start time
						vo_set_int_value(id, HoldVO, HoldVO->count - 1, "startsecs", trackarr[starttrack].utc);
						strcpy_s(VP(HoldVO, HoldVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum);
						Dest = air->Destin;
						if (strlen(Dest) == 4){
							strcpy_s(VP(HoldVO, HoldVO->count - 1, "Destin", char), FLTNUM_SIZE, Dest);
						} else if ( strlen( Dest ) ){
							// convert to 4 letter code
							// for now , just add a 'K'
							sprintf_s(VP(HoldVO, HoldVO->count - 1, "Destin", char), FLTNUM_SIZE, "K%s", Dest);
						}
						Origin = air->Origin;
						if (strlen(Origin) == 4){
							strcpy_s(VP(HoldVO, HoldVO->count - 1, "Origin", char), ORIG_DES_SIZE, Origin);
						} else if ( strlen( Origin ) ){
							// convert to 4 letter code
							// for now , just add a 'K'
							sprintf_s(VP(HoldVO, HoldVO->count - 1, "Origin", char), ORIG_DES_SIZE, "K%s", Origin);
						}
						vo_set_int_value(id, HoldVO, HoldVO->count - 1, "endsecs", trackarr[endtrack].utc);
						vo_set_int_value(id, HoldVO, HoldVO->count - 1, "eta", air->eta);
						vo_set_int_value(id, HoldVO, HoldVO->count - 1, "altitude", air->altitude);
						CalcHoldCentroid(id, HoldVO, HoldVO->count - 1, air);
						vo_set_int_value(id, HoldVO, HoldVO->count - 1, "IsHolding", TRUE);

						strcpy_s(VP(HoldVO, HoldVO->count - 1, "Fixname", char), FLTNUM_SIZE, Fixname);
						UpdateFix(id, HoldVO, HoldVO->count - 1, Fixname, holdtype);
						InsertHold(HoldVO, HoldVO->count - 1);

						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) First Hold found for flight %s, duration=%d\n", cdwThreadId, air->FltNum, VV(HoldVO, HoldVO->count - 1, "endsecs", \
							int) -
							VV(HoldVO, HoldVO->count - 1, "startsecs", int));
						if (HoldVO && HoldVO->count){
							vo_order(HoldVO);
						}
					} else {
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Fix, for flight %s\n", cdwThreadId, air->FltNum);
					}
				}
			}
		}
	}
	if (HoldVO && HoldVO->count){
		vo_order(HoldVO);
	}

	// FindHoldFixes();
}


DrawHoldArea(struct InstanceData* id)
{
	int i;
	double lat, lng, userscale, realuserscale, radius;
	char strbuf[256];
	static int testrun = 1;

	if (id->m_bOnRefresh || id->m_bBuildRangeRings){
		buildRangeRings(id);
	}



	for (i = 0; HoldFixVO && i < HoldFixVO->count; i++){
		if (VV(HoldFixVO, i, "IsActive", int)){
			glPushMatrix();
			glLoadIdentity();

			glMatrixMode(GL_PROJECTION);
			glLoadIdentity();
			glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
				id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

			glMatrixMode(GL_MODELVIEW);
			glLoadIdentity();

			glDisable(GL_DEPTH_TEST);
			glDisable(GL_BLEND);

			// make color red for rings
			glColor3f(1.0f, 0.0f, 0.0f);

			lng = VV(HoldFixVO, i, "X", double);
			lat = VV(HoldFixVO, i, "Y", double);


			radius = VV(HoldFixVO, i, "Radius", double); // size in nm

			/* template Circle is 10NM large, so scale to user selected values */
			userscale = id->m_sCurLayout.m_dRingSize / 10.0 * radius;

			glTranslatef((GLfloat)lng, (GLfloat)lat, (GLfloat)trans[2]);


			glColor3f(1.0f, 1.0f, 0.0f);

			realuserscale = userscale * 1.0 / cos(lat * M_PI / 180.0);
			glScaled(realuserscale, userscale, 1.0f);
			glCallList(quadlist);

			glPopMatrix();
		}

	}

	glFlush();

	for (i = 0; HoldFixVO && i < HoldFixVO->count; i++){
		if (VV(HoldFixVO, i, "IsActive", int)){
			lng = VV(HoldFixVO, i, "X", double);
			lat = VV(HoldFixVO, i, "Y", double);
			radius = VV(HoldFixVO, i, "Radius", double); // size in nm

			// output names
			sprintf_s(strbuf, _countof(strbuf), "%s r=%g x=%g y=%g", VP(HoldFixVO, i, "Fixname", char), radius, lng, lat);

			DrawGLTextXY(id, lng, lat, strbuf, (GLfloat *)red, id->m_gluCustomBase, FALSE); //@@@MCT Check
		}

	}


}



void drawHolds(struct InstanceData* id, AIR **airp, int tcheck, time_t airplottime, int IsASD, int nTrackCount)
{
	GLfloat white[3] = { 1.0, 1.0, 1.0 };
	int i, trk, tcount, aircount, tc;
	PTRACK *trackarr;
	double x2, y2;
	time_t endutc, startsecs, endsecs;
	time_t cursec;
	int pflag = 0;
	int TrackStart;
	static int testsmoothflag = 0;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static time_t prevtime;
	struct row_index *row_index;



	cursec = time(0);

	glPushMatrix();
	glLoadIdentity();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);

	if (IsASD){
		aircount = N_TRACK_ID;
	} else {
		aircount = N_PASSUR_TRACK_ID;
	}

	// ShowWindow(hDlgDialog1, SW_SHOW);
	// for now just check holds for selected aircraft
	if (cursec > prevtime + 30){
		// only look for holds every 30 seconds
		CkAllHolds(id, airp, aircount);
		prevtime = cursec;
	}

	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			// not a valid track
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}
		tcount = air->tcount;

		if (tcount < 2){
			/* first point */
			/* do not plot yet */
			continue;
		}

		if (!strcmp(air->FltNum, "AWE1576")) {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found it\n", cdwThreadId);
		}
		if ((row_index = (struct row_index *) vo_search(HoldVO, "FltNum", air->FltNum, NULL))){
			// is a holding aircraft
		} else {
			continue;
		}
		if (row_index->rownum < 0 || row_index->rownum >= HoldVO->count){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found bad index\n", cdwThreadId);
			continue;
		}

		/* draw a line between all of the points */
		glBegin(GL_LINE_STRIP);
		if (IsASD){
			glColor3fv(green);/* line */
		} else {
			glColor3fv(orange);
		}
		/* make first index current location of aircraft */
		x2 = air->X;
		y2 = air->Y;
		glVertex3f((float)x2, (float)y2, 0.0f);

		/* second point for asd is prev current point */
		if (IsASD && (x2 != air->X1 || y2 != air->Y1)){
			x2 = air->X1;
			y2 = air->Y1;
			glVertex3f((float)x2, (float)y2, 0.0f);
		}

		startsecs = VV(HoldVO, row_index->rownum, "startsecs", int);
		endsecs = VV(HoldVO, row_index->rownum, "endsecs", int);

		TrackStart = air->TrackStart;
		if (TrackStart > tcount - 2) {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad trackstart=%d TrackVO->count=%d flight=%s\n",
				cdwThreadId, TrackStart, tcount, air->FltNum);
			TrackStart = 0;
		}

		for (trk = TrackStart + 1, tc = 0; trk >= 0; trk--){
			endutc = trackarr[trk].utc;
			x2 = trackarr[trk].x;
			y2 = trackarr[trk].y;
			if (trackarr[trk].utc >= startsecs && trackarr[trk].utc <= endsecs){
				glColor3fv(green);/* line */
			} else {
				glColor3fv(orange);
			}

			glVertex3f((float)x2, (float)y2, 0.0f);

			tc++;
			if (tc > nTrackCount){
				break;
			}

		}
		glEnd();

	}

	DrawHoldArea(id);

	glFlush();
	glPopMatrix();


	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}



void drawTrails(struct InstanceData* id, AIR **airp, int tcheck, time_t airplottime, int nFeedType, int nTrailCount)
{
	GLfloat white[3] = { 1.0, 1.0, 1.0 };
	int i, trk, tcount, aircount, tc;
	PTRACK *trackarr;
	double x2, y2;
	time_t endutc;
	time_t cursec;
	char airplotstr[512], trackutcstr[512];
	int pflag = 0;
	int TrackStart;
	static int testsmoothflag = 0;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();


	cursec = time(0);

	if (id->m_sCurLayout.m_dWorldXSize > 50.0){
		/* too large to bother with trails */
		return;
	}

	if (nTrailCount <= 0){
		return;
	}

	glPushMatrix();
	glLoadIdentity();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);

	if (SAT_ASDI == nFeedType){
		aircount = N_TRACK_ID;
	} else if ( SAT_ADSB == nFeedType ){
		aircount = N_ADSB_TRACK_ID;
	} else if ( SAT_NOISE == nFeedType ){
		aircount = N_NOISE_TRACK_ID;
	} else {
		aircount = N_PASSUR_TRACK_ID;
	}
	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			// not a valid track
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}
		if (!strcmp(air->FltNum, "SWA820")){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found it\n", cdwThreadId);
		}
		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( SAT_ASDEX == nFeedType /*&& id->m_sCurLayout.m_bShowADSBAircraft*/ && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( SAT_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if ( SAT_PASSUR == nFeedType && air->IsTracked ){
			if ((air->IsTracked & SAT_ASDEX || air->IsTracked & SAT_MLAT)) {
				if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT){
					/* ASDEX is tracking this aircraft but show when zoom level is beyond ASDEX */
					continue;
				}
			}
			else{
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if ( SAT_ASDI == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}


		if ((SAT_ASDI == nFeedType) && !id->m_sCurLayout.m_bShowASDAircraft){
			if (!(SAT_ASDI == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}else if((SAT_PASSUR == nFeedType) && !id->m_sCurLayout.m_bShowPassurAircraft){
			if (!(SAT_PASSUR == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}else if((SAT_ASDEX == nFeedType) && !id->m_sCurLayout.m_bShowASDEXAircraft){
			if (!(SAT_ASDEX == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}else if((SAT_NOISE == nFeedType) && !id->m_sCurLayout.m_bShowNoiseAircraft){
			if (!(SAT_NOISE == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}

		if ((SAT_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}


		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
			&& id->m_nSelectedTrackID == air->trackid){
			// don't clip selected aircraft
		} else {
			if (!air->vehicle && clipaircraft(id, air)) {
				continue;
			}
		}

		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {
			if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
				&& id->m_nSelectedTrackID == air->trackid) {
				// don't filter selected aircraft
			} else {
				if (!air->vehicle && filtermatch(id, air) < 0) {
					if ((SAT_ASDEX != nFeedType && SAT_MLAT != nFeedType) || !id->m_nAllSurface)
						continue;
				}

			}
		}

		if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
			continue;

		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (SAT_ASDEX == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;
		if (SAT_MLAT == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > MLAT_LKP_TRACK_TIMEOUT))
			continue;

		tcount = air->tcount;

		if (tcount < 2){
			/* first point */
			/* do not plot yet */
			continue;
		}

		if (testsmoothflag){
			glBegin(GL_LINE_STRIP);
			glColor3f(0.0, 1.0, 0.0);
			x2 = air->X1;
			y2 = air->Y1;
			glVertex3f((float)x2, (float)y2, 0.0f);
			x2 = air->X2;
			y2 = air->Y2;
			glVertex3f((float)x2, (float)y2, 0.0f);
			glEnd();
		}


		/* draw a line between all of the points */
		glBegin(GL_LINE_STRIP);
		if (SAT_ASDI == nFeedType){
			glColor3fv(blue);/* line */
		} else {
			glColor3fv(black);
		}
		/* make first index current location of aircraft */
		x2 = air->X;
		y2 = air->Y;
		glVertex3f((float)x2, (float)y2, 0.0f);



		/* second point for asd is prev current point */
		if ((SAT_ASDI == nFeedType) && (x2 != air->X1 || y2 != air->Y1)){
			x2 = air->X1;
			y2 = air->Y1;
			glVertex3f((float)x2, (float)y2, 0.0f);
		}

		// for (trk = TrackVO->count - 1, tcount = 0; trk >= 0; trk-- ){
		TrackStart = air->TrackStart;
		if (TrackStart > tcount - 2) {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad trackstart=%d TrackVO->count=%d flight=%s\n",
				cdwThreadId, TrackStart, tcount, air->FltNum);
			TrackStart = 0;
		}

		for (trk = TrackStart + 1, tc = 0; trk >= 0; trk--){
			endutc = trackarr[trk].utc;


			// This check prevents data points ahead of plottime from displaying
			if (!tcheck || airplottime >= endutc){
				x2 = trackarr[trk].x;
				y2 = trackarr[trk].y;

				// selected flights in red
				if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
					&& id->m_nSelectedTrackID == air->trackid){
					// MedFit( AirVO, i );
					glColor3f(1.0f, 0.0f, 0.0f); /* selected color for line */
					if (pflag){
						/* selected aircraft */
						VOTimeFmt(airplotstr, airplottime, "%Y-%m-%d %H:%M:%S");
						VOTimeFmt(trackutcstr, trackarr[trk].utc, "%Y-%m-%d %H:%M:%S");

						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s tcount=%d x=%g y=%g utc=%s airplottime=%s\n",
							cdwThreadId, air->FltNum, tcount, x2, y2, trackutcstr, airplotstr);
					}
					// draw best fit line, if one

				}
				glVertex3f((float)x2, (float)y2, 0.0f);

			}
			tc++;
			if (tc > nTrailCount){
				break;
			}
		}
		glEnd();

#ifdef TESTSMOOTH
		if ( testsmoothflag ){
			if ( id->m_pSelectedAircraft && !strcmp(  VP(AirVO, i, "FltNum", char ), id->m_pSelectedAircraft )
				&& id->m_nSelectedTrackID == air->trackid ){
				// TestSmoothing( AirVO, i );
				TestSmoothing2( AirVO, i );
			}
		}
#endif

#ifdef MEDFIT_SMOOTHING
		if ( id->m_pSelectedAircraft && !strcmp(  VP(AirVO, i, "FltNum", char ), id->m_pSelectedAircraft )
			&& id->m_nSelectedTrackID == air->trackid ){

			// draw best fit line, if one
			glBegin(GL_LINE_STRIP);
			glColor3f(1.0, 0.0, 0.0 );
			// draw line corresponding to y = a + bx;
			pa = VV(AirVO, i, "pa", double);
			pb = VV(AirVO, i, "pb", double);


			// find intercepts at x1 = 0.0, x2 = -100.0
			x1 = -200.0;
			y1 = pa + (pb * x1);


			x2 = 0.0;
			y2 = pa;

			glVertex3f( (float) x1, (float) y1, 0.0f );
			glVertex3f( (float) x2, (float) y2, 0.0f );
			glEnd();

		}
#endif

	}
	glFlush();

	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}



int drawAircraftRangeRings(struct InstanceData* id, AIR **airp, int aircount, int nFeedType)
{
	int i, r;
	double lat, lng, userscale, realuserscale;
	static int pflag = FALSE;
	PTRACK *trackarr;
	AIR *air;

	if (id->m_bOnRefresh || id->m_bBuildRangeRings){
		buildRangeRings(id);
	}


	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	r = 1; // only one range ring to draw
	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet, or inactive index */
			continue;
		}

		if (clipaircraft(id, air)) {
			continue;
		}
		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {
			if (air->vehicle){
				continue;
			}else if ( filtermatch( id, air ) < 0 ){

					if ((SAT_ASDEX != nFeedType && SAT_MLAT != nFeedType) || !id->m_nAllSurface)
						continue;
				}
		}

		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( SAT_ASDEX == nFeedType /*&& id->m_sCurLayout.m_bShowADSBAircraft*/ && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( SAT_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if ( SAT_PASSUR == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex or mlat is tracking this aircraft */
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if ( SAT_ASDI == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}

		if ((SAT_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}

		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (SAT_ASDEX == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;
		if (SAT_MLAT == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > MLAT_LKP_TRACK_TIMEOUT))
			continue;

		glPushMatrix();
		glLoadIdentity();

		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
			id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

		RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
			id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		glDisable(GL_DEPTH_TEST);
		glDisable(GL_BLEND);

		// make color red for rings
		glColor3f(1.0f, 0.0f, 0.0f);


		lat = air->Y;
		lng = air->X;

		// lat = VV(RangeRingVO, i, "Lat", double );
		// lng = VV(RangeRingVO, i, "Lng", double );
		// nm = VV(RangeRingVO, i, "NauticalMiles", double );

		/* template Circle is 10NM large, so scale to user selected values */
		userscale = id->m_sCurLayout.m_dRingSize / 10.0 * r;

		glTranslatef((GLfloat)lng, (GLfloat)lat, (GLfloat)trans[2]);

		if (r % 5 == 0){
			glColor3f(0.0f, 0.0f, 1.0f);
		} else {
			glColor3f(1.0f, 0.0f, 0.0f);
		}
		realuserscale = userscale * 1.0 / cos(lat * M_PI / 180.0);
		glScaled(realuserscale, userscale, 1.0f);
		glCallList(quadlist);


		glPopMatrix();
	}

	glFlush();
	return(SUCCEED);

}

int drawLKPRings(struct InstanceData* id, AIR **airp, int aircount, int nFeedType)
{
	int i, r;
	double lat, lng, userscale, realuserscale;
	static int pflag = FALSE;
	float AirSize;
	PTRACK *trackarr;
	AIR *air;

	if (id->m_bOnRefresh || id->m_bBuildRangeRings){
		buildRangeRings(id);
	}

	if (!id->m_sUserSettings.LKP)
		return (FAIL);

	AirSize = (float)((id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth) * 4.5f;
	if (AirSize > 1.5) AirSize = 1.5;

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	r = 1; // only one range ring to draw
	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet, or inactive index */
			continue;
		}
		if ( air->IsTracked ){
			/* Don't draw if we are tracking this aircraft from a higher priority feed */
			continue;
		}
		if (clipaircraft(id, air)) {
			continue;
		}
		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		}
		else {
			if (air->vehicle){
				continue;
			}
			else if ( filtermatch( id, air ) < 0 ){
			
				if ((SAT_ASDEX != nFeedType && SAT_MLAT != nFeedType) || !id->m_nAllSurface)
						continue;
			}
		}

		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( SAT_ASDEX == nFeedType && id->m_sCurLayout.m_bShowADSBAircraft && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( SAT_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if ( SAT_PASSUR == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex or mlat is tracking this aircraft */
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if ( SAT_ASDI == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}

		if ((SAT_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}

		// Only draw if track has not been updated after Last Known Position Seconds.
		if (!((id->m_tPlotTime - air->utc) > ASDEX_LKP_TRACK_TIMEOUT)){
			continue;
		}

		// Only draw if FLIGHT is within an airport region and not within a Runway Region.
		if (!air->InRegion && !air->OnRwy){
			continue;
		}

		glPushMatrix();
		glLoadIdentity();

		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
			id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

		RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
			id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		glDisable(GL_DEPTH_TEST);
		glDisable(GL_BLEND);

		// make color red for rings
		glColor3f(1.0f, 0.0f, 0.0f);


		lat = air->Y;
		lng = air->X;

		// lat = VV(RangeRingVO, i, "Lat", double );
		// lng = VV(RangeRingVO, i, "Lng", double );
		// nm = VV(RangeRingVO, i, "NauticalMiles", double );

		/* template Circle is 10NM large, so scale to aricraft size based on window/screen */
		// First attempt using 1/10 of mile for size
		userscale = AirSize /* 10.0 */ * r;

		glTranslatef((GLfloat)lng, (GLfloat)lat, (GLfloat)trans[2]);

		if (r % 5 == 0){
			glColor3f(0.0f, 0.0f, 1.0f);
		} else {
			glColor3f(1.0f, 0.0f, 0.0f);
		}
		realuserscale = userscale * 1.0 / cos(lat * M_PI / 180.0);
		glScaled(realuserscale, userscale, 1.0f);
		glCallList(quadlist);


		glPopMatrix();
	}

	glFlush();
	return(SUCCEED);

}


int drawAlertLoops(struct InstanceData* id, AIR **airp, int aircount, int nFeedType)
{
	int i, r;
	double lat, lng, userscale, realuserscale;
	static int pflag = FALSE;
	float AirSize;
	PTRACK *trackarr;
	AIR *air;

	AirSize = (float)((id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth) * 4.5f;
	if (AirSize > 1.5) AirSize = 1.5;

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	r = 1; // only one range ring to draw
	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet, or inactive index */
			continue;
		}

		if (clipaircraft(id, air)) {
			continue;
		}
		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {
			if (air->vehicle){
				continue;
			}else if ( filtermatch( id, air ) < 0 ){
				if ((SAT_ASDEX != nFeedType && SAT_MLAT != nFeedType) || !id->m_nAllSurface)
					continue;
			}
		}

		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( SAT_ASDEX == nFeedType && id->m_sCurLayout.m_bShowADSBAircraft && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( SAT_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if ( SAT_PASSUR == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex or mlat is tracking this aircraft */
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if ( SAT_ASDI == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}

		if ((SAT_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}

		// Only draw if track has not been updated after Last Known Position Seconds.
		if (ALERT_NONE == air->alert){
			continue;
		}

		glPushMatrix();
		glLoadIdentity();

		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
			id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		glDisable(GL_DEPTH_TEST);
		glDisable(GL_BLEND);

		// make color red for rings
		glColor3f(1.0f, 0.0f, 0.0f);


		lat = air->Y;
		lng = air->X;

		// lat = VV(RangeRingVO, i, "Lat", double );
		// lng = VV(RangeRingVO, i, "Lng", double );
		// nm = VV(RangeRingVO, i, "NauticalMiles", double );

		/* template Circle is 10NM large, so scale to aricraft size based on window/screen */
		// First attempt using 1/10 of mile for size
		userscale = AirSize /* 10.0 */ * r;

		glTranslatef((GLfloat)lng, (GLfloat)lat, (GLfloat)trans[2]);

		if (r % 5 == 0){
			glColor3f(0.0f, 0.0f, 1.0f);
		} else {
			glColor3f(1.0f, 0.0f, 0.0f);
		}
		realuserscale = userscale * 1.0 / cos(lat * M_PI / 180.0);
		glScaled(realuserscale, userscale, 1.0f);
		glCallList(quadlist);


		glPopMatrix();
	}

	glFlush();
	return(SUCCEED);

}

drawAirportRings(struct InstanceData* id)
{
	int i, r; //, NumRings;
	double lat, lng, realdelta, deltalng, userscale, realuserscale;
	static int pflag = FALSE;

	if (!id->m_pRangeRingVO){
		return(FAIL);
	}

	if (id->m_bOnRefresh || id->m_bBuildRangeRings){
		buildRangeRings(id);
	}

	// reset the color to white so textures will appear
	glColor3f(1.0, 1.0, 1.0);

	if (TryEnterCriticalSection(&id->m_csArptRangeRing)){

		for (i = 0; i < ((VO*)id->m_pRangeRingVO)->count; i++){
			//NumRings = VV(RangeRingVO, i, "NumRings", int );
			for (r = 1; r <= id->m_sCurLayout.m_nAirportRingCount; r++){
				glPushMatrix();
				glLoadIdentity();

				glMatrixMode(GL_PROJECTION);
				glLoadIdentity();

				glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
					id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
					0.0f, 1.0f);

				RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
					id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();

				glDisable(GL_DEPTH_TEST);
				glDisable(GL_BLEND);


				if (r % 5 == 0){
					glColor3f(0.0f, 0.0f, 1.0f);
				} else {
					glColor3f(1.0f, 0.0f, 0.0f);
				}

				lat = VV((VO*)id->m_pRangeRingVO, i, "Lat", double);
				lng = VV((VO*)id->m_pRangeRingVO, i, "Lng", double);
				//nm = VV(RangeRingVO, i, "NauticalMiles", double );

				// template Cirlce is 10NM large, so scale to user selected values
				userscale = (double)id->m_sCurLayout.m_nAirportRingSize / 10.0 * r;

				if (lat < 0.0001){
					// have not recevied lat/lon data for this arpt yet
					continue;
				}
				if (projflag){
					deltalng = lng - LngOrig;
					realdelta = deltalng * cos(lat * M_PI / 180.0);
					lng = LngOrig + realdelta;
				}

				glTranslatef((GLfloat)lng, (GLfloat)lat, (GLfloat)trans[2]);

				if (r % 5 == 0){
					glColor3f(0.0f, 0.0f, 1.0f);
				} else {
					glColor3f(1.0f, 0.0f, 0.0f);
				}
				realuserscale = userscale * 1.0 / cos(lat * M_PI / 180.0);
				glScaled(realuserscale, userscale, 1.0f);
				glCallList(quadlist);
				glPopMatrix();
			}
		}
		glFlush();

		LeaveCriticalSection(&id->m_csArptRangeRing);
	}
	return(SUCCEED);
}

void drawTrailLabels(struct InstanceData* id, AIR **airp, int aircount, int tcheck, time_t airplottime, int nTrailCount, int nFeedType)
{
	GLfloat white[3] = { 1.0, 1.0, 1.0 };
	int i, trk, tc;
	PTRACK *trackarr;
	double x2, y2;
	time_t endutc;
	time_t cursec;
	int pflag = 0;
	int TrackStart;
	AIR *air;

	cursec = time(0);

	if (id->m_sCurLayout.m_dWorldXSize > TRAIL_LABEL_WORLD_SIZE){
		/* too large to bother with flight names */
		return;
	}

	if (nTrailCount <= 0){
		return;
	}

	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glColor3fv(darkpurple);

	for (i = 0; airp && i < aircount; i++){
		if (!(air = airp[i])){
			/* no tracks yet */
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}
		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( SAT_ASDEX == nFeedType /*&& id->m_sCurLayout.m_bShowADSBAircraft*/ && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( SAT_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if ( SAT_PASSUR == nFeedType && air->IsTracked ){
			if ((air->IsTracked & SAT_ASDEX || air->IsTracked & SAT_MLAT)) {
				if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT){
					/* ASDEX is tracking this aircraft but show when zoom level is beyond ASDEX */
					continue;
				}
			}
			else{
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if ( SAT_ASDI == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}

		if ((SAT_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}

		if (clipaircraft(id, air)) {
			continue;
		}
		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {
				if (!air->vehicle && filtermatch(id, air) < 0) {
					if ((SAT_ASDEX != nFeedType && SAT_MLAT != nFeedType) || !id->m_nAllSurface)
						continue;
				}
		}

		if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
			continue;

		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (SAT_ASDEX == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;
		if (SAT_MLAT == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > MLAT_LKP_TRACK_TIMEOUT))
			continue;

		if (air->tcount < 2){
			/* first point */
			/* do not plot yet */
			continue;
		}

		TrailLabelColor = darkpurple;
		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
			&& id->m_nSelectedTrackID == air->trackid){
			/* selected aircraft is displayed at bottom */
			id->m_nSelectedAirIndex = i;
			TrailLabelColor = (GLfloat *)red;
		}

		/* make first index current location of aircraft */
		x2 = air->X;
		y2 = air->Y;

		// for (trk = TrackVO->count - 1, tcount = 0; trk >= 0; trk-- ){
		TrackStart = air->TrackStart;
		for (trk = TrackStart + 1, tc = 0; trk >= 0; trk--){
			endutc = trackarr[trk].utc;

			// This check prevents data points ahead of plottime from displaying
			if (!tcheck || airplottime >= endutc){

				x2 = trackarr[trk].x;
				y2 = trackarr[trk].y;

				drawTrailLabel(id, x2, y2, endutc);

			}
			tc++;
			if (tc > nTrailCount){
				break;
			}
		}

	}
	glFlush();

	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}


double CalcDistance(struct InstanceData* id, AIR *air)
{
	char *arpt;
	double lat1, lat2, lng1, lng2, tmprads, dis;
	ARPT *Arpt;


	// calculate the distance from aircraft to it's destination
	// uses great circle algorithm which can be off about 10 miles per 2500mi difference
	/*
	L1 = latitude at the first point (degrees)
	L2 = latitude at the second point (degrees)
	G1 = longitude at the first point (degrees)
	G2 = longitude at the second point (degrees)
	DG = longitude of the second point minus longitude of the first point (degrees)
	DL = latitude of the second point minus latitude of the first point (degrees)
	D = computed distance (km)
	*/
	// Great Circle Distance (Based on Spherical trigonometry)

	/* This method calculates the great circle distance, is based on spherical trigonometry, and assumes that:

	* 1 minute of arc is 1 nautical mile
	* 1 nautical mile is 1.852 km

	D = 1.852 * 60 * ARCOS ( SIN(L1) * SIN(L2) + COS(L1) * COS(L2) * COS(DG))

	Note: If your calculator returns the ARCOS result as radians you will have to convert the radians
	to degrees before multiplying by 60 and 1.852 degrees = (radians/PI)*180, where PI=3.141592654...
	*/

	//if ( !strcasecmp(VP(AirVO, i, "FltNum", char ), "EJA708" ) ){
	//  dis = 0.0;//dummy
	//}

	// find airport lat/lon of destination
	if (!(arpt = air->Destin) || !strlen(arpt)){
		return(0.0);
	}

	//if ( strlen( arpt ) == 4 ){
	// arpt++;
	//}

	if (!(Arpt = FindArptRow(id, arpt, MATCH_ALL))){
		// could not find arpt
		return(0.0);
	}

	lat1 = Arpt->lat;
	lng1 = Arpt->lng;
	lat2 = air->Y;
	lng2 = air->X;

	tmprads = acos(sin(RADS(lat1)) * sin(RADS(lat2)) + cos(RADS(lat1)) * cos(RADS(lat2)) * cos(RADS(lng2 - lng1)));

	dis = 60.0 * DEGS(tmprads); // NM

	air->DestDis = (GLfloat)dis;
	return(dis);

}


void SetAircraftCorner(struct InstanceData* id, int actualx, int actualy, char GridUsed[MAX_X_GRIDS][MAX_Y_GRIDS])
{
	int xgrid, ygrid;

	xgrid = actualx / id->m_nGridXSize;
	ygrid = actualy / id->m_nGridYSize;

	if (xgrid >= id->m_nNumXGrids){
		// xgrid = NumXGrids - 1;
		return;
	}
	if (ygrid >= id->m_nNumYGrids){
		// ygrid = NumYGrids - 1;
		return;
	}

	if (xgrid < 0 || ygrid < 0){
		return;
	}
	GridUsed[xgrid][ygrid] = TRUE;

}

void SetGrid(struct InstanceData* id, int actualx, int actualy, char GridUsed[MAX_X_GRIDS][MAX_Y_GRIDS])
{

	// adjust back to actual location of aircraft
	actualx -= (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER);

	/* set up to 4 grids , one for each corner of aircraft */


	actualx -= id->m_sCurLayout.m_nAircraftSize / 2;
	actualy -= id->m_sCurLayout.m_nAircraftSize / 2;
	SetAircraftCorner(id, actualx, actualy, GridUsed);

	actualx += id->m_sCurLayout.m_nAircraftSize;
	SetAircraftCorner(id, actualx, actualy, GridUsed);

	actualy += id->m_sCurLayout.m_nAircraftSize;
	SetAircraftCorner(id, actualx, actualy, GridUsed);

	actualy -= id->m_sCurLayout.m_nAircraftSize;
	SetAircraftCorner(id, actualx, actualy, GridUsed);
}


double CalcAngle(struct InstanceData* id, AIR *air, int IsASD)
{
	PTRACK *trackarr;
	double y2, y1, x2, x1, rads, degrees, curdegrees, AngleDiff, TimeDiff, startmsecs;
	GLfloat PrevAngle;
	int TrackStart, tcount;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int count, testflag = FALSE;
	static char *testflight = NULL;
	static int use_extrap = TRUE, SmoothTurns = FALSE;

	if (!use_extrap || !IsASD){
		if (!(trackarr = air->TrackPtr)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not calculate angle\n", cdwThreadId);
			return(-999.0);
		}
		TrackStart = air->TrackStart;
		if (TrackStart < 0){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad air structure\n", cdwThreadId);
			return(-9999.0);
		}
		tcount = air->tcount;
		if (tcount < 2){
			/* first point */
			return(-999.0);
		}
		y2 = trackarr[TrackStart + 1].y;
		y1 = trackarr[TrackStart].y;
		x2 = trackarr[TrackStart + 1].x;
		x1 = trackarr[TrackStart].x;
	} else {
		x1 = air->X1;
		x2 = air->X2;
		y1 = air->Y1;
		y2 = air->Y2;
	}


	rads = atan2(y2 - y1, x2 - x1);
	degrees = rads * 180 / M_PI;

	if (SmoothTurns){
		// make smooth changes in angle
		if (IsASD && id->m_dPlotMSecs < (startmsecs = air->StartMSECS) + 5000.0){
			PrevAngle = air->PrevAngle;
			AngleDiff = degrees - PrevAngle;
			TimeDiff = 5000.0;  /* reach full turn in 5 seconds */

			curdegrees = ((id->m_dPlotMSecs - startmsecs) * AngleDiff / TimeDiff) + PrevAngle;
			if (testflag && testflight){
				if (strcmp(air->FltNum, testflight)){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) degrees=%f\n", cdwThreadId, curdegrees);
				}
			}
			return(curdegrees);
		}
	}

	air->PrevAngle = (GLfloat)degrees;
	return(degrees);
}





int drawADSBAircraft(struct InstanceData* id, AIR **airp, int dataonly)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail, nAcType;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int drawcolor, activecount,test;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;
	extern int coloraircraft(struct InstanceData* id, char* flightnum, char *destination, char *Region);

	D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));

	if (!id->m_bIconsLoaded) {
		D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}
	if (!id->m_sCurLayout.m_bShowADSBAircraft){
		D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Return - ADS-B feed is disabled.\n", cdwThreadId));
		// only process the data from the adsb feed if enabled
		return(SUCCEED);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;

	filfail = 0;
	filpass = 0;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_ADSB_TRACK_ID; i++){
		drawcolor = 14; // default
		if (!(air = airp[i])){
			// no tracks yet
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}
		// Show Selected ADS-B Aircraft only (someone did FindFlight and ADS-B is OFF)
		if (!id->m_sCurLayout.m_bShowADSBAircraft){
			if (!(SAT_ADSB == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}

		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ADSB only set interpolation to TRUE for replays
			if (AirScreenPos(id, airp, i, TRUE) == FALSE){
				continue;
			}
		} else {
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		}

		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change == 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change == 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check != 100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}

	t2:	if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
			&& id->m_nSelectedTrackID == air->trackid){
			// selected aircraft, always draw
			if (pflag){
				//PrintTracks( id, air, NOISE );
			}
			drawcolor = 4;
		} else if ( UseADSBFilters ){
			if (clipaircraft(id, air)) {
				filfail++;
				continue;
			}
			if ((drawcolor = filtermatch(id, air)) < 0){
				filfail++;
				continue;
			}
		} else {
			// not filters adsb flights
			drawcolor = 5;
		}

	t1:	 if (UseADSBFilters)
	{
		if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
			drawcolor = id->m_selectedaircraftcolor;
		else
		{
				test = filtermatch(id, air);
				if (test < 0)
					continue;
		}
	}
		
		if (!strlen(air->DivDestin) && REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
			GetDivertedDestination(id, air->FltNum, air->DivDestin);
		}

		filpass++;

		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );
		CalcDistance(id, air);

		utc = air->utc;

		// We used to have a longer timeout for replays, but that will not work well because 
		//   we need the adsb tracks to go away if they are stale so that passur will display
#ifdef OLDWAY
		if ( !GDelaySecs && ( (plottime - utc) > PASSUR_TRACK_TIMEOUT) ){
			RemoveTrack( id, airp, i, TRUE );
			continue;
		} else if ( GDelaySecs && ( (plottime - utc) > PASSUR_REPLAY_TIMEOUT) ){
			// replay mode, use larger PASSUR_REPLAY_TIMEOUT
			RemoveTrack( id, airp, i, TRUE );
			continue;
		}
#endif
		if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > ADSB_TRACK_TIMEOUT)){
			D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ADSB Track Timeout <%d:%d> ADSB TIMEOUT <%d> \n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, ADSB_TRACK_TIMEOUT));
			RemoveTrack(id, airp, i, ADSB, TRUE);
			continue;
		} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > PASSUR_REPLAY_TIMEOUT) ){
			// replay mode, use larger PASSUR_REPLAY_TIMEOUT
			D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ADSB Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, PASSUR_REPLAY_TIMEOUT));
			RemoveTrack(id, airp, i, ADSB, TRUE);
			continue;
		}


		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}

		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("ADSB_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s from %s[%d]\n",
			cdwThreadId, air->FltNum, g_arFeedTypes[ADSB], i));
		D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, TIME:%d\n",
			cdwThreadId, air->FltNum, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); // move center so it doesn't draw on top of aircraft

		if (id->m_sCurLayout.m_bShowLargeTags){
			SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
		}

		glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);
		if ((angle = (GLfloat)CalcAngle(id, air, FALSE)) < -1000.0){
			// we got a bad air struct
			D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);
			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);
			glEnd();
			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}

	D_CONTROL("ADSB_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}

int drawAirAsiaAircraft(struct InstanceData* id, AIR **airp, int dataonly)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail, nAcType;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int drawcolor, activecount;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;

	D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));

	if (!id->m_bIconsLoaded) {
		D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}

	if (!id->m_sCurLayout.m_bShowAirAsiaAircraft){
		D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Return - AirAsia feed is disabled.\n", cdwThreadId));
		// only process the data from the adsb feed if enabled
		return(SUCCEED);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;

	filfail = 0;
	filpass = 0;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_AIRASIA_TRACK_ID; i++){
		drawcolor = 14; // default
		if (!(air = airp[i])){
			// no tracks yet
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}
		// Show Selected AirAsia Aircraft only (someone did FindFlight and ADS-B is OFF)
		if (!id->m_sCurLayout.m_bShowAirAsiaAircraft){
			if (!(SAT_AIRASIA == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}

		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ADSB only set interpolation to TRUE for replays
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		} else {
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		}

		
		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
			&& id->m_nSelectedTrackID == air->trackid){
			// selected aircraft, always draw
			if (pflag){
				//PrintTracks( id, air, AIRASIA );
			}
			drawcolor = 4;
		} else if ( UseAirAsiaFilters ){
			if (clipaircraft(id, air)) {
				filfail++;
				continue;
			}
			if ((drawcolor = filtermatch(id, air)) < 0){
				filfail++;
				continue;
			}
		} else {
			// not filters adsb flights
			drawcolor = 5;
		}

		if (!strlen(air->DivDestin) && REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
			GetDivertedDestination(id, air->FltNum, air->DivDestin);
		}

		filpass++;

		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );
		CalcDistance(id, air);

		utc = air->utc;

		if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > AIRASIA_TRACK_TIMEOUT)){
			D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s,%s[%d]>, Reason: AirAsia Track Timeout <%d:%d> AIRASIA TIMEOUT <%d> \n",
				cdwThreadId, air->FltNum, air->tail, air->trackid, id->m_tPlotTime - utc, air->utc, AIRASIA_TRACK_TIMEOUT));
			RemoveTrack(id, airp, i, AIRASIA, TRUE);
			continue;
		} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > AIRASIA_TRACK_TIMEOUT) ){
			// replay mode, use larger AIRASIA_TRACK_TIMEOUT
			D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s,%s[%d]>, Reason: AirAsia Replay Timeout <%d> AIRASIA TIMEOUT <%d>.\n",
				cdwThreadId, air->FltNum, air->tail, air->trackid, id->m_tPlotTime - utc, AIRASIA_TRACK_TIMEOUT));
			RemoveTrack(id, airp, i, AIRASIA, TRUE);
			continue;
		}


		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}

		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("AIRASIA_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s from %s[%d]\n",
			cdwThreadId, air->FltNum, g_arFeedTypes[AIRASIA], i));
		D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, TIME:%d\n",
			cdwThreadId, air->FltNum, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); // move center so it doesn't draw on top of aircraft

		if (id->m_sCurLayout.m_bShowLargeTags){
			SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
		}

		glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);
		if ((angle = (GLfloat)CalcAngle(id, air, FALSE)) < -1000.0){
			// we got a bad air struct
			D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);
			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);
			glEnd();
			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}

	D_CONTROL("AIRASIA_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}

int drawMLATAircraft(struct InstanceData* id, AIR **airp, int dataonly)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail, nAcType;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int drawcolor, activecount,test;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;
	extern int coloraircraft(struct InstanceData* id, char* flightnum, char *destination, char *Region);
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;
	D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));

	if (!id->m_bIconsLoaded) {
		D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}

	if (!id->m_sCurLayout.m_bShowMLATAircraft){
		D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) M-LAT feed is disabled.\n", cdwThreadId));
		// only process the data from the adsb feed if enabled
		return(SUCCEED);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);


	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;

	filfail = 0;
	filpass = 0;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_MLAT_TRACK_ID; i++){
		drawcolor = 14; // default
		if (!(air = airp[i])){
			// no tracks yet
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}

		if ( air->IsTracked ){
			/* ADSB or ASDEX are tracking this aircraft */
			continue;
		}
		// Show Selected ADS-B Aircraft only (someone did FindFlight and ADS-B is OFF)
		if (!id->m_sCurLayout.m_bShowMLATAircraft){
			if (!(SAT_ADSB == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}

		if( id->m_sCurLayout.m_dWorldXSize >= 1.0 && air->evnoddc & 0x02 ) {
			// Don't draw surface aircraft
			continue;
		}
		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ADSB only set interpolation to TRUE for replays
			if (AirScreenPos(id, airp, i, TRUE) == FALSE){
				continue;
			}
		} else {
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		}


		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change_MLAT == 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin,air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;								
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change_MLAT == 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check !=100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}
	t2:	if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// selected aircraft, always draw
		if (pflag){
			//PrintTracks( id, air, MLAT );
		}
		drawcolor = 4;
		} else if ( UseADSBFilters ){
			if (clipaircraft(id, air)) {
				filfail++;
				continue;
			}
			if ((drawcolor = filtermatch(id, air)) < 0){
				filfail++;
				if (!id->m_nAllSurface)
					continue;
				drawcolor = 16;
			}
		} else {
			// not filters adsb flights
			drawcolor = 5;
		}

	

	t1:if (UseADSBFilters)
	{
		if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
			drawcolor = id->m_selectedaircraftcolor;
		else
		{
				test = filtermatch(id, air);
				if (test < 0)
					continue;
		}
	}
		if (!strlen(air->DivDestin) && REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
		GetDivertedDestination(id, air->FltNum, air->DivDestin);
	}

		filpass++;

		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );
		CalcDistance(id, air);

		utc = air->utc;

		if (air->InRegion){
			if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > MLAT_INREGION_TRACK_TIMEOUT)){
				D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: MLAT INREGION Track Timeout <%d:%d> MLAT_INREGION_TRACK_TIMEOUT <%d> \n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, MLAT_INREGION_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, MLAT, TRUE);
				continue;
			} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > MLAT_INREGION_TRACK_TIMEOUT) ){
				// replay mode, use larger PASSUR_REPLAY_TIMEOUT
				D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: MLAT INREGION Replay Timeout <%d> MLAT_INREGION_TRACK_TIMEOUTT <%d>.\n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, MLAT_INREGION_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, MLAT, TRUE);
				continue;
			}
		}else{
			if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > MLAT_TRACK_TIMEOUT)){
				D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: MLAT Track Timeout <%d:%d> MLAT TIMEOUT <%d> \n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, MLAT_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, MLAT, TRUE);
				continue;
			} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > MLAT_TRACK_TIMEOUT) ){
				// replay mode, use larger PASSUR_REPLAY_TIMEOUT
				D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: MLAT Replay Timeout <%d> MLAT_TRACK_TIMEOUT <%d>.\n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, MLAT_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, MLAT, TRUE);
				continue;
			}
		}

		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (!id->m_sUserSettings.LKP && ((id->m_tPlotTime - utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;

		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}

		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("MLAT_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s from %s[%d]\n",
			cdwThreadId, air->FltNum, g_arFeedTypes[MLAT], i));
		D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, TIME:%d\n",
			cdwThreadId, air->FltNum, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); // move center so it doesn't draw on top of aircraft

		if (id->m_sCurLayout.m_bShowLargeTags){
			SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
		}

		glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);
		if ((angle = (GLfloat)CalcAngle(id, air, FALSE)) < -1000.0){
			// we got a bad air struct
			D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);
			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);
			glEnd();
			glFlush();

			if (ALERT_NONE != air->alert){
				GLfloat Size = AirSize;// + (1.1f * AirSize);
				glDisable(GL_TEXTURE_2D);
				switch (air->alert_level){
				case ALERT_LEVEL_LOW: glColor3fv((GLfloat*)green);
					break;
				case ALERT_LEVEL_MED: glColor3fv((GLfloat*)yellow);
					break;
				case ALERT_LEVEL_HIGH: glColor3fv((GLfloat*)red);
					break;
				}
				glLineWidth(2);
				glBegin(GL_LINE_LOOP);
				glVertex3f((GLfloat)-Size, (GLfloat)-Size, 0.0f);
				glVertex3f((GLfloat)-Size, (GLfloat)Size, 0.0f);
				glVertex3f((GLfloat)Size, (GLfloat)Size, 0.0f);
				glVertex3f((GLfloat)Size, (GLfloat)-Size, 0.0f);
				glEnd();
				glEnable(GL_TEXTURE_2D);
			}

			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}
	
	if (SecondTabGrid)
		SecondTabGrid->aircraftcolor_change_MLAT = 0;
	D_CONTROL("MLAT_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}

int drawLMGVehicles( struct InstanceData* id, AIR **airp, int dataonly )
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int drawcolor, activecount;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;


	D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));

	if( !id->m_sCurLayout.m_bShowASDEXAircraft ){
		D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Return - Asdex/LMG feed is disabled.\n", cdwThreadId));
		// only process the data from the asdex feed if enabled
		return( SUCCEED );
	}
	
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, 
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin, 
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float) (id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if ( AirSize > 1.5 ) AirSize = 1.5;

	filfail = 0;
	filpass = 0;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_PASSUR_TRACK_ID; i++ ){
		drawcolor = 14; // default
		if ( !(air = airp[i]) ){
			// no tracks yet
			continue;
		}
		if ( !(trackarr = air->TrackPtr) ){
			// no tracks yet
			continue;
		}
		// Show Selected ASDE-X Aircraft only (someone did FindFlight and ASDE-X is OFF)
		if(!id->m_sCurLayout.m_bShowASDEXAircraft){
			if(!(SAT_ASDEX == id->m_nSelectedAircraftType && id->m_pSelectedAircraft && 
				!strcmp( air->FltNum, id->m_pSelectedAircraft ) && id->m_nSelectedTrackID == air->trackid) )
				continue;
		}
		// Look for Unknowns (Vehicles)
		if((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr)){
			if(!(SAT_ASDEX == id->m_nSelectedAircraftType && id->m_pSelectedAircraft && 
				!strcmp( air->FltNum, id->m_pSelectedAircraft ) && id->m_nSelectedTrackID == air->trackid) )

				// Check for removal of old vehicle tracks regardless of whether we draw it.
				if ( !id->m_nDelaySecs && ( (id->m_tPlotTime - air->utc) > ASDEX_TRACK_TIMEOUT) ){
					D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing vehicle track<%s[%d]>, Reason: ASDEX Track Timeout <%d:%d> ASDEX TIMEOUT <%d> \n",
						cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - air->utc, air->utc, ASDEX_TRACK_TIMEOUT));
					RemoveTrack( id, airp, i, ASDEX, TRUE );
				} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - air->utc) > ASDEX_TRACK_TIMEOUT) ){
					// replay mode, use larger PASSUR_REPLAY_TIMEOUT
					D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing vehicle track<%s[%d]>, Reason: ASDEX Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
						cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - air->utc, ASDEX_TRACK_TIMEOUT));
					RemoveTrack( id, airp, i, ASDEX, TRUE );
				}

				continue;
		}
		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ASDEX only set interpolation to TRUE for replays
			// MCT - Removed, interpolation drops the tracks entirely
			if ( AirScreenPos( id, airp, i, FALSE ) == FALSE ){
				continue;
			}
		} else {
			if ( AirScreenPos( id, airp, i, FALSE ) == FALSE ){
				continue;
			}
		}

		if ( id->m_pSelectedAircraft && !strcmp( air->FltNum, id->m_pSelectedAircraft )
			&& id->m_nSelectedTrackID == air->trackid ){
				// selected aircraft, always draw
				if ( pflag ){
					//PrintTracks( id, air,LMG );
				}
				drawcolor = 4;
		} else if ( UseASDEXFilters ){
			if ( clipaircraft( id, air ) ) {
				filfail++;
				continue;
			}
			if ( !air->vehicle && (drawcolor = filtermatch( id, air )) < 0 ){
				filfail++;
				if(!id->m_nAllSurface)
					continue;
				drawcolor = 16;
			}
		} else {
			// not filters asdex flights
			drawcolor = 5;
		}

		filpass++;		

		if(air->vehicle) {
			drawcolor = id->m_nVColorIndex;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Vehicle Texture[%d].\n", cdwThreadId, drawcolor);
			glBindTexture( GL_TEXTURE_2D, id->m_gluVehicleTextures[drawcolor] );
		}else{
			continue;
		}
		CalcDistance( id, air );

		utc = air->utc;

		if ( !id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > ASDEX_TRACK_TIMEOUT) ){
			D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ASDEX Track Timeout <%d:%d> ASDEX TIMEOUT <%d> \n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, ASDEX_TRACK_TIMEOUT));
			RemoveTrack( id, airp, i, ASDEX, TRUE );
			continue;
		} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > ASDEX_TRACK_TIMEOUT) ){
			// replay mode, use larger PASSUR_REPLAY_TIMEOUT
			D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ASDEX Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, ASDEX_TRACK_TIMEOUT));
			RemoveTrack( id, airp, i, ASDEX, TRUE );
			continue;
		}		
	
		if ( !(trackarr = air->TrackPtr) ){
			// no tracks yet
			continue;
		}

		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("LMG_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing vehicle %s[%d] from %s[%d], tracked(%d)\n", 
			cdwThreadId, air->FltNum, air->trackid, g_arFeedTypes[ASDEX], i, air->IsTracked ));
		D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing vehicle UID:%s[%d], LAT:%f, LON:%f, TIME:%d\n", 
			cdwThreadId, air->FltNum, air->trackid, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int) rint( (y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight );
		xpixel = (int) rint( (x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth );
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER) ; // move center so it doesn't draw on top of aircraft

		if ( id->m_sCurLayout.m_bShowLargeTags ){
			SetGrid( id, xpixel, ypixel, id->m_arGridAircraftUsed );
		}

		glTranslatef( (GLfloat) x, (GLfloat) y, (GLfloat) trans[2] );
		if ( (angle = (GLfloat) CalcAngle(id,  air, FALSE )) < -1000.0 ){
			// we got a bad air struct
			D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, angle:%f\n", 
				cdwThreadId, air->FltNum, air->Y, air->X, angle));
			glRotatef( (GLfloat) angle, 0.0f, 0.0f, 1.0f );
			
			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) -AirSize, (GLfloat) -AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) -AirSize, (GLfloat) AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat) AirSize, (GLfloat) AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat) AirSize, (GLfloat) -AirSize, 0.0f);
			glEnd();
			glFlush();
			
			if(ALERT_NONE != air->alert){
				GLfloat Size = AirSize;// + (1.1f * AirSize);
				glDisable(GL_TEXTURE_2D);
				switch(air->alert_level){
				case ALERT_LEVEL_LOW: glColor3fv( (GLfloat*)green );
					break;
				case ALERT_LEVEL_MED: glColor3fv( (GLfloat*)yellow );
					break;
				case ALERT_LEVEL_HIGH: glColor3fv( (GLfloat*)red );
					break;
				}
				glLineWidth(2);
				glBegin(GL_LINE_LOOP);
				glVertex3f((GLfloat) -Size, (GLfloat) -Size, 0.0f);
				glVertex3f((GLfloat) -Size, (GLfloat) Size, 0.0f);
				glVertex3f((GLfloat) Size, (GLfloat) Size, 0.0f);
				glVertex3f((GLfloat) Size, (GLfloat) -Size, 0.0f);
				glEnd();
				glEnable(GL_TEXTURE_2D);
			}

			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}

	D_CONTROL("LMG_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP ));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return( SUCCEED );
}

int drawASDEXAircraft(struct InstanceData* id, AIR **airp, int dataonly)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int drawcolor, activecount,test;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;


	D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));

	if (!id->m_bIconsLoaded) {
		D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}

	if (!id->m_sCurLayout.m_bShowASDEXAircraft){
		D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Return - Asdex feed is disabled.\n", cdwThreadId));
		// only process the data from the asdex feed if enabled
		return(SUCCEED);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;

	filfail = 0;
	filpass = 0;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_PASSUR_TRACK_ID; i++){
		drawcolor = 14; // default
		if (!(air = airp[i])){
			// no tracks yet
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}
		if (air->IsTracked){
			/* ADSB is tracking this aircraft */
			continue;
		}
		// Show Selected ASDE-X Aircraft only (someone did FindFlight and ASDE-X is OFF)
		if (!id->m_sCurLayout.m_bShowASDEXAircraft){
			if (!(SAT_ASDEX == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}
		// Look for Unknowns (Vehicles)
		if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr)){
			if (!(SAT_ASDEX == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))

				// Check for removal of old vehicle tracks regardless of whether we draw it.
				if (!id->m_nDelaySecs && ((id->m_tPlotTime - air->utc) > ASDEX_TRACK_TIMEOUT)){
					D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing vehicle track<%s[%d]>, Reason: ASDEX Track Timeout <%d:%d> ASDEX TIMEOUT <%d> \n",
						cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - air->utc, air->utc, ASDEX_TRACK_TIMEOUT));
					RemoveTrack(id, airp, i, ASDEX, TRUE);
				} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - air->utc) > ASDEX_TRACK_TIMEOUT) ){
					// replay mode, use larger PASSUR_REPLAY_TIMEOUT
					D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing vehicle track<%s[%d]>, Reason: ASDEX Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
						cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - air->utc, ASDEX_TRACK_TIMEOUT));
					RemoveTrack(id, airp, i, ASDEX, TRUE);
				}

				continue;
		}
		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ASDEX only set interpolation to TRUE for replays
			// MCT - Removed, interpolation drops the tracks entirely
			if (AirScreenPos(id, airp, i, FALSE /*TRUE*/) == FALSE){
				continue;
			}
		} else {
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		}


		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change_ASDEX == 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;								
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change_ASDEX== 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check != 100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}
	t2:	if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// selected aircraft, always draw
		if (pflag){
			//PrintTracks( id, air, ASDEX );
		}
		drawcolor = 4;
		} else if ( UseASDEXFilters ){
			if (clipaircraft(id, air)) {
				filfail++;
				continue;
			}
			if (!air->vehicle && (drawcolor = filtermatch(id, air)) < 0){
				filfail++;
				if (!id->m_nAllSurface)
					continue;
				drawcolor = 16;
		}
		} else {
			// not filters asdex flights
			drawcolor = 5;
		}

		filpass++;


	t1: if (UseASDEXFilters)
	{
		if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
			drawcolor = id->m_selectedaircraftcolor;
		else
		{
			if (!air->vehicle)
			{
					test = filtermatch(id, air);
					if (test < 0 && !id->m_nAllSurface)
						continue;
			}
		}
	}
		if(air->vehicle) {
			drawcolor = id->m_nVColorIndex;
			D_CONTROL("VEHICLE_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Vehicle Texture[%d].\n", cdwThreadId, drawcolor));
			glBindTexture( GL_TEXTURE_2D, id->m_gluVehicleTextures[drawcolor] );
		}else{
			int nAcType = GetAcType(id, air->actype);
			D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
			glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );
		}
		CalcDistance(id, air);

		utc = air->utc;

		// We used to have a longer timeout for replays, but that will not work well because 
		//   we need the asdex tracks to go away if they are stale so that passur will display
#ifdef OLDWAY
		if ( !GDelaySecs && ( (plottime - utc) > PASSUR_TRACK_TIMEOUT) ){
			RemoveTrack( id, airp, i, TRUE );
			continue;
		} else if ( GDelaySecs && ( (plottime - utc) > PASSUR_REPLAY_TIMEOUT) ){
			// replay mode, use larger PASSUR_REPLAY_TIMEOUT
			RemoveTrack( id, airp, i, TRUE );
			continue;
		}
#endif
		if (air->InRegion){
			if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > ASDEX_INREGION_TRACK_TIMEOUT)){
				D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ASDEX INREGION Track Timeout <%d:%d> ASDEX TIMEOUT <%d> \n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, ASDEX_INREGION_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, ASDEX, TRUE);
				continue;
			} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > ASDEX_INREGION_TRACK_TIMEOUT) ){
				// replay mode, use larger PASSUR_REPLAY_TIMEOUT
				D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ASDEX INREGION Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, ASDEX_INREGION_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, ASDEX, TRUE);
				continue;
			}
		}else{
			if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > ASDEX_TRACK_TIMEOUT)){
				D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ASDEX Track Timeout <%d:%d> ASDEX TIMEOUT <%d> \n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, ASDEX_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, ASDEX, TRUE);
				continue;
			} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > ASDEX_TRACK_TIMEOUT) ){
				// replay mode, use larger PASSUR_REPLAY_TIMEOUT
				D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: ASDEX Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
					cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, ASDEX_TRACK_TIMEOUT));
				RemoveTrack(id, airp, i, ASDEX, TRUE);
				continue;
			}
		}

		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (!id->m_sUserSettings.LKP && ((id->m_tPlotTime - utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;

		if (!strlen(air->DivDestin) && REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
			GetDivertedDestination(id, air->FltNum, air->DivDestin);
		}

		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}
		
		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("ASDEX_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s[%d] from %s[%d], tracked(%d)\n",
			cdwThreadId, air->FltNum, air->trackid, g_arFeedTypes[ASDEX], i, air->IsTracked));
		D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s[%d], LAT:%f, LON:%f, TIME:%d\n",
			cdwThreadId, air->FltNum, air->trackid, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); // move center so it doesn't draw on top of aircraft

		if (id->m_sCurLayout.m_bShowLargeTags){
			SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
		}

		glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);
		if ((angle = (GLfloat)CalcAngle(id, air, FALSE)) < -1000.0){
			// we got a bad air struct
			D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, angle:%f\n",
				cdwThreadId, air->FltNum, air->Y, air->X, angle));
			glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);

			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);
			glEnd();
			glFlush();

			if (ALERT_NONE != air->alert){
				GLfloat Size = AirSize;// + (1.1f * AirSize);
				glDisable(GL_TEXTURE_2D);
				switch (air->alert_level){
				case ALERT_LEVEL_LOW: glColor3fv((GLfloat*)green);
					break;
				case ALERT_LEVEL_MED: glColor3fv((GLfloat*)yellow);
					break;
				case ALERT_LEVEL_HIGH: glColor3fv((GLfloat*)red);
					break;
				}
				glLineWidth(2);
				glBegin(GL_LINE_LOOP);
				glVertex3f((GLfloat)-Size, (GLfloat)-Size, 0.0f);
				glVertex3f((GLfloat)-Size, (GLfloat)Size, 0.0f);
				glVertex3f((GLfloat)Size, (GLfloat)Size, 0.0f);
				glVertex3f((GLfloat)Size, (GLfloat)-Size, 0.0f);
				glEnd();
				glEnable(GL_TEXTURE_2D);
			}

			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}
	
	if (SecondTabGrid)
		SecondTabGrid->aircraftcolor_change_ASDEX = 0;
	D_CONTROL("ASDEX_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}

int drawGateAircraft(struct InstanceData* id, AIR **airp, int dataonly)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail, nAcType;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int track_timeout = GATE_IN_TRACK_TIMEOUT;
	int drawcolor, activecount,test;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;
	
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;

	D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));
	
	if (!id->m_bIconsLoaded) {
		D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}

	if (!(id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowPassurAircraft)) {
		D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Return - ASDE-X and M-LAT feeds are disabled.\n", cdwThreadId));
		// only process the data from the asdex feed if enabled
		return(SUCCEED);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;

	filfail = 0;
	filpass = 0;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_TRACK_ID; i++){
		drawcolor = 14; // default
		if (!(air = airp[i])){
			// no tracks yet
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}
		if (air->IsTracked){
			/* ADSB is tracking this aircraft */
			continue;
		}
		// Show Selected ASDE-X Aircraft only (someone did FindFlight and ASDE-X is OFF)
		if (!(id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowPassurAircraft)) {
			if (!(SAT_ASDEX == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}
		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ASDEX only set interpolation to TRUE for replays
			// MCT - Removed, interpolation drops the tracks entirely
			if (AirScreenPos(id, airp, i, FALSE /*TRUE*/) == FALSE){
				continue;
			}
		} else {
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		}

		
	
		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change_Gate == 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;							
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change_Gate == 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check != 100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}
	t2:	if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// selected aircraft, always draw
		if (pflag){
			//PrintTracks( id, air, ASDEX );
		}
		drawcolor = 4;
		} else if ( UseASDEXFilters ){
			if (clipaircraft(id, air)) {
				filfail++;
				continue;
			}
			if (!air->vehicle && (drawcolor = filtermatch(id, air)) < 0){
				filfail++;
				if (!id->m_nAllSurface)
					continue;
				drawcolor = 16;
		}
		} else {
			// not filters asdex flights
			drawcolor = 5;
		}

		filpass++;

		// For Ease of determination between ASDEX and GATE, use blue drawcolor.
		if (IS_D_CONTROL("GATE_BLUE")){
			drawcolor = 0;
		}


	t1:if (UseASDEXFilters)
	{
		if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
			drawcolor = id->m_selectedaircraftcolor;
		else
		{
				test = filtermatch(id, air);
				if (test < 0)
					continue;
		}
	}
		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );

		utc = air->utc;

		if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > track_timeout)){
			D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: GATE Track Timeout <%d:%d> ASDEX TIMEOUT <%d> \n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, ASDEX_TRACK_TIMEOUT));
			RemoveTrack(id, airp, i, GATE, TRUE);
			continue;
		} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > track_timeout ) ){
			// replay mode, use larger PASSUR_REPLAY_TIMEOUT
			D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: GATE Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, PASSUR_REPLAY_TIMEOUT));
			RemoveTrack(id, airp, i, GATE, TRUE);
			continue;
		}

		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing Gated aircraft FLIGHT:%s[%d], LAT:%f, LON:%f, TIME:%d\n",
			cdwThreadId, air->FltNum, air->trackid, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); // move center so it doesn't draw on top of aircraft

		if (id->m_sCurLayout.m_bShowLargeTags){
			SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
		}

		glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);
		if ((angle = air->PrevAngle/*(GLfloat) CalcAngle(id,  air, FALSE )*/) < -1000.0){
			// we got a bad air struct
			D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, angle:%f\n",
				cdwThreadId, air->FltNum, air->Y, air->X, angle));
			glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);

			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);
			glEnd();
			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}
	
	if (SecondTabGrid)
		SecondTabGrid->aircraftcolor_change_Gate = 0;
	D_CONTROL("GATE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}


int drawNoiseAircraft(struct InstanceData* id, AIR **airp, int dataonly)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, nAcType;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	int drawcolor, activecount,test;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	missedP = 0;
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;
	

	D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ENTRY: id->m_nDelaySecs <%d>.\n", cdwThreadId, id->m_nDelaySecs));

	if (!id->m_bIconsLoaded) {
		D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}

	if (!id->m_sCurLayout.m_bShowNoiseAircraft){
		D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Return - Noise feed is disabled.\n", cdwThreadId));
		// only process the data from the adsb feed if enabled
		return(SUCCEED);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;

	air = NULL;
	for (i = 0, activecount = 0; airp && i < N_NOISE_TRACK_ID; i++){
		drawcolor = 14; // default
		if (!(air = airp[i])){
			// no tracks yet
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}
		// Show Selected NOISE Aircraft only (someone did FindFlight and ADS-B is OFF)
		if (!id->m_sCurLayout.m_bShowNoiseAircraft){
			if (!(SAT_NOISE == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}

		activecount++;

		// get position of aircraft for current second
		if (id->m_nDelaySecs) {
			// for ADSB only set interpolation to TRUE for replays
			if (AirScreenPos(id, airp, i, TRUE) == FALSE){
				continue;
			}
		} else {
			if (AirScreenPos(id, airp, i, FALSE) == FALSE){
				continue;
			}
		}

		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change_Noise== 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;							
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change_Noise== 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check != 100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}
	t2:	if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// selected aircraft, always draw
		if (IS_D_CONTROL(__FUNCTION__)){
			PrintTracks(id, air, GATE);
		}
		drawcolor = 4;
		} else {
			if (clipaircraft(id, air)) {
				continue;
			}
			if ((drawcolor = filtermatch(id, air)) < 0){
				continue;
			}
			//@@@ Currenly always use noise color flights
			drawcolor = 7;
		}


		


	t1:	if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
		drawcolor = id->m_selectedaircraftcolor;
		else
		{
				test = filtermatch(id, air);
				if (test < 0)
					continue;
		}

		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );
		CalcDistance(id, air);

		utc = air->utc;

		if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > NOISE_TRACK_TIMEOUT)){
			D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: NOISE Track Timeout <%d:%d> NOISE TIMEOUT <%d> \n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, air->utc, NOISE_TRACK_TIMEOUT));
			RemoveTrack(id, airp, i, NOISE, TRUE);
			continue;
		} else if ( id->m_nDelaySecs && ( (id->m_tPlotTime - utc) > PASSUR_REPLAY_TIMEOUT) ){
			// replay mode, use larger PASSUR_REPLAY_TIMEOUT
			D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: NOISE Replay Timeout <%d> PASSUR_REPLAY_TIMEOUT <%d>.\n",
				cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime - utc, PASSUR_REPLAY_TIMEOUT));
			RemoveTrack(id, airp, i, NOISE, TRUE);
			continue;
		}

		if (!(trackarr = air->TrackPtr)){
			// no tracks yet
			continue;
		}

		// solid with alpha masking
		glEnable(GL_DEPTH_TEST);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
		glDepthFunc(GL_LEQUAL);
		glPushMatrix();
		glLoadIdentity();

		// move to center of aircraft
		x = air->X;
		y = air->Y;

		D_CONTROL("NOISE_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s from %s[%d]\n",
			cdwThreadId, air->FltNum, g_arFeedTypes[NOISE], i));
		D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft FLIGHT:%s, LAT:%f, LON:%f, TIME:%d\n",
			cdwThreadId, air->FltNum, air->Y, air->X, id->m_tPlotTime));

		// convert X and Y from world to pixel coordinates
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize 
		xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); // move center so it doesn't draw on top of aircraft

		if (id->m_sCurLayout.m_bShowLargeTags){
			SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
		}

		glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);
		if ((angle = (GLfloat)CalcAngle(id, air, FALSE)) < -1000.0){
			// we got a bad air struct
			D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Bad air struct\n", cdwThreadId));
			glPopMatrix();
		} else {
			glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);
			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);
			glEnd();
			glFlush();
			glPopMatrix();
			drawcount++;
		}
	}
	
	if (SecondTabGrid)
		SecondTabGrid->aircraftcolor_change_Noise = 0;
	D_CONTROL("NOISE_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) color=%d, drawcount=%d missedP=%d\n", cdwThreadId, drawcolor, drawcount, missedP));
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}

//int coloraircraft_ASDEX(struct InstanceData* id, char* flightnum, char *destination)
//{
//	
//	
//	int aircount,t;	
//	char *FltNum, *Destination;
//	struct row_index *row_index;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	
//	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//	{
//		DataSource = VP(DataAppVO, t, "DataSource", char);
//		FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);	
//		if (FDOGrid)
//		{
//			if (FDOGrid->icon_set == 1)
//			{
//				if (FDOGrid->filteredvo){
//					row_index = vo_search(ColorASDEXAircraftVO, "FltNum", flightnum, NULL);
//					if (row_index)
//					{
//						FltNum = VP(ColorASDEXAircraftVO, ColorASDEXAircraftVO->row_index[row_index->rownum].rownum, "FltNum", char);
//						Destination = VP(ColorASDEXAircraftVO, ColorASDEXAircraftVO->row_index[row_index->rownum].rownum, "Destin", char);
//
//						if (strcmp(Destination, destination) == 0)
//						{
//							if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//								return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//						}
//						else
//							return 100;
//					}
//				}
//			}
//		}
//	}
//
//	return 100;
//}
//int coloraircraft_MLAT(struct InstanceData* id, char* flightnum, char *destination)
//{
//
//
//	int aircount, t;
//	char *FltNum, *Destination;
//	struct row_index *row_index;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//
//	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//	{
//		DataSource = VP(DataAppVO, t, "DataSource", char);
//		FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//		if (FDOGrid)
//		{
//			if (FDOGrid->icon_set == 1)
//			{
//				if (FDOGrid->filteredvo){
//					row_index = vo_search(ColorMLATAircraftVO, "FltNum", flightnum, NULL);
//					if (row_index)
//					{
//						FltNum = VP(ColorMLATAircraftVO, ColorMLATAircraftVO->row_index[row_index->rownum].rownum, "FltNum", char);
//						Destination = VP(ColorMLATAircraftVO, ColorMLATAircraftVO->row_index[row_index->rownum].rownum, "Destin", char);
//
//						if (strcmp(Destination, destination) == 0)
//						{
//							if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//								return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//						}
//						else
//							return 100;
//					}
//				}
//			}
//		}
//	}
//
//	return 100;
//}
//int coloraircraft_Gate(struct InstanceData* id, char* flightnum, char *destination)
//{
//
//
//	int aircount, t;
//	char *FltNum, *Destination;
//	struct row_index *row_index;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//
//	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//	{
//		DataSource = VP(DataAppVO, t, "DataSource", char);
//		FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//		if (FDOGrid)
//		{
//			if (FDOGrid->icon_set == 1)
//			{
//				if (FDOGrid->filteredvo){
//					row_index = vo_search(ColorGateAircraftVO, "FltNum", flightnum, NULL);
//					if (row_index)
//					{
//						FltNum = VP(ColorGateAircraftVO, ColorGateAircraftVO->row_index[row_index->rownum].rownum, "FltNum", char);
//						Destination = VP(ColorGateAircraftVO, ColorGateAircraftVO->row_index[row_index->rownum].rownum, "Destin", char);
//
//						if (strcmp(Destination, destination) == 0)
//						{
//							if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//								return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//						}
//						else
//							return 100;
//					}
//				}
//			}
//		}
//	}
//
//	return 100;
//}
//
//int coloraircraft_noise(struct InstanceData* id, char* flightnum, char *destination)
//{
//
//
//	int aircount, t;
//	char *FltNum, *Destination;
//	struct row_index *row_index;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//
//	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//	{
//		DataSource = VP(DataAppVO, t, "DataSource", char);
//		FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//		if (FDOGrid)
//		{
//			if (FDOGrid->icon_set == 1)
//			{
//				if (FDOGrid->filteredvo){
//					row_index = vo_search(ColorNoiseAircraftVO, "FltNum", flightnum, NULL);
//					if (row_index)
//					{
//						FltNum = VP(ColorNoiseAircraftVO, ColorNoiseAircraftVO->row_index[row_index->rownum].rownum, "FltNum", char);
//						Destination = VP(ColorNoiseAircraftVO, ColorNoiseAircraftVO->row_index[row_index->rownum].rownum, "Destin", char);
//
//						if (strcmp(Destination, destination) == 0)
//						{
//							if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//								return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//						}
//						else
//							return 100;
//					}
//				}
//			}
//		}
//	}
//
//	return 100;
//}
//int coloraircraft(struct InstanceData* id, char* flightnum, char *destination)
//{
//
//	int aircount, t;
//	char *FltNum, *Destination;
//	struct row_index *row_index;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//
//	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//	{
//		DataSource = VP(DataAppVO, t, "DataSource", char);
//		FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//		if (FDOGrid)
//		{
//			if (FDOGrid->icon_set == 1)
//			{
//				if (FDOGrid->filteredvo){
//					row_index = vo_search(ColorAircraftVO, "FltNum", flightnum, NULL);
//					if (row_index)
//					{
//						FltNum = VP(ColorAircraftVO, ColorAircraftVO->row_index[row_index->rownum].rownum, "FltNum", char);
//						Destination = VP(ColorAircraftVO, ColorAircraftVO->row_index[row_index->rownum].rownum, "Destin", char);
//
//						if (strcmp(Destination, destination) == 0)
//						{
//							if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//								return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//						}
//						else
//							return 100;
//					}
//				}
//			}
//		}
//	}
//
//	return 100;
//}

#ifdef OLD_SEARCH_EACH_ROW
for (i = 0; i < ROIGrid->filteredvo->count; i++){
	FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[i].rownum, "FltNum", char);
	Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[i].rownum, "Region", char);
	co = 0;
	count1 = 0;
	count2 = 0;
	while (FltNum[co] != '\0'){
		count1++;
		co++;
	}

	co = 0;

	while (Region[co] != '\0'){
		if (Region[co] == '-'){
			count2--;
		}
		if (Region[co] == ' ')
		{
			count2--;
		}

		count2++;
		co++;
	}


	Flightnum = (char *)malloc(count1 - count2 + 2);

	for (j = 0; j < (count1 - count2 + 1); j++)
		Flightnum[j] = 0;

	for (j = 0; j < (count1 - count2); j++)
	{
		Flightnum[j] = FltNum[j];

	}

	Flightnum[count1 - count2 + 1] = '\0';
	if (strcmp(Flightnum, flightnum) == 0)
		if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
			return ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
	free(Flightnum);
}

				
#endif



char *delchar(char *outbuf, int outbuflen, char str[], char ch) {
	int i, j = 0;
	int size;
	char ch1;


	size = strlen(str);


	for (i = 0; i < size && i < outbuflen; i++) {
		if (str[i] != ch) {
			ch1 = str[i];
			outbuf[j] = ch1;
			j++;
		}
	}
	outbuf[j] = '\0';

	// This function is not currently being used (and may not be complete), returning NULL
	return NULL;

}

//ARPT *Arpt;
//Arpts = calloc(sizeof(ARPT), GoodAirports);

//qsort((void *)Arpts, (size_t)ArptCount, sizeof(ARPT), compareArpt);


int compareFlut(const void *arg1, const void *arg2)
{
	FilteredLUT *Flut1, *Flut2;
	int res;


	Flut1 = (FilteredLUT *)arg1;
	Flut2 = (FilteredLUT *)arg2;

	if ((res = strcmp(Flut1->flightid, Flut2->flightid))){
		return(res);
	}
	else if ((res = strcmp(Flut1->destination, Flut2->destination ))){
		return(res);
	}

	return 0; // matched 
}

int compareFlut_roi(const void *arg1, const void *arg2)
{
	FilteredLUT *Flut1, *Flut2;
	int res;

	Flut1 = (FilteredLUT *)arg1;
	Flut2 = (FilteredLUT *)arg2;

	if ((res = strcmp(Flut1->flightid, Flut2->flightid))){
		return(res);
	}

	return 0; // matched 
}
FilteredLUT *CrFltNumFlut(VO *filteredvo)
{
	FilteredLUT *flut;
	int i;

	flut = calloc(sizeof(FilteredLUT), filteredvo->count );

	for (i = 0; i < filteredvo->count; i++){
		flut[i].filteredrownum = i;
		strncpy_s(flut[i].flightid, FLTNUM_SIZE, VP(filteredvo, i, "FltNum", char), FLTNUM_SIZE);
		strncpy_s(flut[i].destination, ORIG_DES_SIZE, VP(filteredvo, i, "Destin", char), ORIG_DES_SIZE);
	}

	qsort((void *)flut, (size_t)filteredvo->count, sizeof(FilteredLUT), compareFlut);

	return(flut);
}

FilteredLUT *CrFltNumFlut_roi(VO *filteredvo)
{
	FilteredLUT *flut;
	
	int i;
	
	//int region_length;

	flut = calloc(sizeof(FilteredLUT), filteredvo->count);
	
	for (i = 0; i < filteredvo->count; i++){
		flut[i].filteredrownum = i;		
		//strncpy(flut[i].flightidRegion, VP(filteredvo, i, "flightid", char), 40);	
		//flightnumber=VP(filteredvo, i, "flightid", char);
		//region= VP(filteredvo, i, "Region", char);
		//if (strcmp(region, "ASDE-X") == 0)
		//	strcpy(region, "ASDEX");
		//region_length = strlen(region);
		//flightregion_length = strlen(flightnumber);
		//flight_length = flightregion_length - region_length;
		//strcpy(flut[i].flightid, VP(filteredvo, i, "flightid", char), flight_length);

		strncpy_s(flut[i].flightid, FLTNUM_SIZE, VP(filteredvo, i, "flightid", char), FLTNUM_SIZE);
	}

	qsort((void *)flut, (size_t)filteredvo->count, sizeof(FilteredLUT), compareFlut_roi);

	return(flut);
}

int FltNumMatched(struct InstanceData* id, MGLGRID *ROIGrid, char *flightnum, char *destination)
{
	static char **result;
	FilteredLUT key;
	char *icaoarpt;
	
	struct row_index *row_index;

	strncpy_s(key.flightid, FLTNUM_SIZE, flightnum, FLTNUM_SIZE);

	if (!IATAAirportsVO || !IATAAirportsVO->count){
		// not retrieved from background thread yet
		return(FALSE);
	}
	icaoarpt = destination;
	if (strlen(destination) == 3){

		if ((row_index = vo_search(IATAAirportsVO, "iata", destination, NULL))){
			icaoarpt = VP(IATAAirportsVO, row_index->rownum, "icao", char);
		}
	}
	strncpy_s(key.destination, ORIG_DES_SIZE, icaoarpt, ORIG_DES_SIZE);

	result = (char **) bsearch((char *)&key, (char *)ROIGrid->Flut, ROIGrid->filteredvo->count,
		sizeof(FilteredLUT), (int(*)(const void*, const void*)) compareFlut);
	if (result){
		return(TRUE);
	}

	return(FALSE);
}

int FltNumMatched_roi(struct InstanceData* id, MGLGRID *ROIGrid, char *flightnumRegion)
{
	static char **result;
	FilteredLUT key;
	
	

	strncpy_s(key.flightid, 40, flightnumRegion, 40);
	
	
	result = (char **) bsearch((char *)&key, (char *)ROIGrid->Flut, ROIGrid->filteredvo->count,
		sizeof(FilteredLUT), (int(*)(const void*, const void*)) compareFlut_roi);
	if (result){
		return(TRUE);
}

	return(FALSE);
}


#ifdef OLD_FLTNUM_LOOP
for (i = 0; i < FDOGrid->filteredvo->count; i++){
	FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[i].rownum, "FltNum", char);
	Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[i].rownum, "Destin", char);
	strcpy_s(dest1, 7, "K");
	strcat(dest1, destination);
	if (strcmp(FltNum, flightnum) == 0)
	{
		if ((strcmp(Destination, destination) == 0) || (strcmp(Destination, dest1) == 0))
		{
			if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
				return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
			else
				return 100;
		}

	}

}

#endif

int coloraircraft(struct InstanceData* id, char* flightnum, char *destination,char *Region)
{
	int t;
	
	int count1 = 0;
	int count2 = 0;
	
	//char dest1[7];
	static int testspeedflag = 1;


	MGLGRID *ROIGrid = NULL;
	MGLGRID *FDOGrid = NULL;
	char *DataSource;
	VO *DataAppVO;
	char str[40];
	strcpy_s(str, 40, flightnum);
	if (Region)
	strcat_s(str, 40, Region);

	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
	{
		DataSource = VP(DataAppVO, t, "DataSource", char);
		if (!strcmp(DataSource, "ROI")){
			ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
			if (ROIGrid->icon_set == 1)
			{
				if (ROIGrid->filteredvo){
					if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2)){
						if (!ROIGrid->Flut){
							ROIGrid->Flut = CrFltNumFlut_roi(ROIGrid->filteredvo);
						}
						if (FltNumMatched_roi(id, ROIGrid,flightnum)){
							return ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
						}
					}
				}
			}
		}
		else if (!strcmp(DataSource, "FDO")){
			FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
			if (FDOGrid->icon_set == 1)
			{
				if (FDOGrid->filteredvo){
					if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2)){
						if (!FDOGrid->Flut){
							FDOGrid->Flut = CrFltNumFlut(FDOGrid->filteredvo);
						}
						if (FltNumMatched(id, FDOGrid, flightnum, destination)){
							return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
						}
					}
				}
			}
		}

	}
	//}
	//}
	//}

	return 100;
}

//sy 

int showflightscheck(struct InstanceData* id, AIR *air)
{

	int t;
	char* flightnum;
	char* destination;

	flightnum = air->FltNum;
	destination = air->Destin;


	MGLGRID *ROIGrid = NULL;
	MGLGRID *FDOGrid = NULL;
	char *DataSource;
	VO *DataAppVO;
	char str[40];
	strcpy_s(str, 40, flightnum);


	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++) {
		DataSource = VP(DataAppVO, t, "DataSource", char);
		if (!strcmp(DataSource, "ROI")) {
			ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
			if (ROIGrid->icon_set == 1) {
				if (ROIGrid->filteredvo) {
					if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2)) {
						if (ROIGrid->showflights_check == 1) {
							if (!ROIGrid->Flut) {
								ROIGrid->Flut = CrFltNumFlut_roi(ROIGrid->filteredvo);
							}
							if (FltNumMatched_roi(id, ROIGrid, flightnum)) {
								return ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
							}
						} 
					}
				}
			}
		} else if (!strcmp(DataSource, "FDO")) {
			FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
			if (FDOGrid->icon_set == 1) {
				if (FDOGrid->filteredvo) {
					if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2)) {
						if (FDOGrid->showflights_check == 1) {
							if (!FDOGrid->Flut) {
								FDOGrid->Flut = CrFltNumFlut(FDOGrid->filteredvo);
							}
							if (FltNumMatched(id, FDOGrid, flightnum, destination)) {
								return FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
							}
						} 
					}
				}
			}
		}


	}

	return (-1);

}





int drawAircraft(struct InstanceData* id, AIR **airp, int dataonly, int passurindex)
{
	static VO *DataVO;
	PTRACK *trackarr;
	int i, utc, filpass, filfail, nAcType;
	GLfloat angle;
	GLfloat x, y, AirSize;
	int drawcount = 0;
	int color = 0;
	static int pflag = 0;
	int drawcolor, activecount,test;
	int xpixel, ypixel;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;

	missedP = 0;

	if (dataonly){
		// only process the data from the asd feed, no graphics this loop
		return(SUCCEED);
	}

	if (!id->m_bIconsLoaded) {
		D_CONTROL("PASSUR_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);


	/* AirSize = (WorldXmax - WorldXmin) /  AircraftSize; */
	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;
	/* printf("AirSize=%g, AircraftSize=%d\n", AirSize, AircraftSize); */


	filfail = 0;
	filpass = 0;
	//CkActiveFilters();


	for (i = 0, activecount = 0; airp && i < N_PASSUR_TRACK_ID; i++){
		drawcolor = 3; // default
		if (!(air = airp[i])){
			/* no tracks yet */
			continue;
		}
		D_CONTROL("PASSUR_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Investigating %s from %s[%d], tracked(%d)\n",
			cdwThreadId, air->FltNum, g_arFeedTypes[PASSUR], i, air->IsTracked));
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}
		// Show Selected PASSUR Aircraft only (someone did FindFlight and PASSUR is now OFF)
		if (!id->m_sCurLayout.m_bShowPassurAircraft){
			if (!(SAT_PASSUR == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}
		activecount++;

		/* interpolate position of aircraft for current second */
		if (AirScreenPos(id, airp, i, TRUE) == FALSE){
			continue;
		}

		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change == 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;								
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change == 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check != 100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}
		
	t2:		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// selected aircraft, always draw
		if (pflag){
			//PrintTracks( id, air, PASSUR );
		}
		drawcolor = 4;
		} else {
				if (clipaircraft(id, air)) {
					filfail++;
					continue;
				}
				if ((drawcolor = filtermatch(id, air)) < 0){
					filfail++;
					continue;
				}
			}

		t1:	if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
			drawcolor = id->m_selectedaircraftcolor;
			else
			{
					test = filtermatch(id, air);
					if (test < 0)
						continue;
			}
	
			//if ( !strncasecmp(air->FltNum, "AAL821", 6) ){
			//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found it\n", cdwThreadId );
			//}
			if (air->IsTracked){
				if ((air->IsTracked & SAT_ASDEX || air->IsTracked & SAT_MLAT)) {
					if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT){
						/* ASDEX is tracking this aircraft but show when zoom level is beyond ASDEX */
						continue;
					}
				}else{
					continue;
				}
			}

#ifdef CK_INTRUSIONS
				if ( CkIntrusions && IsIntruding( AirVO, i ) ){
					drawcolor = 5; // lime
				}
#endif
				if (!strlen(air->DivDestin) && REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
					GetDivertedDestination(id, air->FltNum, air->DivDestin);
				}

				filpass++;


				// drawcolor = GetDrawColor( AirVO, i );
		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );		
				CalcDistance(id, air);

				utc = air->utc;
				if (!id->m_nDelaySecs && ((id->m_tPlotTime - utc) > PASSUR_TRACK_TIMEOUT)){
					D_CONTROL("PASSUR_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: PASSUR Track Timeout\n", cdwThreadId, air->FltNum, air->trackid));
					RemoveTrack(id, airp, i, PASSUR, TRUE);
					continue;
				} else if (id->m_nDelaySecs && ((id->m_tPlotTime - utc) > PASSUR_REPLAY_TIMEOUT)){
					// replay mode, use larger PASSUR_REPLAY_TIMEOUT
					D_CONTROL("PASSUR_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Removing track<%s[%d]>, Reason: PASSUR Replay Timeout(%d,%d)\n", cdwThreadId, air->FltNum, air->trackid, id->m_tPlotTime, utc));
					RemoveTrack(id, airp, i, PASSUR, TRUE);
					continue;
				}

				if (!(trackarr = air->TrackPtr)){
					/* no tracks yet */
					continue;
				}


				/* solid with alpha masking */
				glEnable(GL_DEPTH_TEST);
				/* glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); */
				glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

				glEnable(GL_BLEND);
				glDepthFunc(GL_LEQUAL);

				glPushMatrix();
				glLoadIdentity();

				/* move to center of aircraft */
				/* printf("aircraft center at %g %g\n", VV(AirVO, i, "X", double ),
				VV(AirVO, i, "Y", double ) ); */

				x = air->X;
				y = air->Y;
				/* printf("aircraft center at %g %g\n", x, y ); */

				D_CONTROL("PASSUR_TRACKS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s from %s[%d], tracked(%d)\n",
					cdwThreadId, air->FltNum, g_arFeedTypes[PASSUR], i, air->IsTracked));

				/* convert X and Y from world to pixel coordinates */
				ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
				xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
				/* size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize */
				xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); /* move center so it doesn't draw on top of aircraft */

				if (id->m_sCurLayout.m_bShowLargeTags){
					SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
				}

				glTranslatef((GLfloat)x, (GLfloat)y, (GLfloat)trans[2]);

				angle = (GLfloat)CalcAngle(id, air, FALSE);


				glRotatef((GLfloat)angle, 0.0f, 0.0f, 1.0f);

				glBegin(GL_QUADS);
				glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
				glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
				glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
				glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);

				glEnd();
				glFlush();

				glPopMatrix();

				drawcount++;
	}
	
	if (SecondTabGrid)
		SecondTabGrid->aircraftcolor_change=0;
	if (pflag){
		printf("drawAircraft, color=%d, drawcount=%d missedP=%d\n",
			drawcolor, drawcount, missedP);
	}
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}



void ConvertDecimal2DegMinSecs(struct InstanceData* id, double degrees, int *degs, int *mins, int *secs)
{
	int rem;
	int nsecs;

	nsecs = (int)rint((degrees * 3600.0)); // better this way to avoid rounding problems
	*degs = nsecs / 3600;
	rem = nsecs % 3600;
	*mins = rem / 60;
	*secs = rem % 60;

	if (*secs > 59){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ConvertDecimal2DegMinSecs, degrees=%g degs=%d mins=%d secs=%d rem=%d\n",
			GetCurrentThreadId(), degrees, *degs, *mins, *secs, rem);
	}

}

int IsASDAirP(struct InstanceData* id, AIR **airp)
{

	if (airp == GetASDAirP(id)){
		return(TRUE);
	}

	return(FALSE);
}

int IsASDEXAirP(struct InstanceData* id, AIR **airp)
{

	if (airp == GetASDEXAirP(id)){
		return(TRUE);
	}

	return(FALSE);
}

int IsADSBAirP(struct InstanceData* id, AIR **airp)
{

	if (airp == GetADSBAirP(id)){
		return(TRUE);
	}

	return(FALSE);
}

void AddFPFix(VO *FPFixesVO, char *fixname, double lat, double lng, int ftype)
{
	if (strlen(fixname)){
		vo_alloc_rows(FPFixesVO, 1);
		strcpy_s(VP(FPFixesVO, FPFixesVO->count - 1, "Name", char), 20, fixname);
		VV(FPFixesVO, FPFixesVO->count - 1, "lat", double) = lat;
		VV(FPFixesVO, FPFixesVO->count - 1, "lng", double) = lng;
		VV(FPFixesVO, FPFixesVO->count - 1, "type", double) = ftype;
	}
}

FIX *FindFixRow(struct InstanceData* id, char *fixname, double lng, double lat)
{
	static char **result;
	FIX key;
	FIX *curfix, *closestfix;
	int fcount = 0;
	double mindis = 9.0e99;
	double tmprads, dis;
	static int fixerrcount = 0;

	/* use Arpts struct to find the arpt */
	if (g_bFixesLoaded){

		/* if match_type == EXACT_MATCH, then do not try alternate extensions. We need this logic for cases
		like ATL, where we do NOT want to match to PATL */


		strncpy_s(key.fixname, 7, fixname, _TRUNCATE);
		StrUpper(key.fixname);

		result = (char **)bsearch((char *)&key, (char *)g_pFixes, g_nFixCount,
			sizeof(FIX), (int(*)(const void*, const void*)) compareFix);
		curfix = (FIX *)result;
		if (result){
			// may be multiple matching fixes, so chose closest one to given lng , lat
			if (fabs(lng) > 0.0001 && fabs(lat) > 0.0001){ // make sure values have been initialized or ignore them

				// go back to first fix if multiple fixes with same name
				do {
					curfix--;
					if (!strcmp(curfix->fixname, key.fixname)){
						// still matches
					} else {
						curfix++; // last good fix
						break;
					}
				} while (curfix && curfix > g_pFixes && fcount++ < 8);
			}
			if (strcmp(curfix->fixname, key.fixname)){
				// some problem
				if (fixerrcount++ < 10){  // only print 10 of these
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not find fix for '%s'\n", GetCurrentThreadId(), key.fixname);
				}
				return((FIX *)NULL);
			}

			// find closest fix to lng, lat
			closestfix = curfix;
			fcount = 0;
			do {
				tmprads = acos(sin(RADS(lat)) * sin(RADS(curfix->lat)) + cos(RADS(lat)) * cos(RADS(curfix->lat)) * cos(RADS(curfix->lng - lng)));
				dis = 60.0 * DEGS(tmprads); // NM
				if (dis < mindis){
					closestfix = curfix;
					mindis = dis;
				}

				curfix++;
				if (strcmp(curfix->fixname, key.fixname)){
					// no more matching fixes
					break;
				}
			} while (fcount++ < 8);

			return((FIX *)closestfix);
		}
	}
	return((FIX *)NULL);
}


int compareNav(const void *arg1, const void *arg2)
{
	NAV *Nav1, *Nav2;

	//char *str1, *str2;
	/* Compare all of both strings: */
	//str1 = *arg1;
	//str2 = *arg2;

	Nav1 = (NAV *)arg1;
	Nav2 = (NAV *)arg2;

	return _strcmpi(Nav1->navname, Nav2->navname);
}

NAV *FindNavRow(struct InstanceData* id, char *navname)
{
	static char **result;
	NAV key;

	if (g_bNavLoaded){
		strncpy_s(key.navname, 5, navname, _TRUNCATE);
		StrUpper(key.navname);

		result = (char **)bsearch((char *)&key, (char *)g_pNavs, g_nNavCount,
			sizeof(NAV), (int(*)(const void*, const void*)) compareNav);
		if (result){
			return((NAV *)result);
		}
	}
	/* 3 letter code not found, try US with 'K' */

	return((NAV *)NULL);
}

int LoadNav(struct InstanceData* id)
{
	FILE *in;
	const char* filename = "NAV.txt";
	char filepath[256] = { 0 };
	char linebuf[FIX_RECORD_SIZE + 3];  /* need room for CR, LF and '\0' characters */
	int degs, minutes, secs;
	float fracs, lat, lng;
	char tmpstr[TMPBUF_SIZE];
	char navname[7];
	NAV* Navs = NULL;
	int navcount = 0;
	HANDLE hMutex = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Create a System wide Mutex, with ownership to serialize loading (all instances share NAVS)
	hMutex = CreateMutex(NULL, TRUE, "WEBTRACKER_NAV_MUTEX");
	// Check if Mutex was created by other process/thread and exit
	if (!hMutex || ERROR_ALREADY_EXISTS == GetLastError())
		return (FALSE);

	if (!GetLocalFile(id, id->m_strMapDir, filename, id->m_strHttpMapPath, SM_HTTPS))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local %s file.\n", cdwThreadId, filename);
		return (FALSE);
	}

	sprintf_s(filepath, _countof(filepath), "%s%s", id->m_strMapDir, filename);
	if (fopen_s(&in, filepath, "rb")){
		fprintf(stderr, "Could not open file %s.\n", filepath);
		return(FALSE);
	}

	Navs = calloc(sizeof(NAV), MAX_NAVS);
	memset(linebuf, 0, sizeof linebuf);

	while (!feof(in)){
		if (!fgets(linebuf, sizeof linebuf, in)){
			/* ran out of data */
			break;
		}

		if (strncmp(linebuf, "NAV1", 4)){
			// wrong record type
			continue;
		}
		strncpy_s(navname, 7, &linebuf[4], 3);
		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[283], 13);   // latitude
		degs = (10 * (linebuf[283] - '0')) + linebuf[284] - '0';
		minutes = (10 * (linebuf[286] - '0')) + linebuf[287] - '0';
		secs = (10 * (linebuf[289] - '0')) + linebuf[290] - '0';
		fracs = (float)(100.0f * (linebuf[292] - '0')) + (10.0f * (linebuf[293] - '0')) + linebuf[294] - '0';
		fracs /= 1000.0;
		lat = (float)(degs + (minutes / 60.0) + (secs / 3600.0) + (fracs / 3600.0));

		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[308], 13);   // longitude
		tmpstr[13] = '\0';
		degs = (100 * (linebuf[308] - '0')) + (10 * (linebuf[309] - '0')) + linebuf[310] - '0';
		minutes = (10 * (linebuf[312] - '0')) + linebuf[313] - '0';
		secs = (10 * (linebuf[315] - '0')) + linebuf[316] - '0';
		fracs = (100.0f * (linebuf[318] - '0')) + (10.0f * (linebuf[319] - '0')) + linebuf[320] - '0';
		fracs /= 1000.0;
		lng = (float)degs + (minutes / 60.0f) + (secs / 3600.0f) + (fracs / 3600.0f);

		strncpy_s(Navs[navcount].navname, 5, navname, _TRUNCATE);
		STrimRight(Navs[navcount].navname);

		Navs[navcount].lat = lat;
		Navs[navcount].lng = -lng; // always negative for US

		// navArray[navcount].navname[6] = '\0';


		//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) linebuf='%s'\n len=%d degs=%d minutes=%d secs=%d lat=%g lng=%g\n",
		//   cdwThreadId, linebuf, strlen(linebuf), degs, minutes, secs, lat, lng );

		if (navcount < MAX_NAVS - 1){
			navcount++;
		} else {
			break; // ran out of naves
		}
	}
	fclose(in);

	qsort((void *)Navs, (size_t)navcount, sizeof(NAV), compareNav);

	g_pNavs = Navs;
	g_nNavCount = navcount;
	if( IS_D_CONTROL( "NAVS" ) ){
		int i;
		for (i = 0; i < g_nNavCount; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) NAV[%d]='%s',lat=%g lng=%g\n",
				cdwThreadId, i, g_pNavs[i].navname, g_pNavs[i].lat, g_pNavs[i].lng );
		}
	}
	g_bNavLoaded = TRUE;
	ReleaseMutex(hMutex);
	CloseHandle(hMutex);

	return(TRUE);
}

int compareStar(const void *arg1, const void *arg2)
{
	STARSID *star1, *star2;

	//char *str1, *str2;
	/* Compare all of both strings: */
	//str1 = *arg1;
	//str2 = *arg2;

	star1 = (STARSID *)arg1;
	star2 = (STARSID *)arg2;

	return _strcmpi(star1->starname, star2->starname);
}

STARSID *FindStarRow(struct InstanceData* id, char *starname)
{
	static char **result;
	STARSID key;

	if (g_bStarsLoaded){
		strncpy_s(key.starname, 7, starname, _TRUNCATE);
		StrUpper(key.starname);

		result = (char **)bsearch((char *)&key, (char *)g_pStarSID, g_nStarCount,
			sizeof(STARSID), (int(*)(const void*, const void*)) compareStar);
		if (result){
			return((STARSID *)result);
		}
	}
	return((STARSID *)NULL);
}

void LoadStars(struct InstanceData* id)
{
	FILE *in;
	const char *filename = "stardp.txt";
	char filepath[256] = { 0 };
	char linebuf[1024];
	int degs, minutes, secs, len;
	float fracs, lat, lng;
	char tmpstr[TMPBUF_SIZE];
	char starname[7];
	char *str;
	char northsouth, eastwest, star_dp;
	char prevstr[6];
	int starcount = 0;
	STARSID* StarSID = NULL;
	HANDLE hMutex = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Create a System wide Mutex, with ownership to serialize loading (all instances share STARS)
	hMutex = CreateMutex(NULL, TRUE, "WEBTRACKER_STAR_MUTEX");
	// Check if Mutex was created by other process/thread and exit
	if (!hMutex || ERROR_ALREADY_EXISTS == GetLastError())
		return;

	prevstr[0] = '\0';

	if (!GetLocalFile(id, id->m_strMapDir, filename, id->m_strHttpMapPath, SM_HTTPS))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local %s file.\n", cdwThreadId, filename);
		return;
	}

	sprintf_s(filepath, _countof(filepath), "%s%s", id->m_strMapDir, filename);
	if (fopen_s(&in, filepath, "rb")){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open file %s\n", cdwThreadId, filepath);
		return;
	}

	StarSID = calloc(sizeof(STARSID), MAX_STARS);
	memset(linebuf, 0, sizeof linebuf);

	while (!feof(in)){
		if (!fgets(linebuf, sizeof linebuf, in)){
			/* ran out of data */
			break;
		}

		// get sequence number string
		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[0], 5);
		tmpstr[5] = '\0';
		star_dp = tmpstr[0];  // 'D' or 'S'

		if (!strcmp(prevstr, tmpstr)){
			// matches previous , so part of same star, so ignore
			continue;
		}
		// new star
		strncpy_s(prevstr, _countof(prevstr), tmpstr, _TRUNCATE);

		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[36], 13);

		// star name is after the '.' for STARS nad before the '.' for DP's
		if (!(str = strchr(tmpstr, '.'))){
			D_CONTROL("STARS", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unexpected star name linebuf='%s'\n", cdwThreadId, linebuf));
			continue;
		}

		if (star_dp == 'S'){
			str++;
			strncpy_s(starname, 7, str, _TRUNCATE);
		} else {
			len = str - tmpstr;
			strncpy_s(starname, 7, tmpstr, len);
		}

		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[13], 8);   // latitude
		northsouth = tmpstr[0];
		degs = (10 * (tmpstr[1] - '0')) + tmpstr[2] - '0';
		minutes = (10 * (tmpstr[3] - '0')) + tmpstr[4] - '0';
		secs = (10 * (tmpstr[5] - '0')) + tmpstr[6] - '0';

		fracs = (float)(tmpstr[7] - '0');
		fracs /= 10.0;
		lat = (float)(degs + (minutes / 60.0) + (secs / 3600.0) + (fracs / 3600.0));

		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[21], 9);   // longitude
		eastwest = tmpstr[0];
		degs = (100 * (tmpstr[1] - '0')) + (10 * (tmpstr[2] - '0')) + tmpstr[3] - '0';
		minutes = (10 * (tmpstr[4] - '0')) + tmpstr[5] - '0';
		secs = (10 * (tmpstr[6] - '0')) + tmpstr[7] - '0';
		fracs = (float)(tmpstr[8] - '0');
		fracs /= 10.0;

		lng = (float)degs + (minutes / 60.0f) + (secs / 3600.0f) + (fracs / 3600.0f);

		strncpy_s(StarSID[starcount].starname, 7, starname, _TRUNCATE);
		STrimRight(StarSID[starcount].starname);

		StarSID[starcount].lat = lat;
		StarSID[starcount].lng = -lng; // always negative for US


		D_CONTROL("STARS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) linebuf='%s'\n len=%d degs=%d minutes=%d secs=%d lat=%g lng=%g\n",
			cdwThreadId, linebuf, strlen(linebuf), degs, minutes, secs, lat, lng));

		if (starcount < MAX_STARS){
			starcount++;
		} else {
			break; // ran out of stars
		}
	}
	fclose(in);

	qsort((void *)StarSID, (size_t)starcount, sizeof(STARSID), compareStar);

	if (IS_D_CONTROL("STARS")){
		int i;
		for (i = 0; i < starcount; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) star '%s' lat=%g lng=%g\n", cdwThreadId, StarSID[i].starname, StarSID[i].lat, StarSID[i].lng);
		}
	}
	g_pStarSID = StarSID;
	g_nStarCount = starcount;
	g_bStarsLoaded = TRUE;
	ReleaseMutex(hMutex);
	CloseHandle(hMutex);
}

int compareAirways(const void *arg1, const void *arg2)
{
	AIRWAY *Air1, *Air2;
	char name1[256], name2[256];

	//char *str1, *str2;
	/* Compare all of both strings: */
	//str1 = *arg1;
	//str2 = *arg2;

	Air1 = (AIRWAY *)arg1;
	Air2 = (AIRWAY *)arg2;

	sprintf_s(name1, _countof(name1), "%s%c%03d", Air1->name, Air1->type, Air1->node);
	sprintf_s(name2, _countof(name2), "%s%c%03d", Air2->name, Air2->type, Air2->node);

	return _strcmpi(name1, name2);

}

AIRWAY *FindAirRow(struct InstanceData* id, char *airname)
{
	static char **result;
	AIRWAY key;

	if (!g_bAirwaysLoaded){

		strncpy_s(key.name, 6, airname, _TRUNCATE);
		StrUpper(key.name);

		result = (char **)bsearch((char *)&key, (char *)g_pAirways, g_nAirwayCount,
			sizeof(AIRWAY), (int(*)(const void*, const void*)) compareAirways);
		if (result){
			return((AIRWAY *)result);
		}
		/* 3 letter code not found, try US with 'K' */
	}
	return((AIRWAY *)NULL);
}

int LoadAirAsiaAirways( struct InstanceData* id, AIRWAY **ppAirways, int *pCount )
{
	FILE *in = NULL;
	const char* filename = "aaawys.txt";
	char filepath[256] = {0};
	char linebuf[100] = {0};
	char val[15] = {0};
	AIRWAY *Airways = NULL;
	char *s = NULL;
	int rcnt = 0;
	int lcnt = 0;
	int node = 0;
	int degs, minutes, secs;
	float fracs, sign;
	int bytes1, bytes2;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if(!GetLocalFile(id, id->m_strMapDir, filename, id->m_strHttpMapPath, SM_HTTPS))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local %s file.\n", cdwThreadId, filename);	
		return (FALSE);
	}

	sprintf_s(filepath, _countof(filepath), "%s%s", id->m_strMapDir, filename);
	if ( fopen_s(&in, filepath, "r") ){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open file %s.\n", cdwThreadId, filepath);	
		return (FALSE);
	}

	// Allocate Buffer for Incoming Records
	Airways = calloc(50000, sizeof(AIRWAY));

	// Read Records and load fix data
	while ( !feof(in) ){
		memset(linebuf, 0, sizeof linebuf);
		if ( !fgets(linebuf, sizeof linebuf, in) ){
			/* ran out of data */
			break;
		}else{
			// skip over headers
			if(++lcnt < 2)
				continue;
		}
		if ( !strncmp( linebuf, "EOD", 3 ) ){
			break; // End of File
		}

		// Get ID
		s = GetNextField(linebuf, Airways[rcnt].name, 6);

		s = GetNextField(s, val, 15);
		node = atoi(val) / 10;
		Airways[rcnt].node = node;

		s = GetNextField(s, Airways[rcnt].fixname, 5);

		// Skip End of Segment
		s = GetNextField(s, val, 15);

		// Get Lat
		s = GetNextField(s, val, 15);
		sign = 1.0f;
		if( 'S' == val[0] || 's' == val[0] ) sign = -1.0f;
		degs = (10 * (val[1] - '0') ) + val[2] - '0';
		minutes = (10 * (val[4] - '0') ) + val[5] - '0';
		secs = (10 * (val[7] - '0') ) + val[8] - '0';
		fracs = (100.0f * (val[10] - '0') );
		if ( isdigit(val[11]) ){
			fracs += (10.0f * (val[11] - '0'));
		}
		if ( isdigit(val[12] ) ){
			fracs += val[12] - '0';
		}
		fracs /= 1000.0;
		Airways[rcnt].lat = sign * ((float) degs + ( minutes / 60.0f ) + (secs / 3600.0f) + (fracs / 3600.0f));

		// Get Lng
		s = GetNextField(s, val, 15);
		sign = 1.0f;
		if( 'W' == val[0] || 'W' == val[0] ) sign = -1.0f;
		degs = (100 * (val[1] - '0') ) + (10 * (val[2] - '0') ) + val[3] - '0';
		minutes = (10 * (val[5] - '0') ) + val[6] - '0';
		secs = (10 * (val[8] - '0') ) + val[9] - '0';
		fracs = (100.0f * (val[11] - '0') );
		if ( isdigit(val[12]) ){
			fracs += 10.0f * (val[12] - '0');
		} if ( isdigit(val[13]) ){
			fracs += val[13] - '0';
		}
		fracs /= 1000.0;
		Airways[rcnt].lng = sign * ((float) degs + ( minutes / 60.0f ) + (secs / 3600.0f) + (fracs / 3600.0f));

		Airways[rcnt].type = ' ';
		rcnt++;
	}

	if( IS_D_CONTROL( "AAAIRWAYS" ) ){
		int i;
		for (i = 0; i < rcnt; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) AIRWAY[%d] name='%s', fixname='%s', node=%d, lat=%g lng=%g\n",
				cdwThreadId, i, Airways[i].name, Airways[i].fixname, Airways[i].node, Airways[i].lat, Airways[i].lng );
		}
	}
	// Append to end of existing fix array
	bytes1 = *pCount * sizeof(AIRWAY);
	bytes2 = rcnt * sizeof(AIRWAY);
	if(append_lg_buffers((char**)ppAirways, &bytes1, (char*)Airways, bytes2))
	{	
		*pCount += rcnt;
	} 

	free(Airways);
	return (TRUE);
}


LoadAirways(struct InstanceData* id)
{
	FILE *in;
	const char* filename = "AWY.txt";
	char filepath[256] = { 0 };
	char linebuf[AWY_RECORD_SIZE + 3];  /* need room for CR, LF and '\0' characters */
	int degs, minutes, secs, node;
	float fracs, lat, lng;
	char tmpstr[TMPBUF_SIZE];
	char name[6], prevname[6], fixtype[4];
	char airway_type;
	int airwaycount = 0;
	AIRWAY* airways = NULL;
	HANDLE hMutex = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Create a System wide Mutex, with ownership to serialize loading (everybody instance shares Fixes)
	hMutex = CreateMutex(NULL, TRUE, "WEBTRACKER_AIRWAYS_MUTEX");
	// Check if Mutex was created by other process/thread and exit
	if (!hMutex || ERROR_ALREADY_EXISTS == GetLastError())
		return (FALSE);

	if(HavePermission(id, "AIRASIA"))
	{
		LoadAirAsiaAirways(id, &airways, &airwaycount);
	}
	else
	{
	if (!GetLocalFile(id, id->m_strMapDir, filename, id->m_strHttpMapPath, SM_HTTPS))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local %s file.\n", cdwThreadId, filename);
		return (FALSE);
	}

	sprintf_s(filepath, _countof(filepath), "%s%s", id->m_strMapDir, filename);
	if (fopen_s(&in, filepath, "rb")){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open file %s.\n", cdwThreadId, filepath);
		return(FALSE);
	}

	airways = calloc(sizeof(AIRWAY), MAX_AIRWAYS);
	memset(linebuf, 0, sizeof linebuf);

	while (!feof(in)){
		if (!fgets(linebuf, sizeof linebuf, in)){
			/* ran out of data */
			break;
		}

		if (strncmp(linebuf, "AWY2", 4)){
			continue; // wrong record type, we only use AWY2
		}

		strncpy_s(name, _countof(name), &linebuf[4], 5);
		strncpy_s(fixtype, _countof(fixtype), &linebuf[64], 3);
		if (!strcmp(fixtype, "FIX")){
			// intersection is a fix
			strncpy_s(airways[airwaycount].fixname, 5, &linebuf[15], _TRUNCATE);
			STrimRight(airways[airwaycount].fixname);
			} else {
			// intersection is probably a vortac
			// get name, if one for airroute
			strncpy_s(airways[airwaycount].fixname, 5, &linebuf[114], _TRUNCATE);
			STrimRight(airways[airwaycount].fixname);
		}


		airway_type = linebuf[9];
		if (airway_type != ' '){
			airway_type = linebuf[9];
		}

		strncpy_s(tmpstr, TMPBUF_SIZE, &linebuf[81], 13);   // latitude
		if (!isdigit(linebuf[81])){
			/* no lat/lon info */
			continue;
		}

		degs = (10 * (linebuf[81] - '0')) + linebuf[82] - '0';
		minutes = (10 * (linebuf[84] - '0')) + linebuf[85] - '0';
		secs = (10 * (linebuf[87] - '0')) + linebuf[88] - '0';
		fracs = (100.0f * (linebuf[90] - '0'));
		if (isdigit(linebuf[91])){
			fracs += (10.0f * (linebuf[91] - '0'));
		}
		if (isdigit(linebuf[92])){
			fracs += linebuf[92] - '0';
		}
		fracs /= 1000.0;
		lat = (float)degs + (minutes / 60.0f) + (secs / 3600.0f) + (fracs / 3600.0f);

		// longitude
		degs = (100 * (linebuf[95] - '0')) + (10 * (linebuf[96] - '0')) + linebuf[97] - '0';
		minutes = (10 * (linebuf[99] - '0')) + linebuf[100] - '0';
		secs = (10 * (linebuf[102] - '0')) + linebuf[103] - '0';
		fracs = (100.0f * (linebuf[105] - '0'));
		if (isdigit(linebuf[106])){
			fracs += 10.0f * (linebuf[106] - '0');
		} if (isdigit(linebuf[107])){
			fracs += linebuf[107] - '0';
		}
		fracs /= 1000.0;
		lng = (float)degs + (minutes / 60.0f) + (secs / 3600.0f) + (fracs / 3600.0f);

		strncpy_s(airways[airwaycount].name, 6, name, _TRUNCATE);
		STrimRight(airways[airwaycount].name);

		if (strcmp(name, prevname)){
			// new airway
			node = 0;
			strcpy_s(prevname, _countof(prevname), name);
		}

		airways[airwaycount].lat = lat;
		airways[airwaycount].lng = -lng; // always negative for US
		airways[airwaycount].node = node++;
		airways[airwaycount].type = airway_type;

			D_CONTROL("AIRWAYS_BUF", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) linebuf='%s'\n count=%d, len=%d degs=%d minutes=%d secs=%d lat=%g lng=%g node=%d type=%c\n",
			cdwThreadId, linebuf, airwaycount, strlen(linebuf), degs, minutes, secs, lat, lng, node - 1, airways[airwaycount].type));

		if (airwaycount < MAX_AIRWAYS - 1){
			airwaycount++;
			} else {
			break; // ran out of fixes
		}
	}
	fclose(in);
	}

	qsort((void *)airways, (size_t)airwaycount, sizeof(AIRWAY), compareAirways);

	if (IS_D_CONTROL("AIRWAYS")){
		int i;
		for (i = 0; i < airwaycount; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) AIRWAY name[%d]='%s'lat=%g lng=%g node=%d fix='%s' type='%c'\n",
				cdwThreadId, i, airways[i].name, airways[i].lat, airways[i].lng, airways[i].node, airways[i].fixname, airways[i].type );
		}
	}
	g_pAirways = airways;
	g_nAirwayCount = airwaycount;
	g_bAirwaysLoaded = TRUE;
	ReleaseMutex(hMutex);
	CloseHandle(hMutex);

	return(TRUE);
}

char *AdjustAirwayName(char *airway)
{
	static char newairway[6];
	int airnum, len;
	// see if this is an airway and we need to inject some leading 0's
	if ((airway[0] == 'J' || airway[0] == 'V') && (len = strlen(airway)) < 5){
		if (len == 2 && isdigit(airway[1])){  // ex J2
			goto fixstr;
		} else if (len == 3 && isdigit( airway[1] ) && isdigit( airway[2] ) ){ // ex: J22
			goto fixstr;
		} else if (len == 4){
			return(airway); // no need to adjust
		} else if ( len == 1 ){
			return(NULL);
		}
	}
	return(NULL);

fixstr:
	airnum = atoi(&airway[1]);
	if (airnum < 999){
		_snprintf_s(newairway, 6, _TRUNCATE, "%c%03d", airway[0], airnum);
		return(newairway);
	}
	return(NULL);
}



void ProcessFltPlans(char *buf, int len, AIR *air)
{
	char *FltRoute;
	char *str;

	if (len > 0 && len < 512){
		if (strlen(buf) < 8 && strstr(buf, "EOD")){
			// no data in database
			return;
		}

		if (!(str = air->FltRoute)){
			FltRoute = malloc(len + 1);
			strcpy_s(FltRoute, len + 1, buf);
			air->FltRoute = FltRoute;
		} else {
			/* if different, then free and malloc again */
			if (strcmp(str, buf)){
				free(str);
				FltRoute = malloc(len + 1);
				strcpy_s(FltRoute, len + 1, buf);
				air->FltRoute = FltRoute;
			} else {
				/* it's the same route, so do nothing */
			}
		}
	}
}

void QryFlightPlanLines(struct InstanceData* id, AIR *air)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	int trycount = 0;
	char *flightid;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!air){
		return;
	}

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	flightid = air->FltNum;

	while (trycount++ < PULS_SRVR_LIST_SZ){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=FlightRoute&flightid=%s", flightid);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
			cdwThreadId, GetPulseSrvr(id), tmpstr);
		if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FlightRoute from %s failed, switching srvrs to %s and trying again.\n",
				cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		}
		if (chunk.memory){
			ProcessFltPlans(chunk.memory, chunk.size, air);
			free(chunk.memory);
			chunk.memory = NULL;
			return;

		} else {

			vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) No FlightRoute retrieved from server\n",
				cdwThreadId);
		}
	}

	// should never get here, unless error
	return;

}

VLL *addvlink(struct InstanceData* id, VLL *CurVLL, double x, double y)
{
	VLL *Newll;
	Newll = calloc(1, sizeof(VLL));

	if (!CurVLL){
		// first list, set global
		id->m_pVList = Newll;
	} else {
		CurVLL->np = Newll;
	}

	Newll->x = x;
	Newll->y = y;

	return(Newll);
}

void CheckVList(struct InstanceData* id)
{
	VLL *p1 = NULL, *p2 = NULL, *p3 = NULL;
	VLL *p;
	double tmprads, d12, d23, d13;

	// go through linked list of flight plan vertex points and see if any points are bad
	// bad points occur when international fixes and domestic fixes have the same names, causes flight plan to go from one continent to another
	p1 = id->m_pVList;
	if (p1){
		p2 = p1->np;
	}
	if (p2){
		p3 = p2->np;
	}

	while (p1 && p2 && p3){
		// use great circle equation to figure out distance between points
		// find d12
		tmprads = acos(sin(RADS(p1->y)) * sin(RADS(p2->y)) + cos(RADS(p1->y)) * cos(RADS(p2->y)) * cos(RADS(p2->x - p1->x)));
		d12 = 60.0 * DEGS(tmprads); // NM

		// find d23
		tmprads = acos(sin(RADS(p2->y)) * sin(RADS(p3->y)) + cos(RADS(p2->y)) * cos(RADS(p3->y)) * cos(RADS(p3->x - p2->x)));
		d23 = 60.0 * DEGS(tmprads); // NM

		// find d13
		tmprads = acos(sin(RADS(p1->y)) * sin(RADS(p3->y)) + cos(RADS(p1->y)) * cos(RADS(p3->y)) * cos(RADS(p3->x - p1->x)));
		d13 = 60.0 * DEGS(tmprads); // NM

		if ((d12 + d23) > (4.0 * d13) || ((d12 + d23) - d13) > 1500.0 || d12 > 3000.0 || d23 > 3000.0){
			// skip bad point p2, set to p1 so next calcs are OK
			p2->x = p1->x;
			p2->y = p1->y;

		} else {
			// points are good, so plot p1
			// glVertex3f( (float) lng, (float) lat, 0.0f );
		}

		p1 = p2;
		p2 = p3;
		p3 = p3->np;
	}

	// plot all non-zero points
	for (p = id->m_pVList; p; p = p->np){
		if (fabs(p->x) < 0.0001 && fabs(p->y) < 0.0001){
			// bad point
		} else {
			glVertex3f((float)p->x, (float)p->y, 0.0f);
		}
	}


}


FreeVList(struct InstanceData* id)
{
	VLL *fp = NULL;
	VLL *vll;

	for (vll = id->m_pVList; vll; vll = vll->np){
		if (fp){
			free(fp);
		}
		fp = vll;
	}

	if (fp){
		free(fp);
	}
	id->m_pVList = NULL;
}

VLL *FixFarEast(struct InstanceData* id, VO *FPFixesVO, double *latptr, double *lngptr, char *token, int fixtype, VLL *CurVLL)
{
	double origlng, prevlng;

	if (!FPFixesVO || !FPFixesVO->count){
		// no prior points, so do nothing
		return(CurVLL);
	}

	// get prior points lng
	prevlng = VV(FPFixesVO, FPFixesVO->count - 1, "lng", double);

	if (*lngptr > 80.0 && prevlng < -80.0){
		// heading west
		// in pacific/japan/china region, so draw from left side of screen
		// terminate prior line
		// see if prior point is in west half
		if (VV(FPFixesVO, FPFixesVO->count - 1, "lng", double) > 80.0){
			// also east, so do nothing
			return(CurVLL);
		}
		origlng = *lngptr;

		// start new point at far left of screen
		*lngptr = -180.0;

		glColor3fv(black);
		// glVertex3f( (float) *lngptr, (float) *latptr, 0.0f );
		CurVLL = addvlink(id, CurVLL, *lngptr, *latptr);

		AddFPFix(FPFixesVO, token, *latptr, *lngptr, fixtype);
		glEnd();

		glBegin(GL_LINE_STRIP);

		// start new point at far left of screen
		*lngptr = 180.0;
		glColor3fv(black);
		// glVertex3f( (float) *lngptr, (float) *latptr, 0.0f );
		CurVLL = addvlink(id, CurVLL, *lngptr, *latptr);
		AddFPFix(FPFixesVO, token, *latptr, *lngptr, fixtype);

		*lngptr = origlng;
		glColor3fv(black);
		// glVertex3f( (float) *lngptr, (float) *latptr, 0.0f );
		CurVLL = addvlink(id, CurVLL, *lngptr, *latptr);
		AddFPFix(FPFixesVO, token, *latptr, *lngptr, fixtype);

		return(CurVLL);
	} else if ( prevlng > 80.0 && *lngptr < -80.0 ){
		// heading east across +180
		origlng = *lngptr;
		*lngptr = 180.0;
		glColor3fv(black);
		// glVertex3f( (float) *lngptr, (float) *latptr, 0.0f );
		CurVLL = addvlink(id, CurVLL, *lngptr, *latptr);

		AddFPFix(FPFixesVO, token, *latptr, *lngptr, fixtype);

		glEnd();

		glBegin(GL_LINE_STRIP);

		// start new point at far left of screen
		*lngptr = -180.0;
		glColor3fv(black);
		// glVertex3f( (float) *lngptr, (float) *latptr, 0.0f );
		CurVLL = addvlink(id, CurVLL, *lngptr, *latptr);

		AddFPFix(FPFixesVO, token, *latptr, *lngptr, fixtype);

		*lngptr = origlng;
		glColor3fv(black);
		// glVertex3f( (float) *lngptr, (float) *latptr, 0.0f );
		CurVLL = addvlink(id, CurVLL, *lngptr, *latptr);

		AddFPFix(FPFixesVO, token, *latptr, *lngptr, fixtype);
	}

	return(CurVLL);
}




RouteInitOpenGL(struct InstanceData* id)
{
	glPushMatrix();
	glLoadIdentity();

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);

	glColor3fv(black);
}

VLL *PlotAirway(struct InstanceData* id, AIRWAY *startairway, char *startfixname, char *endfixname, char *airname, VLL *CurVLL)
{
	AIRWAY *firstairway = NULL, *endairway = NULL, *aw;
	double lat, lng;
	int aircount = 0;
	int inc;

	/* draw from starting fix till ending fix */
	// startfixname and endfixname can be fix or navair
	while (!strcmp(startairway->name, airname)){
		if (strlen(startairway->fixname) && !strcmp(startairway->fixname, startfixname)){
			firstairway = startairway;
		}
		if (strlen(startairway->fixname) && !strcmp(startairway->fixname, endfixname)){
			endairway = startairway;
		}

		startairway += 1;
		aircount++;
	}

	if (!firstairway || !endairway){
		// error
		return(CurVLL);
	}

	// plot from firstairway till endairway, must go in proper direction
	if (firstairway < endairway){
		inc = 1;
	} else {
		inc = -1;
	}

	aw = firstairway;
	do {
		lat = aw->lat;
		lng = aw->lng;
		glColor3fv(blue);
		// glVertex3f( (float) lng, (float) lat, 0.0f );
		CurVLL = addvlink(id, CurVLL, lng, lat);

		if (aw == endairway){
			break;
		} else {
			aw += inc;
		}
	} while (aw && aircount-- > 0);

	return(CurVLL);
}




GLubyte *LoadCustomPNGMap(struct InstanceData* id, char *filename, int ACols, int ARows, int alpha_mode)
{
	gdImagePtr im;
	FILE *in;
	int row, col, startrow, endrow, startcol, endcol, maprow, mapcol;
	unsigned int c;
	int alpha, pflag = 0;
	char tmpstr[TMPBUF_SIZE];
	char pngname[TMPBUF_SIZE];
	GLubyte *mapimage = NULL;
	float colscale, rowscale, inc_col_count, inc_row_count;
	unsigned char redval, greenval, blueval;
	int index, truecolor;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// load in the PNG
	if (!GetLocalFile(id, id->m_strImageDir, filename, id->m_strHttpImagePath, SM_HTTPS))
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s).\n", cdwThreadId, filename);
		return (NULL);
	}
	_snprintf_s(pngname, TMPBUF_SIZE, 128, "%s%s", id->m_strImageDir, filename);

	if (fopen_s(&in, pngname, "rb")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename);
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open file(%s).\n", cdwThreadId, filename);
		return(NULL);
	}

	im = gdImageCreateFromPng(in);
	fclose(in);
	/* ... Use the image ... */

	mapimage = (GLubyte *)calloc(1, ARows * ACols * 4);
	colscale = (float)im->sx / ACols;
	rowscale = (float)im->sy / ARows;


	inc_col_count = 1.0f / colscale;
	inc_row_count = 1.0f / rowscale;

	if (gdImageTrueColor(im)){
		// true color
		truecolor = 1;
	} else {
		truecolor = 0;
	}
	for (row = 0; row < im->sy; row++){
		for (col = 0; col < im->sx; col++){

			c = gdImageGetPixel(im, col, row);
			if (truecolor){
				// alpha = 255;
				// gd uses max alpha of 127, so scale to opengl value of 255
				alpha = 255 - (gdImageAlpha(im, c) * 2);

				redval = gdImageRed(im, c);
				greenval = gdImageGreen(im, c);
				blueval = gdImageBlue(im, c);
				if (alpha_mode == ALPHA_MODE_BLACK){
					if (redval == 0 && greenval == 0 && blueval == 0){
						alpha = 0;
					}
				}
			} else if ( !truecolor && (c < 0 || c > 255) ){
				alpha = 0;
				redval = greenval = blueval = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if (alpha > 255) alpha = 255;

				redval = im->red[c];
				greenval = im->green[c];
				blueval = im->blue[c];
			}

			startrow = (int)(row / rowscale);
			endrow = (int)((row + 1) / rowscale);
			startcol = (int)(col / colscale);
			endcol = (int)((col + 1) / colscale);

			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) r=%d col=%d rgba= %d %d %d %d\n",
					cdwThreadId, row, col, redval, greenval, blueval, alpha);
			}
			for (maprow = startrow; maprow < endrow; maprow++){
				for (mapcol = startcol; mapcol < endcol; mapcol++){
					index = (maprow * ACols * 4) + (mapcol * 4);
					mapimage[index] = redval;
					mapimage[index + 1] = greenval;
					mapimage[index + 2] = blueval;
					mapimage[index + 3] = alpha;
					if (pflag){
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) maprow=%d col=%d startrow=%d endrow=%d stcol=%d endc=%d\n",
							cdwThreadId, maprow, mapcol, startrow, endrow, startcol, endcol);
					}
				}
			}

		}
	}

	gdImageDestroy(im);

	return(mapimage);

}



int DisplayCachedPNG(struct InstanceData* id, char *filename, int texturesize, GLfloat x1, GLfloat x2, GLfloat y1, GLfloat y2, GLfloat XSize,
										 GLfloat YSize, GLenum dfactor, int alpha_mode, int rotate )
{
	int map_square_pixels = 0;
	GLubyte *mapimage;
	MAPLL *png = NULL;
	GLfloat params[4];
	const DWORD cdwThreadId = GetCurrentThreadId();

	// this routine will load in a png image, create a texture, and draw it on the screen. 
	//  This routine will cache the texture so it will not load into memory on subsequent calls
	//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) filename=%s, tsize=%d, x1=%g,x2=%g,y1=%g,y2=%g, XSize=%g YSize=%g\n",
	//		cdwThreadId, filename, texturesize, x1,x2,y1,y2, XSize, YSize);
	// see if we have this file loaded into a texture already
	for (png = id->m_pPngLL; png; png = png->np){
		if (!strcmp(png->mapfilename, filename)){
			// already have this process
			break;
		}
	}
	if (!png){
		mapimage = LoadCustomPNGMap(id, filename, texturesize, texturesize, alpha_mode);
		if (!id->m_pPngLL){
			id->m_pPngLL = calloc(1, sizeof(MAPLL));
			id->m_pPngCurp = id->m_pPngLL;
		} else {
			(id->m_pPngCurp)->np = calloc(1, sizeof(MAPLL));
			id->m_pPngCurp = (id->m_pPngCurp)->np;
		}

		strncpy_s((id->m_pPngCurp)->mapfilename, NAMESIZE, filename, _TRUNCATE);
		(id->m_pPngCurp)->x1 = x1;
		(id->m_pPngCurp)->y1 = y1;
		(id->m_pPngCurp)->x2 = x2;
		(id->m_pPngCurp)->y2 = y2;

		if (!mapimage){
			(id->m_pPngCurp)->nStatus = 1;
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to open \"%s\", file does not exist.\n", cdwThreadId, filename);
			return (FAIL);
		}

		glGenTextures(1, &(id->m_pPngCurp)->maptexture);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", cdwThreadId, filename, (id->m_pPngCurp)->maptexture);
		png = id->m_pPngCurp;

		glBindTexture(GL_TEXTURE_2D, png->maptexture);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texturesize, texturesize, 0, GL_RGBA,
			GL_UNSIGNED_BYTE, mapimage);
		if (map_square_pixels){
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		} else {
			/* Linear Filtering */
			/* produces a smoothed image, more accurate and realistic? */
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		}
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);


		free(mapimage);
		mapimage = NULL;

	} else if(png->nStatus){
		return (FAIL);
	}

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	if (rotate == 1){
		RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
			id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);
	}

	//glOrtho((GLfloat) 0.0f, (GLfloat)id->m_nWidth,
	//(GLfloat) 0.0f, (GLfloat) id->m_nHeight, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);
	glBindTexture(GL_TEXTURE_2D, png->maptexture);

	/* solid with alpha masking */
	//  fw  glEnable(GL_DEPTH_TEST);


	// glDepthFunc(GL_LEQUAL); // must be Less than or Equal since ocean has depth now for terrain
	// glDepthFunc(GL_EQUAL);

	glPushMatrix();
	glLoadIdentity();


	glTranslatef((GLfloat)x1, (GLfloat)y1, (GLfloat)trans[2]);

	params[0] = 1.0f;
	params[1] = 1.0f;
	params[2] = 1.0f;
	params[3] = 1.0f;

	glEnable(GL_BLEND);
	// glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glBlendFunc(GL_SRC_ALPHA, dfactor);

	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

	glEnable(GL_TEXTURE_2D);
	glColor4f(MapIntensity, MapIntensity, MapIntensity, 1.0f);

	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat)YSize, 0.0);
	glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)XSize, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)XSize, (GLfloat)YSize, 0.0);

	glEnd();

	glFlush();

	glPopMatrix();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

	// reset to standard blend func
	//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	return(SUCCEED);

}




PlotFixes(struct InstanceData* id, VO *FPFixesVO)
{
	int i;
	double y, x, x2, y2;
	char pngfilename[256];
	int xpixel, ypixel, colorcode;

	for (i = 0; i < FPFixesVO->count; i++){

		colorcode = VV(FPFixesVO, i, "type", int);
		switch (colorcode)
		{
		case 0:
			sprintf_s(pngfilename, _countof(pngfilename), "purplesquare.png");
			break;
		case 1:
			sprintf_s(pngfilename, _countof(pngfilename), "brownsquare.png");
			break;
		case 2:
			sprintf_s(pngfilename, _countof(pngfilename), "magentasquare.png");
			break;
		case 3:
			sprintf_s(pngfilename, _countof(pngfilename), "greensquare.png");
			break;
		default:
			sprintf_s(pngfilename, _countof(pngfilename), "greensquare.png");
			break;
		}

		/* convert X and Y from world to pixel coordinates */
		y = VV(FPFixesVO, i, "lat", double);
		x = VV(FPFixesVO, i, "lng", double);

		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		// move the dot so it centers on the original point
		xpixel -= 6;
		ypixel -= 6;
		y = (((double)ypixel / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
		x = (((double)xpixel / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;

		xpixel += FAABallSize;  // move to opposite corner for the other endpoints of image
		ypixel += FAABallSize;

		y2 = (((double)ypixel / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
		x2 = (((double)xpixel / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;

		DisplayCachedPNG(id, pngfilename, 16, (float)x, (float)x2, (float)y, (float)y2,
			(float)(x2 - x), (float)(y2 - y), GL_ONE_MINUS_SRC_ALPHA, ALPHA_MODE_NONE, TRUE);

		DrawGLText(id, xpixel, ypixel, VP(FPFixesVO, i, "Name", char), (GLfloat *)blue, id->m_gluCustomBase, TRUE); 
	}
}

void PlotRoute2( struct InstanceData* id, char *FltRoute, char *FltWaypoints )
{
	char *token;
	//char route[512];
	static VO *FPFixesVO;
	char seps[] = "./";
	//char startfixname[11], endfixname[11];
	double lat = 0.0, lng = 0.0;//, miles, degrees, angle_rads, rads, degree_long, radius, cosval, sinval;
	//double tmprads, dis;
	//double mindis = 9.0e9;
	//int tk;
	//int degs, minutes, ew;
	char tmpstr[ TMPBUF_SIZE ];
	char waypoints[ TMPBUF_SIZE ];
	//AIRWAY *Airway, *startairway;
	//NAV *Nav;
	//FIX *Fix;
	char fixname[7] = {0};
	//char buf[15] = {0};
	float fval = 0;
	//STARSID *Star;
	//ARPT *Arpt;
	//char *airwaystr;
	//char *airname;
	int cnt = 0;
	char *context;
	VLL *CurVLL = NULL;
	char *cptr;
	GLfloat *textColor = (GLfloat *) white;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if ( !FltRoute || !strlen( FltRoute ) ){
		return;
	}

	if ( id->m_pVList ){
		FreeVList(id);
	}

	if ( !FPFixesVO ){
		FPFixesVO = (VO *) vo_create( 0 , NULL);
		vo_set( FPFixesVO, V_NAME, "FPFixesVO", NULL );
		VOPropAdd( FPFixesVO, "Name", NTBSTRINGBIND, 20, VO_NO_ROW );
		VOPropAdd( FPFixesVO, "lat", FLT8BIND, -1, VO_NO_ROW );
		VOPropAdd( FPFixesVO, "lng", FLT8BIND, -1, VO_NO_ROW );
		VOPropAdd( FPFixesVO, "type", INTBIND, -1, VO_NO_ROW ); // 0 = fix, 1 = Nav, 2 = ARPT
		vo_rm_rows( FPFixesVO, 0, FPFixesVO->count );
	}
	vo_rm_rows( FPFixesVO, 0, FPFixesVO->count );

	strncpy_s( waypoints, TMPBUF_SIZE, FltWaypoints, strlen(FltWaypoints) );
	
	RouteInitOpenGL(id);

	token = strtok_s( waypoints, seps, &context );
	
	glBegin(GL_LINE_STRIP);

	while( token != NULL )
	{
		// Get Name
		strncpy_s(fixname, 7, token, strlen(token));
		// Get Latitude
		token = strtok_s( NULL, seps, &context );
		lat = atof(token)/3600.0f;
		// Get Longitude
		token = strtok_s( NULL, seps, &context );
		lng = atof(token)/3600.0f;

		CurVLL = FixFarEast( id, FPFixesVO, &lat, &lng, token, 2, CurVLL );

		// FixFarEast( FPFixesVO, &lat, &lng, token, 2 );
		glColor3fv(black);
		// in vlist now glVertex3f( (float) lng, (float) lat, 0.0f );
		CurVLL = addvlink( id, CurVLL, lng, lat );
		
		token = strtok_s( NULL, seps, &context );
		if(0 == cnt || NULL == token) 
			AddFPFix(FPFixesVO, fixname, lat, lng, 2 );
		else
			AddFPFix(FPFixesVO, fixname, lat, lng, 0 );
		cnt++;
	}

	sprintf_s(tmpstr, TMPBUF_SIZE, "%s", FltRoute );
	MGLGridText(id, statusgrid, 22, 0, "route");
	MGLGridText(id, statusgrid, 22, 1, tmpstr);

	CheckVList(id);

	glEnd();

	glFlush ();
	glPopMatrix();

	glColor3fv(white);

	PlotFixes( id, FPFixesVO );

	switch(id->m_nSelectedAircraftType){
			case SAT_PASSUR:
				textColor = id->m_sCurLayout.m_glfLargeTagTextColorPASSUR;
				break;
			case SAT_ASDI: 
				textColor = id->m_sCurLayout.m_glfLargeTagTextColorASDI; 
				break;
			case SAT_ASDEX: 
				textColor = id->m_sCurLayout.m_glfLargeTagTextColorASDEX;
				break;
	}
	sprintf_s(tmpstr, TMPBUF_SIZE, "Flight plan route: %s", FltRoute);
	for(cptr=tmpstr; *cptr; cptr++)
		if(*cptr=='\n' || *cptr=='\r')
			*cptr='\0';
	DrawGLText(id, FLIGHTPLAN_X_OFFSET, id->m_nViewPortHeight - FLIGHTPLAN_Y_OFFSET, tmpstr, textColor, id->m_gluCustomBase, FALSE);
}

void PlotRoute(struct InstanceData* id, char *FltRoute)
{
	char *token;
	char route[512];
	static VO *FPFixesVO;
	char seps[] = "./";
	char startfixname[11], endfixname[11];
	double lat = 0.0, lng = 0.0, miles, degrees, angle_rads, rads, degree_long, radius, cosval, sinval;
	double tmprads, dis;
	double mindis = 9.0e9;
	int tk;
	int degs, minutes, ew;
	char tmpstr[TMPBUF_SIZE];
	AIRWAY *Airway, *startairway;
	NAV *Nav;
	FIX *Fix;
	STARSID *Star;
	ARPT *Arpt;
	char *airwaystr;
	char  *airname;
	char *context;
	VLL *CurVLL = NULL;
	char *cptr;
	GLfloat *textColor = (GLfloat *)white;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!FltRoute || !strlen(FltRoute)){
		return;
	}

	if (id->m_pVList){
		FreeVList(id);
	}

	if (!FPFixesVO){
		FPFixesVO = (VO *)vo_create(0, NULL);
		vo_set(FPFixesVO, V_NAME, "FPFixesVO", NULL);
		VOPropAdd(FPFixesVO, "Name", NTBSTRINGBIND, 20, VO_NO_ROW);
		VOPropAdd(FPFixesVO, "lat", FLT8BIND, -1, VO_NO_ROW);
		VOPropAdd(FPFixesVO, "lng", FLT8BIND, -1, VO_NO_ROW);
		VOPropAdd(FPFixesVO, "type", INTBIND, -1, VO_NO_ROW); // 0 = fix, 1 = Nav, 2 = ARPT
		vo_rm_rows(FPFixesVO, 0, FPFixesVO->count);
	}
	vo_rm_rows(FPFixesVO, 0, FPFixesVO->count);

	strncpy_s(route, _countof(route), FltRoute, 511);

	RouteInitOpenGL(id);


	token = strtok_s(route, seps, &context);

	glBegin(GL_LINE_STRIP);

	startfixname[0] = '\0';
	endfixname[0] = '\0';
	while (token != NULL)
	{
		/* While there are tokens in "string" */

		// find the lat/long for this token
		if (isdigit(token[0]) && isdigit(token[1]) && isdigit(token[2]) && isdigit(token[3])){
			// lat/lng found
			// first is latitude
			degs = (10 * (token[0] - '0')) + token[1] - '0';
			minutes = (10 * (token[2] - '0')) + token[3] - '0';
			if (token[4] == 'S'){
				// south latitude
				degs *= -1;
				minutes *= -1;
			}
			lat = (float)degs + ((float)minutes / 60.0);

			// next token must be longitude
			token = strtok_s(NULL, seps, &context);
			if (!token){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad lat/lng pair in route\n", cdwThreadId);
				break;
			}
			if (isdigit(token[0]) && isdigit(token[1]) && isdigit(token[2]) && isdigit(token[3])){
				// valid long found
				if (isdigit(token[4])){
					// five digits in longitude, first three are degrees
					degs = (100 * (token[0] - '0')) + (10 * (token[1] - '0')) + token[2] - '0';
					minutes = (10 * (token[3] - '0')) + token[4] - '0';
					ew = token[5];
				} else {
					degs = (10 * (token[0] - '0')) + token[1] - '0';
					minutes = (10 * (token[2] - '0')) + token[3] - '0';
					ew = token[4];
				}
				if (ew != 'E'){
					degs *= -1;
					minutes *= -1;
				}
			}
			lng = (float)degs + (minutes / 60.0f);
			CurVLL = FixFarEast(id, FPFixesVO, &lat, &lng, token, 2, CurVLL);

			// FixFarEast( FPFixesVO, &lat, &lng, token, 2 );
			glColor3fv(black);
			// in vlist now glVertex3f( (float) lng, (float) lat, 0.0f );
			CurVLL = addvlink(id, CurVLL, lng, lat);

			sprintf_s(tmpstr, TMPBUF_SIZE, "%2.0f%c/%2.0f%c", lat, 'N', fabs(lng), ew);
			AddFPFix(FPFixesVO, tmpstr, lat, lng, 0);
		} else if ( ( strlen( token ) == 9 && isalpha(token[0]) && isalpha(token[1]) && isalpha(token[2]) && isdigit(token[3]) &&
			isdigit(token[4]) && isdigit(token[5]) && isdigit(token[6]) && isdigit(token[7]) && isdigit(token[8])) ||
			(strlen(token) == 11 && isalpha(token[0]) && isalpha(token[1]) && isalpha(token[2]) && isalpha(token[3])
			&& isalpha(token[4]) && isdigit(token[5]) &&
			isdigit(token[6]) && isdigit(token[7]) && isdigit(token[8]) && isdigit(token[9]) && isdigit(token[10]))
			){
			// radial fix
			// find nav point for first 3 chars
			strncpy_s(tmpstr, TMPBUF_SIZE, token, 3);

			do {
				if ((Nav = FindNavRow(id, tmpstr))){
					lat = Nav->lat;
					lng = Nav->lng;
					} else if (Fix = FindFixRow( id, token, lng, lat )){
					lat = Fix->lat;
					lng = Fix->lng;
					} else {
					break;
				}
				// get nautical miles from fix
				strncpy_s(tmpstr, TMPBUF_SIZE, &token[6], 3);
				tmpstr[3] = '\0';
				miles = atof(tmpstr);
				// get degrees for angle from fix
				strncpy_s(tmpstr, TMPBUF_SIZE, &token[3], 3);
				tmpstr[3] = '\0';
				degrees = atoi(tmpstr);

				// convert to radians
				angle_rads = degrees * M_PI / 180.0;

				// adjust for radial values
				rads = lat * M_PI / 180.0;
				degree_long = 69.172 * cos(rads);

				radius = miles / degree_long;
				cosval = cos(angle_rads);
				sinval = sin(angle_rads);
				lng = lng + (radius * cosval);
				lat = lat + (radius * sinval);

				/// glVertex3f( (float) lng, (float) lat, 0.0f );
				CurVLL = addvlink(id, CurVLL, lng, lat);

				strncpy_s(startfixname, _countof(startfixname), token, _TRUNCATE);
				AddFPFix(FPFixesVO, startfixname, lat, lng, 1);
			} while (0); // no need to loop, just need to break out on occasion
		} else {  // see if closest token is arpt, fix, or nav
			mindis = 9.9e9;
			tk = 0;
			if (strlen(token) <= 4 && (Arpt = FindArptRow(id, token, MATCH_ALL))){
				// if no lat lng found yet, use airport since that is usually first point
				if (fabs(lng) < 0.001 && fabs(lat) < 0.001){
					lng = Arpt->lng;
					lat = Arpt->lat;
				}
				tmprads = acos(sin(RADS(lat)) * sin(RADS(Arpt->lat)) + cos(RADS(lat)) * cos(RADS(Arpt->lat)) * cos(RADS(Arpt->lng - lng)));
				dis = 60.0 * DEGS(tmprads); // NM
				if (dis < mindis){
					tk = 1; // arpt
					mindis = dis;
				}
			}
			if ((Nav = FindNavRow(id, token))){
				tmprads = acos(sin(RADS(lat)) * sin(RADS(Nav->lat)) + cos(RADS(lat)) * cos(RADS(Nav->lat)) * cos(RADS(Nav->lng - lng)));
				dis = 60.0 * DEGS(tmprads); // NM
				if (dis < mindis){
					tk = 2; // nav
					mindis = dis;
				}
			}
			if ((Fix = FindFixRow(id, token, lng, lat))){
				tmprads = acos(sin(RADS(lat)) * sin(RADS(Fix->lat)) + cos(RADS(lat)) * cos(RADS(Fix->lat)) * cos(RADS(Fix->lng - lng)));
				dis = 60.0 * DEGS(tmprads); // NM
				if (dis < mindis){
					tk = 3; // fix
					mindis = dis;
				}
			}
			if ((Star = FindStarRow(id, token))){
				tmprads = acos(sin(RADS(lat)) * sin(RADS(Star->lat)) + cos(RADS(lat)) * cos(RADS(Star->lat)) * cos(RADS(Star->lng - lng)));
				dis = 60.0 * DEGS(tmprads); // NM
				if (dis < mindis){
					tk = 4; // star
					mindis = dis;
				}
			}
			if ((airwaystr = AdjustAirwayName(token)) && (Airway = FindAirRow(id, airwaystr))){
				tmprads = acos(sin(RADS(lat)) * sin(RADS(Airway->lat)) + cos(RADS(lat)) * cos(RADS(Airway->lat)) * cos(RADS(Airway->lng - lng)));
				dis = 60.0 * DEGS(tmprads); // NM
				if (dis < mindis){
					tk = 5;  // airway
					mindis = dis;
				}
			}

			if (tk == 1){
				// use arpt
				// found arpt
				lat = Arpt->lat;
				lng = Arpt->lng;

				CurVLL = FixFarEast(id, FPFixesVO, &lat, &lng, token, 2, CurVLL);

				glColor3fv(black);
				//  glVertex3f( (float) lng, (float) lat, 0.0f );
				CurVLL = addvlink(id, CurVLL, lng, lat);

				strncpy_s(startfixname, _countof(startfixname), Arpt->icao, 6);
				AddFPFix(FPFixesVO, startfixname, lat, lng, 2);
			} else if ( tk == 2 ){
				lat = Nav->lat;
				lng = Nav->lng;
				CurVLL = FixFarEast(id, FPFixesVO, &lat, &lng, token, 2, CurVLL);
				// glVertex3f( (float) lng, (float) lat, 0.0f );
				CurVLL = addvlink(id, CurVLL, lng, lat);

				strncpy_s(startfixname, 11, Nav->navname, 6);
				AddFPFix(FPFixesVO, startfixname, lat, lng, 1);
			} else if ( tk == 3  ){
				lat = Fix->lat;
				lng = Fix->lng;
				CurVLL = FixFarEast(id, FPFixesVO, &lat, &lng, token, 2, CurVLL);
				glColor3fv(black);
				// glVertex3f( (float) lng, (float) lat, 0.0f );
				CurVLL = addvlink(id, CurVLL, lng, lat);

				strncpy_s(startfixname, 11, Fix->fixname, 6);
				AddFPFix(FPFixesVO, startfixname, lat, lng, 0);
			} else if ( tk == 4 ){
				lat = Star->lat;
				lng = Star->lng;
				CurVLL = FixFarEast(id, FPFixesVO, &lat, &lng, token, 2, CurVLL);
				glColor3fv(black);
				// glVertex3f( (float) lng, (float) lat, 0.0f );
				CurVLL = addvlink(id, CurVLL, lng, lat);

				strncpy_s(startfixname, 11, Star->starname, 6);
				AddFPFix(FPFixesVO, startfixname, lat, lng, 0);
			} else if ( tk == 5 ){
				airname = Airway->name;
				startairway = Airway;

				do {
					startairway -= 1;
				} while (startairway > (AIRWAY*)g_pAirways && !strcmp(startairway->name, airname));

				startairway += 1; // go to last good airway
				// next token must be ending fix
				token = strtok_s(NULL, seps, &context);
				if (!token){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad fix/airway pair in route\n", cdwThreadId);
					break;
				}
				if ((Fix = FindFixRow(id, token, lng, lat))){
					lat = Fix->lat;
					lng = Fix->lng;
					glColor3fv(black);
					// do not plot, will be plotted in PlotAirway()  glVertex3f( (float) lng, (float) lat, 0.0f );
					strncpy_s(endfixname, 11, Fix->fixname, 6);
					AddFPFix(FPFixesVO, endfixname, lat, lng, 0);
				} else if ( (Nav = FindNavRow( id, token ) ) ){
					lat = Nav->lat;
					lng = Nav->lng;
					// do not plot, will be plotted in PlotAirway() glVertex3f( (float) lng, (float) lat, 0.0f );
					strncpy_s(endfixname, 11, Nav->navname, 6);
					AddFPFix(FPFixesVO, endfixname, lat, lng, 1);
				}

				CurVLL = PlotAirway(id, startairway, startfixname, endfixname, airname, CurVLL);
				strncpy_s(startfixname, 11, endfixname, 6);
			} else {
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad tk=%d token=%s\n", cdwThreadId, tk, token);
			}
		}

		/* Get next token: */
		token = strtok_s(NULL, seps, &context);

	}
	sprintf_s(tmpstr, TMPBUF_SIZE, "%s", FltRoute);
	MGLGridText(id, statusgrid, 22, 0, "route");
	MGLGridText(id, statusgrid, 22, 1, tmpstr);

	CheckVList(id);

	glEnd();

	glFlush();
	glPopMatrix();

	glColor3fv(white);

	PlotFixes(id, FPFixesVO);

	switch (id->m_nSelectedAircraftType){
	case SAT_PASSUR:
		textColor = id->m_sCurLayout.m_glfLargeTagTextColorPASSUR;
		break;
	case SAT_ASDI:
		textColor = id->m_sCurLayout.m_glfLargeTagTextColorASDI;
		break;
	case SAT_ASDEX:
		textColor = id->m_sCurLayout.m_glfLargeTagTextColorASDEX;
		break;
	}
	sprintf_s(tmpstr, TMPBUF_SIZE, "Flight plan route: %s", FltRoute);
	for (cptr = tmpstr; *cptr; cptr++)
		if (*cptr == '\n' || *cptr == '\r')
			*cptr = '\0';
	DrawGLText(id, FLIGHTPLAN_X_OFFSET, id->m_nViewPortHeight - FLIGHTPLAN_Y_OFFSET, tmpstr, textColor, id->m_gluCustomBase, FALSE);
}

void PlotFltPlan(struct InstanceData* id, AIR **airp, int TrackID)
{
	char *FltRoute, *origroute;
	char *Orig;
	char *nastr;
	AIR *air;
	char tmpstr[256];

	if (!airp || TrackID < 0){
		return;
	}

	if (!(air = airp[TrackID])){
		return;
	}

	if (!(FltRoute = air->FltRoute)){
		// not in AirVO, so query from FlightPlan database

		if ((Orig = air->FltRouteOrig) &&
			!strcmp(Orig, "N/A"))
		{
			// already checked this aircraft, no flight plan found
			// try to fill in with orig/dest
			if (strlen(air->Destin) && strlen(air->Origin)){
				// use origin and destination as flight plan
				sprintf_s(tmpstr, _countof(tmpstr), "%s..%s", air->Origin, air->Destin);
				air->FltRoute = str_falloc(tmpstr);
				air->FltRouteOrig = str_falloc(tmpstr);
			} else {
				id->m_strFltRoute[0] = '\0';
				return;
			}
		}

		QryFlightPlanLines(id, air);
		if (!(FltRoute = air->FltRoute)){
			if (strlen(air->Destin) && strlen(air->Origin)){
				// use origin and destination as flight plan
				sprintf_s(tmpstr, _countof(tmpstr), "%s..%s", air->Origin, air->Destin);
				air->FltRoute = str_falloc(tmpstr);
				air->FltRouteOrig = str_falloc(tmpstr);
			} else {
				// put in N/A to avoid querying for this flight plan every second
				id->m_strFltRoute[0] = '\0';
				nastr = malloc(4);
				strcpy_s(nastr, 4, "N/A");
				air->FltRouteOrig = nastr;
				return;
			}
		}

		if (!(FltRoute = air->FltRoute)){
			// should not get here
			return;
		}

	}

	/* draw lines for each leg of flight */
	/* flight plans is composed of airports, fixes, lat/lon coordinates, jet routes */
	/* use data from APT.TXT, NAV.TXT, FIX,TXT, AWY.TXT */


	/*  ...copy arpts structure to use for nav aids... */
	origroute = air->FltRouteOrig;

	// parse the fltroute into components

	strncpy_s(id->m_strFltRoute, 512, FltRoute, _TRUNCATE);

	if( air->FltRouteWaypoints )
	{
		PlotRoute2( id, id->m_strFltRoute, air->FltRouteWaypoints );
	}
	else
	{
		PlotRoute(id, id->m_strFltRoute);
	}
}

void DisplayFltPlan(struct InstanceData* id)
{
	int aircount;
	AIR **airp;
	AIR *air;

	/* show flight plan lines for selected aircraft */
	if (!id->m_pSelectedAirP){
		return;
	}

	airp = (AIR**)id->m_pSelectedAirP;
	air = airp[id->m_nSelectedTrackID];
	if (IsASDAirP(id, airp)){
		aircount = N_TRACK_ID;
	} else {
		aircount = N_PASSUR_TRACK_ID;
	}
	if (id->m_pSelectedAircraft && id->m_nSelectedTrackID >= 0 &&
		air && id->m_nSelectedTrackID < aircount &&
		!strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// found selected
		PlotFltPlan(id, (AIR**)id->m_pSelectedAirP, id->m_nSelectedTrackID);
	} else {
		/* no selected flight to show */
		return;
	}
}


int CalcSpeed(struct InstanceData* id, AIR **airp, int AI, int startindex)
{
	int prevtrack, alt, tcount;
	PTRACK *trackarr;
	double lat1, lng1, lat2, lng2, dis, speed, tmprads;
	time_t endutc, startutc;
	AIR *air;
	int e1 = 10, e2 = 5;
	// char starttime[256], endtime[256];

	// calc speed in knots (NM per hour)
	// try to calc speed based on last few target points

	if (!(air = airp[AI])){
		return(0);
	}
	if (!(trackarr = air->TrackPtr)){
		/* first point */
		/* use asd speed */
		return(0);
	}

	alt = air->altitude;
	if (IsASDAirP(id, airp) && alt > 10000 && alt > 0 && air->speed > 0){
		/* use reported speed from ASD */
		return(0);
	}

	// Adjust Track length for ADSB abd ASDEX Tracks to determine speed
	if (IsASDEXAirP(id, airp) || IsADSBAirP(id, airp)){
		e1 = 20;
		e2 = 10;
	}

	/* make sure the new point id different than previous,
	mainly for asd tracks */
	if (startindex < 0){
		// use last point in array
		tcount = air->tcount;
	} else {
		// use starting point specified
		tcount = startindex + 1; // add one since we used tcount - 1 as start point
	}
	if (tcount > 1){

		if (alt < 3000){
			prevtrack = MAX(tcount - 3, 0);
			endutc = trackarr[tcount - 1].utc;
			startutc = trackarr[prevtrack].utc;
			if (endutc - startutc < 10){
				// must be passur tracks less than 10 seconds apart, so increase points
				prevtrack = MAX(tcount - e2, 0);
			}
		} else {
			prevtrack = MAX(tcount - e1, 0);
		}
		endutc = trackarr[tcount - 1].utc;
		startutc = trackarr[prevtrack].utc;

		lat1 = trackarr[tcount - 1].y;
		lng1 = trackarr[tcount - 1].x;
		lat2 = trackarr[prevtrack].y;
		lng2 = trackarr[prevtrack].x;

		tmprads = acos(sin(RADS(lat1)) * sin(RADS(lat2)) + cos(RADS(lat1)) * cos(RADS(lat2)) * cos(RADS(lng2 - lng1)));

		dis = 60.0 * DEGS(tmprads); // NM

		speed = dis * 3600 / (endutc - startutc); // rough nmph
		// Show slower speeds with ASDEX data
		if (!(id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft || id->m_sCurLayout.m_bShowMLATAircraft) && speed < 100.0){
			return(100);
		}
		if (speed < 700.0){
			return((int)speed);
		}
	}
	return(0);
}

float PolarToCompass(float polar){
	// Attempt to Normalize angle between 360 to -360
	while (polar > 360.0f) polar -= 360.0f;
	while (polar < -360.0f) polar += 360.0f;
	// Convert To Compass
	polar = polar * -1.0f + 90.0f;
	// Re-normalize
	if (polar > 360.0f) polar -= 360.0f;
	else if (polar < 0.0f) polar += 360.0f;
	return polar;
}


char *GetValue(struct InstanceData* id, char *field, AIR **airp, int AI)
{
	char *str;
	static char bufstr[64];
	int etasecs, speed;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!(air = airp[AI])){
		return("");
	}

	if (!strcmp(field, "None")){
		return("");
	} else if ( !strcmp( field , "Flight ID")){
		if ((str = air->FltNum) && strlen(str)){
			if (air->IsBARR)
				str = "Blocked";
			else if (!strcmp(str, "UNKN")){
				if ( strlen(air->TmpFltNum) )
					str = air->TmpFltNum;
				else{
				sprintf_s(bufstr, _countof(bufstr), "UNKN[%d]", air->trackid);
				return(bufstr);
			}
		}
		}else if ( strlen(air->TmpFltNum) ){
			if( air->IsBARR )
				str = "Blocked";
			else if ( !strcmp( str, "UNKN" ) ){
				sprintf_s(bufstr, _countof(bufstr), "UNKN[%d]", air->trackid );
				return( bufstr );
			}else{
				str = air->TmpFltNum;
			}
		} else {
			str = "N/A";
		}
		return(str);
	} else if ( !strcmp( field , "Origin")){
		return(air->Origin);
	} else if ( !strcmp( field , "Gate")){
		if (strlen(air->gate)){
			sprintf_s(bufstr, _countof(bufstr), "GATE:%s", air->gate);
			return (bufstr);
		}else
			return("");
	} else if ( !strcmp( field , "Runway")){
		if (strlen(air->runway)){
			sprintf_s(bufstr, _countof(bufstr), "RWY:%s", air->runway);
			return (bufstr);
		}else
			return("");
	} else if ( !strcmp( field , "Destination")){
		return(air->Destin);
	} else if ( !strcmp( field , "Estimated Time of Arrival")){
		if ((etasecs = air->eta) > 100000){
			_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "@%s", ShowTime(id, air->eta));
		} else {
			strncpy_s(bufstr, _countof(bufstr), "", _TRUNCATE);
		}
		return(bufstr);
	} else if ( !strcmp( field , "Estimated Time of Departure")){
		if ((etasecs = air->etd) > 100000){
			_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "@%s", ShowTime(id, air->etd));
		} else {
			strncpy_s(bufstr, _countof(bufstr), "", _TRUNCATE);
		}
		return(bufstr);
	} else if ( !strcmp( field, "Time of Departure")){
		if ((etasecs = air->atd) > 100000){
			_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "dp %s", ShowTime(id, air->atd));
		} else {
			strncpy_s(bufstr, _countof(bufstr), "", _TRUNCATE);
		}
		return(bufstr);
	} else if ( !strcmp( field, "Aircraft Type")){
		return(air->actype);
	} else if ( !strcmp( field, "Speed")){
		if ((speed = CalcSpeed(id, airp, AI, -1)) || (speed = air->speed)){
			sprintf_s(bufstr, _countof(bufstr), "%dkt", speed);
			return(bufstr);
		} else {
			return("");
		}
	} else if ( !strcmp( field, "Altitude")){
		if (air->altitude > 0){
			if (IS_D_CONTROL("ALTITUDE")){
				sprintf_s(bufstr, _countof(bufstr), "%03d", air->altitude);
			}else{
				sprintf_s(bufstr, _countof(bufstr), "%03d", (air->altitude / 100));
			}
			return(bufstr);
		}else
			return("");
	} else if (!strcmp( field, "PASSUR Tail") || !strcmp(field, "Tail Number")){
		if ((str = air->tail) && strlen(str)){
		} else {
			str = "";
		}
		return(str);
	} else if ( !strcmp( field, "N. Miles to Destination")){
		sprintf_s(bufstr, _countof(bufstr), "%2.1f N.M.", air->DestDis);
		return(bufstr);
	} else if ( !strcmp( field, "Region")){
		return(air->Region);
	} else if ( !strcmp( field , "Arrival Fix")){
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (1) field <%s> air->FltNum <%s>, air->ArrivalFix <%s> \n",
			cdwThreadId, field, air->FltNum, air->ArrivalFix));
		return(air->ArrivalFix);
	} else if ( !strcmp( field , "Departure Fix")){
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2) field <%s> air->FltNum <%s>, air->DepartureFix <%s> \n",
			cdwThreadId, field, air->FltNum, air->DepartureFix));
		return(air->DepartureFix);
	} else if ( !strcmp( field, "Time Taxiing")){
		if (air->tt){
			int hours = air->tt / 3600;
			int mins = (air->tt - (hours * 3600)) / 60;
			int secs = (air->tt - (hours * 3600) - (mins * 60));
			if (hours > 0)
				_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "%02d:%02d:%02d", hours, mins, secs);
			else
				_snprintf_s(bufstr, _countof(bufstr), _TRUNCATE, "%02d:%02d", mins, secs);
			return(bufstr);
		}else{
			return ("");
		}
	} else if ( !strcmp( field, "Diverted From")){
		return(air->DivDestin);
	} else if ( !strcmp( field, "Latitude")){
		sprintf_s(bufstr, _countof(bufstr), "LAT:%2.3f", air->CurY);
		return(bufstr);
	} else if ( !strcmp( field, "Longitude")){
		sprintf_s(bufstr, _countof(bufstr), "LON:%2.3f", air->CurX);
		return(bufstr);
	} else if ( !strcmp( field, "Heading")){
		if (air->heading >= 0.0f && air->heading <= 360.0f){
			sprintf_s(bufstr, _countof(bufstr), "%3.1f\xB0", air->heading);
		}else if(air->PrevAngle){
			float h = PolarToCompass(air->PrevAngle);
			sprintf_s(bufstr, _countof(bufstr), "%3.1f\xB0", h);
		}else
			return ("");
		return(bufstr);
	} else if ( !strcmp( field, "Beacon")){
		sprintf_s(bufstr, _countof(bufstr), "%04o", air->beacon);
		return(bufstr);
	} else if ( !strcmp( field, "Track ID")){
		sprintf_s(bufstr, _countof(bufstr), "%d", air->trackid);
		return(bufstr);
	} else if ( !strcmp( field, "icao24")){
		sprintf_s(bufstr, _countof(bufstr), "%X", air->icao24);
		return(bufstr);
	} else if ( !strcmp( field, "Freeform Text")){
		if (air->FFTInfoPtr && air->FFTInfoPtr->text){
			sprintf_s(bufstr, _countof(bufstr), "%s", air->FFTInfoPtr->text);
			return( bufstr );
		}else
			return ("");
	} else if ( !strcmp( field, "Fuel on Board")){
		if( air->fob > 0 ){
			sprintf_s(bufstr, _countof(bufstr), "%d", air->fob);
			return( bufstr );
		}else{
			return ("");
	}
	} else if ( !strcmp( field, "Description") && air->VInfoPtr){
		sprintf_s(bufstr, _countof(bufstr), "%s", air->VInfoPtr->Description);
		return(bufstr);
	} else if ( !strcmp( field, "Vehicle Tag") && air->VInfoPtr){
		sprintf_s(bufstr, _countof(bufstr), "%s", air->VInfoPtr->Tag);
		return(bufstr);
	} else if ( !strcmp( field, "Vehicle ID") && air->vehicle ){
		if (air->VInfoPtr){
			sprintf_s(bufstr, _countof(bufstr), "%s", air->VInfoPtr->Id);
		}else if ( (str = air->FltNum ) && !strcmp( str, "UNKN" ) ){
			sprintf_s(bufstr, _countof(bufstr), "UNKN[%d]", air->trackid);
			return(bufstr);
		}
		return(bufstr);
	} else if ( !strcmp( field, "RANGR-G") && air->VInfoPtr){
		sprintf_s(bufstr, _countof(bufstr), "%s", air->VInfoPtr->SerNo);
		return(bufstr);
	} else if ( !strcmp( field, "Frequency") && air->VInfoPtr){
		sprintf_s(bufstr, _countof(bufstr), "%s", air->VInfoPtr->Frequency);
		return(bufstr);
	} else if ( !strcmp( field, "Category") && air->VInfoPtr){
		sprintf_s(bufstr, _countof(bufstr), "%s", air->VInfoPtr->Type);
		return(bufstr);
	} else {
		return("");
	}
	return ("");
}

char *GetAlertLine(struct InstanceData* id, AIR *air)
{
	char val1[256] = { 0 };
	char val2[256] = { 0 };
	char val3[256] = { 0 };
	int hours = 0;
	int mins = 0;
	int secs = 0;
	static char valstr[256];

	switch (air->alert)
	{
	case ALERT_TD_OTO:
		strncpy_s(val1, _countof(val1), "Tarmac Delay OTO", _TRUNCATE);
		hours = air->td_oto / 3600;
		mins = (air->td_oto - (hours * 3600)) / 60;
		secs = (air->td_oto - (hours * 3600) - (mins * 60));

		if (hours > 0)
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d:%02d", hours, mins, secs);
		else
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d", mins, secs);
		break;
	case ALERT_TD_OTI:
		strncpy_s(val1, _countof(val1), "Tarmac Delay OTI", _TRUNCATE);
		hours = air->td_oti / 3600;
		mins = (air->td_oti - (hours * 3600)) / 60;
		secs = (air->td_oti - (hours * 3600) - (mins * 60));

		if (hours > 0)
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d:%02d", hours, mins, secs);
		else
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d", mins, secs);
		break;
	case ALERT_RG_OTO:
		strncpy_s(val1, _countof(val1), "Region Delay OTO", _TRUNCATE);
		hours = air->rg_oto / 3600;
		mins = (air->rg_oto - (hours * 3600)) / 60;
		secs = (air->rg_oto - (hours * 3600) - (mins * 60));

		if (hours > 0)
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d:%02d", hours, mins, secs);
		else
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d", mins, secs);
		break;
	case ALERT_RG_OTI:
		strncpy_s(val1, _countof(val1), "Region Delay OTI", _TRUNCATE);
		hours = air->rg_oti / 3600;
		mins = (air->rg_oti - (hours * 3600)) / 60;
		secs = (air->rg_oti - (hours * 3600) - (mins * 60));

		if (hours > 0)
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d:%02d", hours, mins, secs);
		else
			_snprintf_s(val2, _countof(val2), _TRUNCATE, "%02d:%02d", mins, secs);
		break;
	}

	_snprintf_s(valstr, _countof(valstr), _TRUNCATE, "ALERT: %s %s %s", val1, val2, val3);
	return(valstr);
}

char *GetTagLine(struct InstanceData* id, char *TagLine, AIR **airp, int AI)
{
	char *field1 = NULL, *field2 = NULL, *field3 = NULL;
	char val1[256], val2[256], val3[256];
	static char valstr[256];
	char	*sprtr = ",";
	char tmpstr[256];
	char *context;


	strncpy_s(tmpstr, _countof(tmpstr), TagLine, _TRUNCATE);
	val1[0] = '\0';
	val2[0] = '\0';
	val3[0] = '\0';

	if (!(field1 = strtok_s(tmpstr, sprtr, &context))){
		return("");
	} else if ( !( field2 = strtok_s ( NULL, sprtr, &context ) )){
	} else if ( !( field3 = strtok_s ( NULL, sprtr, &context )		)){
	}


	if (field1) strncpy_s(val1, _countof(val1), GetValue(id, field1, airp, AI), _TRUNCATE);
	if (field2) strncpy_s(val2, _countof(val1), GetValue(id, field2, airp, AI), _TRUNCATE);
	if (field3) strncpy_s(val3, _countof(val1), GetValue(id, field3, airp, AI), _TRUNCATE);

	_snprintf_s(valstr, _countof(valstr), _TRUNCATE, "%s %s %s", val1, val2, val3);
	return(valstr);
}


char pcS1[] = "%Y-%m-%d %H:%M:%S";
char* pFmt1 = NULL;
char* pFmt2 = NULL;


void DrawPlotTime(struct InstanceData* id)
{
	static time_t oldplottime = 0;
	char strVersion[100] = { 0 };
	double lng2, lat2, realdelta, deltalng, origlng, tmprads, dis;
	int lngdegs, lngmins, lngsecs;
	int latdegs, latmins, latsecs;
	char *mode;
	char tmpstr[512] = { 0 };
	char framestr[64];
	char elapstr[100] = { 0 };
	char lngtmp[TMPBUF_SIZE] = { 0 }, lattmp[TMPBUF_SIZE] = { 0 };
	char stdtime[V_DATE_SIZE] = { 0 };
	char gmtime[V_DATE_SIZE] = { 0 };
	int nPixelHeight = 9;
	AVILIB * avip = &id->avilib;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (subversion){
		sprintf_s(strVersion, 100, "%s.%s", version, subversion);
	}else{
		sprintf_s(strVersion, 100, "%s.0", version);
	}
	switch (id->m_bReplayStatus){
	case REPLAY_STATUS_PLAYING: mode = "REPLAY MODE"; break;
	case REPLAY_STATUS_PAUSED: mode = "REPLAY PAUSED"; break;
	default: mode = " ";
	}
#ifndef _FREE_TYPE_DEV
	GL_ASSERT(glPushMatrix());
	GL_ASSERT(glDisable(GL_DITHER));
	GL_ASSERT(glDisable(GL_TEXTURE_2D));
	GL_ASSERT(glDisable(GL_DEPTH_TEST));
	GL_ASSERT(glDisable(GL_BLEND));
	GL_ASSERT(glShadeModel(GL_FLAT));
	GL_ASSERT(glLoadIdentity());
	GL_ASSERT(glColor3f(1.0, 1.0, 1.0));
	GL_ASSERT(glMatrixMode(GL_PROJECTION));
	GL_ASSERT(glLoadIdentity());
	GL_ASSERT(glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f));
	GL_ASSERT(glMatrixMode(GL_MODELVIEW));
	GL_ASSERT(glLoadIdentity());

	GL_ASSERT(glTranslatef(trans[0], trans[1], trans[2]));
	GL_ASSERT(glLineWidth(1));

	GL_ASSERT(glRasterPos2i(GUI_BORDER_SIZE, nPixelHeight));
#endif//_FREE_TYPE_DEV

	lng2 = (((double)id->m_nBoxX2 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
	lat2 = (((double)id->m_nBoxY2 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

	// inverse coordinates from world projected coordinates into true lat/lon //
	if (lat2 > 0.0001 && projflag){
		origlng = lng2;
		realdelta = lng2 - LngOrig;
		deltalng = realdelta / cos(lat2 * M_PI / 180.0);
		lng2 = deltalng + LngOrig;
	} else {
		origlng = lng2;
	}

	if (!id->m_nBox){
		// show location of cursor
		lng2 = (((double)id->m_nBoxX1 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		lat2 = (((double)id->m_nBoxY1 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
	}

	if (id->m_sUserSettings.DisplayDegrees){
		ConvertDecimal2DegMinSecs(id, lng2, &lngdegs, &lngmins, &lngsecs);
		ConvertDecimal2DegMinSecs(id, lat2, &latdegs, &latmins, &latsecs);
		if (lng2 < 0.0){
			sprintf_s(lngtmp, TMPBUF_SIZE, "W %d %d' %d''", -lngdegs, -lngmins, -lngsecs);
		} else {
			sprintf_s(lngtmp, TMPBUF_SIZE, "E %d %d' %d''", lngdegs, lngmins, lngsecs);
		}
		if (lat2 < 0.0){
			sprintf_s(lattmp, TMPBUF_SIZE, "S %d %d' %d''", -latdegs, -latmins, -latsecs);
		} else {
			sprintf_s(lattmp, TMPBUF_SIZE, "N %d %d' %d''", latdegs, latmins, latsecs);
		}
		if (id->m_sCurLayout.m_bShowPassurAircraft){
			if (id->m_tPlotTime > 0){
				_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "%s %s  ASOF: %sL %sZ %s v%s",
					lattmp, lngtmp, VOTimeFmt(stdtime, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S"),
					VOGMTime(gmtime, id->m_tPlotTime, "%H:%M:%S"), mode, strVersion);
				TIME_TRACE_DBG("DrawPlotTime");
			}
		} else {
			_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "%s %s  ASOF: %sL %sZ %s v%s %s",
				lattmp, lngtmp, VOTimeFmt(stdtime, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S"),
				VOGMTime(gmtime, id->m_tPlotTime, "%H:%M:%S"), mode, strVersion, id->m_strUserName);
			TIME_TRACE_DBG("DrawPlotTime");
		}
	} else {
		if (id->m_sCurLayout.m_bShowPassurAircraft){
			if (id->m_tPlotTime > 0){
				VOTimeFmt(stdtime, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S");
				VOGMTime(gmtime, id->m_tPlotTime, "%H:%M:%S");
				sprintf_s(tmpstr, _countof(tmpstr), "Lat: %1.6f  Long: %1.6f   ASOF: %sL %sZ %s v%s %s",
					lat2, lng2, stdtime, gmtime, mode, strVersion, id->m_strUserName);
				TIME_TRACE_DBG("DrawPlotTime");
			} else {
				return;
			}
		} else if ( id->m_sCurLayout.m_bShowASDAircraft ){
			if (id->m_tPlotTime){
				sprintf_s(tmpstr, _countof(tmpstr), "Lat: %1.6f  Long: %1.6f   ASOF: %sL %sZ %s v%s %s",
					lat2, lng2, VOTimeFmt(stdtime, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S"),
					VOGMTime(gmtime, id->m_tPlotTime, "%H:%M:%S"), mode, strVersion, id->m_strUserName);
				TIME_TRACE_DBG("DrawPlotTime");
			} else {
				return;
			}
		} else {
			// ASDEX Only
			if (id->m_tPlotTime > 0){
				VOTimeFmt(stdtime, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S");
				VOGMTime(gmtime, id->m_tPlotTime, "%H:%M:%S");
				sprintf_s(tmpstr, _countof(tmpstr), "Lat: %1.6f  Long: %1.6f   ASOF: %sL %sZ %s v%s %s",
					lat2, lng2, stdtime, gmtime, mode, strVersion, id->m_strUserName);
				TIME_TRACE_DBG("DrawPlotTime");
			} else {
				return;
			}
		}
	}
	// print location of cursor and time
	glColor3fv(white);
	if (!strncmp(id->m_strUserName, "sm", 2)){
		sprintf_s(framestr, _countof(framestr), " %d %+.1f ", gframecount, id->m_glfRotateAngle);
		strcat_s(tmpstr, _countof(tmpstr), framestr);
	}

	if (avip->m_bRecordVideoButton){
		int dur = time(0) - avip->m_RecStart;
		int min = dur / 60;
		int sec = dur - (min * 60);
		sprintf_s(elapstr, _countof(elapstr), "  Recording Elapsed Time(%02d:%02d)", min, sec);
		strcat_s(tmpstr, _countof(tmpstr), elapstr);
	}

#ifdef _FREE_TYPE_DEV
	PrintFreeType(id, id->m_nCustFontIdx, (float)GUI_BORDER_SIZE, (float)nPixelHeight, red, tmpstr);
#else
	glPrintCustom(id, id->m_gluCustomBase, tmpstr);
#endif

	if (oldplottime != id->m_tPlotTime){
		if (0 == oldplottime && !id->m_bClass1){
			id->m_tDelayTime = 300;
			id->m_tPlotTime -= id->m_tDelayTime;
		}
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New Plot Time of %d changed from %d\n", cdwThreadId, id->m_tPlotTime, oldplottime);
		if (abs(id->m_tPlotTime - oldplottime) > 60){
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Plottime jump of %d, DT<%d>\n", cdwThreadId, id->m_tPlotTime - oldplottime, id->m_tDelayTime);
		}
		oldplottime = id->m_tPlotTime;
	}

	if (!strncmp(id->m_strUserName, "sm", 2)){  // take anything for now
		tmprads = acos(sin(RADS(id->m_dPrevY1)) * sin(RADS(lat2)) + cos(RADS(id->m_dPrevY1)) * cos(RADS(lat2)) * cos(RADS(lng2 - id->m_dPrevX1)));

		dis = 60.0 * DEGS(tmprads); // NM

		sprintf_s(tmpstr, _countof(tmpstr), "PI v%s x=%d y=%d, %s px=%1.6f py=%1.6f d=%g", builddate, id->m_nMouseX, id->m_nMouseY, id->m_strUserName, id->m_dPrevX1, id->m_dPrevY1, dis);
		DrawGLText(id, GUI_BORDER_SIZE, nPixelHeight + id->m_tmCustom.tmHeight - 4, tmpstr, (GLfloat *)white, id->m_gluCustomBase, FALSE);
		// Print out latest filename retreived, only if developer logged in 
		DrawGLText(id, GUI_BORDER_SIZE, nPixelHeight + (3 * (id->m_tmCustom.tmHeight - 4)), id->m_strLatestPassurURL, (GLfloat *)white, id->m_gluCustomBase, FALSE);
		// Print out Logfile name
		DrawGLText(id, GUI_BORDER_SIZE, nPixelHeight + (4 * (id->m_tmCustom.tmHeight - 4)), id->m_strLogfileName, (GLfloat *)white, id->m_gluCustomBase, FALSE);
		// Print out ERROR URL/FAILURE
		DrawGLText(id, GUI_BORDER_SIZE, nPixelHeight + (5 * (id->m_tmCustom.tmHeight - 4)), id->m_strLatestErrorURL, (GLfloat *)red, id->m_gluCustomBase, FALSE);
	}

	if (strlen(id->m_strHeader)){
		DrawGLText(id, GUI_BORDER_SIZE, id->m_nHeight - 30, id->m_strHeader, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorASDI, id->m_gluCustomBase, FALSE);
	}

	//@@@glFlush();
	//@@@glPopMatrix();
}

void DrawFlightNumAlerts(struct InstanceData* id, AIR **airp, int aircount, int nFeedType)
{
	int i;
	double y, x;//, lng2, lat2, realdelta, deltalng, origlng;//, tmprads, dis;
	int xpixel, ypixel;
	//GLfloat *txtColor = mycolor;
	char tmpstr[512] = { 0 };
	static int pflag = 0;
	char stdtime[V_DATE_SIZE] = { 0 };
	char gmtime[V_DATE_SIZE] = { 0 };
	AIR *air;
	//char *prevDest;
	const DWORD cdwThreadId = GetCurrentThreadId();

	/*glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable( GL_BLEND );
	glShadeModel (GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0 ); // white line

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	// glortho (left, right, bottom , top, near, far )
	// glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f);
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2] );
	glLineWidth(1);

	glColor3fv(txtColor);
	*/

	//if ( id->m_sCurLayout.m_dWorldXSize > 25.0 && id->m_nActiveFilters == FALSE ){
	//	// large area of map and no filters, so do not draw all of the flight numbers
	//	goto trailer;
	//}

	//if ( !id->m_bShowFlightID || TrailerOnly ){
	//	goto trailer;
	//}

	for (i = 0; airp && i < aircount; i++){
		//txtColor = mycolor;
		/* to reduce text jitter, round to 3 decimal places */
		if (!(air = airp[i])){
			/* no tracks yet */
			continue;
		}
		if (ALERT_NONE == air->alert)
		{
			// Draw text using Alert format, not both
			continue;
		}
		//if ( !air->TrackPtr ){ 
		//	/* no tracks yet */
		//   continue;
		//}
		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( SAT_ASDEX == nFeedType && id->m_sCurLayout.m_bShowADSBAircraft && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( SAT_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if ( SAT_PASSUR == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex or mlat is tracking this aircraft */
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if ( SAT_ASDI == nFeedType && air->IsTracked ){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}

		if((SAT_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (air->vehicle && id->m_bDisableVTag) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}
		if (clipaircraft(id, air)) {
			continue;
		}
		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {
			if (!air->vehicle && filtermatch(id, air) < 0){
				if (!id->m_nAllSurface || (TCI_ASDEX != nFeedType && TCI_MLAT != nFeedType))
					continue;
				//else
				//	txtColor = (GLfloat*)grey;
			}
		}

		if ((!id->m_nVehicles && air->vehicle) || (air->vehicle && id->m_bDisableVTag) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
			continue;

		y = air->Y;
		x = air->X;
		if (x == 0.0 && y == 0.0){

			// bad location, probably landed
			const char* feed = "ASDI";
			switch (nFeedType)
			{
			case TCI_PASSUR: feed = "PASSUR"; break;
			case TCI_ASDEX: feed = "ASDE-X"; break;
			case TCI_ADSB: feed = "ADS-B"; break;
			}
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) \"%s\" Flight (%s) is to be drawn, but lat and lng values are 0, ignoring.\n", cdwThreadId, feed, air->FltNum);
			continue;
		}

		/* convert X and Y from world to pixel coordinates */
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		/* size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize */
		xpixel += id->m_sCurLayout.m_nAircraftSize; /* move center so it doesn't draw on top of aircraft */

		if (!PixOnScreen(id, xpixel, ypixel)){
			continue;
		}

		if (!strcmp(id->m_sCurLayout.m_strTagLine1, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagLine2, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagLine3, ",,")){
			//!strlen( id->m_sCurLayout.m_strTagLine4 ) && 
			//!strlen( id->m_sCurLayout.m_strTagLine5 ) ){
			// user had old layout w/o tags, or user did not specify any, so use default large tags
			strcpy_s(id->m_sCurLayout.m_strTagLine1, TAG_LENGTH, "Flight ID,Aircraft Type,");
		}

		if (!strcmp(id->m_sCurLayout.m_strTagVLine1, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagVLine2, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagVLine3, ",,")){
			// user had old layout w/o tags, or user did not specify any, so use default large tags
			strcpy_s(id->m_sCurLayout.m_strTagVLine1, TAG_LENGTH, "Vehicle ID,Vehicle Tag,Category");
		}

		if (air->vehicle && air->icao24){
			strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagVLine1, airp, i), 256);
			if (!strcmp(id->m_strRollPanelStr1, "  "))
				strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine1, airp, i), 256);
		}else
			strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine1, airp, i), 256);

		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
			&& id->m_nSelectedTrackID == air->trackid){
			/* selected aircraft is displayed at bottom */
			id->m_nSelectedAirIndex = i;

		} else {
			// flt num only for non-selected flights
			if (ALERT_NONE != air->alert){
				DrawRoll(id, airp, i, 0, 0, TCI_ALERT, FALSE);
			}
		}
	}

	//glFlush ();
	//glPopMatrix();
}

void DrawFlightNums(struct InstanceData* id, AIR **airp, int aircount, GLfloat *mycolor, int TrailerOnly, int nFeedType)
{
	int i;
	double y, x, lng2, lat2, realdelta, deltalng, origlng;//, tmprads, dis;
	int xpixel, ypixel;
	GLfloat *txtColor = mycolor;
	char tmpstr[512] = { 0 };
	static int pflag = 0;
	char stdtime[V_DATE_SIZE] = { 0 };
	char gmtime[V_DATE_SIZE] = { 0 };
	AIR *air;
	char *prevDest;
	const DWORD cdwThreadId = GetCurrentThreadId();

	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glColor3fv(txtColor);

	if (id->m_sCurLayout.m_dWorldXSize > 25.0 && id->m_nActiveFilters == FALSE){
		// large area of map and no filters, so do not draw all of the flight numbers
		goto trailer;
	}

	if (!id->m_bShowFlightID || TrailerOnly){
		if (!id->m_sCurLayout.m_bShowLargeTags){
			DrawFlightNumAlerts(id, airp, aircount, nFeedType);
		}
		goto trailer;
	}

	for (i = 0; airp && i < aircount; i++){
		txtColor = mycolor;
		/* to reduce text jitter, round to 3 decimal places */
		if (!(air = airp[i])){
			/* no tracks yet */
			continue;
		}
		//if( ALERT_NONE != air->alert )
		//{
		//	// Draw text using Alert format, not both
		//	continue;
		//}
		if ( !air->TrackPtr ){ 
			/* no tracks yet */
		   continue;
		}
		// Priority Tracking
		// 1) ADS-B
		// 2) ASDE-X
		// 3) M-LAT
		// 4) PASSUR
		// 5) ASDI

		// GATE Tracks
		if (TCI_GATE == nFeedType && air->IsTracked) {
			continue;
		}

		// ADSBTracks is set if aircraft is ASDEX and ADSB is tracking
		if ( TCI_ASDEX == nFeedType /*&& id->m_sCurLayout.m_bShowADSBAircraft*/ && air->IsTracked ){
			/* adsb is tracking this aircraft */
			continue;
		}

		// MLATTracks is set if aircraft is MLAT and ASDE-X or ADSB is tracking
		if ( TCI_MLAT == nFeedType ){
			if( air->IsTracked && (id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowADSBAircraft ) ){
				/* asdex or adsb is tracking this aircraft */
				continue;
			}
			if( id->m_sCurLayout.m_dWorldXSize >= 0.75 && air->evnoddc & 0x02 ) {
				// Don't draw surface aircraft
				continue;
			}
		}

		// PassurTracks is set if aircraft is PASSUR and ASDE-X, MLAT or ADSB is tracking
		if (TCI_PASSUR == nFeedType && air->IsTracked){
			if ((air->IsTracked & SAT_ASDEX || air->IsTracked & SAT_MLAT)) {
				if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT){
					/* ASDEX is tracking this aircraft but show when zoom level is beyond ASDEX */
					continue;
				}
			}
			else{
				continue;
			}
		}

		// AsdTracks is set if aircraft is ASD and PASSUR, ASDEX, MLAT or ADSB is tracking
		if (TCI_ASDI == nFeedType && air->IsTracked){
			if (((id->m_sCurLayout.m_bShowMLATAircraft || id->m_sCurLayout.m_bShowASDEXAircraft) && !(id->m_sCurLayout.m_dWorldXSize > 1.5)) ||
				id->m_sCurLayout.m_bShowPassurAircraft ||
				id->m_sCurLayout.m_bShowADSBAircraft){
				/* adsb, asdex, mlat or passur is tracking this aircraft */
				continue;
			}
		}

		if ((TCI_ASDEX == nFeedType) && id->m_sCurLayout.m_bShowASDEXAircraft){
			if ((!id->m_nVehicles && air->vehicle) || (air->vehicle && id->m_bDisableVTag) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
				continue;
		}
		if (clipaircraft(id, air)) {
			continue;
		}
		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {

			// Support Tag Filtering
			if (!air->vehicle /*&& ALERT_NONE == air->alert*/ && !tagfiltermatch(id, air))
			{
					continue;
			}

			if (!air->vehicle && filtermatch(id, air) < 0){
			
				if (!id->m_nAllSurface || (TCI_ASDEX != nFeedType && TCI_MLAT != nFeedType))
						continue;
					else
						txtColor = (GLfloat*)grey;
			}
		}

		if ((!id->m_nVehicles && air->vehicle) || (air->vehicle && id->m_bDisableVTag) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
			continue;

		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (TCI_ASDEX == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;
		if (TCI_MLAT == nFeedType && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > MLAT_LKP_TRACK_TIMEOUT))
			continue;

		y = air->Y;
		x = air->X;
		if (x == 0.0 && y == 0.0){

			// bad location, probably landed
			const char* feed = "ASDI";
			switch (nFeedType)
			{
			case TCI_PASSUR: feed = "PASSUR"; break;
			case TCI_ASDEX: feed = "ASDE-X"; break;
			case TCI_ADSB: feed = "ADS-B"; break;
			}
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) \"%s\" Flight (%s) is to be drawn, but lat and lng values are 0, ignoring.\n", cdwThreadId, feed, air->FltNum);
			continue;
		}

		/* convert X and Y from world to pixel coordinates */
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		/* size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize */
		xpixel += id->m_sCurLayout.m_nAircraftSize; /* move center so it doesn't draw on top of aircraft */

		if (!PixOnScreen(id, xpixel, ypixel)){
			continue;
		}

#ifdef OLDWAY
		if ( (str = air->FltNum) && strlen(str) ){
		} else {
			sprintf(tmpstr, "%04o", air->beacon );
			// str = "N/A";
			if ( !strcmp( tmpstr, "1200" ) ){
				str = "G.A.";
			} else {
				str = tmpstr;
			}
		}
#endif
		if (!strcmp(id->m_sCurLayout.m_strTagLine1, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagLine2, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagLine3, ",,")){
			//!strlen( id->m_sCurLayout.m_strTagLine4 ) && 
			//!strlen( id->m_sCurLayout.m_strTagLine5 ) ){
			// user had old layout w/o tags, or user did not specify any, so use default large tags
			strcpy_s(id->m_sCurLayout.m_strTagLine1, TAG_LENGTH, "Flight ID,Aircraft Type,");
		}

		if (!strcmp(id->m_sCurLayout.m_strTagVLine1, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagVLine2, ",,") &&
			!strcmp(id->m_sCurLayout.m_strTagVLine3, ",,")){
			// user had old layout w/o tags, or user did not specify any, so use default large tags
			strcpy_s(id->m_sCurLayout.m_strTagVLine1, TAG_LENGTH, "Vehicle ID,Vehicle Tag,Category");
		}

		if (air->vehicle && air->icao24){
			strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagVLine1, airp, i), 256);
			if (!strcmp(id->m_strRollPanelStr1, "  "))
				strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine1, airp, i), 256);
		}else
			strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine1, airp, i), 256);

		if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
			&& id->m_nSelectedTrackID == air->trackid){
			/* selected aircraft is displayed at bottom */
			id->m_nSelectedAirIndex = i;

			// DrawRoll( SelectedAirVO, SelectedAirIndex, RollVO );
			//if (ShowStatusWin){
			//MGLGridText(id, statusgrid, 0, 0, "selected rs");
			//MGLGridText(id, statusgrid, 0, 1, VP(AirVO, i, "FltNum", char ));
			//MGLGridText(id, statusgrid, 1, 0, "s index");
			//sprintf(tmpstr, "%d", i );
			//MGLGridText(id, statusgrid, 1, 1, tmpstr );
			//}
		} else {
			// flt num only for non-selected flights
			//if ( ALERT_NONE == air->alert ){
			glColor3fv(txtColor);
			glRasterPos2i(xpixel, ypixel);
			glPrintCustom(id, id->m_gluCustomBase, id->m_strRollPanelStr1);
			//}else{
			//	DrawRoll(id, airp, i, 0, 0, TCI_ALERT, FALSE);				
			//}
		}

	}

trailer:

	if (!id->m_bShowBorder){
		/* print location of cursor */
		glColor3fv(red);
		/* glColor3f(1.0, 0.0, 0.0 ); *//* red */
		glRasterPos2i(20, 20);

		lng2 = (((double)id->m_nBoxX2 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		lat2 = (((double)id->m_nBoxY2 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

		/* inverse coordinates from world projected coordinates into true lat/lon */
		if (lat2 > 0.0001 && projflag){
			origlng = lng2;
			realdelta = lng2 - LngOrig;
			deltalng = realdelta / cos(lat2 * M_PI / 180.0);
			lng2 = deltalng + LngOrig;
		} else {
			origlng = lng2;
		}

		// Draw holding aircraft, first 10
		if (HoldVO){
			if (HoldVO->order_cols){
				vo_free(HoldVO->order_cols);
				HoldVO->order_cols = NULL;
			}
			vo_set(HoldVO, V_ORDER_COLS, "Destin", "FltNum", NULL, NULL);
			vo_order(HoldVO);
			prevDest = NULL;

			if (HoldVO->order_cols){
				vo_free(HoldVO->order_cols);
				HoldVO->order_cols = NULL;
			}
			vo_set(HoldVO, V_ORDER_COLS, "FltNum", NULL, NULL); // we change the sort columns during printing, so reset here
			vo_order(HoldVO);
		}

		glFlush();
		glPopMatrix();
	}

}



float ConvertDMS2Degrees(int degs, int minutes, int secs, int fracs)
{
	double fracsecs;

	fracsecs = fracs / 1000.0;
	return((float)(degs + (minutes / 60.0) + (secs / 3600.0) + (fracsecs / 3600.0)));

}


float cnvlatlng(char *linebuf)
{
	float pn;
	float lat;
	int degs, minutes, secs, fracs;

	if (!linebuf){
		return(0.0);
	}

	// format we are expecting is this: 
	//    N040.39.47.246 W073.47.46.041 N040.39.47.419 W073.47.50.149 TAXI
	//
	if (linebuf[0] == 'N' || linebuf[0] == 'E'){
		pn = 1.0;
	} else {
		pn = -1.0;
	}

	degs = (100 * (linebuf[1] - '0')) + (10 * (linebuf[2] - '0')) + linebuf[3] - '0';
	minutes = (10 * (linebuf[5] - '0')) + linebuf[6] - '0';
	secs = (10 * (linebuf[8] - '0')) + linebuf[9] - '0';
	fracs = (100 * (linebuf[11] - '0')) + (10 * (linebuf[12] - '0')) + linebuf[13] - '0';

	lat = ConvertDMS2Degrees(degs, minutes, secs, fracs);
	lat *= pn;

	return(lat);

}



int CreateSctList(struct InstanceData* id, char *sctfilename, int gl_typeval, char *keystr)
{
	GLUtriangulatorObj *tobj;
	struct clist_struct *vlist;
	FILE *f;
	char *p1str, *p2str, *p3str, *p4str;
	float lng1, lng2, lat1, lat2;
	GLuint newlistindex;
	char linebuf[LINEBUF_SIZE];
	int StartNewPoly, startedpoly;
	int endtaxis = FALSE;
	char *context;

	newlistindex = glGenLists(1);
	glNewList(newlistindex, GL_COMPILE);

	lat2 = lng2 = 0.0; // make compiler happy, though not needed

	if (fopen_s(&f, sctfilename, "rb")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open file %s", GetCurrentThreadId(), sctfilename);
		return(0);
	}

	// find start of taxiways section
	do {
		if (!fgets(linebuf, LINEBUF_SIZE, f)){
			break;
		}
		// if ( strstr( linebuf , "; Taxiways" ) ){
		if (strstr(linebuf, keystr)){
			// found start
			break;
		}
	} while (!feof(f));

	/*
	they do not seem to be polygons.. so skip for now
	don't make poly's,, must make polylist so we can tesselate the polygons
	*/
	if (GL_POLYGON == gl_typeval){
		vlist = clist_alloc();
		tobj = gluNewTess();
		gluTessCallback(tobj, GLU_TESS_VERTEX, vertexCallback);
		gluTessCallback(tobj, GLU_TESS_BEGIN, vertexglBegin);
		gluTessCallback(tobj, GLU_TESS_END, vertexglEnd);
		gluTessCallback(tobj, GLU_TESS_ERROR, (void *)errorCallback);
	}

	StartNewPoly = TRUE;
	startedpoly = FALSE;
	do {
		if (feof(f) || !fgets(linebuf, LINEBUF_SIZE, f)){
			break;
		}
		if (linebuf[0] == ';'){
			// end of taxi polys
			if (startedpoly){
				if (GL_POLYGON == gl_typeval)
					gluEndPolygon(tobj);
				else
					glEnd();
			}
			break;
		}
		// format we are expecting is this: 
		//    N040.39.47.246 W073.47.46.041 N040.39.47.419 W073.47.50.149 TAXI
		//
		if (!(p1str = strtok_s(linebuf, " ", &context)));
		if (!(p2str = strtok_s(NULL, " ", &context))) break;
		if (!(p3str = strtok_s(NULL, " ", &context))) break;
		if (!(p4str = strtok_s(NULL, " ", &context))) break;

		lat1 = cnvlatlng(p1str);
		lng1 = cnvlatlng(p2str);

		if (lat1 != lat2 || lng1 != lng2){
			// start new poly, this line segment does not connect to previous one
			StartNewPoly = 1;
		}

		lat2 = cnvlatlng(p3str);
		lng2 = cnvlatlng(p4str);

		if (StartNewPoly){
			if (startedpoly){
				if (GL_POLYGON == gl_typeval)
					gluEndPolygon(tobj);
				else
					glEnd(); // end previous line strip if we have inner polys
			}

			if (GL_POLYGON == gl_typeval)
				gluBeginPolygon(tobj);
			else
				glBegin(gl_typeval);
			startedpoly = TRUE;
			StartNewPoly = FALSE;

			if (GL_POLYGON == gl_typeval){
				GLdouble* v = calloc(3, sizeof(GLdouble));
				v[0] = lng1;
				v[1] = lat1;
				clist_add(vlist, v);
				gluTessVertex(tobj, v, v);
			}
			else
				glVertex3f(lng1, lat1, 0.0);
		}


		if (GL_POLYGON == gl_typeval){
			GLdouble* v = calloc(3, sizeof(GLdouble));
			v[0] = lng2;
			v[1] = lat2;
			clist_add(vlist, v);
			gluTessVertex(tobj, v, v);
		}
		else
			glVertex3f(lng2, lat2, 0.0);

	} while (!feof(f) && !endtaxis);


	fclose(f);
	glEndList();


	//if ( !newlistindex ){
	//	newlistindex = CreateTessPolyList( id, sctpolylist , white, NULL, -1 );
	//}
	if (GL_POLYGON == gl_typeval){
		gluDeleteTess(tobj);

		clist_head(vlist);
		do{
			free(vlist->data);
		} while (clist_del(vlist));
		clist_free(vlist);
	}

	return(newlistindex);
}

#ifdef OLDWAY
DrawSctVectors()
{
	static GLuint taxipolys, taxilines, rwylines, bldlines, bldlist;
	char tmpstr[ 512 ];

#ifdef NOT_POLYS_JUST_LINES
	if ( !taxipolys ){
		if( !GetLocalFile(mapdir, "KJFK_APT_ASDE.sct", httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).", GetCurrentThreadId(), mapdir, "KJFK_APT_ASDE.sct");
		} else {
			// load in polygons from the file
			_snprintf(tmpstr, sizeof(tmpstr), "%s%s", mapdir, "KJFK_APT_ASDE.sct" );
			taxipolys = CreateSctList( id, tmpstr, GL_POLYGON );
		}
	}
#endif

	if ( bOnRefresh || !bldlines ){
		if( !GetLocalFile(mapdir, "KJFK_APT_ASDE.sct", httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).", GetCurrentThreadId(), mapdir, "KJFK_APT_ASDE.sct");
		} else {
			_snprintf(tmpstr, sizeof(tmpstr), "%s%s", mapdir, "KJFK_APT_ASDE.sct" );
			bldlines = CreateSctList( id, tmpstr, GL_LINE_STRIP, "; Buildings"  );			
			bldlist = CreateSctList( id, tmpstr, GL_POLYGON, "; Buildings"  );
		}
	}
	if ( bldlines ){		
		glColor3fv( BuildingFillColor );
		glCallList( bldlist );
		glColor3fv( BuildingColor );
		glCallList( bldlines );
	}


	if ( bOnRefresh || !rwylines ){
		if( !GetLocalFile(mapdir, "KJFK_APT_ASDE.sct", httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).", GetCurrentThreadId(), mapdir, "KJFK_APT_ASDE.sct");
		} else {
			_snprintf(tmpstr, sizeof(tmpstr), "%s%s", mapdir, "KJFK_APT_ASDE.sct" );
			rwylines = CreateSctList( id, tmpstr, GL_LINE_STRIP, "; Runways"  );
		}
	}
	if ( rwylines ){
		//glColor3fv( green );
		//glCallList( rwyslist );
		glColor3fv( RunwayColor );
		glCallList( rwylines );
	}

	if ( bOnRefresh || !taxilines ){
		if( !GetLocalFile(mapdir, "KJFK_APT_ASDE.sct", httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to find local texture(%s%s).", GetCurrentThreadId(), mapdir, "KJFK_APT_ASDE.sct");
		} else {
			_snprintf(tmpstr, sizeof(tmpstr), "%s%s", mapdir, "KJFK_APT_ASDE.sct" );
			taxilines = CreateSctList( id, tmpstr, GL_LINE_STRIP, "; Taxiways" );
			taxipolys = CreateSctList( id, tmpstr, GL_POLYGON, "; Taxiways" );
		}
	}
	if ( taxilines ){
		glColor3fv( TaxiFillColor );
		glCallList( taxipolys );
		glColor3fv( TaxiColor );
		glCallList( taxilines );
	}


}
#endif


int LoadTriangles(struct InstanceData* id, int curindex, int *count)
{
	int len, nbytes, i;
	int CkOvrlpFlag = FALSE;  // right now, do not check since it does not work correctly
	DISKTRIANGLES triangles;
	// need to fix grids to work for whole world, not just US and recreate triangles.dat
	//  and grid.dat
	char fname[256];
	const DWORD cdwThreadId = GetCurrentThreadId();

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) curindex=%d, count=%d, alltrianglessize=%d\n",
		cdwThreadId, curindex, *count, alltrianglessize);

	_snprintf_s(fname, _countof(fname), _TRUNCATE, "%s%s", id->m_strMapDir, "triangles.dat");

	if (!GetLocalFile(id, id->m_strMapDir, "triangles.dat", id->m_strHttpMapPath, SM_HTTPS)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not open file '%s'\n", cdwThreadId, fname);
		return(-1);
	}
	if (fopen_s(&trianglefile, fname, "rb")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) could not open file '%s'\n", cdwThreadId, fname);
		return(-1);
	}

	len = sizeof(DISKTRIANGLES);
	alltriangles = (DISKTRIANGLES *)calloc(1, NUM_TRIANGLES * len);

	for (i = 0; i < NUM_TRIANGLES; i++){

		if (!(nbytes = fread(&triangles, 1, sizeof(DISKTRIANGLES), trianglefile))){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Empty file found\n", cdwThreadId);
			return(-1);
		}

		memcpy(&alltriangles[i], &triangles, len);

		//		(*count) += grids[curindex].tnum;

		// seek out the location of these triangles for this grid

	}
	alltrianglescount = NUM_TRIANGLES;

	return(TRUE);
}


DispCachedTriangles()
{
	int t;

	for (t = 0; t < alltrianglescount; t++){
		glBegin(GL_POLYGON);

		glVertex3f(alltriangles[t].vertex[0][0], alltriangles[t].vertex[0][1], 0.0);
		glVertex3f(alltriangles[t].vertex[1][0], alltriangles[t].vertex[1][1], 0.0);
		glVertex3f(alltriangles[t].vertex[2][0], alltriangles[t].vertex[2][1], 0.0);

		glEnd();
	}

}

void LoadBinaryTriangles(struct InstanceData* id)
{
	int trianglecount;

	if (!id->m_glTrianglesList){
		if (UseTriangleList){
			id->m_glTrianglesList = glGenLists(1);
			glNewList(id->m_glTrianglesList, GL_COMPILE);
		}

		if (UseCachedTriangles){
			if (!alltriangles){
				//   grids dont work now, so load triangels directly CacheTriangles(0, &trianglecount );
				trianglecount = 0;
				LoadTriangles(id, 0, &trianglecount);
				if (trianglefile){
					fclose(trianglefile);
					trianglefile = NULL;
				}
			}
			DispCachedTriangles();
		} else {
			//trianglecount = 0;
			//DisplayTriangles(0, &trianglecount);
		}

		if (UseTriangleList){
			glEndList();
			glCallList(id->m_glTrianglesList);
		}
	}
}


int fillBinaryTriangles(struct InstanceData* id)
{
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);


	// test code
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	// end test code

	//glDisable( GL_LINE_SMOOTH );
	glPushMatrix();
	glLoadIdentity();

	glShadeModel(GL_SMOOTH);

	// map background color
	glColor3f(id->m_sCurLayout.m_glfUSFillColor[0], id->m_sCurLayout.m_glfUSFillColor[1], id->m_sCurLayout.m_glfUSFillColor[2]);


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */

	// DisplayTriangles(top_grid_tree);

	if (id->m_glTrianglesList) {
		glCallList(id->m_glTrianglesList);
	}else if( alltrianglescount ){
		DispCachedTriangles();
	}

	glFlush();

	glPopMatrix();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
	return(SUCCEED);

}

void DrawRunways(struct InstanceData* id)
{
	if (id->m_sCurLayout.m_bShowRunways && id->m_gluRunwayList){
		glColor3fv(id->m_sCurLayout.m_glfRunwayFillColor);
		glCallList(id->m_gluRunwayList);
		glColor3fv(id->m_sCurLayout.m_glfRunwayColor);
		glCallList(id->m_gluRunwayLines);
	}
}

DrawRoads(struct InstanceData* id)
{
	const char shapefiles[][25] = { "fe_2007_36081_edges.shp",
		"fe_2007_36081_edges.shx",
		"fe_2007_36081_edges.dbf" };
	char shapefilename[256];


	if (!ConstructionPolyList){
		if (!GetLocalFile(id, id->m_strMapDir, shapefiles[0], id->m_strHttpMapPath, SM_HTTPS) ||
			!GetLocalFile(id, id->m_strMapDir, shapefiles[1], id->m_strHttpMapPath, SM_HTTPS) ||
			!GetLocalFile(id, id->m_strMapDir, shapefiles[2], id->m_strHttpMapPath, SM_HTTPS))
		{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf_s(shapefilename, _countof(shapefilename), "%s%s", id->m_strMapDir, shapefiles[0]);
		ConstructionPolyList = LoadShp(id, shapefilename, 0.3, 0.1, 0.4);
	}

	LoadCurrentConstructionStatus(ConstructionPolyList); // retrieve current status from web server
	if (id->m_bOnRefresh || !Constructionlist){
		// initialize gl list, or recreate if user changed a color
		Constructionlist = CreateConstructionList(ConstructionPolyList);
	}
	if (Constructionlist){
		glCallList(Constructionlist);
	}

}


void CreatePolyGL(poly *SrcPoly)
{
	static GLUtriangulatorObj *tobj;
	poly *newpoly;
	points *np;
	int count;
	static int pflag = 0;

	if (!SrcPoly){
		return;
	}
	tobj = gluNewTess();

	pcount = 0;
	newpoly = SrcPoly;

	gluTessCallback(tobj, GLU_TESS_VERTEX, vertexCallback);
	gluTessCallback(tobj, GLU_TESS_BEGIN, vertexglBegin);
	gluTessCallback(tobj, GLU_TESS_END, vertexglEnd);
	gluTessCallback(tobj, GLU_TESS_ERROR, (void *)errorCallback);

	newpoly->polylistcount = pcount;

	gluBeginPolygon(tobj);

	for (np = newpoly->ppoints, count = 0; np; np = np->np, count++){
		gluTessVertex(tobj, np->vt, np->vt);
	}
	gluEndPolygon(tobj);
	pcount++;

	gluDeleteTess(tobj);

}




GLuint CreateTessGLList(struct InstanceData* id, char *mapdir, char *filename, int gl_typeval)
{
	SHPHandle	hSHP;
	int nShapeType, nEntities, i, iPart, polycount = 0, pointcount = 0, startedpoly;
	const char 	*pszPlus;
	double adfMinBound[4], adfMaxBound[4];
	static int pflag = 0;
	int StartNewPoly;
	int innerflag = TRUE;  //  inner polygons???
	GLuint newlistindex;
	char shapefilename[256];
	poly *newpoly;
	points *np;

	/*      Open the passed shapefile.   */
	if (mapdir && filename){
		_snprintf_s(shapefilename, _countof(shapefilename), _TRUNCATE, "%s%s", mapdir, filename);
	} else {
		return(0);
	}

	hSHP = SHPOpen(shapefilename, "rb");

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Creating Tesselation from shapefile '%s'\n", GetCurrentThreadId(), shapefilename);

	if (hSHP == NULL)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to open shapefile '%s'\n", GetCurrentThreadId(), shapefilename);
		return(FALSE);
	}

	newlistindex = glGenLists(1);
	glNewList(newlistindex, GL_COMPILE);

	/*      Print out the file bounds.                                      */
	SHPGetInfo(hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound);

	/*	Skim over the list of shapes, printing all the vertices.	*/
	for (i = 0; i < nEntities; i++)
	{
		int		j;
		SHPObject	*psShape;

		psShape = SHPReadObject(hSHP, i);

		if (psShape->nSHPType == SHPT_POLYGON ||
			psShape->nSHPType == SHPT_POLYGONZ || psShape->nSHPType == SHPT_ARC){

			StartNewPoly = 1;
			startedpoly = FALSE;
			for (j = 0, iPart = 1; j < psShape->nVertices; j++){
				const char	*pszPartType = "";

				if (j == 0 && psShape->nParts > 0)
					pszPartType = SHPPartTypeName(psShape->panPartType[0]);

				if (iPart < psShape->nParts && psShape->panPartStart[iPart] == j){
					pszPartType = SHPPartTypeName(psShape->panPartType[iPart]);

					if (!innerflag){
						/* IGNORE INNER POLYGONS??? */
						break;
					}
					StartNewPoly = 1;
					iPart++;
					pszPlus = "+";
					} else {
					pszPlus = " ";
				}

				if (StartNewPoly){

					if (startedpoly){
						//  glEnd(); // end previous line strip if we have inner polys
						if (newpoly){
							CreatePolyGL(newpoly);
							FreePoly(newpoly);
							newpoly = NULL;
						}
					}
					newpoly = (poly *)vo_malloc(sizeof(poly));

					//  glBegin( gl_typeval );
					startedpoly = TRUE;
					StartNewPoly = FALSE;
				}

				//lng = (float) psShape->padfX[j];
				//lat = (float) psShape->padfY[j];
				//glVertex3f( lng, lat, 0.0 );
				if (!newpoly->ppoints){
					/* first points */
					newpoly->ppoints = (points *)vo_malloc(sizeof(points));
					np = newpoly->ppoints;
					} else {
					np->np = (points *)vo_malloc(sizeof(points));
					np = np->np;
				}
				np->vt[0] = (float)psShape->padfX[j];
				np->vt[1] = (float)psShape->padfY[j];
				np->vt[2] = 0.0;
			}
			if (startedpoly){
				// glEnd();
				// create polygon commands from the poly
				CreatePolyGL(newpoly);
				FreePoly(newpoly);
				newpoly = NULL;
			}
			SHPDestroyObject(psShape);
		}
	}
	SHPClose(hSHP);

	glEndList();
	return(newlistindex);
}




GLuint CreateCensusGLList(struct InstanceData* id, char *mapdir, char *filename, int gl_typeval)
{
	SHPHandle	hSHP;
	int nShapeType, nEntities, i, iPart, polycount = 0, pointcount = 0, startedpoly;
	const char 	*pszPlus;
	double adfMinBound[4], adfMaxBound[4];
	float lng, lat, prevlng = 999.999f, prevlat = 999.999f;
	static int pflag = 0;
	int StartNewPoly;
	int innerflag = TRUE;  //  inner polygons???
	GLuint newlistindex;
	char shapefilename[256];

	/*      Open the passed shapefile.   */
	if (mapdir && filename){
		_snprintf_s(shapefilename, _countof(shapefilename), _TRUNCATE, "%s%s", mapdir, filename);
	} else {
		return(0);
	}

	hSHP = SHPOpen(shapefilename, "rb");


	if (hSHP == NULL)
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to open shapefile '%s'\n", GetCurrentThreadId(), shapefilename);
		return(FALSE);
	}

	newlistindex = glGenLists(1);
	glNewList(newlistindex, GL_COMPILE);

	/*      Print out the file bounds.                                      */
	SHPGetInfo(hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound);

	/*	Skim over the list of shapes, printing all the vertices.	*/
	for (i = 0; i < nEntities; i++)
	{
		int		j;
		SHPObject	*psShape;

		psShape = SHPReadObject(hSHP, i);

		if (psShape->nSHPType == SHPT_POLYGON ||
			psShape->nSHPType == SHPT_POLYGONZ || psShape->nSHPType == SHPT_ARC){

			StartNewPoly = 1;
			startedpoly = FALSE;
			for (j = 0, iPart = 1; j < psShape->nVertices; j++){
				const char	*pszPartType = "";

				if (j == 0 && psShape->nParts > 0)
					pszPartType = SHPPartTypeName(psShape->panPartType[0]);

				if (iPart < psShape->nParts && psShape->panPartStart[iPart] == j){
					pszPartType = SHPPartTypeName(psShape->panPartType[iPart]);

					if (!innerflag){
						/* IGNORE INNER POLYGONS??? */
						break;
					}
					StartNewPoly = 1;
					iPart++;
					pszPlus = "+";
					} else {
					pszPlus = " ";
				}

				if (StartNewPoly){
					if (startedpoly){
						glEnd(); // end previous line strip if we hve inner polys
					}

					glBegin(gl_typeval);
					startedpoly = TRUE;
					StartNewPoly = FALSE;
				}

				lng = (float)psShape->padfX[j];
				lat = (float)psShape->padfY[j];
				glVertex3f(lng, lat, 0.0);


			}
			if (startedpoly){
				glEnd();
			}
			SHPDestroyObject(psShape);
		}
	}
	SHPClose(hSHP);

	glEndList();
	return(newlistindex);
}


void LoadBorders(struct InstanceData* id)
{
	TIME_TRACE_DBG("START - LoadBorders");
	if (id->m_bOnRefresh || !id->m_gluBordersList) {
		// retrieve from web
		TIME_TRACE_DBG("START - DownloadBorderFiles");
		if (!GetLocalFile(id, id->m_strMapDir, "StateHigh1.shp", id->m_strHttpMapPath, SM_HTTPS) ||
			!GetLocalFile(id, id->m_strMapDir, "StateHigh1.shx", id->m_strHttpMapPath, SM_HTTPS) ||
			!GetLocalFile(id, id->m_strMapDir, "StateHigh1.dbf", id->m_strHttpMapPath, SM_HTTPS)) {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
			return;
		}
		TIME_TRACE_DBG("END - DownloadBorderFiles");
		TIME_TRACE_DBG("START - BuildBorders");
		id->m_gluBordersList = CreateCensusGLList(id, id->m_strMapDir, "StateHigh1.shp", GL_LINE_STRIP);
		TIME_TRACE_DBG("END - BuildBorders");
	}
	TIME_TRACE_DBG("END - LoadBorders");
}

void drawBorders(struct InstanceData* id)
{
	if (!id->m_gluBordersList)
		return;

	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);


	// test code
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	// end test code

	//glDisable( GL_LINE_SMOOTH );
	glPushMatrix();
	glLoadIdentity();

	glShadeModel(GL_SMOOTH);

	// map background color
	glColor3f(id->m_sCurLayout.m_glfUSColor[0], id->m_sCurLayout.m_glfUSColor[1], id->m_sCurLayout.m_glfUSColor[2]);


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);


	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	glTranslatef(trans[0], trans[1], trans[2]);

	TIME_TRACE_DBG("START - drawingBorders");
	glColor3fv(id->m_sCurLayout.m_glfUSColor);
	glCallList(id->m_gluBordersList);
	TIME_TRACE_DBG("END - drawingBorders");

	glFlush();

	glPopMatrix();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);


}

void LoadLakes(struct InstanceData* id)
{
	if (!id->m_gluLakeList){
		if (GetLocalFile(id, id->m_strMapDir, "LAKES.SHP", id->m_strHttpMapPath, SM_HTTPS) &&
			GetLocalFile(id, id->m_strMapDir, "LAKES.SHX", id->m_strHttpMapPath, SM_HTTPS) &&
			GetLocalFile(id, id->m_strMapDir, "LAKES.DBF", id->m_strHttpMapPath, SM_HTTPS))
		{
			// must first tesselate these polygons
			id->m_gluLakeList = CreateTessGLList(id, id->m_strMapDir, "LAKES.SHP", GL_POLYGON);
		}
		else
		{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
	}
}


void fillLakes(struct InstanceData* id)
{
	if (id->m_gluLakeList){
		glColor3fv(id->m_sCurLayout.m_glfWaterFillColor);
		glCallList(id->m_gluLakeList);
	}
}

void InitRollGrids(struct InstanceData* id)
{

	int x, y;


	if (!MaxTagHeight){
		MaxTagHeight = id->m_tmCustom.tmHeight;  // smallest tag is one row height
	}
	if (!MaxTagWidth){
		MaxTagWidth = (int)TAG_WIDTH / 2;
	}

#ifdef OLDWAY
	MaxTagHeight = id->m_tmCustom.tmHeight;  // smallest tag is one row height
	MaxTagWidth = TAG_WIDTH / 2;
#endif


	id->m_nGridXSize = MaxTagWidth + TAG_BORDER;
	id->m_nGridYSize = MaxTagHeight + TAG_BORDER;

	id->m_nNumXGrids = (id->m_nWidth - GUI_BORDER_SIZE) / id->m_nGridXSize;
	id->m_nNumYGrids = (id->m_nHeight - GUIIconHeight - GUI_BORDER_SIZE) / id->m_nGridYSize;
	if (id->m_nNumXGrids > MAX_X_GRIDS){
		id->m_nNumXGrids = MAX_X_GRIDS;
	}
	if (id->m_nNumYGrids > MAX_Y_GRIDS){
		id->m_nNumYGrids = MAX_Y_GRIDS;
	}

	for (x = 0; x < id->m_nNumXGrids; x++){
		for (y = 0; y < id->m_nNumYGrids; y++){
			id->m_arGridUsed[x][y] = FALSE;
			id->m_arGridAircraftUsed[x][y] = FALSE;
		}
	}
}

int CkOL(struct InstanceData* id, int xpixel, int ypixel, int x1, int y1, int x2, int y2)
{
	static int pflag = 0;

	if (xpixel >= x1 && xpixel <= x2 && ypixel >= y1 && ypixel <= y2){
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) overlap xpixel=%d ypixel=%d x1=%d y1=%d x2=%d y2=%d\n",
				GetCurrentThreadId(), xpixel, ypixel, x1, y1, x2, y2);
		}
		return(TRUE);
	}

	return(FALSE);
}



#define ERROR_SZ 200
char *GetLastErrorStr()
{
	static char m_szErrorString[ERROR_SZ];
	LPTSTR lpMsgBuf;
	DWORD dwError = GetLastError();
	DWORD dwLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwError,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPSTR)&lpMsgBuf,
		0, NULL);

	sprintf_s(m_szErrorString, ERROR_SZ, "%ld:%s", dwError, lpMsgBuf);

	LocalFree(lpMsgBuf);

	return(m_szErrorString);
}



void CalcTagWidth(int *maxwidth, char *linestr)
{
	SIZE size;
	int len;
	char errorbuf[TMPBUF_SIZE];

	if ((len = strlen(linestr))){
		if (GetTextExtentPoint32(wglGetCurrentDC(), linestr, len, &size) == 0){
			// function failed
			sprintf_s(errorbuf, TMPBUF_SIZE, "error is %s", GetLastErrorStr());
		} else {
			if (size.cx > *maxwidth){
				*maxwidth = size.cx;
			}
		}
	}
}



void CalcTagSize(struct InstanceData* id, AIR **airp, int AI, int *twidth, int *theight)
{
	AIR* air = NULL;
	int maxheight, maxwidth;
	int rowheight;
	int alert = 0;

	if (!(air = airp[AI])){
		return;
	}

	// rowheight = (id->m_tmCustom.tmAscent + id->m_tmCustom.tmExternalLeading) + id->m_tmCustom.tmDescent;
	rowheight = id->m_tmCustom.tmAscent;

	maxheight = 0; maxwidth = 0;

	if (ALERT_NONE != air->alert){
		strncpy_s(id->m_strAlertRollPanelStr, TAG_LENGTH, GetAlertLine(id, air), 256);
		CalcTagWidth(&maxwidth, id->m_strAlertRollPanelStr);
		if (strlen(id->m_strAlertRollPanelStr) > 2){
			maxheight = rowheight;
			alert = 1;
		}
	}

	strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine1, airp, AI), 256);
	CalcTagWidth(&maxwidth, id->m_strRollPanelStr1);
	if (strlen(id->m_strRollPanelStr1) > 2){
		maxheight = alert ? 2 * rowheight : rowheight;
	}

	if (!id->m_sCurLayout.m_bShowSmallTags || ALERT_NONE != air->alert || (id->m_pSelectedAirP && (air = ((AIR**)id->m_pSelectedAirP)[id->m_nSelectedAirIndex]))){

		strncpy_s(id->m_strRollPanelStr2, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine2, airp, AI), 256);
		CalcTagWidth(&maxwidth, id->m_strRollPanelStr2);
		if (strlen(id->m_strRollPanelStr2) > 2){
			maxheight = (2 + alert) * rowheight;
		}

		strncpy_s(id->m_strRollPanelStr3, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine3, airp, AI), 256);
		CalcTagWidth(&maxwidth, id->m_strRollPanelStr3);
		if (strlen(id->m_strRollPanelStr3) > 2){
			maxheight = (3 + alert) * rowheight;
		}

		strncpy_s(id->m_strRollPanelStr4, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine4, airp, AI), 256);
		CalcTagWidth(&maxwidth, id->m_strRollPanelStr4);
		if (strlen(id->m_strRollPanelStr4) > 2){
			maxheight = (4 + alert) * rowheight;
		}

		strncpy_s(id->m_strRollPanelStr5, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine5, airp, AI), 256);
		CalcTagWidth(&maxwidth, id->m_strRollPanelStr5);
		if (strlen(id->m_strRollPanelStr5) > 2){
			maxheight = (5 + alert) * rowheight;
		}
	}
	maxheight += 2; // a little margin for Y

	if (maxheight > MaxTagHeight){
		MaxTagHeight = maxheight;
	}
	if (maxwidth > MaxTagWidth){
		MaxTagWidth = maxwidth;
	}

	*twidth = maxwidth;
	*theight = maxheight;
}

CalcVehicleTagSize(struct InstanceData* id, AIR **airp, int AI, int *twidth, int *theight)
{
	int maxheight, maxwidth;
	int rowheight;

	// rowheight = (id->m_tmCustom.tmAscent + id->m_tmCustom.tmExternalLeading) + id->m_tmCustom.tmDescent;
	rowheight = id->m_tmCustom.tmAscent;

	maxheight = 0; maxwidth = 0;

	strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagVLine1, airp, AI), 256);
	if (!strcmp(id->m_strRollPanelStr1, "  "))
		strncpy_s(id->m_strRollPanelStr1, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagLine1, airp, AI), 256);
	CalcTagWidth(&maxwidth, id->m_strRollPanelStr1);
	if (strlen(id->m_strRollPanelStr1) > 2){
		maxheight = rowheight;
	}


	strncpy_s(id->m_strRollPanelStr2, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagVLine2, airp, AI), 256);
	CalcTagWidth(&maxwidth, id->m_strRollPanelStr2);
	if (strlen(id->m_strRollPanelStr2) > 2){
		maxheight = 2 * rowheight;
	}

	strncpy_s(id->m_strRollPanelStr3, TAG_LENGTH, GetTagLine(id, id->m_sCurLayout.m_strTagVLine3, airp, AI), 256);
	CalcTagWidth(&maxwidth, id->m_strRollPanelStr3);
	if (strlen(id->m_strRollPanelStr3) > 2){
		maxheight = 3 * rowheight;
	}

	/*strncpy_s( id->m_strRollPanelStr4, TAG_LENGTH, GetTagLine( id, id->m_sCurLayout.m_strTagLine4, airp, AI  ), 256 );
	CalcTagWidth(&maxwidth, id->m_strRollPanelStr4);
	if ( strlen( id->m_strRollPanelStr4 ) > 2 ){
	maxheight = 4 * rowheight;
	}

	strncpy_s( id->m_strRollPanelStr5, TAG_LENGTH, GetTagLine( id, id->m_sCurLayout.m_strTagLine5, airp, AI  ), 256 );
	CalcTagWidth(&maxwidth, id->m_strRollPanelStr5);
	if ( strlen( id->m_strRollPanelStr5 ) > 2 ){
	maxheight = 5 * rowheight;
	}*/
	maxheight += 2; // a little margin for Y

	if (maxheight > MaxTagHeight){
		MaxTagHeight = maxheight;
	}
	if (maxwidth > MaxTagWidth){
		MaxTagWidth = maxwidth;
	}

	*twidth = maxwidth;
	*theight = maxheight;
}




int CkOverlap(struct InstanceData* id, int *xpixel, int *ypixel, AIR **airp, int AI)
{
	taglist *tag;
	int x, y, xorig, yorig, ysize, xsize, xinc, yinc, xmin, xmax, ymin, ymax;
	int laynum = 0;
	int layside = 5;
	int loopcount, xtest, ytest, twidth, theight, i;
	static int pflag = FALSE;
	double yac, xac;
	int ypix_ac, xpix_ac;
	char *flightid;
	static char testflight[32] = "test";
	AIR *air;
	int aircount;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// check for overlap with another tag
	x = *xpixel;
	y = *ypixel;

	xorig = x;
	yorig = y;

	if (!(air = airp[AI])){
		return(FALSE);
	}
	if (IsASDAirP(id, airp)){
		aircount = N_TRACK_ID;
	} else {
		aircount = N_PASSUR_TRACK_ID;
	}

	flightid = air->FltNum;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flightid=%s xorig=%d yorig=%d, GHeight=%d GWidth=%d\n",
			cdwThreadId, flightid, xorig, yorig, id->m_nHeight, id->m_nWidth);
	}

	xinc = 20;  // 0,0,0,0,20,20,20,20,40,40,40,40
	yinc = 10;

	xmin = 40000;
	xmax = -40000;
	ymin = 40000;
	ymax = -40000;

	layside = 0;
	laynum = 1;
	xsize = (laynum * xinc);
	ysize = (laynum * yinc);
	x = xorig + xsize;
	y = yorig + ysize;
	xmin = xorig - xsize;
	ymin = yorig - ysize;
	xmax = xorig + xsize;
	ymax = yorig + ysize;

	tag = gtaglist;
	loopcount = 0;

	if (air->vehicle && air->icao24)
		CalcVehicleTagSize(id, airp, AI, &twidth, &theight);
	else
		CalcTagSize(id, airp, AI, &twidth, &theight);

	while (tag && laynum < 10 && loopcount < 500){

		tag = gtaglist;
		// if over borders, move back onto panel
		xtest = x;
		ytest = y;
		xtest = MAX(0, xtest);
		xtest = MIN(id->m_nWidth - twidth, xtest);
		ytest = MAX(0, ytest);
		ytest = MIN(id->m_nHeight - theight, ytest);
		// if not within border, ignore this tag location
		if (xtest != x || ytest != y){
			// bad tag, go to next location
		} else {
			for (; tag; tag = tag->np){
				if (RectanglesOverlap(xtest - tag_margin_size, ytest - tag_margin_size,
					xtest + twidth + tag_margin_size, ytest + theight + tag_margin_size,
					tag->x1 - tag_margin_size, tag->y1 - tag_margin_size, tag->x2 + tag_margin_size,
					tag->y2 + tag_margin_size)) {
					if (pflag){
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) trying x=%d, y=%d, x + twidth=%d, y +tHeight=%d\n",
							cdwThreadId, xtest, ytest, xtest + twidth, ytest + theight);
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tag overlaps tag->x1=%d, tag->y1=%d, tag->x2=%d, tag->y2=%d\n",
							cdwThreadId, tag->x1, tag->y1, tag->x2, tag->y2);
					}
					break;
				}
			}
			if (!tag){
				// no rectangles overlapped, so check aircraft overlap
				for (i = 0; airp && i < aircount; i++){

					yac = air->Y;
					xac = air->X;
					if (clipaircraft(id, air)) {
						continue;
					}
					if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
						// ignore filters for asdex if !UseASDEXFilters 
					} else {
						if (filtermatch(id, air) < 0){
							continue;
						}
					}
					/* convert X and Y from world to pixel coordinates */
					ypix_ac = (int)rint((yac - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
					xpix_ac = (int)rint((xac - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
					/* size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize */
					ypix_ac -= (id->m_sCurLayout.m_nAircraftSize / 2);
					xpix_ac -= (id->m_sCurLayout.m_nAircraftSize / 2);
					if (RectanglesOverlap(xtest - tag_margin_size, ytest - tag_margin_size,
						xtest + twidth + tag_margin_size, ytest + theight + tag_margin_size,
						xpix_ac, ypix_ac, xpix_ac + id->m_sCurLayout.m_nAircraftSize, xpix_ac + id->m_sCurLayout.m_nAircraftSize)) {
						if (pflag){
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) trying x=%d, y=%d, x + twidth=%d, y +tHeight=%d\n",
								cdwThreadId, xtest, ytest, xtest + twidth, ytest + theight);
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tag overlaps tag->x1=%d, tag->y1=%d, tag->x2=%d, tag->y2=%d\n",
								cdwThreadId, tag->x1, tag->y1, tag->x2, tag->y2);
						}
						break;
					}
				}
				if (i >= aircount){
					// no overlapping aircraft found
				} else {
					tag = gtaglist; // mark this tag as overlapped
				}
			}
		}
		if (tag){
			// overlap found, or tag out of range, move location of our tag
			if (layside == 0){
				// top side
				if (x > xmin){
					x -= xinc;
				} else {
					layside = 1;
				}
			}
			if (layside == 1){
				// left side , dec y
				if (y > ymin){
					y -= yinc;
				} else {
					layside = 2;
				}
			}
			if (layside == 2){
				if (x < xmax){
					x += xinc;
				} else {
					layside = 3;
				}
			}
			if (layside == 3){
				if (y < ymax){
					y += yinc;
				} else {
					// start new box layer
					laynum++;
					layside = 0;
					xsize = (laynum * xinc);
					ysize = (laynum * yinc);
					x = xorig + xsize;
					y = yorig + ysize;
					xmin = xorig - xsize;
					ymin = yorig - ysize;
					xmax = xorig + xsize;
					ymax = yorig + ysize;
				}
			}
		}

		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) x=%d y=%d laynum=%d \n", cdwThreadId, x, y, laynum);
		}

		loopcount++;
	}

	if (!strcasecmp(flightid, testflight)){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flightid=%s\n", cdwThreadId, flightid);
	}

	if (laynum == 10){
		// ran out, could not find a spot reset to closer to original location
		x = xorig + xinc;
		y = yorig + yinc;
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flightid=%s box overlaps, no solution found\n",
				cdwThreadId, flightid);
		}
	}

	x = MAX(0, x);
	x = MIN(id->m_nWidth - twidth, x);
	y = MAX(0, y);
	y = MIN(id->m_nHeight - theight, y);
	// no overlap with another tag

	// check for overlap with aircraft icon

	// add this tag location to linked list so others will not write over it
	if (!gtaglist){
		gtaglist = calloc(1, sizeof(taglist));
		tag = gtaglist;
	} else {
		tag = calloc(1, sizeof(taglist));
		gtaglist->lastp->np = tag; // link to prior tag
	}

	gtaglist->lastp = tag;
	tag->x1 = x;
	tag->y1 = y;
	tag->x2 = x + twidth;
	tag->y2 = y + theight;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) final x=%d y=%d laynum=%d xorig=%d yorig=%d\n",
			cdwThreadId, x, y, laynum, xorig, yorig);
	}
	*xpixel = x;
	*ypixel = y;


	/* did not find a good grid */
	return(TRUE);

}





void FindClosestTagCorner(struct InstanceData* id, int ac_ypixel, int ac_xpixel, int *xpixel, int *ypixel, char *fltnum,
	int tagwidth, int tagheight)
{
	double x, y, dy, dx, dis, bestdis;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int pflag = 0;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s acx=%d acy=%d xpix=%d ypix=%d\n",
			cdwThreadId, fltnum, ac_xpixel, ac_ypixel, *xpixel, *ypixel);
	}


	x = *xpixel - tag_margin_size;
	y = *ypixel - tag_margin_size;

	dy = ac_ypixel - y;
	dx = ac_xpixel - x;
	dis = sqrt((dx * dx) + (dy * dy));
	bestdis = dis;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bestdis1=%g x=%g y=%g\n", cdwThreadId, bestdis, x, y);
	}
	*xpixel = (int)x;
	*ypixel = (int)y;

	x += (double)tagwidth + (tag_margin_size * 2);
	dy = ac_ypixel - y;
	dx = ac_xpixel - x;
	dis = sqrt((dx * dx) + (dy * dy));
	if (dis < bestdis){
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bestdis2=%g x=%g y=%g\n", cdwThreadId, bestdis, x, y);
		}
		*xpixel = (int)x;
		*ypixel = (int)y;
		bestdis = dis;
	}


	y += (double)tagheight + (tag_margin_size * 2);
	dy = ac_ypixel - y;
	dx = ac_xpixel - x;
	dis = sqrt((dx * dx) + (dy * dy));
	if (dis < bestdis){
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bestdis3=%g x=%g y=%g\n", cdwThreadId, bestdis, x, y);
		}
		*xpixel = (int)x;
		*ypixel = (int)y;
		bestdis = dis;
	}

	x -= (double)tagwidth - (tag_margin_size * 2);
	dy = ac_ypixel - y;
	dx = ac_xpixel - x;
	dis = sqrt((dx * dx) + (dy * dy));
	if (dis < bestdis){
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bestdis4=%g x=%g y=%g\n", cdwThreadId, bestdis, x, y);
		}
		*xpixel = (int)x;
		*ypixel = (int)y;
		bestdis = dis;
	}
}

void FindClosestTagEdge(struct InstanceData* id, int ac_ypixel, int ac_xpixel, int *xpixel, int *ypixel, char *fltnum,
	int tagwidth, int tagheight)
{
	double x, y, dy, dx, dis, bestdis;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int pflag = 0;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s acx=%d acy=%d xpix=%d ypix=%d\n",
			cdwThreadId, fltnum, ac_xpixel, ac_ypixel, *xpixel, *ypixel);
	}


	x = *xpixel - tag_margin_size;
	y = *ypixel - tag_margin_size + tagheight / 2;

	dy = ac_ypixel - y;
	dx = ac_xpixel - x;
	dis = sqrt((dx * dx) + (dy * dy));
	bestdis = dis;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bestdis1=%g x=%g y=%g\n", cdwThreadId, bestdis, x, y);
	}
	*xpixel = (int)x;
	*ypixel = (int)y;

	x += (double)tagwidth + (tag_margin_size * 2);
	dy = ac_ypixel - y;
	dx = ac_xpixel - x;
	dis = sqrt((dx * dx) + (dy * dy));
	if (dis < bestdis){
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bestdis2=%g x=%g y=%g\n", cdwThreadId, bestdis, x, y);
		}
		*xpixel = (int)x;
		*ypixel = (int)y;
		bestdis = dis;
	}
}


void DispTextureSize(GLfloat x, GLfloat y, GLfloat rot, GLfloat xsize, GLfloat ysize)
{
	glLoadIdentity();
	glTranslatef(x, y, (float)trans[2]);
	glRotatef(rot, 0.0f, 0.0f, 1.0f);
	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f(0.0f, ysize, 0.0f);
	glTexCoord2f(0.0f, 1.0f); glVertex3f(0.0f, 0.0f, 0.0f);
	glTexCoord2f(1.0f, 1.0f); glVertex3f(xsize, 0.0f, 0.0f);
	glTexCoord2f(1.0f, 0.0f); glVertex3f(xsize, ysize, 0.0f);
	glEnd();
}




void GetGUIColorImage(GLfloat *colorvec, int ntexture, int xsize, int ysize, int alpha)
{
	int row, col;
	int pflag = 0;
	int r, g, b;


	r = (int)rint(colorvec[0] * 255.0);
	g = (int)rint(colorvec[1] * 255.0);
	b = (int)rint(colorvec[2] * 255.0);
	for (row = 0; row < ysize; row++){
		for (col = 0; col < xsize; col++){

			guiimage[ntexture][row][col][0] = r;
			guiimage[ntexture][row][col][1] = g;
			guiimage[ntexture][row][col][2] = b;
			//alpha = r + g + b;
			//if ( alpha > 255 ){alpha=255;}
			guiimage[ntexture][row][col][3] = alpha;
		}
	}

}


void DrawRollPanel(struct InstanceData* id, int xpixel, int ypixel, int width, int height, int TailPanel, int TagColorIndex)
{
	int AlphaBlendFactor;
	GLfloat *TagBkColor = NULL;
	char *pstrPanel = "DEFAULT";

	switch (TagColorIndex){
	case TCI_PASSUR: TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorPASSUR;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyPASSUR / 100.0) * 255);
		pstrPanel = "PASSUR";
		break;
	case TCI_ASDI:   TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorASDI;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyASDI / 100.0) * 255);
		pstrPanel = "ASDI";
		break;
	case TCI_ASDEX:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorASDEX;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyASDEX / 100.0) * 255);
		pstrPanel = "ASDEX";
		break;
	case TCI_ADSB:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorADSB;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyADSB / 100.0) * 255);
		pstrPanel = "ADSB";
		break;
	case TCI_NOISE:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorADSB;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyADSB / 100.0) * 255);
		pstrPanel = "NOISE";
		break;
	case TCI_ALERT:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorAlerts;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyAlerts / 100.0) * 255);
		pstrPanel = "ALERT";
		break;
	case TCI_MLAT:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorMLAT;
		AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyMLAT / 100.0) * 255);
		pstrPanel = "MLAT";
		break;
	  case TCI_AIRASIA:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorAirAsia;
		  AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyAirAsia/100.0)*255);
		  pstrPanel = "AIRASIA";
		  break;
	  case TCI_LMG:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorASDEX;
		  AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyASDEX/100.0)*255);
		  pstrPanel = "LMG";
		  break;
	  case TCI_GATE:
		  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorGate;
		  AlphaBlendFactor = (int)((id->m_sCurLayout.m_nLargeTagTransparencyGate/100.0)*255);
		  pstrPanel = "GATE";
		  break;
	default:         TagBkColor = LightUS;
		AlphaBlendFactor = 255;
	}
	glPushMatrix();

	glColor3fv(white);
	/* use border as background of text */

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	/* solid with alpha masking */


	glEnable(GL_DEPTH_TEST);
	/* glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); */
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glEnable(GL_BLEND);
	glDepthFunc(GL_LEQUAL);

	if (!id->m_gluGuiTextures[TagColorIndex]){
		/* special texture for tag background */
		glGenTextures(1, &id->m_gluGuiTextures[TagColorIndex]);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Roll Panel Texture: %d.\n", GetCurrentThreadId(), pstrPanel, id->m_gluGuiTextures[TagColorIndex]);

		GetGUIColorImage((GLfloat *)TagBkColor, TagColorIndex, 32, 32, AlphaBlendFactor);

		glBindTexture(GL_TEXTURE_2D, id->m_gluGuiTextures[TagColorIndex]);

		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GUI_IMAGE_SIZE, GUI_IMAGE_SIZE, 0, GL_RGBA,
			GL_UNSIGNED_BYTE, guiimage[TagColorIndex]);

		/* Linear Filtering */
		/* produces a smoothed image, more accurate and realistic? */
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	}

	glBindTexture(GL_TEXTURE_2D, id->m_gluGuiTextures[TagColorIndex]);

	//glBindTexture( GL_TEXTURE_2D,  guitexture[7] );
	DispTextureSize((float)xpixel, (float)ypixel, 0.0f, (float)width, (float)height);
	glPopMatrix();

	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);
	glLoadIdentity();

}




FreeGrid(struct InstanceData* id, int *x, int *y, int actualx, int actualy, char GridUsed[MAX_X_GRIDS][MAX_Y_GRIDS])
{
	int xgrid, ygrid;
	int xpixel, ypixel;
	int x1, y1, x2, y2;

	if (*y < 0) return (FALSE);
	if (*x < 0) return (FALSE);
	xgrid = *x / id->m_nGridXSize;
	ygrid = *y / id->m_nGridYSize;

	actualx -= (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); /* readjust back to actual location of aircraft */


	if (xgrid >= id->m_nNumXGrids){
		xgrid = id->m_nNumXGrids - 1;
	}
	if (ygrid >= id->m_nNumYGrids){
		ygrid = id->m_nNumYGrids - 1;
	}

	if (!GridUsed[xgrid][ygrid] && PixOnScreen(id, *x, *y)){
		/* not used yet, so set grid point and return */

		/* make sure tag will fit entirely on the screen */
		xpixel = xgrid * id->m_nGridXSize;
		ypixel = ygrid * id->m_nGridYSize;

		x1 = xpixel;
		y1 = ypixel;
		x2 = x1 + (int)MaxTagWidth;
		y2 = y1 + (int)MaxTagHeight;

		/* make sure this location does not overlap current aircraft location */
		//if ( CkOL( id, actualx, actualy, x1, y1, x2, y2 ) ){
		// /* overlap original aircraft, so do not use this grid */
		// return( FALSE );
		//}

		if (!CkOL(id, xpixel, ypixel, GUI_BORDER_SIZE, GUI_BORDER_SIZE, id->m_nWidth - GUI_BORDER_SIZE,
			id->m_nHeight - GUIIconHeight - GUI_BORDER_SIZE)){
			/* tag is not within borders of screen */
			return(FALSE);
		}
		xpixel += (int)MaxTagWidth;
		if (!CkOL(id, xpixel, ypixel, GUI_BORDER_SIZE, GUI_BORDER_SIZE, id->m_nWidth - GUI_BORDER_SIZE,
			id->m_nHeight - GUIIconHeight - GUI_BORDER_SIZE)){
			return(FALSE);
		}
		ypixel += (int)MaxTagWidth;
		if (!CkOL(id, xpixel, ypixel, GUI_BORDER_SIZE, GUI_BORDER_SIZE, id->m_nWidth - GUI_BORDER_SIZE,
			id->m_nHeight - GUIIconHeight - GUI_BORDER_SIZE)){
			return(FALSE);
		}
		xpixel -= (int)MaxTagWidth;
		if (!CkOL(id, xpixel, ypixel, GUI_BORDER_SIZE, GUI_BORDER_SIZE, id->m_nWidth - GUI_BORDER_SIZE,
			id->m_nHeight - GUIIconHeight - GUI_BORDER_SIZE)){
			return(FALSE);
		}

		GridUsed[xgrid][ygrid] = TRUE;
		*x = xgrid * id->m_nGridXSize;
		*y = ygrid * id->m_nGridYSize;
		return(TRUE);
	}

	return(FALSE);
}

void CkScreenBorder(struct InstanceData* id, int *xpixel, int *ypixel)
{

	// make sure we are not within 250 pixels of the edge of screen
	if (*xpixel > id->m_nWidth - 250){
		*xpixel -= 250;
	}
	// don't need to check for left border since the default is to draw gird to the right
	//if ( *xpixel < 250 ){
	//	*xpixel += 250;
	//}
	if (*ypixel > id->m_nHeight - 100){
		*ypixel -= 100;
	}
	//if ( *ypixel < 100 ){
	//	*ypixel += 100;
	//}

}



int CkTagOverlap(struct InstanceData* id, int *xpixel, int *ypixel, char GridUsed[MAX_X_GRIDS][MAX_Y_GRIDS])
{
	int MaxLoops;
	int x, y;
	int loopcount;
	int xmin, xmax, ymin, ymax;
	static int pflag = 0;
	int xgrid, ygrid;

	/* 21 jul 2006 always move even for selected aircraft
	/if ( !id->m_sCurLayout.m_bShowLargeTags ){
	/  return(FALSE);  // OK anywhere
	/}
	*/

	if (!id->m_nGridXSize){
		InitRollGrids(id);
	}

	MaxLoops = id->m_nWidth / id->m_nGridXSize;

	xgrid = *xpixel / id->m_nGridXSize;
	ygrid = *ypixel / id->m_nGridYSize;


	if (FreeGrid(id, xpixel, ypixel, *xpixel, *ypixel, GridUsed)){
		return(FALSE);
	}

	/* find closest grid box that we can use */
	for (loopcount = 0; loopcount < MaxLoops; loopcount++){

		/* start at upper level */
		x = *xpixel + (id->m_nGridXSize * (loopcount + 1));
		y = *ypixel + (id->m_nGridYSize * (loopcount + 1));

		xmin = x - (id->m_nGridXSize * ((loopcount + 1) * 2));
		for (; x >= xmin; x -= id->m_nGridXSize){
			if (FreeGrid(id, &x, &y, *xpixel, *ypixel, GridUsed)){
				goto foundspot;
			}
		}
		x = xmin;
		ymin = y - (id->m_nGridYSize * ((loopcount + 1) * 2));
		for (; y >= ymin; y -= id->m_nGridYSize){
			if (FreeGrid(id, &x, &y, *xpixel, *ypixel, GridUsed)){
				goto foundspot;
			}
		}
		y = ymin;
		xmax = x + (id->m_nGridXSize * ((loopcount + 1) * 2));
		for (; x <= xmax; x += id->m_nGridXSize){
			if (FreeGrid(id, &x, &y, *xpixel, *ypixel, GridUsed)){
				goto foundspot;
			}

		}
		x = xmax;
		ymax = y + (id->m_nGridYSize * ((loopcount + 1) * 2));
		for (; y <= ymax; y += id->m_nGridYSize){
			if (FreeGrid(id, &x, &y, *xpixel, *ypixel, GridUsed)){
				goto foundspot;
			}
		}
	}

	/* did not find a good grid */
	return(TRUE);

foundspot:
	*xpixel = x;
	*ypixel = y;
	return(FALSE);
}



void DrawCompression(struct InstanceData* id)
{
	PTRACK comptrack[3];
	PTRACK *trackarr;
	int i, AI, curr_alt, ccount;
	int yOffset;
	AIR **airp;
	AIR *air;
	char tmpbuf[256];
	char stdtime[V_DATE_SIZE] = { 0 };
	GLfloat *textColor = (GLfloat *)white;

	// draw compression information

	// from selected point, or aircraft, display altitude and speed from those locations
	// (from selected point not implemented yet.  It is always from selecte aircraft right now)

	if (!id->m_pSelectedAirP || !id->m_pSelectedAircraft /*|| !id->m_nSelectedIsTrail*/){
		return;
	}

	AI = id->m_nSelectedAirIndex;
	airp = (AIR**)id->m_pSelectedAirP;
	if (!(air = airp[AI])){
		return;
	}
	if (!(trackarr = air->TrackPtr)){
		return;
	}
	yOffset = id->m_sCurLayout.m_bShowFltPlan ? id->m_nViewPortHeight - FLIGHTPLAN_Y_OFFSET * 2 : id->m_nViewPortHeight - FLIGHTPLAN_Y_OFFSET;

	// start with current altitude and find points in trail every 1000 feet of altitude
	curr_alt = -20000;
	for (i = air->tcount - 1, ccount = 0; i >= 0 && ccount < 3; i--){
		if (trackarr[i].altitude >= curr_alt + 1000){
			// found next
			comptrack[ccount].altitude = trackarr[i].altitude;
			comptrack[ccount].speed = CalcSpeed(id, airp, AI, i);
			comptrack[ccount].utc = trackarr[i].utc;
			curr_alt = comptrack[ccount].altitude;
			ccount++;
		}
	}
	if (ccount > 0) {
		// set text color (default is white, already set)
		switch (id->m_nSelectedAircraftType){
		case SAT_PASSUR:
			textColor = id->m_sCurLayout.m_glfLargeTagTextColorPASSUR;
			break;
		case SAT_ASDI:
			textColor = id->m_sCurLayout.m_glfLargeTagTextColorASDI;
			break;
		case SAT_ASDEX:
			textColor = id->m_sCurLayout.m_glfLargeTagTextColorASDEX;
			break;
		}

		// output flight id line if available
		if (air->FltNum && *air->FltNum) {
			sprintf_s(tmpbuf, _countof(tmpbuf), "%s:", air->FltNum);
			DrawGLText(id, FLIGHTPLAN_X_OFFSET, yOffset, tmpbuf, textColor, id->m_gluCustomBase, FALSE);
			yOffset -= 10;
		}

		// output times, speeds & alts
		for (i = 0; i < ccount && i < 4; i++){
			sprintf_s(tmpbuf, _countof(tmpbuf), "%s %dkts %dft", VOTimeFmt(stdtime, comptrack[i].utc, "%H:%M:%S"), comptrack[i].speed, comptrack[i].altitude);
			DrawGLText(id, FLIGHTPLAN_X_OFFSET, yOffset - (i)* 10, tmpbuf, textColor, id->m_gluCustomBase, FALSE);
		}
	}
}



int DrawRoll(struct InstanceData* id, AIR **airp, int AI, int xoffset, int yoffset, int TagColorIndex, int bGreyed)
{
	double y, x;
	int xpixel, ypixel, ac_ypixel, ac_xpixel, tagx, tagy;
	static int pflag = 0;
	static int first_time = TRUE;
	char *FltNum;
	int maxwidth, maxheight, rowheight;
	int nBorder = TRUE;
	AIR *air;
	GLfloat *TagBkColor = NULL;
	GLfloat *TagTextColor = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();
	extern int ColorVorow_iconselected(struct InstanceData* id, char *FltNum1);
	if (!(air = airp[AI])){
		return(FALSE);
	}
	
	// Prevents the selected aircraft from being displayed as "selected" after a higher priority feed has marked it as being tracked
	if (air->IsTracked && id->m_pSelectedAirP) {
		AIR** airp2 = (AIR**)id->m_pSelectedAirP;
		AIR* air2 = airp2[id->m_nSelectedAirIndex];
		if (air2 == air) {
			ClearSelectedAircraft(id);
			return (FALSE);
		}
	}

	y = air->Y;
	x = air->X;

	if (x == 0.0 && y == 0.0){
		// bad location, probably landed
		const char* feed = "ASDI";
		switch (TagColorIndex)
		{
		case TCI_PASSUR: feed = "PASSUR"; break;
		case TCI_ASDEX: feed = "ASDE-X"; break;
		case TCI_ADSB: feed = "ADS-B"; break;
		case TCI_NOISE: feed = "NOISE"; break;
		case TCI_AIRASIA: feed = "AIRASIA"; break;
		case TCI_LMG: feed = "LMG"; break;
		case TCI_GATE: feed = "GATE"; break;
		}
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) \"%s\" Flight (%s) is to be drawn, but lat and lng values are 0, ignoring.\n", cdwThreadId, feed, air->FltNum);
		return(FALSE);
	}

	if (ALERT_NONE != air->alert)
		TagColorIndex = TCI_ALERT;

	switch (TagColorIndex){
	case TCI_PASSUR: TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorPASSUR;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorPASSUR;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_PASSUR;
		break;
	case TCI_ASDI:   TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorASDI;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorASDI;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_ASDI;
		break;
			case TCI_LMG:
	case TCI_ASDEX:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorASDEX;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorASDEX;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_ASDEX;
		break;
	case TCI_ADSB:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorADSB;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorADSB;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_ADSB;
		break;
	case TCI_NOISE:  TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorADSB;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorADSB;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_ADSB;
		break;
	case TCI_ALERT:
		TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorAlerts;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorAlerts;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_ALERTS;
		break;
	case TCI_MLAT:
		TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorMLAT;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorMLAT;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_MLAT;
		break;
	case TCI_AIRASIA:
		TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorAirAsia;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorAirAsia;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_AIRASIA;				
		break;
	case TCI_GATE:
		TagBkColor = id->m_sCurLayout.m_glfLargeTagBkColorGate;
		TagTextColor = id->m_sCurLayout.m_glfLargeTagTextColorGate;
		nBorder = id->m_sCurLayout.m_nTagBorderEnableFlag & TB_GATE;
		break;
	default:         TagBkColor = (GLfloat*)black;
		TagTextColor = (GLfloat*)black;
	}

	if (bGreyed && ALERT_NONE != air->alert){
		TagTextColor = (GLfloat*)grey;
	}
	/* convert X and Y from world to pixel coordinates */
	ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
	xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

	if (0.0f != id->m_glfRotateAngle){
		RotateScreenPoint(id, id->m_nWidth / 2, id->m_nHeight / 2, &xpixel, &ypixel);
	}

	/* size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize */
	xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); /* move center so it doesn't draw on top of aircraft */

	xpixel += xoffset;
	ypixel += yoffset;
	FltNum = air->FltNum;
	//   not needed ColorVorow_iconselected(id, FltNum, air->Destin);

	if (!id->m_sCurLayout.m_bShowLargeTags){
		// if showlargetags is off, we don't need to check all the overlaps, just the edge of the screen
		CkScreenBorder(id, &xpixel, &ypixel);
	} else if (id->m_sCurLayout.m_bShowLargeTags && CkTagOverlap( id, &xpixel, &ypixel, id->m_arGridAircraftUsed ) ){
		CkTagOverlap(id, &xpixel, &ypixel, id->m_arGridUsed);
	}

	// 12mar2010 -- CkOverlap is brute force algo and too slow with ASD
	// if ( CkOverlap( &xpixel, &ypixel, airp, AI ) ){
	// check w/o aircraft check
	// CkOverlap( &xpixel, &ypixel, AirVO, AI );
	// }

	rowheight = id->m_tmCustom.tmAscent;

	tagx = xpixel; // origin of tag 
	tagy = ypixel;

	if (!strcmp(id->m_sCurLayout.m_strTagLine1, ",,") &&
		!strcmp(id->m_sCurLayout.m_strTagLine2, ",,") &&
		!strcmp(id->m_sCurLayout.m_strTagLine3, ",,")){
		//!strlen( id->m_sCurLayout.m_strTagLine4 ) && 
		//!strlen( id->m_sCurLayout.m_strTagLine5 ) ){
		// user had old layout w/o tags, or user did not specify any, so use default large tags
		strcpy_s(id->m_sCurLayout.m_strTagLine1, TAG_LENGTH, "Flight ID,Aircraft Type,");
	}

	if ((!strcmp(id->m_sCurLayout.m_strTagVLine1, ",,") &&
		!strcmp(id->m_sCurLayout.m_strTagVLine2, ",,") &&
		!strcmp(id->m_sCurLayout.m_strTagVLine3, ",,")) ||
		0 == strlen(id->m_sCurLayout.m_strTagVLine1)){
		// user had old layout w/o tags, or user did not specify any, so use default large tags
		strcpy_s(id->m_sCurLayout.m_strTagVLine1, TAG_LENGTH, "Vehicle ID,Vehicle Tag,Category");
	}

	if (xpixel < 0 || xpixel > id->m_nWidth ||
		ypixel < 0 || ypixel > id->m_nHeight){
		/* skip */
	} else {

		maxheight = 0; maxwidth = 0;

		if (air->vehicle && air->icao24)
			CalcVehicleTagSize(id, airp, AI, &maxwidth, &maxheight);
		else
			CalcTagSize(id, airp, AI, &maxwidth, &maxheight);

		if (ALERT_NONE != air->alert)
			DrawRollPanel(id, xpixel - tag_margin_size, ypixel - tag_margin_size,
			maxwidth + (tag_margin_size * 2), maxheight + (tag_margin_size * 2), 0, TCI_ALERT);
		else
			DrawRollPanel(id, xpixel - tag_margin_size, ypixel - tag_margin_size,
			maxwidth + (tag_margin_size * 2), maxheight + (tag_margin_size * 2), 0, TagColorIndex);

		if (nBorder){
			// Draws the Large Tag Border
			glBegin(GL_LINE_STRIP);

			glColor3fv(TagBkColor);
			glVertex3i(xpixel - tag_margin_size, ypixel - tag_margin_size, 0);
			glVertex3i(xpixel - tag_margin_size, ypixel + maxheight + tag_margin_size, 0);
			glVertex3i(xpixel + maxwidth + tag_margin_size, ypixel + maxheight + tag_margin_size, 0);
			glVertex3i(xpixel + maxwidth + tag_margin_size, ypixel - tag_margin_size, 0);
			glVertex3i(xpixel - tag_margin_size, ypixel - tag_margin_size, 0);

			glEnd();
		}

		/* move to point for top line of text */
		ypixel += (maxheight - id->m_tmCustom.tmAscent);
		if (UseMapColors >= 1){
			glColor3fv(TagTextColor);
			//glColor3fv(white);
		} else {
			glColor3fv(black);
		}

		if (ALERT_NONE != air->alert){
			glRasterPos2i(xpixel, ypixel);
			glPrintCustom(id, id->m_gluCustomBase, id->m_strAlertRollPanelStr);
			ypixel -= rowheight;
		}

		glRasterPos2i(xpixel, ypixel);
		glPrintCustom(id, id->m_gluCustomBase, id->m_strRollPanelStr1);

		// move to line 2
		// ypixel -= id->m_tmCustom.tmAscent;


		ypixel -= rowheight;
		glRasterPos2i(xpixel, ypixel);

		if (strlen(id->m_strRollPanelStr2)){
			glPrintCustom(id, id->m_gluCustomBase, id->m_strRollPanelStr2);
		}

		// move to line 3 
		ypixel -= rowheight;
		glRasterPos2i(xpixel, ypixel);


		if (strlen(id->m_strRollPanelStr3)){
			glPrintCustom(id, id->m_gluCustomBase, id->m_strRollPanelStr3);
		}

		// move to line 4 
		ypixel -= rowheight;
		glRasterPos2i(xpixel, ypixel);


		if (strlen(id->m_strRollPanelStr4)){
			glPrintCustom(id, id->m_gluCustomBase, id->m_strRollPanelStr4);
		}

		// move to line 5 

		ypixel -= rowheight;
		glRasterPos2i(xpixel, ypixel);
		if (strlen(id->m_strRollPanelStr5)){
			glPrintCustom(id, id->m_gluCustomBase, id->m_strRollPanelStr5);
		}

		// Draw line to center of aircraft
		ac_ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		ac_xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		if (0.0f != id->m_glfRotateAngle){
			RotateScreenPoint(id, id->m_nWidth / 2, id->m_nHeight / 2, &ac_xpixel, &ac_ypixel);
		}

		if (nBorder){
			FindClosestTagCorner(id, ac_ypixel, ac_xpixel, &tagx, &tagy, air->FltNum, maxwidth, maxheight);
		}else{
			FindClosestTagEdge(id, ac_ypixel, ac_xpixel, &tagx, &tagy, air->FltNum, maxwidth, maxheight);
		}

		glBegin(GL_LINE_STRIP);
		glColor3fv(TagBkColor);
		glVertex3i(tagx, tagy, 0);
		glVertex3i(ac_xpixel, ac_ypixel, 0);
		glEnd();
	}
	return(TRUE);
}





DrawAirRollovers(struct InstanceData* id, AIR **airp, int TagColorIndex)
{
	int i, drawcount, aircount;
	int bGreyed = FALSE;
	AIR *air;

	if (IsASDAirP(id, airp)){
		aircount = N_TRACK_ID;
	} else {
		aircount = N_PASSUR_TRACK_ID;
	}
	for (i = 0, drawcount = 0; airp && i < aircount; i++){
		bGreyed = FALSE;
		if (!(air = airp[i])){
			continue;
		}
		if (!strcmp(air->FltNum, "SWA3164")){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "test\n");
		}
		if (!air->TrackPtr){
			/* no tracks yet */
			continue;
		}
		// PassurTracks is set if aircraft is ASD and passur is tracking
		if (air->IsTracked && !((air->IsTracked & TBF_ASDEX || air->IsTracked & TBF_MLAT) && id->m_sCurLayout.m_dWorldXSize > 1.5)){
			/* passur is tracking this aircraft */
			continue;
		}

		/* must be able to view aircraft if on screen or not??? */
		if (clipaircraft(id, air)) {
			continue;
		}

		if (airp == GetASDEXAirP(id) && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {

			// Support Tag Filtering
			if (!air->vehicle && ALERT_NONE == air->alert && !tagfiltermatch(id, air)) 
			{
				continue;
			}
			if (!air->vehicle && filtermatch(id, air) < 0){
			
					if (TCI_ASDEX != TagColorIndex)
						continue;
					else
						bGreyed = TRUE;		
			}
		}

		if ((!id->m_nVehicles && air->vehicle) || // Looking for Vehicle ASDEX Tracks and status of Showing Vehicles
			(air->vehicle && id->m_bDisableVTag && !(id->m_pSelectedAircraft && strcmp(air->FltNum, id->m_pSelectedAircraft))) || // Show Vehicle Tags and Not the Selected Aircraft
			(2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr)) // ASDEX Vehicle, Defined Vehicles Only and Vehicle Data
			continue;
		// Skip drawing aircraft if last known position time has elapsed and LKP is off.
		if (TCI_ASDEX == TagColorIndex && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > ASDEX_LKP_TRACK_TIMEOUT))
			continue;
		if (TCI_MLAT == TagColorIndex && !id->m_sUserSettings.LKP && ((id->m_tPlotTime - air->utc) > MLAT_LKP_TRACK_TIMEOUT))
			continue;

		// Only Draw non-selected aircraft
		//if (ALERT_NONE != air->alert){
		//	DrawRoll( id, airp, i, 0, 0, TCI_ALERT, FALSE );
		//}
		/*else*/ if (id->m_nSelectedTrackID != air->trackid){
			DrawRoll(id, airp, i, 0, 0, TagColorIndex, bGreyed);
		}
		if (drawcount++ > 100){
			// too many displayed at once, so stop
			break;
		}
	}
}




VO *GetAirlinesVO(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	VO *AirlinesVO = NULL;
	char *membuf;
	int len;
	char linebuf[256];
	char *eolstr;
	char *field1 = NULL, *field2 = NULL, *field3 = NULL;
	char	*sprtr = ",";
	char *context;
	const DWORD cdwThreadId = GetCurrentThreadId();


	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> STRING <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), "Action=GetAirlines");

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), "Action=GetAirlines", SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Airlines from %s, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return(NULL);
	}

	if (chunk.memory && chunk.size){

		membuf = chunk.memory;

		while ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 255){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);

			membuf = eolstr;
			membuf++; /* skip over eol char */

			StrSubs(linebuf, ",,", ", ,", 255);
			if (!(field1 = strtok_s(linebuf, sprtr, &context))){
				continue;
			} else if ( !( field2 = strtok_s ( NULL, sprtr, &context ) )){
				continue;
			} else if ( !( field3 = strtok_s ( NULL, sprtr, &context )		)){
				continue;
			}

			if (!AirlinesVO){
				AirlinesVO = (VO *)vo_create(0, NULL);
				vo_set(AirlinesVO, V_NAME, "AirlinesVO", NULL);
				VOPropAdd(AirlinesVO, "iataairline", NTBSTRINGBIND, 3, VO_NO_ROW);
				VOPropAdd(AirlinesVO, "icaoairline", NTBSTRINGBIND, 4, VO_NO_ROW);
				VOPropAdd(AirlinesVO, "airlinename", NTBSTRINGBIND, 64, VO_NO_ROW);
				vo_rm_rows(AirlinesVO, 0, AirlinesVO->count);
			}
			vo_alloc_rows(AirlinesVO, 1);

			if (field1){
				strncpy_s(VP(AirlinesVO, AirlinesVO->count - 1, "icaoairline", char),
					4, field1, _TRUNCATE);
			}
			if (field2){
				strncpy_s(VP(AirlinesVO, AirlinesVO->count - 1, "iataairline", char),
					3, field2, _TRUNCATE);
			}
			if (field3){
				strncpy_s(VP(AirlinesVO, AirlinesVO->count - 1, "airlinename", char),
					64, field3, _TRUNCATE);
			}

		}

		free_chunk_memory(&chunk);

		//for (i = 0; i < AirlinesVO->count; i++){
		//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) row %d iata='%s' icao='%s' name='%s'\n",
		//    cdwThreadId, i, VP(AirlinesVO, i, "iataairline", char ),
		//   VP(AirlinesVO, i, "icaoairline", char ),
		//   VP(AirlinesVO, i, "airlinename", char ) );
		//}
		if (!AirlinesVO){
			return(NULL);
		}

		/* sort the array by code (should already be done by server, but make sure here */
		vo_set(AirlinesVO, V_ORDER_COLS, "icaoairline", NULL, NULL);
		vo_order(AirlinesVO);
		return(AirlinesVO);

	} else { 
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) No Airline data retrieved from server\n",
			cdwThreadId);
	}

	return(NULL);
}




char *IsValidAirline(struct InstanceData* id, char *airline)
{
	static int pflag = FALSE;
	char *airlinename;
	struct row_index *row_index;

	if (!AirlinesVO){
		AirlinesVO = GetAirlinesVO(id);
	}

	if (AirlinesVO && (row_index = (struct row_index *) vo_search(AirlinesVO, "icaoairline", airline, NULL))){
		airlinename = VP(AirlinesVO, row_index->rownum, "airlinename", char);
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found airline for %s name='%s'\n",
				GetCurrentThreadId(), airline, airlinename);
		}
		return(airlinename);
	}

	return(NULL);

}



char *GetTailString(struct InstanceData* id, char *FltNum)
{
	struct MemoryStruct chunk;
	char *membuf;
	int u_type;
	char parmstr[256];
	static char tailstr[256];

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	// example query
	// http://www3.passur.com/fcgi/imap.fcg?username=imaputest&pwd=dhsdhs44&Action=GetMouseOverInfo&tail=N1JK&u_type=3

	if (UserIsAvitat){
		u_type = 3; // all avitat for now
	} else if ( UserIsAmstat ){ 
		u_type = 2;  // amstat data, but not avitat (BACK data u_tpe=1 will come later)
	} else {
		u_type = 0; // faa only
	}
	_snprintf_s(parmstr, _countof(parmstr), _TRUNCATE, "username=fwuser&pwd=rhino&Action=GetMouseOverInfo&tail=%s&u_type=%d",
		FltNum, u_type);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentIMAPServer <%s> parmstr <%s>.\n",
		GetCurrentThreadId(), CurrentIMAPServer, parmstr);

	GetCurlFormGetResults(id, &chunk, CurrentIMAPServer, parmstr, SM_HTTPS, TRUE);

	if (chunk.memory && chunk.size){

		membuf = chunk.memory;

		strncpy_s(tailstr, _countof(tailstr), membuf, _TRUNCATE);

		StrSubs(tailstr, "<BR>", "\n", 255);
		StrSubs(tailstr, "<br>", "\n", 255);
		StrSubs(tailstr, "&amp;", "&", 255);
		StrSubs(tailstr, "&lt;", "<", 255);
		StrSubs(tailstr, "&gt;", ">", 255);
		StrSubs(tailstr, "&quot;", "\"", 255);
		StrSubs(tailstr, "&nbsp;", " ", 255);
		StrSubs(tailstr, "TailInfo: ", "", 255);

		free(chunk.memory);
		chunk.memory = NULL;

		if (strstr(tailstr, "DOCTYPE")){
			// error , probably timed out
			sprintf_s(tailstr, _countof(tailstr), "%s Timeout", FltNum);
			return(tailstr);
		}
		return(tailstr);

	}

	return(NULL);

}





VOID TailThreadDefault(void* pvoid)
{
	static int TailThreadCount;
	char *tailstr;
	int thisthreadcount;
	struct InstanceData* id = (struct InstanceData*)pvoid;
	const DWORD cdwThreadId = GetCurrentThreadId();


	thisthreadcount = TailThreadCount++;
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d starting, FltNum='%s'\n", cdwThreadId, id->m_nControlId, thisthreadcount, id->m_strTailStrFltNum);

	sprintf_s(id->m_strPrevTailStrDefault, 256, "%s ...Searching", id->m_strTailStrFltNum);

	// wait until we have the mutex, should always have it
	WaitForSingleObject(TailMutexDefault, INFINITE);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) calling GetTailString for threadnum %d FltNum='%s'\n", cdwThreadId, thisthreadcount, id->m_strTailStrFltNum);
	if (!(tailstr = GetTailString(id, id->m_strTailStrFltNum))){
		id->m_strPrevTailStrDefault[0] = '\0';
		ReleaseMutex(TailMutexDefault);
		return;
	}
	strncpy_s(id->m_strPrevTailStrDefault, 256, tailstr, _TRUNCATE);


	ReleaseMutex(TailMutexDefault);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d ending, FltNum='%s'\n", cdwThreadId, id->m_nControlId, thisthreadcount, id->m_strTailStrFltNum);

	_endthread();

}



int DrawTailInfoPopup(struct InstanceData* id, char *FltNum)
{
	static int pflag = 0;
	static int first_time = TRUE;
	char *airlinename;
	char linestr1[256], linestr2[256], linestr3[256], linestr4[256], linestr5[256], linestr6[256];
	static char PrevFltNum[FLTNUM_SIZE];
	char tmpstr[TMPBUF_SIZE];
	char tailinfostr[TMPBUF_SIZE];
	char airline[4];
	char	*sprtr = "\n";
	char *tptr, *str;
	char *context;
	int mutexstatus;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Tail number information lookup
	//   

	if (!strcmp(FltNum, PrevFltNum)){
		// use cached value
		if (!strlen(id->m_strPrevTailStrDefault)){
			// some problem with the data, or data not ready yet
			return(FALSE);
		}
	} else {
		// retrieve string to display
		// first check 
		if (strlen(FltNum) > 3 && isalpha(FltNum[0]) && isalpha(FltNum[1]) && isalpha(FltNum[2]) && isdigit(FltNum[3])){
			// probably a commercial flight, but check the airline list just to make sure
			strncpy_s(airline, _countof(airline), FltNum, 3);
			if ((airlinename = IsValidAirline(id, airline))){
				// almost certainly a commercial flight ;)
				// so no tail number stuff to display
				strncpy_s(id->m_strPrevTailStrDefault, 256, airlinename, _TRUNCATE);
				strncpy_s(PrevFltNum, FLTNUM_SIZE, FltNum, _TRUNCATE);
				goto DispTailTag;
			} else {
				// not a known airline, so see if it is a strange tail number
			}
		}

		if (strlen(FltNum) <= 2){
			return(FALSE);
		}
		if (!TailMutexDefault){
			TailMutexDefault = CreateMutex(NULL, FALSE, NULL);
		}

		// make sure another thread is not running
		if ((mutexstatus = WaitForSingleObject(TailMutexDefault, 1000)) == WAIT_OBJECT_0){
			// the mutex is ready for and we have the signal and can use the Tail data
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) the mutex is ready, no other threads are running\n", cdwThreadId);
			_snprintf_s(id->m_strPrevTailStrDefault, 256, _TRUNCATE, "Searching for %s", FltNum);
			ReleaseMutex(TailMutexDefault);
			strcpy_s(id->m_strTailStrFltNum, 8, FltNum);
			_beginthread(TailThreadDefault, 0, id);
		} else if ( mutexstatus == WAIT_TIMEOUT ){
			// the mutex timed out, continue drawing but do not access the thread Tail data
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) the mutex timed out, still waiting for another thread\n", cdwThreadId);
			ForceRefresh = TRUE;
			return(FALSE);
		} else if ( mutexstatus == WAIT_ABANDONED ) {
			// the thread has broken, this should never happen
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tail thread abandoned\n", cdwThreadId);
			return(FALSE);
		}



		// first time must wait if TailThreadDefault just started, but hereafter should usually not have to wait
		if ((mutexstatus = WaitForSingleObject(TailMutexDefault, 1000)) == WAIT_OBJECT_0){
			// the mutex is ready for and we have the signal and can use the Tail data
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) the mutex is ready, WAIT_OBJECT_0 found\n", cdwThreadId);

		} else if ( mutexstatus == WAIT_TIMEOUT ){
			// the mutex timed out, continue drawing but do not access the thread Tail data
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) the mutex timed out, continue drawing\n", cdwThreadId);
			ForceRefresh = TRUE;
			return(FALSE);
		} else if ( mutexstatus == WAIT_ABANDONED ) {
			// the thread has broken, this should never happen
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tail thread abandoned\n", cdwThreadId);
			return(FALSE);
		}

	}


	// we have the mutex now, so we can use or wrote to PrevTailStrDefault
	// Display the string
DispTailTag:

	strncpy_s(PrevFltNum, FLTNUM_SIZE, FltNum, _TRUNCATE);

	if (!strlen(id->m_strPrevTailStrDefault) || strstr(id->m_strPrevTailStrDefault, "Searching")){
		strcpy_s(id->m_strPrevTailStrDefault, 256, "No Data");
		ReleaseMutex(TailMutexDefault); // let the thread have the handle now
		ForceRefresh = TRUE;  // process thread in next loop
		return(FALSE);
	}


	FltNum[0] = '\0'; // setting to null so that this routine does not get called again since we do not need to keep
	// drawing into dialog
	linestr1[0] = '\0'; linestr2[0] = '\0'; linestr3[0] = '\0'; linestr4[0] = '\0'; linestr5[0] = '\0', linestr6[0] = '\0';

	strncpy_s(tmpstr, TMPBUF_SIZE, id->m_strPrevTailStrDefault, _TRUNCATE); // must make a copy since strtok destroys contents
	tptr = tmpstr;
	str = strtok_s(tptr, sprtr, &context);

	tptr = NULL; // next call to strtok must be null

	strncpy_s(linestr1, _countof(linestr1), str, 256);

	if ((str = strtok_s(tptr, sprtr, &context))){
		strncpy_s(linestr2, _countof(linestr2), str, 256);
	}

	if (str && (str = strtok_s(tptr, sprtr, &context))){
		strncpy_s(linestr3, _countof(linestr3), str, 256);
	}

	if (str && (str = strtok_s(tptr, sprtr, &context))){
		strncpy_s(linestr4, _countof(linestr4), str, 256);
	}

	if (str && (str = strtok_s(tptr, sprtr, &context))){
		strncpy_s(linestr5, _countof(linestr5), str, 256);
	}

	if (str && (str = strtok_s(tptr, sprtr, &context))){
		strncpy_s(linestr6, _countof(linestr6), str, 256);
	}


	sprintf_s(tailinfostr, TMPBUF_SIZE, "%s\n%s\n%s\n%s\n%s\n%s\n", linestr1, linestr2, linestr3, linestr4, linestr5, linestr6);

	//  ShowMyMessage2( tailinfostr, 12 );

	ReleaseMutex(TailMutexDefault); // let the thread have the handle now

	return(TRUE);
}



ResetTaglist()
{
	taglist *tag, *deltag;

	// free the global linked list of tags

	tag = gtaglist;
	while (tag)
	{
		deltag = tag;
		tag = tag->np;
		free(deltag);
	}

	gtaglist = NULL; // all cleared
}



void DrawRollovers(struct InstanceData* id)
{
	AIR *air = NULL;
	VO *RollVO = NULL;
	AIR **airp = NULL;
	char *str = NULL;
	int TagColorIndex = TCI_OTHER;

#ifdef LOADNAVS
	if ( !navcount ){
		LoadNav();
	}
	if ( !airways ){
		LoadAirways();
	}
	if ( !fixcount ){
		LoadFixes();
	}
	if ( !starcount ){
		LoadStars();
	}
#endif

	// startsecs = time(0);
	if (id->m_sCurLayout.m_bShowLargeTags || (id->m_pSelectedAirP && (airp = (AIR**)id->m_pSelectedAirP) && (air = airp[id->m_nSelectedAirIndex]) &&
		id->m_pSelectedAircraft && id->m_nSelectedAirIndex >= 0 && air &&
		!strcmp(air->FltNum, id->m_pSelectedAircraft) &&
		id->m_nSelectedTrackID == air->trackid))
	{
		glPushMatrix();
		glDisable(GL_DITHER);
		glDisable(GL_TEXTURE_2D);
		glDisable(GL_DEPTH_TEST);
		glDisable(GL_BLEND);
		glShadeModel(GL_FLAT);

		glLoadIdentity();

		glColor3f(1.0, 1.0, 1.0); /* white line */

		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		/* glortho (left, right, bottom , top, near, far ) */
		/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
		glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		glTranslatef(trans[0], trans[1], trans[2]);
		glLineWidth(1);

		glColor3fv(darkpurple);

		// Draw Large Tags only if WorldSize is not too large or we are using filters
		if (id->m_sCurLayout.m_bShowLargeTags && !(id->m_sCurLayout.m_dWorldXSize > 25.0 && id->m_nActiveFilters == FALSE)){
			if (id->m_sCurLayout.m_bShowASDAircraft){
				airp = GetASDAirP(id);
				DrawAirRollovers(id, airp, TCI_ASDI);
			}
			if (id->m_sCurLayout.m_bShowPassurAircraft){
				airp = GetAirP(id, 0);
				DrawAirRollovers(id, airp, TCI_PASSUR);
			}
			if (id->m_sCurLayout.m_bShowASDEXAircraft && id->m_sCurLayout.m_dWorldXSize < 0.86){
				airp = GetASDEXAirP(id);
				DrawAirRollovers(id, airp, TCI_ASDEX);
				if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
					airp = GetGateAirP(id);
					DrawAirRollovers(id, airp, TCI_ASDEX);
				}
				airp = GetLMGAirP(id);
				DrawAirRollovers( id, airp, TCI_LMG );
			}
			if (id->m_sCurLayout.m_bShowMLATAircraft && id->m_sCurLayout.m_dWorldXSize < 0.86){
				airp = GetMLATAirP(id);
				DrawAirRollovers(id, airp, TCI_MLAT);
				if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
					airp = GetGateAirP(id);
					DrawAirRollovers(id, airp, TCI_MLAT);
				}
			}
			if (id->m_sCurLayout.m_bShowADSBAircraft){
				airp = GetADSBAirP(id);
				DrawAirRollovers(id, airp, TCI_ADSB);
			}
			if (id->m_sCurLayout.m_bShowNoiseAircraft){
				airp = GetNoiseAirP(id);
				DrawAirRollovers(id, airp, TCI_NOISE);
			}
			if(id->m_sCurLayout.m_bShowAirAsiaAircraft){
				airp = GetAirAsiaAirP(id);
				DrawAirRollovers( id, airp, TCI_AIRASIA );
			}
		} else {
			// InitRollGrids();
			//if ( (str = VP(AirVO, SelectedAirIndex, "FltNum", char )) && strlen(str) ){
			//  DrawRoll( id, AirVO, SelectedAirIndex, NULL );
			//} else {
			//  DrawRoll( id, AirVO, SelectedAirIndex, NULL ); // beacon only flight
			//}

		}
		// always draw selected aircraft
		switch (id->m_nSelectedAircraftType){
		case SAT_PASSUR: TagColorIndex = TCI_PASSUR; break;
		case SAT_ASDI: TagColorIndex = TCI_ASDI; break;
		case SAT_ASDEX: TagColorIndex = TCI_ASDEX; break;
		case SAT_ADSB: TagColorIndex = TCI_ADSB; break;
		case SAT_MLAT: TagColorIndex = TCI_MLAT; break;
		case SAT_AIRASIA: TagColorIndex = TCI_AIRASIA; break;
		case SAT_LMG: TagColorIndex = TCI_LMG; break;
		case SAT_GATE: TagColorIndex = TCI_GATE; break;
		}

		if (id->m_pSelectedAirP && (air = ((AIR**)id->m_pSelectedAirP)[id->m_nSelectedAirIndex]) && filtermatch(id, air) < 0){
			// the selected aircraft is not in the filter, but draw tag anyway
			if ((str = air->FltNum) && strlen(str)){
				DrawRoll(id, (AIR**)id->m_pSelectedAirP, id->m_nSelectedAirIndex, 40, 70, TagColorIndex, FALSE);
				// not supported yet DrawTailInfo( SelectedAirVO, SelectedAirIndex, 40, -140 );
			} else {
				DrawRoll(id, (AIR**)id->m_pSelectedAirP, id->m_nSelectedAirIndex, 40, 70, TagColorIndex, FALSE); // beacon only flight
				// DrawTailInfo( SelectedAirVO, SelectedAirIndex, 40, 40 );
			}
		} else if ( (AIR**)id->m_pSelectedAirP ){
			// small tags on, but draw large tags for selected aircraft
			// DRAW SELECTED AIRCRAFT TAG
			DrawRoll(id, (AIR**)id->m_pSelectedAirP, id->m_nSelectedAirIndex, 40, 70, TagColorIndex, FALSE);
			// DrawTailInfo( SelectedAirVO, SelectedAirIndex, 40, -140 );
		}
		glFlush();
		glPopMatrix();
		glColor3fv(white);
	}

}



VO *CreateDepGatesVO()
{
	VO *DepVO;


	DepVO = (VO *)vo_create(0, NULL);
	vo_set(DepVO, V_NAME, "DepVO", NULL);
	VOPropAdd(DepVO, "arpt", NTBSTRINGBIND, 4, VO_NO_ROW);
	VOPropAdd(DepVO, "lat1", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "lng1", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "lat2", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "lng2", FLT8BIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "heightlo", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "heighthi", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "runway", NTBSTRINGBIND, 4, VO_NO_ROW);
	VOPropAdd(DepVO, "precedence", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(DepVO, "gateid", INTBIND, -1, VO_NO_ROW);
	vo_rm_rows(DepVO, 0, DepVO->count);

	return(DepVO);

}

VO *GetDepGates(struct InstanceData* id, int gatearr)
{
	struct MemoryStruct chunk;
	char *membuf;
	int len;
	char parmstr[256];
	static char tailstr[256];
	static VO *DepGatesVO;
	char *eolstr;
	char linebuf[1024];
	char *arpt, *lat1, *lat2, *lng1, *lng2, *heightlo, *heighthi, *runway, *precedence,
		*gateid;
	char parpt[4];
	char *context;

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	// example query
	// http://www3.passur.com/fcgi/FTracks.fcg?username=imaputest&pwd=dhsdhs44&Action=DepartureGates&arpt=lga

	_snprintf_s(parpt, _countof(parpt), 3, "%s", id->m_strPassurArpts[0]);

	// strcpy( parpt, "jfk"); // hardwire for now
	//_snprintf(parmstr, 255, "username=fwuser&pwd=rhino&Action=DepartureGates&arpt=%s",
	//	parpt );

	if (gatearr){
		_snprintf_s(parmstr, _countof(parmstr), _TRUNCATE, "username=fwuser&pwd=rhino&Action=ArrivalGates&arpt=%s",
			parpt);
	} else {
		_snprintf_s(parmstr, _countof(parmstr), _TRUNCATE, "username=fwuser&pwd=rhino&Action=DepartureGates&arpt=%s",
			parpt);
	}


	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentFTracksServer <%s> parmstr <%s>.\n",
		GetCurrentThreadId(), GetFTrackSrvr(id), parmstr);

	if (!GetCurlFormGetResults(id, &chunk, GetFTrackSrvr(id), parmstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Failed to get gate information for arpt<%s>\n", GetCurrentThreadId(), parpt);
		GetNxtFTrackSrvr(id);
	}

	if (chunk.memory && chunk.size){

		membuf = chunk.memory;

		while (membuf){
			if ((eolstr = strchr(membuf, '\n'))){
				len = eolstr - membuf;
				if (len > 255){
					break;  // some problem with the data
				}
				strncpy_s(linebuf, _countof(linebuf), membuf, len);

				membuf = eolstr;
				membuf++; /* skip over eol char */

				do {
					if (!(arpt = strtok_s(linebuf, "\t", &context))) break;
					if (!(lat1 = strtok_s(NULL, "\t", &context))) break;
					if (!(lng1 = strtok_s(NULL, "\t", &context))) break;
					if (!(lat2 = strtok_s(NULL, "\t", &context))) break;
					if (!(lng2 = strtok_s(NULL, "\t", &context))) break;
					if (!(heightlo = strtok_s(NULL, "\t", &context))) break;
					if (!(heighthi = strtok_s(NULL, "\t", &context))) break;
					if (!(runway = strtok_s(NULL, "\t", &context))) break;
					if (!(precedence = strtok_s(NULL, "\t", &context))) break;
					if (!(gateid = strtok_s(NULL, "\t", &context))) break;

					if (!DepGatesVO){
						DepGatesVO = CreateDepGatesVO();
					}
					vo_alloc_rows(DepGatesVO, 1);
					strncpy_s(VP(DepGatesVO, DepGatesVO->count - 1, "arpt", char), 4, arpt, _TRUNCATE);
					VV(DepGatesVO, DepGatesVO->count - 1, "lat1", double) = atof(lat1);
					VV(DepGatesVO, DepGatesVO->count - 1, "lng1", double) = atof(lng1);
					VV(DepGatesVO, DepGatesVO->count - 1, "lat2", double) = atof(lat2);
					VV(DepGatesVO, DepGatesVO->count - 1, "lng2", double) = atof(lng2);
					strncpy_s(VP(DepGatesVO, DepGatesVO->count - 1, "runway", char), 4, runway, _TRUNCATE);
					VV(DepGatesVO, DepGatesVO->count - 1, "gateid", int) = atoi(gateid);
				} while (0);
			} else {
				membuf = NULL;
			}

		}
		free(chunk.memory);
		chunk.memory = NULL;
		return(DepGatesVO);
	}

	return(NULL);


}



DrawDepartureGates(struct InstanceData* id)
{
	static VO *DepGatesVO;
	int i;
	float x, y;
	char tmpstr[TMPBUF_SIZE];
	static int prevgatearr = 0;
	static int gatearr = 0; // if 1, then show arrival gates, else departure
	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
	glPushMatrix();
	glLoadIdentity();

	glColor3f(0.0, 0.0, 0.0); /* line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);


	glColor3f(1.0, 0.0, 0.0);

	if (DepGatesVO && gatearr != prevgatearr){
		vo_free(DepGatesVO);
		DepGatesVO = NULL;
	}
	if (!DepGatesVO){
		DepGatesVO = GetDepGates(id, gatearr);
		prevgatearr = gatearr;
	}
	for (i = 0; DepGatesVO && i < DepGatesVO->count; i++){
		glColor3f(1.0, 0.0, 0.0);
		glBegin(GL_LINE_STRIP);
		x = (float)VV(DepGatesVO, i, "lng1", double);
		y = (float)VV(DepGatesVO, i, "lat1", double);
		glVertex3f(x, y, 0.0);

		x = (float)VV(DepGatesVO, i, "lng2", double);
		y = (float)VV(DepGatesVO, i, "lat2", double);
		glVertex3f(x, y, 0.0);
		glEnd();

		sprintf_s(tmpstr, TMPBUF_SIZE, "%d rw %s", VV(DepGatesVO, i, "gateid", int),
			VP(DepGatesVO, i, "runway", char));
		glColor3fv(lightpurple);

		glRasterPos2f(x, y);
		glPrintCustom(id, id->m_gluCustomBase, tmpstr);
	}

	glFlush();


	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}

#ifdef OLDWAY
DrawRunwayElements()
{
	static polylist *RunwayPolyList;
	static GLuint Runwaylist;
	const char shapefiles[][25] = { "RunwayElement.shp",
		"RunwayElement.shx",
		"RunwayElement.dbf" };
	char shapefilename[256];

	if ( !RunwayPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		RunwayPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Runwaylist ){
		// initialize gl list, or recreate if user changed a color
		Runwaylist = CreateTessPolyList( id, RunwayPolyList, NULL, -1 );		
	}
	if ( Runwaylist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( RunwayColor );
		glCallList( Runwaylist );
	}
}

DrawParking()
{
	static polylist *ParkingPolyList;
	static GLuint Parkinglist;
	const char shapefiles[3][35] = { "ParkingStandArea.shp",
		"ParkingStandArea.shx",
		"ParkingStandArea.dbf" };
	char shapefilename[256];

	if ( !ParkingPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		ParkingPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Parkinglist ){
		// initialize gl list, or recreate if user changed a color
		Parkinglist = CreateTessPolyList( id, ParkingPolyList, NULL, -1 );		
	}
	if ( Parkinglist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( (GLfloat *) ParkingFillColor );
		glCallList( Parkinglist );
	}
}


DrawAprons()
{
	static polylist *ApronPolyList;
	static GLuint Apronlist;
	const char shapefiles[3][35] = { "ApronElement.shp",
		"ApronElement.shx",
		"ApronElement.dbf" };
	char shapefilename[256];

	if ( !ApronPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		ApronPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Apronlist ){
		// initialize gl list, or recreate if user changed a color
		Apronlist = CreateTessPolyList( id, ApronPolyList, NULL, -1 );		
	}
	if ( Apronlist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		}
		else							// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing

		glColor3fv( ApronFillColor );
		glCallList( Apronlist );
	}
}



DrawRunwayExits()
{
	static GLuint Markingslist;
	const char shapefiles[3][35] = { "RunwayExitLine.shp",
		"RunwayExitLine.shx",
		"RunwayExitLine.dbf" };
	char shapefilename[256];

	if ( !Markingslist ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		Markingslist = CreatePolyGLList( shapefilename, GL_LINE_STRIP, NULL, -1 );
	}
	if ( Markingslist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( MarkingsFillColor );
		glCallList( Markingslist );
	}

}


DrawTaxiMarkings()
{
	static GLuint Markingslist;
	const char shapefiles[3][35] = { "TaxiwayGuidanceLine.shp",
		"TaxiwayGuidanceLine.shx",
		"TaxiwayGuidanceLine.dbf" };
	char shapefilename[256];

	if ( !Markingslist ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());			
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		Markingslist = CreatePolyGLList( shapefilename, GL_LINE_STRIP, NULL, -1 );
	}
	if ( Markingslist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( MarkingsColor );
		glCallList( Markingslist );
	}

}



DrawRunwayMarkings()
{
	static polylist *MarkingsPolyList;
	static GLuint Markingslist;
	const char shapefiles[3][35] = { "RunwayMarking.shp",
		"RunwayMarking.shx",
		"RunwayMarking.dbf" };
	char shapefilename[256];

	if ( !MarkingsPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		MarkingsPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Markingslist ){
		// initialize gl list, or recreate if user changed a color
		Markingslist = CreateTessPolyList( id, MarkingsPolyList, NULL, -1 );		
	}
	if ( Markingslist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( MarkingsColor );
		glCallList( Markingslist );
	}
}

DrawBuildings()
{
	static polylist *BuildingPolyList;
	static GLuint Buildinglist;
	const char shapefiles[3][35] = { "VerticalPolygonalStructure.shp",
		"VerticalPolygonalStructure.shx",
		"VerticalPolygonalStructure.dbf" };
	char shapefilename[256];

	if ( !BuildingPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		BuildingPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Buildinglist ){
		// initialize gl list, or recreate if user changed a color
		Buildinglist = CreateTessPolyList( id, BuildingPolyList, NULL, -1 );		
	}
	if ( Buildinglist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( BuildingFillColor );
		glCallList( Buildinglist );
	}
}



DrawStopWay()
{
	static polylist *StopPolyList;
	static GLuint Stoplist;
	const char shapefiles[][25] = { "Stopway.shp",
		"Stopway.shx",
		"Stopway.dbf" };
	char shapefilename[256];

	if ( !StopPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		StopPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Stoplist ){
		// initialize gl list, or recreate if user changed a color
		Stoplist = CreateTessPolyList( id, StopPolyList, NULL, -1 );		
	}
	if ( Stoplist ){
		glColor3fv( TaxiColor );
		glCallList( Stoplist );
	}
}

DrawRunwayShoulder()
{
	static polylist *ShoulderPolyList;
	static GLuint Shoulderlist;
	const char shapefiles[][25] = { "RunwayShoulder.shp",
		"RunwayShoulder.shx",
		"RunwayShoulder.dbf" };
	char shapefilename[256];

	if ( !ShoulderPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		ShoulderPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Shoulderlist ){
		// initialize gl list, or recreate if user changed a color
		Shoulderlist = CreateTessPolyList( id, ShoulderPolyList, NULL, -1 );		
	}
	if ( Shoulderlist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( ShoulderFillColor );
		glCallList( Shoulderlist );
	}
}


DrawTaxiShoulder()
{
	static polylist *ShoulderPolyList;
	static GLuint Shoulderlist;
	const char shapefiles[][25] = { "TaxiwayShoulder.shp",
		"TaxiwayShoulder.shx",
		"TaxiwayShoulder.dbf" };
	char shapefilename[256];

	if ( !ShoulderPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		ShoulderPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Shoulderlist ){
		// initialize gl list, or recreate if user changed a color
		Shoulderlist = CreateTessPolyList( id, ShoulderPolyList, NULL, -1 );		
	}
	if ( Shoulderlist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}
		glColor3fv( ShoulderColor );
		glCallList( Shoulderlist );
	}
}

DrawTaxiElements()
{
	static polylist *TaxiPolyList;
	static GLuint Taxilist;
	const char shapefiles[][25] = { "TaxiwayElement.shp",
		"TaxiwayElement.shx",
		"TaxiwayElement.dbf" };
	char shapefilename[256];

	if ( !TaxiPolyList ){
		if( !GetLocalFile(mapdir, shapefiles[0], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[1], httpMapPath) ||
			!GetLocalFile(mapdir, shapefiles[2], httpMapPath) )
		{
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open local shapefiles.", GetCurrentThreadId());
		}
		sprintf(shapefilename, "%s%s", mapdir, shapefiles[0] );
		TaxiPolyList = LoadShp( id, shapefilename , 0.3, 0.1, 0.4 );
	}

	if ( bOnRefresh || !Taxilist ){
		// initialize gl list, or recreate if user changed a color
		Taxilist = CreateTessPolyList( id, TaxiPolyList, NULL, -1 );		
	}
	if ( Taxilist ){
		if (outlineSmooth)					// Check To See If We Want Anti-Aliased Lines
		{
			glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
			glEnable (GL_LINE_SMOOTH);			// Enable Anti-Aliasing
		} else	{
			// We Don't Want Smooth Lines
			glDisable (GL_LINE_SMOOTH);			// Disable Anti-Aliasing
		}


		glColor3fv( TaxiFillColor );
		glCallList( Taxilist );
	}
}
#endif

//struct clist_struct *g_mlist = NULL;
void DrawElements(struct InstanceData* id, const char* elem, int glType, const GLfloat* fillColor, const GLfloat* outlineColor)
{
	struct mapdatastruct* mdata = NULL;
	polylist *elemPolyList = NULL;
	GLuint elemListPolygon = 0;
	GLuint elemListPolygonClosed = 0;
	GLuint elemListLine = 0;
	GLuint elemListLineClosed = 0;
	int nStatus = 0;
	static int nOutlineSmooth = TRUE;
	static int bSmoothCheck = FALSE;
	const char shapefileTypes[][4] = { "shp", "shx", "dbf" };
	char shapefilename[256];
	struct clist_struct *mlist = NULL;

	if (!bSmoothCheck) {
		if (IS_D_CONTROL("DISABLE_SMOOTH_MAPS") || id->m_bCitrixUser)
			nOutlineSmooth = FALSE;
		bSmoothCheck = TRUE;
	}
	// Update mlist if we can/need to
	if (TryEnterCriticalSection(&id->m_csSync)){
		if (id->m_sMapList)
			mlist = clist_copy(id->m_sMapList);
		LeaveCriticalSection(&id->m_csSync);
	}

	if (mlist){

		// Build Initial filename used for retrieving from list
		sprintf_s(shapefilename, _countof(shapefilename), "%s%s_%s.%s", id->m_strMapDir, id->m_strAirportMap, elem, shapefileTypes[0]);

		// Find stored mapdata in clist
		if (clist_head(mlist)) {
			do {
				if (!strcmp(((struct mapdatastruct*)mlist->data)->shapeFilename, shapefilename)) {
					mdata = (struct mapdatastruct*)mlist->data;
					elemPolyList = mdata->elemPolyList;
					elemListPolygon = mdata->elemListPolygon;
					elemListPolygonClosed = mdata->elemListPolygonClosed;
					elemListLine = mdata->elemListLine;
					elemListLineClosed = mdata->elemListLineClosed;
					nStatus = mdata->nStatus;
					break;
				}
			} while (clist_next(mlist));
		}
		// Does Not Exist in list, can't go further
		if (!mdata || mdata->nStatus){
			clist_free(mlist);
			return;
		}
			
		if (elemListPolygon) {
			GLint gliCurPolygonSmooth = FALSE;
			GLint gliCurPolygonSmoothHint = GL_DONT_CARE;
			GLfloat glfvCurColor[4] = { 0.0 };

			// Capture OPENGL Settings
			glGetIntegerv(GL_POLYGON_SMOOTH, &gliCurPolygonSmooth);
			glGetIntegerv(GL_POLYGON_SMOOTH_HINT, &gliCurPolygonSmoothHint);
			glGetFloatv(GL_CURRENT_COLOR, glfvCurColor);

			if (nOutlineSmooth)					// Check To See If We Want Anti-Aliased Lines
			{
				glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
				glEnable(GL_POLYGON_SMOOTH);			// Enable Anti-Aliasing
			} else {
				// We Don't Want Smooth Lines
				glDisable(GL_POLYGON_SMOOTH);			// Disable Anti-Aliasing
			}

			glColor3fv(fillColor);
			glCallList(elemListPolygon);

			// Restore OPENGL Settings
			glColor3fv(glfvCurColor);
			if (gliCurPolygonSmooth)
				glEnable(GL_POLYGON_SMOOTH);
			else
				glDisable(GL_POLYGON_SMOOTH);
			glHint(GL_POLYGON_SMOOTH_HINT, gliCurPolygonSmoothHint);
		}

		if (elemListPolygonClosed && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_CLOSED)) {
			GLint gliCurPolygonSmooth = FALSE;
			GLint gliCurPolygonSmoothHint = GL_DONT_CARE;
			GLfloat glfvCurColor[4] = { 0.0 };

			// Capture OPENGL Settings
			glGetIntegerv(GL_POLYGON_SMOOTH, &gliCurPolygonSmooth);
			glGetIntegerv(GL_POLYGON_SMOOTH_HINT, &gliCurPolygonSmoothHint);
			glGetFloatv(GL_CURRENT_COLOR, glfvCurColor);

			if (nOutlineSmooth)					// Check To See If We Want Anti-Aliased Lines
			{
				glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
				glEnable(GL_POLYGON_SMOOTH);			// Enable Anti-Aliasing
			} else {
				// We Don't Want Smooth Lines
				glDisable(GL_POLYGON_SMOOTH);			// Disable Anti-Aliasing
			}

			glColor3fv(id->m_sCurLayout.m_glfClosedFillColor);
			glCallList(elemListPolygonClosed);

			// Restore OPENGL Settings
			glColor3fv(glfvCurColor);
			if (gliCurPolygonSmooth)
				glEnable(GL_POLYGON_SMOOTH);
			else
				glDisable(GL_POLYGON_SMOOTH);
			glHint(GL_POLYGON_SMOOTH_HINT, gliCurPolygonSmoothHint);
		}

		if (elemListLine) {
			GLint gliCurLineSmooth = FALSE;
			GLint gliCurLineSmoothHint = GL_DONT_CARE;
			GLfloat glfvCurColor[4] = { 0.0 };

			// Capture OPENGL Settings
			glGetIntegerv(GL_LINE_SMOOTH, &gliCurLineSmooth);
			glGetIntegerv(GL_LINE_SMOOTH_HINT, &gliCurLineSmoothHint);
			glGetFloatv(GL_CURRENT_COLOR, glfvCurColor);

			if (nOutlineSmooth)					// Check To See If We Want Anti-Aliased Lines
			{
				glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
				glEnable(GL_LINE_SMOOTH);			// Enable Anti-Aliasing
			} else {
				// We Don't Want Smooth Lines
				glDisable(GL_LINE_SMOOTH);			// Disable Anti-Aliasing
			}

			glColor3fv(outlineColor);
			glCallList(elemListLine);

			// Restore OPENGL Settings
			glColor3fv(glfvCurColor);
			if (gliCurLineSmooth)
				glEnable(GL_LINE_SMOOTH);
			else
				glDisable(GL_LINE_SMOOTH);
			glHint(GL_LINE_SMOOTH_HINT, gliCurLineSmoothHint);
		}

		if (elemListLineClosed && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_CLOSED)) {
			GLint gliCurLineSmooth = FALSE;
			GLint gliCurLineSmoothHint = GL_DONT_CARE;
			GLfloat glfvCurColor[4] = { 0.0 };

			// Capture OPENGL Settings
			glGetIntegerv(GL_LINE_SMOOTH, &gliCurLineSmooth);
			glGetIntegerv(GL_LINE_SMOOTH_HINT, &gliCurLineSmoothHint);
			glGetFloatv(GL_CURRENT_COLOR, glfvCurColor);

			if (nOutlineSmooth)					// Check To See If We Want Anti-Aliased Lines
			{
				glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);	// Use The Good Calculations
				glEnable(GL_LINE_SMOOTH);			// Enable Anti-Aliasing
			} else {
				// We Don't Want Smooth Lines
				glDisable(GL_LINE_SMOOTH);			// Disable Anti-Aliasing
			}

			glColor3fv(id->m_sCurLayout.m_glfClosedOutlineColor);
			glCallList(elemListLineClosed);

			// Restore OPENGL Settings
			glColor3fv(glfvCurColor);
			if (gliCurLineSmooth)
				glEnable(GL_LINE_SMOOTH);
			else
				glDisable(GL_LINE_SMOOTH);
			glHint(GL_LINE_SMOOTH_HINT, gliCurLineSmoothHint);
		}

		clist_free(mlist);
	}
}

void LoadElements(struct InstanceData* id, const char* elem, int glType, const GLfloat* fillColor, const GLfloat* outlineColor)
{
	struct mapdatastruct* mdata = NULL;
	polylist *elemPolyList = NULL;
	GLuint elemListPolygon = 0;
	GLuint elemListPolygonClosed = 0;
	GLuint elemListLine = 0;
	GLuint elemListLineClosed = 0;
	VO* DBFVO = NULL;
	HGLRC hRC = NULL;
	int nCreated = FALSE, nStatus = 0, nShoulder = FALSE;
	const char shapefileTypes[][4] = { "shp", "shx", "dbf" };
	char shapefilename[256];
	struct clist_struct *mlist = NULL, // New List for RCU
		*olist = NULL; // Old List for RCU

	// Shoulder Files are processed differently for status check
	if (!strcmp(elem, "RunwayShoulder") || !strcmp(elem, "TaxiwayShoulder")) {
		nShoulder = TRUE;
	}

	if (id->m_sMapList){
		// Save pointer to old list
		olist = id->m_sMapList;
		// Create new copy of Old list to modify
		mlist = clist_copy(id->m_sMapList);
	}else{
		mlist = clist_alloc();
	}

	// Build Initial filename used for retrieving from list
	sprintf_s(shapefilename, _countof(shapefilename), "%s%s_%s.%s", id->m_strMapDir, id->m_strAirportMap, elem, shapefileTypes[0]);

	// Find stored mapdata in clist
	if (clist_head(mlist)) {
		do {
			if (!strcmp(((struct mapdatastruct*)mlist->data)->shapeFilename, shapefilename)) {
				mdata = (struct mapdatastruct*)mlist->data;
				elemPolyList = mdata->elemPolyList;
				elemListPolygon = mdata->elemListPolygon;
				elemListLine = mdata->elemListLine;
				elemListLineClosed = mdata->elemListLineClosed;
				nStatus = mdata->nStatus;
				hRC = mdata->hRC;
				DBFVO = mdata->DBFVO;
				break;
			}
		} while (clist_next(mlist));
	}
	// Does Not Exist in list, create it for us
	if (!mdata){
		mdata = calloc(1, sizeof(struct mapdatastruct));
		strcpy_s(mdata->shapeFilename, 256, shapefilename);
		nCreated = TRUE;
	}else if(mdata->nStatus){
		// Release new list, bad shapefile status
		clist_free(mlist);
		return; // Check log for Error downloading shapefile, Do not Attempt again
	}

	if (nCreated){
		int nIdx = 0;
		for (nIdx = 0; nIdx < 3; nIdx++){
			sprintf_s(shapefilename, _countof(shapefilename), "%s_%s.%s", id->m_strAirportMap, elem, shapefileTypes[nIdx]);
			if (!GetLocalFile(id, id->m_strMapDir, shapefilename, id->m_strHttpMapPath, SM_HTTPS)){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to open shapefile %s.\n", GetCurrentThreadId(), shapefilename);
				if (nCreated){
					mdata->nStatus = 1;
					clist_add(mlist, mdata);

					//DEBUG
					sprintf_s(shapefilename, _countof(shapefilename), "Unable to open shapefile %s_%s.%s\n", id->m_strAirportMap, elem, shapefileTypes[nIdx]);
					TIME_TRACE_DBG(shapefilename);

					// RCU Update for bad-file status
					EnterCriticalSection(&id->m_csSync);
					id->m_sMapList = mlist;
					LeaveCriticalSection(&id->m_csSync);
					// Free up older list
					if (olist)
						clist_free(olist);
					return;
				}
			}
		}
		sprintf_s(shapefilename, _countof(shapefilename), "%s%s_%s.%s", id->m_strMapDir, id->m_strAirportMap, elem, shapefileTypes[2]);
		DBFVO = LoadDBFFile(id, shapefilename);

		sprintf_s(shapefilename, _countof(shapefilename), "%s%s_%s.%s", id->m_strMapDir, id->m_strAirportMap, elem, shapefileTypes[0]);
		if (nShoulder) {
			elemListLine = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 0);
			mdata->elemListLine = elemListLine;
			elemListLineClosed = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 1);
			mdata->elemListLineClosed = elemListLineClosed;
		} else {
			elemListLine = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 1);
			mdata->elemListLine = elemListLine;
			elemListLineClosed = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 0);
			mdata->elemListLineClosed = elemListLineClosed;
		}
		

		if (GL_POLYGON == glType){
			elemPolyList = LoadShp(id, shapefilename, 0.3, 0.1, 0.4);
			if (elemPolyList){
				mdata->elemPolyList = elemPolyList;
				if (nShoulder) {
					elemListPolygon = CreateTessPolyList(id, elemPolyList, DBFVO, 0);
					elemListPolygonClosed = CreateTessPolyList(id, elemPolyList, DBFVO, 1);
				} else {
					elemListPolygon = CreateTessPolyList(id, elemPolyList, DBFVO, 1);
					elemListPolygonClosed = CreateTessPolyList(id, elemPolyList, DBFVO, 0);
				}
			}
			mdata->elemListPolygon = elemListPolygon;
			mdata->elemListPolygonClosed = elemListPolygonClosed;
		}
	}

	if (hRC != id->m_hRCPassive[0]){
		// initialize gl list, or recreate if user changed a color
#ifdef PERFORMANCE_TESTING
		{
			char buffer[200] = {0};
			sprintf_s(buffer, _countof(buffer), "loading %s", shapefilename);
			TIME_TRACE_DBG(buffer);
		}
#endif//PERFORMANCE_TESTING
		mdata->hRC = id->m_hRCPassive[0];

		if (nShoulder) {
			elemListLine = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 0);
			mdata->elemListLine = elemListLine;
			elemListLineClosed = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 1);
			mdata->elemListLineClosed = elemListLineClosed;
		} else {
			elemListLine = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 1);
			mdata->elemListLine = elemListLine;
			elemListLineClosed = CreatePolyGLList(shapefilename, GL_LINE_STRIP, DBFVO, 0);
			mdata->elemListLineClosed = elemListLineClosed;
		}

		if (GL_POLYGON == glType){
			if (!mdata->elemPolyList){
				elemPolyList = LoadShp(id, shapefilename, 0.3, 0.1, 0.4);
				if (elemPolyList){
					mdata->elemPolyList = elemPolyList;
					if (nShoulder) {
						elemListPolygon = CreateTessPolyList(id, elemPolyList, DBFVO, 0);
						elemListPolygonClosed = CreateTessPolyList(id, elemPolyList, DBFVO, 1);
					} else {
						elemListPolygon = CreateTessPolyList(id, elemPolyList, DBFVO, 1);
						elemListPolygonClosed = CreateTessPolyList(id, elemPolyList, DBFVO, 0);
					}
				}
			}else{
				if (nShoulder) {
					elemListPolygon = CreateTessPolyList(id, mdata->elemPolyList, DBFVO, 0);
					elemListPolygonClosed = CreateTessPolyList(id, elemPolyList, DBFVO, 1);
				} else {
					elemListPolygon = CreateTessPolyList(id, mdata->elemPolyList, DBFVO, 1);
					elemListPolygonClosed = CreateTessPolyList(id, elemPolyList, DBFVO, 0);
				}
			}
			mdata->elemListPolygon = elemListPolygon;
		}
	}

	if (nCreated){
		clist_add(mlist, mdata);
		sprintf_s(shapefilename, _countof(shapefilename), "Loaded shapefile %s%s_%s.%s\n", id->m_strMapDir, id->m_strAirportMap, elem, shapefileTypes[0]);
		TIME_TRACE_DBG(shapefilename);
	}

	// RCU Update for successful file-load status
	EnterCriticalSection(&id->m_csSync);
	id->m_sMapList = mlist;
	LeaveCriticalSection(&id->m_csSync);
	// Free up older list
	if (olist)
		clist_free(olist);
}

VO *ASDSort(struct InstanceData* id)
{
	AIR **airp;
	AIR *air;
	int i;
	static VO *ASDSearchVO;


	if (!ASDSearchVO){
		ASDSearchVO = vo_create(0, NULL);
		vo_set(ASDSearchVO, V_NAME, "ASDSearchVO", NULL);
		VOPropAdd(ASDSearchVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
		VOPropAdd(ASDSearchVO, "Index", INTBIND, -1, VO_NO_ROW);
		vo_set(ASDSearchVO, V_ORDER_COLS, "FltNum", NULL, NULL);
	}
	  
	vo_rm_rows(ASDSearchVO, 0, ASDSearchVO->count);
	airp = GetASDAirP(id);

	for (i = 0; i < N_TRACK_ID; i++){
		/* calculate closest distance to this point */
		if (!(air = airp[i])){
			continue;
		}
		if (!air->TrackPtr){
			/* no tracks yet */
			continue;
		}
		// add to Active flights
		if (strlen(air->FltNum)){
			vo_alloc_rows(ASDSearchVO, 1);
			VV(ASDSearchVO, ASDSearchVO->count - 1, "Index", int) = i;
			strcpy_s(VP(ASDSearchVO, ASDSearchVO->count - 1, "FltNum", char),
				FLTNUM_SIZE, air->FltNum);
		}

	}
	vo_order(ASDSearchVO);

	return(ASDSearchVO);
}

int compareFlt(char **arg1, char **arg2); /* Declare a function for compare */

int ProcessModeSTails(struct InstanceData* id)
{
	AIR **airp;
	VO *ASDSearchVO;
	char *curstr, *endstr, *recstr;
	int len;
	int proccount = 0;
	struct feedstruct record;
	char linebuf[LINE_BUFSIZE], tmpstr[LINE_BUFSIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!id->m_pGTailBuf){
		return(FALSE);
	}
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) processing GTailbuf = %x\n", cdwThreadId, id->m_pGTailBuf );


	// we must create a sorted array of flightids / airp indexes
	//   in order to quickly put in these values

	memset(&record, 0, sizeof(struct feedstruct));


	curstr = id->m_pGTailBuf;
	// need to create a sorted list of asd flightid/ indexes so that
	//    we can find the correct asd flight to insert this modes tail info
	ASDSearchVO = ASDSort(id);
	// test code
	//for (i = 0; ASDSearchVO && i < ASDSearchVO->count; i++ ){
	//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) i=%d tail=%s index=%d\n",
	//		cdwThreadId, i, VP(ASDSearchVO, i, "FltNum", char ), VV(ASDSearchVO, i, "Index", int ) );
	//}
	// end test code
	TIME_TRACE_DBG("START - ProcessModeSTails");
	while (curstr && curstr[0] != '\0' && (endstr = strchr(curstr, '\n'))){
		len = endstr - curstr;
		if (len <= 10 || len >= LINE_BUFSIZE){
			/// some bad problem
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unexpected string size = %d\n", cdwThreadId, len);
			break;
		}
		strncpy_s(linebuf, _countof(linebuf), curstr, len);

		curstr += len;
		curstr++; /* skip over newline */

		memset(&record, 0, sizeof(struct feedstruct));
		strncpy_s(record.airport, MXAPCHAR + 1, linebuf, 4);

		recstr = linebuf;
		if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){ // passur airport
			continue;
		}
		if (!GetNextRec(tmpstr, sizeof(tmpstr), &recstr)){ // rectype
			continue;
		}
		// clear out old values

		record.rectype = atoi(tmpstr);
		if (record.rectype != 20){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unexpected record type = %d, linebuf='%s', proccount=%d\n",
				cdwThreadId, record.rectype, linebuf, proccount);
			break;
		}
		RdRecType20(id, &record, recstr);
		
		if (record.rectype == 20){
			airp = GetASDAirP(id);
			// mode s tail information
			SaveASDModeS(id, &record, airp, ASDSearchVO);
			
			SaveModeS(id, &record);
			if (id->m_sCurLayout.m_bShowASDEXAircraft){
				MergeModeSTails(id, &record, ASDEX);				
			}
			if (id->m_sCurLayout.m_bShowMLATAircraft){
				MergeModeSTails(id, &record, MLAT);
			}
			proccount++;
		}		
	}
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) , "processed %d records\n", cdwThreadId, proccount );
	TIME_TRACE_DBG("START - ProcessModeSTails");
	return(FALSE);
}



void ASDZipsProcess(struct InstanceData* id)
{
	char *str;
	time_t starttime;
	char *endstr;
	int linelen;
	char buf[LINE_BUFSIZE];
	struct feedstruct *record;
	struct feedstruct record_local;
	int reccount, asdlen;
	char *asdstr;
	const DWORD cdwThreadId = GetCurrentThreadId();

	starttime = 0;
	reccount = 0;

	if (TryEnterCriticalSection(&id->m_csASDSync))
	{
		if (id->m_pGTailBuf){
			ProcessModeSTails(id);
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) freeing GTailBuf %x\n", cdwThreadId, id->m_pGTailBuf );
			free(id->m_pGTailBuf);
			id->m_pGTailBuf = NULL;
		}

		if (!id->m_pASDfilebuf){
			LeaveCriticalSection(&id->m_csASDSync);
			return;
		}

		asdstr = id->m_pASDfilebuf;
		asdlen = id->m_nASDFileNBytes;

		// we can clear it out since we have the data and don't want to process again
		id->m_pASDfilebuf = NULL;
		id->m_nASDFileNBytes = 0;
		LeaveCriticalSection(&id->m_csASDSync);

		str = asdstr;
		for (;;){
			if (!(endstr = strchr(str, '\n'))){
				/* end of file */
				break;
			}
			linelen = endstr - str;
			if (!linelen){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) zero length line\n", cdwThreadId);
				str += linelen + 1;
				continue;
			}
			if (linelen < LINE_BUFSIZE){
				strncpy_s(buf, LINE_BUFSIZE, str, linelen);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Line buf too long=%d\n", cdwThreadId, linelen);
				break;
			}
			str += linelen + 1; // skip over line and newline character
			if (str - asdstr >= asdlen){
				// at end of buffer        
				break;
			}

			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) buf='%s'\n", cdwThreadId, buf );
			reccount++;

			//if ( strstr( buf, "N813VZ") ){
			//  vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) found flight\n", cdwThreadId);
			//}
			if (!(record = RdRecord(id, &record_local, (char *)buf))){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) RdRecord returned NULL for buf='%s'\n", cdwThreadId, buf);
				continue;
			}
			//if ( !strcmp( record->FltNum, "N908VZ" ) ){
			//  vo_log_info(id->m_pfVoLogFile, "test", "test\n");
			//}
			if (!starttime){
				starttime = record->eventtime;
			}
			UpdASDAircraft(id, record);
			record = NULL;
		}
		//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Processes %d records from file %s\n", cdwThreadId, reccount, id->m_strLastZipName );
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Processed %d records\n", cdwThreadId, reccount);
		free(asdstr);
	}
}


int IsBadTrack(struct InstanceData* id, time_t endutc, AIR *air)
{
	char *src_radar;
	static int pflag = FALSE;
	char stime[256], etime[256], etatime[256];
	time_t etasecs, atasecs;
	double destdis;
	char *flightid;


	// 22 jun, use main src_radar, not for each point src_radar = VP(TrackVO, TrackVO->count - 1, "src_radar", char );
	src_radar = air->src_radar;
	atasecs = air->ata;
	etasecs = air->eta;  // changed to eta from ata 21jun2007 matt

	destdis = air->DestDis;

	if (!strlen(src_radar) || (strlen(src_radar) && !strcasecmp(src_radar, "ETMS"))){
		// possible transoceanic flight, so do not remove unless very old
		if ((id->m_tPlotTime - endutc) > ASD_TRANS_OCEAN_TIMEOUT_SECS){
			return(TRUE); // more than 1.5 hours old 
		}
	} else if ( (id->m_tPlotTime - endutc) > ASD_TIMEOUT_SECS ||
		((id->m_tPlotTime - endutc) > ASD_CLOSE_TO_AIRPORT_TIMEOUT &&
		(destdis < 8.0) && (id->m_tPlotTime - StartProgramTime) > 60 &&
		destdis > 0.00001 /* ignore if destdis = 0 */
		)
		)
	{ // past expected time, or close to airport timeout and within 8 nm of airport
		// past eta and smaller timeout

		flightid = air->FltNum;

		if (destdis > 20.0 && (id->m_tPlotTime - endutc) < ASD_FAR_AWAY_TIMEOUT){
			// aircraft far away, do not timeout unless over 30 minutes between hits
			return(FALSE); // matt 21jun2007 changed to FALSE -- don't time out until past timeout
		}
		if (pflag){
			VOTimeFmt(stime, id->m_tPlotTime, "%Y-%m-%d %H:%M:%S");
			VOTimeFmt(etime, endutc, "%Y-%m-%d %H:%M:%S");
			VOTimeFmt(etatime, etasecs, "%Y-%m-%d %H:%M:%S");
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing OLD track for flight '%s', trackid='%d' "
				"plottime=%s endutc=%s, destdis=%g, eta=%s\n",
				GetCurrentThreadId(), air->FltNum, air->trackid, stime, etime,
				air->DestDis, etatime);
		}
		return(TRUE);
	}  else if ( atasecs && ( (id->m_tPlotTime - atasecs) > ASD_CLOSE_TO_AIRPORT_TIMEOUT ) &&
		((id->m_tPlotTime - endutc) > ASD_CLOSE_TO_AIRPORT_TIMEOUT)) {
		// AZ message is in the past, and last track point is past timeout
		return(TRUE);
	}


	return(FALSE);
}




int SingleTrack(struct InstanceData* id, PTRACK *trackarr, AIR **airp, int AI)
{
	double x1, y1;
	time_t endutc;
	static int pflag = 0;
	AIR *air;

	if (!(air = airp[AI])){
		return(FALSE);
	}
	x1 = trackarr[0].x;
	y1 = trackarr[0].y;
	endutc = trackarr[0].utc;

	air->Y = (GLfloat)y1;
	air->X = (GLfloat)x1;
	air->PlotMSECS = (GLfloat)(endutc * 1000.0);
	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s curx=%g cury=%g plotmsecs=%1.3f\n",
			GetCurrentThreadId(), air->FltNum, x1, y1, air->PlotMSECS / 1000.0);
	}

	if (IsBadTrack(id, endutc, air)){
		// SaveASDRemoveRecordAirVO( AirVO, AI );
		RemoveASDTrack(id, airp, AI, TRUE);
		return(FILFAIL_OLD_PLOT);
	}
	return(TRUE);
}



int RemoveOldTracks(struct InstanceData* id, PTRACK *trackarr, int tcount, AIR **airp, int AI)
{
	time_t endutc;
	AIR *air;

	if (!(air = airp[AI])){
		return(0);
	}

	// check last point and if it is very old, then get rid of the track
	if (trackarr && tcount){
		endutc = trackarr[tcount - 1].utc;
		if (IsBadTrack(id, endutc, air)){
			// SaveASDRemoveRecordAirVO( AirVO, AI );
			RemoveASDTrack(id, airp, AI, TRUE);
			return(FILFAIL_OLD_PLOT);
		}
	}
	return(0);

}




int CalcFirstAimpoint(struct InstanceData* id, AIR *air, double *aptr, double *bptr, PTRACK *trackarr, int i,
	double startmsecs, double endmsecs, double *x1, double *x2, double *y1, double *y2)
{
	static int pflag = 0;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) first time, or past aimpoint\n", GetCurrentThreadId());
	}
	air->X1 = trackarr[i - 1].x;
	air->X2 = trackarr[i].x;
	air->Y1 = trackarr[i - 1].y;
	air->Y2 = trackarr[i].y;
	air->StartMSECS = (GLfloat)startmsecs;
	air->EndMSECS = (GLfloat)endmsecs;
	*x1 = air->X1;
	*x2 = air->X2;
	*y1 = air->Y1;
	*y2 = air->Y2;

	*aptr = *x2 - *x1;
	*bptr = *y2 - *y1;
	air->PrevX = trackarr[i - 1].x;
	air->PrevY = trackarr[i - 1].y;

	return(TRUE);
}



int CalcNewVector(struct InstanceData* id, AIR *air, double *aptr, double *bptr, double *tptr, PTRACK *trackarr,
	int i, double *startmsecs, double *endmsecs, double *x1, double *x2, double *y1, double *y2)
{
	char *FltNum;
	static int pflag = 0;
	int use_smoothing = 1;
	int starti;
	time_t startutc;
	double aimpointx, aimpointy;
	const DWORD cdwThreadId = GetCurrentThreadId();


	FltNum = air->FltNum;
	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) calc new vector, fltnum=%s prevx=%g prevy=%g x=%g y=%g i=%d\n",
			cdwThreadId, FltNum, air->PrevX, air->PrevY,
			trackarr[i - 1].x, trackarr[i - 1].y, i);
	}

	air->TrackStart = i - 1;
	// calculate the future "aim point" of this aircraft using latest segment
	if (use_smoothing){
		// use point i - 4 for start
		starti = i - 4;
		if (starti < 0) starti = 0;
		startutc = trackarr[starti].utc;;
		*startmsecs = startutc * 1000.0;
		*x1 = trackarr[starti].x;
		*x2 = trackarr[i].x;
		*y1 = trackarr[starti].y;
		*y2 = trackarr[i].y;
		*aptr = *x2 - *x1;
		*bptr = *y2 - *y1;
		// push aimpoint out further for smoother transitions using ASD_UPDATE_INTERVAL * 2
		*tptr = (double)(id->m_dPlotMSecs + ((double)(ASD_UPDATE_INTERVAL * 2) * 1000.0) - *startmsecs) /
			(double)(*endmsecs - *startmsecs);
	} else {
		*x1 = trackarr[i - 1].x;
		*x2 = trackarr[i].x;
		*y1 = trackarr[i - 1].y;
		*y2 = trackarr[i].y;
		*aptr = *x2 - *x1;
		*bptr = *y2 - *y1;
		*tptr = (double)(id->m_dPlotMSecs + ((double)ASD_UPDATE_INTERVAL * 1000.0) - *startmsecs) /
			(double)(*endmsecs - *startmsecs);
	}
	aimpointx = *x1 + (*aptr * *tptr);
	aimpointy = *y1 + (*bptr * *tptr);
	if (fabs(air->X) < 0.0001 || i < 2) {
		/* use first point */
		air->StartMSECS = (GLfloat)*startmsecs;
	} else {
		// start from currently plotted position of aircraft
		air->StartMSECS = air->PlotMSECS;
		*x1 = air->X;
		*y1 = air->Y;
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) start from currently plotted position x1=%g y1=%g startmsecs=%1.3f\n",
				cdwThreadId, *x1, *y1, air->StartMSECS / 1000.0);
		}
	}
	/* update current vector */
	air->EndMSECS = (GLfloat)(id->m_dPlotMSecs + ((double)ASD_UPDATE_INTERVAL * 1000.0));
	// 17nov04  update startmsecs, endmsecs
	*startmsecs = air->StartMSECS;
	*endmsecs = air->EndMSECS;

	air->X1 = (GLfloat)*x1;
	air->X2 = (GLfloat)aimpointx;
	air->Y1 = (GLfloat)*y1;
	air->Y2 = (GLfloat)aimpointy;
	*y2 = aimpointy;
	*x2 = aimpointx;
	*aptr = *x2 - *x1;
	*bptr = *y2 - *y1;
	air->PrevX = trackarr[i - 1].x;
	air->PrevY = trackarr[i - 1].y;

	return(TRUE);
}


CalcPastEnd(struct InstanceData* id, AIR *air, double *aptr, double *bptr, double *tptr, PTRACK *trackarr,
	int i, double *startmsecs, double *endmsecs, double *x1, double *x2, double *y1, double *y2)
{
	time_t endutc, startutc;
	static int pflag = 0;

	// Past the end of the last point
	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) plotmsecs > airend\n", GetCurrentThreadId());
	}

	air->X1 = trackarr[i - 1].x;
	air->X2 = trackarr[i].x;
	air->Y1 = trackarr[i - 1].y;
	air->Y2 = trackarr[i].y;
	//VV(AirVO, AI, "StartMSECS", double ) = startmsecs;
	//VV(AirVO, AI, "EndMSECS", double ) = endmsecs;
	endutc = trackarr[i].utc;
	startutc = trackarr[i - 1].utc;
	*endmsecs = endutc * 1000.0;
	*startmsecs = startutc * 1000.0;
	air->StartMSECS = (GLfloat)*startmsecs;
	air->EndMSECS = (GLfloat)*endmsecs;
	*x1 = air->X1;
	*x2 = air->X2;
	*y1 = air->Y1;
	*y2 = air->Y2;
	*aptr = *x2 - *x1;
	*bptr = *y2 - *y1;
	air->PrevX = trackarr[i - 1].x;
	air->PrevY = trackarr[i - 1].y;
}



int Continue2Aimpoint(struct InstanceData* id, AIR *air, double *aptr, double *bptr, PTRACK *trackarr,
	int i, double *x1, double *x2, double *y1, double *y2)
{
	static int pflag = 0;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) continue toward aimpoint\n", GetCurrentThreadId());
	}
	// continue toward aimpoint
	*x1 = air->X1;
	*x2 = air->X2;
	*y1 = air->Y1;
	*y2 = air->Y2;
	*aptr = *x2 - *x1;
	*bptr = *y2 - *y1;
	air->PrevX = trackarr[i - 1].x;
	air->PrevY = trackarr[i - 1].y;

	return(TRUE);
}




int BadSpeedTest(struct InstanceData* id, AIR **airp, int AI, PTRACK *trackarr, int tcount, double a, double b, double startmsecs,
	double endmsecs)
{
	double dis, speed;
	time_t startutc, endutc;
	static int xflag = 0;
	char stime[256], etime[256];
	char tmpstr[TMPBUF_SIZE];
	double maxspeed, x1, y1;
	int cnt;
	time_t utc1, utc2;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();


	if (!(air = airp[AI])){
		return(SUCCEED);
	}
	dis = sqrt((a*a) + (b*b));
	speed = (dis * 67.0) / ((endmsecs - startmsecs) / 1000.0) * 3600.0; // rough mph

	if (dis > 0.3 && speed > 3000.0){ // more than 3 times normal max speed, ignore small distances due to feed errors
		// greater than 1000 mph, some problem
		startutc = (int)rint(startmsecs / 1000.0);
		endutc = (int)rint(endmsecs / 1000.0);
		VOTimeFmt(stime, startutc, "%Y-%m-%d %H:%M:%S");
		VOTimeFmt(etime, endutc, "%Y-%m-%d %H:%M:%S");
		/* printf("skipping large delta dis=%g plottime=%s, startutc=%s endutc=%s "
		" diffsecs = %d\n",
		dis,
		VOTimeFmt( plottime, "%Y-%m-%d %H:%M:%S" ),
		stime, etime, endutc - startutc);	*/
		/* printf("removing track for flight '%s', trackid='%d'\n",
		VP(AirVO, AI, "FltNum", char ),
		VV(AirVO, AI, "TrackID", int ) ); */
		if (xflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) removing badly separated track, flight '%s', trackid='%d'\ndis=%g, start=%s end=%s\n "
				"speed=%g plottime=%d\n"
				"a=%g b=%g endmsecs=%1.3f startmsecs=%1.3f secs =%1.3f\n",
				cdwThreadId, air->FltNum, air->trackid, dis, stime, etime,
				speed, id->m_tPlotTime, a, b, endmsecs / 1000.0, startmsecs / 1000.0,
				(endmsecs - startmsecs) / 1000.0);
		}
		maxspeed = -9.9e99;
		for (cnt = 0; cnt < tcount; cnt++){
			VOTimeFmt(tmpstr, trackarr[cnt].utc, "%H:%M:%S");
			if (cnt == 0){
				if (xflag){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tcnt=%d utc=%s, %d, x=%g y=%g\n",
						cdwThreadId, cnt, tmpstr, trackarr[cnt].utc,
						trackarr[cnt].x, trackarr[cnt].y);
				}
			} else {
				a = trackarr[cnt].x - x1;
				b = trackarr[cnt].y - y1;
				utc2 = trackarr[cnt].utc;
				dis = sqrt((a*a) + (b*b));
				speed = (dis * 67.0) / (utc2 - utc1) * 3600.0;
				if (xflag){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) tcnt=%d utc=%s, %d, x=%g y=%g dis2prev=%g speed=%g\n",
						cdwThreadId, cnt, tmpstr, trackarr[cnt].utc, trackarr[cnt].x,
						trackarr[cnt].y, dis, speed);
				}
				if (speed > maxspeed){
					maxspeed = speed;
				}
			}
			x1 = trackarr[cnt].x;
			y1 = trackarr[cnt].y;
			utc1 = trackarr[cnt].utc;
		}
		if (maxspeed > 2000.0){
			// badtracks++;
			if (xflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Remove bad track for flight '%s'\n",
					cdwThreadId, air->FltNum);
			}
			// SaveASDRemoveRecordAirVO( AirVO, AI);
			RemoveASDTrack(id, airp, AI, TRUE);
			return(FILFAIL_SEPARATED);
		} else {
			if (xflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Keeping track for flight '%s'\n",
					cdwThreadId, air->FltNum);
			}
		}
	}

	return(FALSE);  // not a bad track
}


int UpdCurrentPoint(struct InstanceData* id, AIR *air, double curx, double cury)
{
	static int pflag = 0;


	air->Y = (GLfloat)cury;
	air->X = (GLfloat)curx;
	air->PlotMSECS = (GLfloat)id->m_dPlotMSecs;
	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) fltnum=%s curx=%g cury=%g plotmsecs=%1.3f\n",
			GetCurrentThreadId(), air->FltNum, curx, cury, air->PlotMSECS / 1000.0);
	}
	return(TRUE);
}



int ASDAirScreenPos(struct InstanceData* id, AIR **airp, int AI)
{
	double x1, y1, x2, y2, a, b, t, curx, cury, airend;
	int i, cc, tcount;
	time_t endutc, startutc;
	double endmsecs, startmsecs;
	int distest = TRUE;
	static int pflag = 0;
	static int xflag = 0;
	static int updcount = 0;
	static int testflag = FALSE;
	int NewVector = FALSE;
	PTRACK *trackarr;
	AIR *air;
	const DWORD cdwThreadId = GetCurrentThreadId();


	if (!(air = airp[AI])){
		return(FILFAIL_NOTRACKS);
	}
	/* go through tracks to find 2 points that contain plottime */

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) flight %s, X=%g y=%g\n", cdwThreadId, air->FltNum,
			air->X, air->Y);
	}

	/* interpolate position based on position at plottime */
	if (!(trackarr = air->TrackPtr)){
		if (pflag){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No tracks yet for flight '%s'\n", cdwThreadId, air->FltNum);
		}
		return(FILFAIL_NOTRACKS);
	}

	air->TrackStart = 0;

	tcount = air->tcount;
	if (tcount == 1){
		// only one point so far, so update in place
		return(SingleTrack(id, trackarr, airp, AI));
	}

	NewVector = FALSE;


	//endmsecsvcol = vcol_find(AirVO, "EndMSECS" );
	//trackstartvcol = vcol_find(AirVO, "TrackStart" );
	//d = V_ROW_PTR(AirVO, AI );

	for (i = 1; i < tcount; i++){
		endutc = trackarr[i].utc;
		startutc = trackarr[i - 1].utc;

		if (i == 1 && (id->m_tPlotTime < startutc)) {
			// do not display asd tracks before the first point
			return(FILFAIL_FUTURE_TRACKS);
		}
		/* find first track within plottime, but for asd use latest track if out of range */
		if ((id->m_tPlotTime < startutc) || (id->m_tPlotTime >= startutc && id->m_tPlotTime <= endutc) ||
			i == tcount - 1)
		{
			/* found correct 2 points */

			air->TrackStart = i - 1;

			if (ExtrapolateMaxMSecs == 0){
				UpdPastEndpoint(id, trackarr, tcount - 1, air);
				if (RemoveOldTracks(id, trackarr, tcount, airp, AI) == FILFAIL_OLD_PLOT)
					return(FILFAIL_OLD_PLOT);
				return(TRUE);
			}

			airend = air->EndMSECS;
			endmsecs = endutc * 1000.0;
			startmsecs = startutc * 1000.0;

			if (fabs(air->X1) < 0.0001){
				/* first time, or past aimpoint, so straighten out to prior points */
				CalcFirstAimpoint(id, air, &a, &b, trackarr, i, startmsecs, endmsecs, &x1, &x2, &y1, &y2);
				NewVector = TRUE;
				cc = 1;
			} else if ( trackarr[i - 1].x != air->PrevX ||
				trackarr[i - 1].y != air->PrevY){
				// new seqment is being used, calc new vector
				CalcNewVector(id, air, &a, &b, &t, trackarr, i, &startmsecs, &endmsecs, &x1, &x2, &y1, &y2);
				NewVector = TRUE;
				cc = 2;
			} else if ( airend > 0.0001 && id->m_dPlotMSecs > airend ){
				CalcPastEnd(id, air, &a, &b, &t, trackarr, i, &startmsecs, &endmsecs, &x1, &x2, &y1, &y2);
				cc = 3;
			} else {
				Continue2Aimpoint(id, air, &a, &b, trackarr, i, &x1, &x2, &y1, &y2);
				cc = 4;
			}
			if (distest && NewVector &&
				(BadSpeedTest(id, airp, AI, trackarr, tcount, a, b, startmsecs, endmsecs) == FILFAIL_SEPARATED)){
				return(FILFAIL_SEPARATED);
			}
			startmsecs = air->StartMSECS;
			endmsecs = air->EndMSECS;
			t = (double)(id->m_dPlotMSecs - startmsecs) / (double)(endmsecs - startmsecs);
			curx = x1 + (a * t);
			cury = y1 + (b * t);
			if (id->m_pSelectedAircraft && strlen(id->m_pSelectedAircraft)){
				// TestSelectedAircraft( AirVO, AI, curx, cury, x1, y1, x2, y2, a, b, startmsecs, endmsecs, t, i, cc);
			}
			updcount++;
			if (i == tcount - 1 && id->m_dPlotMSecs > ((endutc * 1000.0) + ExtrapolateMaxMSecs)){
				// last track and we are past the endpoint by more than ExtrapolateMaxMSecs seconds, so use last point
				UpdPastEndpoint(id, trackarr, i, air);
			} else {
				UpdCurrentPoint(id, air, curx, cury);
			}
			if (RemoveOldTracks(id, trackarr, tcount, airp, AI) == FILFAIL_OLD_PLOT)
				return(FILFAIL_OLD_PLOT);
			return(TRUE);
		}
	}

	if (pflag){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No track found for '%s' plottime=%d startutc=%d"
			" endutc=%d\n", cdwThreadId, air->FltNum, id->m_tPlotTime, startutc, endutc);
	}
	missedASD++;

	return(FILFAIL_MISSED);
}

drawASD(struct InstanceData* id)
{
	int i, utc, filpass, filfail, airscreenfail, clipfail, drawfail, screenstat;
	int futuretracks, septracks, oldplot, filmissed, notracks, calcd, nAcType;
	float angle;
	float x, y, AirSize;
	int drawcount = 0;
	static int pflag = 0;
	int drawcolor = -1;
	int activecount, tcount,test;
	time_t nowsecs;  // OK for replay since nowsecs is used here to check if threads are running
	static time_t LastCalcDistanceSecs;
	int xpixel, ypixel;
	const DWORD cdwThreadId = GetCurrentThreadId();
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;
	

	PTRACK *trackarr;
	AIR **airp;
	AIR *air;

	if (!id->m_bIconsLoaded) {
		D_CONTROL("ASDI_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) EXIT - Icons not loaded yet.\n", cdwThreadId));
		return(SUCCEED);
	}

	airp = GetASDAirP(id);

	nowsecs = time(0);
	// MCT 1/7/11, Code removed to support single thread loading Aircraft Data
	//	if ( !ASDThreadStarted || bOnRefresh || ( ((nowsecs - id->m_tLastASDThreadSecs) > 300) && ((nowsecs - StartProgramTime) > 500) )){
	//		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDThread started\n", cdwThreadId);
	//  RegisterThreadHandle(_beginthread(ASDThread, 0, NULL ));
	//  ASDThreadStarted = TRUE;
	//  id->m_tLastASDThreadSecs = time(0);
	//}

	// make sure Wx is still working
#ifdef WX
	if ( WxThreadStarted && (nowsecs - LastGoodWxSecs > 1800) ){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error, &s seconds since last good wx track\n", cdwThreadId, nowsecs - LastGoodWxSecs );
		// reset time too keep error messages down
		LastGoodWxSecs = nowsecs;
	}
#endif

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);


	/* AirSize = (WorldXmax - id->m_dWorldXmin) /  AircraftSize; */
	AirSize = (float)(id->m_sCurLayout.m_nAircraftSize * id->m_sCurLayout.m_dWorldXSize) / id->m_nWidth;

	if (AirSize > 1.5) AirSize = 1.5;
	/* printf("AirSize=%g, AircraftSize=%d\n", AirSize, AircraftSize); */

	airscreenfail = clipfail = drawfail = filpass = filfail = futuretracks = septracks = oldplot = filmissed = notracks = 0;


	calcd = FALSE;
	nowsecs = time(0);
	if (nowsecs - LastCalcDistanceSecs > 30){
		calcd = TRUE;
		LastCalcDistanceSecs = nowsecs;
	}

	//CkActiveFilters();

	/* increment plottime and client time */
	if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
		Updplottime(id);
	if (id->m_sUserSettings.Extrapolation == TRUE){
		ExtrapolateMaxMSecs = ASD_EXTRAPOLATE_MAX_MSECS;
	} else {
		ExtrapolateMaxMSecs = 0;
	}

	for (i = 0, activecount = 0; i < N_TRACK_ID; i++){
		if (!(air = airp[i])){
			continue;
		}
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}
		// Show Selected ASDI Aircraft only (someone did FindFlight)
		if (!id->m_sCurLayout.m_bShowASDAircraft){
			if (!(SAT_ASDI == id->m_nSelectedAircraftType && id->m_pSelectedAircraft &&
				!strcmp(air->FltNum, id->m_pSelectedAircraft) && id->m_nSelectedTrackID == air->trackid))
				continue;
		}

		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Investigating aircraft %s from %s[%d], tracked(%d)\n", 
			cdwThreadId, air->FltNum, g_arFeedTypes[ASDI], i, air->IsTracked));

		tcount = air->tcount;
		activecount++;

		/* interpolate position of aircraft for current second */
		if (ExtrapolateMaxMSecs == 0){
			if (tcount == 1){
				if (SingleTrack(id, trackarr, airp, i) == FILFAIL_OLD_PLOT){
					continue;
				}
			} else {
				UpdPastEndpoint(id, trackarr, tcount - 1, air);
				if (RemoveOldTracks(id, trackarr, tcount, airp, i) == FILFAIL_OLD_PLOT){
					continue;
				}
			}
		} else if ( (screenstat = ASDAirScreenPos( id, airp, i )) != TRUE ){
			filfail++;
			airscreenfail++;
			switch (screenstat)
			{
			case FILFAIL_FUTURE_TRACKS:
				futuretracks++;
				break;
			case FILFAIL_SEPARATED:
				septracks++;
				break;
			case FILFAIL_OLD_PLOT:
				oldplot++;
				break;
			case FILFAIL_MISSED:
				filmissed++;
				break;
			case FILFAIL_NOTRACKS:
				notracks++;
				break;
			}

			continue;
		}

		// MCT: Moved, it appears we want to do the following each time regardless of
		// whether the aircraft is displayed.
		// recalc position of all aircraft every 30 seconds, even if not on screen, in
		//  order to keep grid distances correct
		if (calcd){
			// update all distances every 30 seconds MIN, more if filtered (see below)
			CalcDistance(id, air);
		}

		if (air->IsTracked){

			if (!(air->IsTracked == TBF_ASDEX && id->m_sCurLayout.m_bShowASDEXAircraft && (id->m_sCurLayout.m_dWorldXSize > 1.5)))
				// Any of the other feeds are enabled and one is tracking this aircraft already
				continue;
			if (!(air->IsTracked == TBF_MLAT && id->m_sCurLayout.m_bShowMLATAircraft && (id->m_sCurLayout.m_dWorldXSize > 1.5)))
				// Any of the other feeds are enabled and one is tracking this aircraft already
				continue;
		}

		if (SecondTabGrid)
		{
			if (SecondTabGrid->childgrid)
			{
				if (SecondTabGrid->childgrid->filteredvo){
					if (SecondTabGrid->icon_set == 1)
					{
						if (SecondTabGrid->aircraftcolor_change_ASD == 1)
						{
							airp[i]->color = 100;
							airp[i]->check = 100;
							airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
							if (airp[i]->color != 100)
							{
								drawcolor = airp[i]->color;								
								goto t1;
							}
							else
								goto t2;
						}
						else if (SecondTabGrid->aircraftcolor_change_ASD == 0)
						{
							if ((airp[i]->color == 0) && (airp[i]->check != 100))
							{
								airp[i]->color = coloraircraft(id, air->FltNum, air->Destin, air->Region);
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
							else
							{
								if (airp[i]->color != 100)
								{
									drawcolor = airp[i]->color;
									goto t1;
								}
								else
									goto t2;
							}
						}
					}
				}
			}
		}
	t2:	if (id->m_pSelectedAircraft && !strcmp(air->FltNum, id->m_pSelectedAircraft)
		&& id->m_nSelectedTrackID == air->trackid){
		// selected aircraft, always draw
		if (pflag){
			PrintTracks(id, air, ASDI);
		}
		drawcolor = 4;
		} else {
			if (clipaircraft(id, air)) {
				filfail++;
				clipfail++;
				continue;
			}

			if ((drawcolor = filtermatch(id, air)) < 0){
				filfail++;
				drawfail++;
				continue;
			}
		}


	

		// for active flights on screen always run CalcDistance, so grids and tags get updated
	t1:if (strcmp(air->FltNum, id->m_selectedaircraft) == 0)
		drawcolor = id->m_selectedaircraftcolor;
	   else
	   {
			   test = filtermatch(id, air);
			   if (test < 0)
				   continue;
	   }
	
		if (!calcd){
		// calc was not done before filtering, so do now
		CalcDistance(id, air);
	}

		nAcType = GetAcType(id, air->actype);
		D_CONTROL("AIRCRAFT_TEXTURES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Aircraft(%s) Texture[%d] for actype[%s:%d].\n", cdwThreadId, air->FltNum, drawcolor, air->actype, nAcType));
		glBindTexture( GL_TEXTURE_2D, id->m_gluAircraftTextures[nAcType][drawcolor] );

			utc = air->utc;
			if (id->m_tPlotTime - utc > 4000){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) removing very old (4000) track for flight '%s', trackid='%d'\n",
					cdwThreadId, air->FltNum, air->trackid);
				// SaveASDRemoveRecordAirVO( air );
				RemoveASDTrack(id, airp, i, TRUE);
				filfail++;
				continue;
			}

			if (!strlen(air->DivDestin) && REPLAY_STATUS_STOPPED == id->m_bReplayStatus){
				GetDivertedDestination(id, air->FltNum, air->DivDestin);
			}

			filpass++;

			/* solid with alpha masking */
			glEnable(GL_DEPTH_TEST);
			/* glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); */
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

			glEnable(GL_BLEND);
			glDepthFunc(GL_LEQUAL);

			glPushMatrix();
			glLoadIdentity();

			/* move to center of aircraft */
			/* printf("aircraft center at %g %g\n", VV(AirVO, i, "X", double ), VV(AirVO, i, "Y", double ) ); */

			x = air->X;
			y = air->Y;
			if (pflag){
				printf("aircraft %s center at %g %g\n", air->FltNum, x, y);
			}


			// initialize the Grid of Where aircraft are so that the selected tag, or large tags will not
			// draw over other aircraft
			/* convert X and Y from world to pixel coordinates */
			ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
			xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
			/* size of aircraft is 2 * AircraftSize , so from center is 1 * aircraftsize */
			xpixel += (id->m_sCurLayout.m_nAircraftSize + TAG_BORDER); /* move center so it doesn't draw on top of aircraft */

			if (id->m_sCurLayout.m_bShowLargeTags){
				SetGrid(id, xpixel, ypixel, id->m_arGridAircraftUsed);
			}

		D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Drawing aircraft %s from %s[%d], tracked(%d)\n", 
				cdwThreadId, air->FltNum, g_arFeedTypes[ASDI], i, air->IsTracked));

			glTranslatef(x, y, (float)trans[2]);
			angle = (float)CalcAngle(id, air, TRUE);  // set isASD to false since asdairscreen now calc trackstart

			glRotatef(angle, 0.0f, 0.0f, 1.0f);

			glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)-AirSize, 0.0f);
			glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat)-AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)AirSize, (GLfloat)AirSize, 0.0f);
			glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)AirSize, (GLfloat)-AirSize, 0.0f);

			glEnd();
			glFlush();
			glPopMatrix();

			drawcount++;
	}

	if (SecondTabGrid)
		SecondTabGrid->aircraftcolor_change_ASD = 0;
	if (pflag){
		printf("drawASD, color=%d, drawcount=%d missedASD=%d plottime=%d\n",
			drawcolor, drawcount, missedASD, id->m_tPlotTime);
	}
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);

	return(SUCCEED);
}

void LoadHiResMap(struct InstanceData* id)
{
	int i = 0;
	int start = 0;
	int count = 0;
	int type = 0;

	if (strlen(id->m_strAirportMap) && strcmp(id->m_strAirportMap, "NONE")){
		// Order Show low-priority to high-priority
		// Polygons before Line structures

		// Only Supports ATL,BOS,JFK, IAD, ORD and SLC, remove once all Hi-Res maps are supplied
		// or update with new airport icao's
		// Removing for server supplied map list to prevent having to continually modify code.
		//if(strcmp("ATL", id->m_strAirportMap) && strcmp("JFK", id->m_strAirportMap) &&
		//   strcmp("IAD", id->m_strAirportMap) && strcmp("ORD", id->m_strAirportMap) &&
		//   strcmp("SLC", id->m_strAirportMap) && strcmp("BOS", id->m_strAirportMap))
		//	return;
		if (!IsMapSupported(id, id->m_strAirportMap))
			return;

		// Only Attempt to LoadElements when Airport Changes
		if (!strcmp(id->m_strAirportMap, id->m_strPrevAirportMap))
			return;
		else
			strcpy_s(id->m_strPrevAirportMap, ARPTNAME_SZ, id->m_strAirportMap);

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Loading/Downloading map files for airport %s\n", GetCurrentThreadId(), id->m_strAirportMap);

		// New Polygons
		LoadElements(id, "ConstructionArea", GL_POLYGON, id->m_sCurLayout.m_glfConstructionFillColor, id->m_sCurLayout.m_glfConstructionOutlineColor);
		LoadElements(id, "DeicingArea", GL_POLYGON, id->m_sCurLayout.m_glfDeicingFillColor, id->m_sCurLayout.m_glfDeicingOutlineColor);
		LoadElements(id, "FinalApproachAndTakeOffArea", GL_POLYGON, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "FrequencyArea", GL_POLYGON, id->m_sCurLayout.m_glfFrequencyFillColor, id->m_sCurLayout.m_glfFrequencyOutlineColor);
		LoadElements(id, "RunwayDisplacedArea", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		LoadElements(id, "RunwayIntersection", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		LoadElements(id, "RunwayShoulder", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		LoadElements(id, "ServiceRoad", GL_POLYGON, id->m_sCurLayout.m_glfRoadFillColor, id->m_sCurLayout.m_glfRoadOutlineColor);
		LoadElements(id, "TouchDownLiftOffArea", GL_POLYGON, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);

		// Original Polygons
		LoadElements(id, "TaxiwayElement", GL_POLYGON, id->m_sCurLayout.m_glfTaxiFillColor, id->m_sCurLayout.m_glfTaxiColor);
		LoadElements(id, "RunwayElement", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		LoadElements(id, "VerticalPolygonalStructure", GL_POLYGON, id->m_sCurLayout.m_glfBuildingFillColor, id->m_sCurLayout.m_glfBuildingColor);
		LoadElements(id, "ApronElement", GL_POLYGON, id->m_sCurLayout.m_glfApronFillColor, id->m_sCurLayout.m_glfApronColor);
		LoadElements(id, "ParkingStandArea", GL_POLYGON, id->m_sCurLayout.m_glfParkingFillColor, id->m_sCurLayout.m_glfParkingColor);
		LoadElements(id, "Stopway", GL_POLYGON, id->m_sCurLayout.m_glfTaxiFillColor, id->m_sCurLayout.m_glfTaxiColor);
		LoadElements(id, "TaxiwayShoulder", GL_POLYGON, id->m_sCurLayout.m_glfShoulderFillColor, id->m_sCurLayout.m_glfShoulderColor);
		LoadElements(id, "RunwayMarking", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);

		// New Lines
		LoadElements(id, "ArrestingGearLocation", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "LandAndHoldShortOperationLocation", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "PaintedCenterline", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "StandGuidanceLine", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "TaxiwayHoldingPosition", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "VerticalLineStructure", GL_LINE_STRIP, id->m_sCurLayout.m_glfBuildingFillColor, id->m_sCurLayout.m_glfBuildingColor);
		// Original Lines
		LoadElements(id, "TaxiwayGuidanceLine", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		LoadElements(id, "RunwayExitLine", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);

		// Unused, Mostly point shape files
		//LoadElements(id, "AerodromeReferencePoint", GL_LINE_STRIP, teal, silver);		
		//LoadElements(id, "HelipadThreshold", GL_LINE_STRIP, teal, silver);
		//LoadElements(id, "ParkingStandLocation", GL_LINE_STRIP, teal, silver);
		//LoadElements(id, "RunwayThreshold", GL_LINE_STRIP, teal, silver);
		//LoadElements(id, "TaxiwayIntersectionMarking", GL_LINE_STRIP, MarkingsFillColor, MarkingsColor);
		//LoadElements(id, "VerticalPointStructure", GL_LINE_STRIP, teal, silver);
		//LoadElements(id, "Water", GL_POLYGON, LightWater, DarkWater);
		if (HaveCustomMap(id, id->m_strAirportMap, &start, &count, &type))
		{
			for (i = start; i < count; i++){
				char CustomMapName[FILENAME_SZ] = { 0 };
				sprintf_s(CustomMapName, FILENAME_SZ, "CustomMap%d", start);
				LoadElements(id, CustomMapName, type, id->m_sCurLayout.m_glfCustomFillColor, id->m_sCurLayout.m_glfCustomOutlineColor);
			}
		}
	}
}

DrawHiResMap(struct InstanceData* id)
{
	int i = 0;
	int start = 0;
	int count = 0;
	int type = 0;
	static int ConstructionArea = 1;
	static int DeicingArea = 1;
	static int FinalApproachAndTakeOffArea = 1;
	static int FrequencyArea = 1;
	static int RunwayDisplacedArea = 1;
	static int RunwayIntersection = 1;
	static int RunwayShoulder = 1;
	static int ServiceRoad = 1;
	static int TouchDownLiftOffArea = 1;
	static int TaxiwayElement = 1;
	static int RunwayElement = 1;
	static int VerticalPolygonalStructure = 1;
	static int ApronElement = 1;
	static int ParkingStandArea = 1;
	static int Stopway = 1;
	static int TaxiwayShoulder = 1;
	static int RunwayMarking = 1;
	static int ArrestingGearLocation = 1;
	static int LandAndHoldShortOperationLocation = 1;
	static int PaintedCenterline = 1;
	static int StandGuidanceLine = 1;
	static int TaxiwayHoldingPosition = 1;
	static int VerticalLineStructure = 1;
	static int TaxiwayGuidanceLine = 1;
	static int RunwayExitLine = 1;






	// TODO: Pull Names from DB as configuration ?	
	TIME_TRACE_DBG("START - DrawHiResMap");

	if (strlen(id->m_strAirportMap) && strcmp(id->m_strAirportMap, "NONE")){
		// Order Show low-priority to high-priority
		// Polygons before Line structures

		// Updated Drawing Order, Request Order:
		//frequency area
		//parking
		//apron
		//buildings
		//roads
		//taxi shoulders
		//taxiways
		//runways
		//runway markings
		//deice
		//construction
		// Finally, Draw Polygons First, Lines Last
		if (FrequencyArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_FREQUENCY)) DrawElements(id, "FrequencyArea", GL_POLYGON, id->m_sCurLayout.m_glfFrequencyFillColor, id->m_sCurLayout.m_glfFrequencyOutlineColor);
		if (ParkingStandArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_AIRPORT_PARKING)) DrawElements(id, "ParkingStandArea", GL_POLYGON, id->m_sCurLayout.m_glfParkingFillColor, id->m_sCurLayout.m_glfParkingColor);
		if (ApronElement && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_AIRPORT_APRON)) DrawElements(id, "ApronElement", GL_POLYGON, id->m_sCurLayout.m_glfApronFillColor, id->m_sCurLayout.m_glfApronColor);
		if (VerticalPolygonalStructure && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_BUILDINGS)) DrawElements(id, "VerticalPolygonalStructure", GL_POLYGON, id->m_sCurLayout.m_glfBuildingFillColor, id->m_sCurLayout.m_glfBuildingColor);
		if (VerticalLineStructure && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_BUILDINGS)) DrawElements(id, "VerticalLineStructure", GL_LINE_STRIP, id->m_sCurLayout.m_glfBuildingFillColor, id->m_sCurLayout.m_glfBuildingColor);
		if (ServiceRoad && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_ROADS)) DrawElements(id, "ServiceRoad", GL_POLYGON, id->m_sCurLayout.m_glfRoadFillColor, id->m_sCurLayout.m_glfRoadOutlineColor);
		if (TaxiwayShoulder && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_SHOULDER)) DrawElements(id, "TaxiwayShoulder", GL_POLYGON, id->m_sCurLayout.m_glfShoulderFillColor, id->m_sCurLayout.m_glfShoulderColor);
		if (TaxiwayElement && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_TAXIWAY)) DrawElements(id, "TaxiwayElement", GL_POLYGON, id->m_sCurLayout.m_glfTaxiFillColor, id->m_sCurLayout.m_glfTaxiColor);
		if (Stopway && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_TAXIWAY)) DrawElements(id, "Stopway", GL_POLYGON, id->m_sCurLayout.m_glfTaxiFillColor, id->m_sCurLayout.m_glfTaxiColor);
		if (RunwayDisplacedArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_RUNWAY)) DrawElements(id, "RunwayDisplacedArea", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		if (RunwayIntersection && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_RUNWAY)) DrawElements(id, "RunwayIntersection", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		if (RunwayShoulder && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_RUNWAY)) DrawElements(id, "RunwayShoulder", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		if (RunwayElement && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_RUNWAY)) DrawElements(id, "RunwayElement", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		if (RunwayMarking && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_RUNWAY)) DrawElements(id, "RunwayMarking", GL_POLYGON, id->m_sCurLayout.m_glfRunwayFillColor, id->m_sCurLayout.m_glfRunwayColor);
		if (FinalApproachAndTakeOffArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "FinalApproachAndTakeOffArea", GL_POLYGON, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (TouchDownLiftOffArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "TouchDownLiftOffArea", GL_POLYGON, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (ArrestingGearLocation && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "ArrestingGearLocation", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (LandAndHoldShortOperationLocation && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "LandAndHoldShortOperationLocation", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (PaintedCenterline && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "PaintedCenterline", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (StandGuidanceLine && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "StandGuidanceLine", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (TaxiwayHoldingPosition && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "TaxiwayHoldingPosition", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (TaxiwayGuidanceLine && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "TaxiwayGuidanceLine", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (RunwayExitLine && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_MARKINGS)) DrawElements(id, "RunwayExitLine", GL_LINE_STRIP, id->m_sCurLayout.m_glfMarkingsFillColor, id->m_sCurLayout.m_glfMarkingsColor);
		if (DeicingArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_DEICING)) DrawElements(id, "DeicingArea", GL_POLYGON, id->m_sCurLayout.m_glfDeicingFillColor, id->m_sCurLayout.m_glfDeicingOutlineColor);
		if (ConstructionArea && (id->m_sCurLayout.m_nLayerEnableFlag & LEF_CONSTRUCTION)) DrawElements(id, "ConstructionArea", GL_POLYGON, id->m_sCurLayout.m_glfConstructionFillColor, id->m_sCurLayout.m_glfConstructionOutlineColor);

		// Unused, Mostly point shape files
		//DrawElements(id, "AerodromeReferencePoint", GL_LINE_STRIP, teal, silver);		
		//DrawElements(id, "HelipadThreshold", GL_LINE_STRIP, teal, silver);
		//DrawElements(id, "ParkingStandLocation", GL_LINE_STRIP, teal, silver);
		//DrawElements(id, "RunwayThreshold", GL_LINE_STRIP, teal, silver);
		//DrawElements(id, "TaxiwayIntersectionMarking", GL_LINE_STRIP, MarkingsFillColor, MarkingsColor);
		//DrawElements(id, "VerticalPointStructure", GL_LINE_STRIP, teal, silver);
		//DrawElements(id, "Water", GL_POLYGON, LightWater, DarkWater);

		if (HaveCustomMap(id, id->m_strAirportMap, &start, &count, &type) && id->m_sCurLayout.m_nLayerEnableFlag & LEF_CUSTOM)
		{
			for (i = start; i < count; i++){
				char CustomMapName[FILENAME_SZ] = { 0 };
				sprintf_s(CustomMapName, FILENAME_SZ, "CustomMap%d", start);
				DrawElements(id, CustomMapName, type, id->m_sCurLayout.m_glfCustomFillColor, id->m_sCurLayout.m_glfCustomOutlineColor);
			}
		}
	}
	TIME_TRACE_DBG("END - DrawHiResMap");
}


drawASDAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	int nowsecs;

	airp = GetASDAirP(id);

	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (0) airp <%x>.\n", GetCurrentThreadId(), airp));

	nowsecs = time(0);

	if (nowsecs - id->m_LastASDFillTags > FILL_ASD_TIME){
		// fill in orig/dest and other fields into airp
		id->m_LastASDFillTags = FillASDTags(id, airp);
	}

	//if(GUseADSB)
	//	AirVO = GetAirVO(1);
	aircount = N_TRACK_ID;
	drawASD(id);

	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails(id, airp, TRUE, id->m_tPlotTime, SAT_ASDI, ASD_TRACK_MODIFIER(id->m_sCurLayout.m_nAsdiTrailCount));
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, ASD_TRACK_MODIFIER(id->m_sCurLayout.m_nAsdiTrailCount), SAT_ASDI);
	}
	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_ASDI);
	}



	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorASDI, FALSE, TCI_ASDI);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)blue, TRUE, TCI_ASDI);
	}

	if (ShowHolds){
		drawHolds(id, airp, TRUE, id->m_tPlotTime, TRUE, ASD_TRACK_MODIFIER(id->m_sCurLayout.m_nAsdiTrailCount));
	}

}


VO *ProcessPlannedDeps(char *outbuf, struct InstanceData* id)
{
	int row;
	char *str, *eolstr;
	char linebuf[256];
	int len, matches, i;
	char flightid[256], origbuf[256], destinbuf[256], dfix[256], gate[256];
	char actype[256], runway[256];
	time_t outsecs, offsecs, nowsecs, stdsecs;

	VO *PlannedVO;  // get a new one every time so the thread can create a new one w/o affecting existing one
	int pflag = 0;
	const char* strError = "ASDEXDeps, Could not find Arpt";
	const DWORD cdwThreadId = GetCurrentThreadId();

	flightid[0] = '\0';
	origbuf[0] = '\0';
	destinbuf[0] = '\0';
	dfix[0] = '\0';
	gate[0] = '\0';
	actype[0] = '\0';
	runway[0] = '\0';

	PlannedVO = (VO *)vo_create(0, NULL);
	vo_set(PlannedVO, V_NAME, "PlannedDepsVO", NULL);
	VOPropAdd(PlannedVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "Origin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "Destin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "DFix", NTBSTRINGBIND, DEP_FIX_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "outsecs", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(PlannedVO, "stdsecs", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(PlannedVO, "gate", NTBSTRINGBIND, GATE_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "runway", NTBSTRINGBIND, RUNWAY_SIZE, VO_NO_ROW);

	vo_rm_rows(PlannedVO, 0, PlannedVO->count);

	vo_set(PlannedVO, V_ORDER_COLS, "FltNum", NULL, NULL);


	row = 0;
	str = outbuf;
	while (str){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > 250){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}

			if (!strncmp(linebuf, strError, strlen(strError))){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Departure data empty:%s\n", cdwThreadId, linebuf);
				break; // No actual data in file
			}

			str = eolstr;
			str++; /* skip over eol char */

			if (len > 3){  // skip over the EOD string
				matches = sscanf_s(linebuf, "%s\t%s\t%s\t%s\t%s\t%d\t%d\t%s\t%s\t%d", flightid, _countof(flightid),
					origbuf, _countof(origbuf), destinbuf, _countof(destinbuf), dfix, _countof(dfix), gate, _countof(gate),
					&outsecs, &offsecs, actype, _countof(actype), runway, _countof(runway), &stdsecs);

				// Skip over Header Info
				if (!strcasecmp(flightid, "FLIGHTID"))
					continue;

				if (matches > 3){
					D_CONTROL("PROCESS_DEPS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) LINEBUF:%s\n", cdwThreadId, linebuf));
					vo_alloc_rows(PlannedVO, 1);
					strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
					strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "Origin", char), ORIG_DES_SIZE, origbuf);
					strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "Destin", char), ORIG_DES_SIZE, destinbuf);
					if (strlen(dfix) >= DEP_FIX_SIZE || dfix[0] == '+')
						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "DFix", char), DEP_FIX_SIZE, &dfix[1]);
					else
						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "DFix", char), DEP_FIX_SIZE, dfix);

					if (IS_D_CONTROL("PROCESS_DEPS") && strlen(gate) && strcmp("null", gate))
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)DEP FltNum(%s), gate: %s\n", cdwThreadId, flightid, gate);

					strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "gate", char), GATE_SIZE, gate);

					if (IS_D_CONTROL("PROCESS_DEPS") && strlen(runway) && strcmp("null", runway))
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)DEP FltNum(%s), runway: %s\n", cdwThreadId, flightid, runway);

					strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "runway", char), RUNWAY_SIZE, runway);
					VV(PlannedVO, PlannedVO->count - 1, "outsecs", int) = outsecs;
					VV(PlannedVO, PlannedVO->count - 1, "stdsecs", int) = stdsecs;
				}
			}
		} else {
			str = NULL;
		}
	}

	vo_order(PlannedVO);
	nowsecs = time(0);
	for (i = 0; PlannedVO && i < PlannedVO->count; i++){
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) %d '%s' '%s' '%s' '%s' '%d' '%s' '%s' '%d'\n",
			cdwThreadId, i,
			VP(PlannedVO, i, "FltNum", char),
			VP(PlannedVO, i, "Origin", char),
			VP(PlannedVO, i, "Destin", char),
			VP(PlannedVO, i, "DFix", char),
			VV(PlannedVO, i, "outsecs", int),
			VP(PlannedVO, i, "gate", char),
			VP(PlannedVO, i, "runway", char),
			nowsecs));
	}

	return(PlannedVO);
}


VO *ProcessPlannedArrs(char *outbuf, struct InstanceData* id)
{
	int row;
	char *str, *eolstr;
	char linebuf[256];
	int len, matches, i;
	char flightid[256], origbuf[256], destinbuf[256], afix[256], gate[256];
	char actype[256], runway[256];
	time_t onsecs, insecs, etasecs, nowsecs, stasecs;

	VO *PlannedVO;  // get a new one every time so the thread can create a new one w/o affecting existing one
	int pflag = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	flightid[0] = '\0';
	origbuf[0] = '\0';
	destinbuf[0] = '\0';
	afix[0] = '\0';
	gate[0] = '\0';
	actype[0] = '\0';
	runway[0] = '\0';

	PlannedVO = (VO *)vo_create(0, NULL);
	vo_set(PlannedVO, V_NAME, "PlannedArrVO", NULL);
	VOPropAdd(PlannedVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "Origin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "Destin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "AFix", NTBSTRINGBIND, ARR_FIX_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "onsecs", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(PlannedVO, "etasecs", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(PlannedVO, "stasecs", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(PlannedVO, "gate", NTBSTRINGBIND, GATE_SIZE, VO_NO_ROW);
	VOPropAdd(PlannedVO, "runway", NTBSTRINGBIND, RUNWAY_SIZE, VO_NO_ROW);

	vo_rm_rows(PlannedVO, 0, PlannedVO->count);

	vo_set(PlannedVO, V_ORDER_COLS, "FltNum", NULL, NULL);


	row = 0;
	str = outbuf;
	while (str){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > 250){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}
			str = eolstr;
			str++; /* skip over eol char */

			if (len > 3){  // skip over the EOD string
				matches = sscanf_s(linebuf, "%s\t%s\t%s\t%s\t%s\t%d\t%d\t%s\t%s\t%d\t%d", flightid, _countof(flightid),
					origbuf, _countof(origbuf), destinbuf, _countof(destinbuf), afix, _countof(afix), gate, _countof(gate),
					&onsecs, &insecs, actype, _countof(actype), runway, _countof(runway), &etasecs, &stasecs);

				// Skip over Header Info
				if (!strcasecmp(flightid, "FLIGHTID"))
					continue;

				if (matches > 3){
					if (insecs <= 0){
						// not "In" yet, so use arrival info
						vo_alloc_rows(PlannedVO, 1);
						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "Origin", char), ORIG_DES_SIZE, origbuf);
						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "Destin", char), ORIG_DES_SIZE, destinbuf);
						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "AFix", char), ARR_FIX_SIZE, afix);

						if (IS_D_CONTROL("PROCESS_ARRS") && strlen(gate) && strcmp("null", gate))
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)ARR FltNum(%s), gate: %s\n", cdwThreadId, flightid, gate);

						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "gate", char), GATE_SIZE, gate);

						if (IS_D_CONTROL("PROCESS_ARRS") && strlen(runway) && strcmp("null", runway))
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X)ARR FltNum(%s), runway: %s\n", cdwThreadId, flightid, runway);

						strcpy_s(VP(PlannedVO, PlannedVO->count - 1, "runway", char), RUNWAY_SIZE, runway);
						VV(PlannedVO, PlannedVO->count - 1, "onsecs", int) = onsecs;
						VV(PlannedVO, PlannedVO->count - 1, "etasecs", int) = etasecs;
						VV(PlannedVO, PlannedVO->count - 1, "stasecs", int) = stasecs;
					} else {
						// do not send data about aircraft that already are "in", use departure information
					}
				}
			}
		} else {
			str = NULL;
		}
	}

	vo_order(PlannedVO);
	nowsecs = time(0);
	for (i = 0; PlannedVO && i < PlannedVO->count; i++){
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) %d '%s' '%s' '%s' '%s' '%d' '%s' '%s' '%d'\n",
			cdwThreadId, i,
			VP(PlannedVO, i, "FltNum", char),
			VP(PlannedVO, i, "Origin", char),
			VP(PlannedVO, i, "Destin", char),
			VP(PlannedVO, i, "DFix", char),
			VV(PlannedVO, i, "onsecs", int),
			VP(PlannedVO, i, "gate", char),
			VP(PlannedVO, i, "runway", char),
			nowsecs));
	}

	return(PlannedVO);
}



VO *ProcessETAs(char *outbuf)
{
	int row;
	char *str, *eolstr;
	char linebuf[256];
	int len, matches, intsecs;
	char flightid[256], timebuf[256];
	time_t etasecs;
	VO *ETAVO;  // get a new one every time so the thread can create a new one w/o affecting existing one


	ETAVO = (VO *)vo_create(0, NULL);
	vo_set(ETAVO, V_NAME, "ETAVO", NULL);
	VOPropAdd(ETAVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(ETAVO, "eta", INTBIND, -1, VO_NO_ROW);  // in unix time


	vo_rm_rows(ETAVO, 0, ETAVO->count);

	vo_set(ETAVO, V_ORDER_COLS, "FltNum", NULL, NULL);


	row = 0;
	str = outbuf;
	while (str){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > 40){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}
			str = eolstr;
			str++; /* skip over eol char */

			if (len > 3){  // skip over the EOD string
				matches = sscanf_s(linebuf, "%s %s %d", flightid, _countof(flightid), timebuf, _countof(timebuf), &intsecs);
				etasecs = intsecs; // needs to be on separate line on Vista- Vista bug?
				if (matches == 3){
					vo_alloc_rows(ETAVO, 1);
					strcpy_s(VP(ETAVO, ETAVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
					VV(ETAVO, ETAVO->count - 1, "eta", int) = (int)etasecs;
				}
			}
		} else {
			str = NULL;
		}
	}

	return(ETAVO);
}

VO *ProcessTDs(struct InstanceData* id, char *outbuf)
{
	int row;
	char *str, *eolstr;
	char linebuf[256];
	int len, matches;
	char flightid[FLTNUM_SIZE];
	char tailnum[N_TAIL_SIZE];
	char origin[ORIG_DES_SIZE];
	char dest[ORIG_DES_SIZE];
	char ata[6];
	char sta[6];
	char out[6];
	char std[6];
	int delay;
	char arrdep[2] = { 0 };
	const char* err1 = "TD, Could not find Arpt";
	const char* err2 = "TD, No Tarmac for Arpt";
	VO *TDVO;  // get a new one every time so the thread can create a new one w/o affecting existing one
	const DWORD cdwThreadId = GetCurrentThreadId();

	TDVO = (VO *)vo_create(0, NULL);
	vo_set(TDVO, V_NAME, "TDVO", NULL);
	VOPropAdd(TDVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(TDVO, "TailNum", NTBSTRINGBIND, N_TAIL_SIZE, VO_NO_ROW);
	VOPropAdd(TDVO, "Orig", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(TDVO, "Dest", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
	VOPropAdd(TDVO, "arrdep", NTBSTRINGBIND, 2, VO_NO_ROW);
	VOPropAdd(TDVO, "ATA", NTBSTRINGBIND, 6, VO_NO_ROW);
	VOPropAdd(TDVO, "STA", NTBSTRINGBIND, 6, VO_NO_ROW);
	VOPropAdd(TDVO, "OUT", NTBSTRINGBIND, 6, VO_NO_ROW);
	VOPropAdd(TDVO, "STD", NTBSTRINGBIND, 6, VO_NO_ROW);
	VOPropAdd(TDVO, "Delay", INTBIND, -1, VO_NO_ROW);


	vo_rm_rows(TDVO, 0, TDVO->count);

	vo_set(TDVO, V_ORDER_COLS, "FltNum", NULL, NULL);


	row = 0;
	str = outbuf;
	while (str){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > 50){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}
			if (!strncmp(linebuf, err1, strlen(err1)) || // Make sure we are not just getting error data back
				!strncmp(linebuf, err2, strlen(err2))){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get TarmacDelay data from %s <reason:%s>, switching srvrs to %s and trying again.\n",
					cdwThreadId, linebuf, GetPulseSrvr(id), GetNxtPulseSrvr(id));
				return (TDVO);
			}
			str = eolstr;
			str++; /* skip over eol char */

			if (!strncmp(linebuf, "FLIGHTID", 8))
			{
				if ('A' == arrdep[0])
					arrdep[0] = 'D';
				else
					arrdep[0] = 'A';
				continue;
			}

			if (len > 3){  // skip over the EOD string
				if ('A' == arrdep[0])
				{
					//Process Arrivals first
					//FLIGHTID TAIL ORIGIN DEST ATA STA DELAY
					matches = sscanf_s(linebuf, "%s %s %s %s %s %s %d", flightid, FLTNUM_SIZE,
						tailnum, N_TAIL_SIZE, origin, ORIG_DES_SIZE, dest, ORIG_DES_SIZE,
						ata, 6, sta, 6, &delay);

					if (matches == 7){
						D_CONTROL("TARMAC_DELAY", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ARRIVAL='%s'\n", cdwThreadId, linebuf));
						vo_alloc_rows(TDVO, 1);
						strcpy_s(VP(TDVO, TDVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
						strcpy_s(VP(TDVO, TDVO->count - 1, "TailNum", char), N_TAIL_SIZE, tailnum);
						strcpy_s(VP(TDVO, TDVO->count - 1, "Orig", char), ORIG_DES_SIZE, origin);
						strcpy_s(VP(TDVO, TDVO->count - 1, "Dest", char), ORIG_DES_SIZE, dest);
						strcpy_s(VP(TDVO, TDVO->count - 1, "arrdep", char), 2, arrdep);
						strcpy_s(VP(TDVO, TDVO->count - 1, "ATA", char), 6, ata);
						strcpy_s(VP(TDVO, TDVO->count - 1, "STA", char), 6, sta);
						VV(TDVO, TDVO->count - 1, "Delay", int) = (int)delay * 60; // Delay is in minutes, convert to seconds
					}
				}else{
					//Process Departures second
					//FLIGHTID TAIL ORIGIN DEST OUT STD DELAY
					matches = sscanf_s(linebuf, "%s %s %s %s %s %s %d", flightid, FLTNUM_SIZE,
						tailnum, N_TAIL_SIZE, origin, ORIG_DES_SIZE, dest, ORIG_DES_SIZE,
						out, 6, std, 6, &delay);

					if (matches == 7){
						D_CONTROL("TARMAC_DELAY", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DEPARTURE='%s'\n\n", cdwThreadId, linebuf));
						vo_alloc_rows(TDVO, 1);
						strcpy_s(VP(TDVO, TDVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
						strcpy_s(VP(TDVO, TDVO->count - 1, "TailNum", char), N_TAIL_SIZE, tailnum);
						strcpy_s(VP(TDVO, TDVO->count - 1, "Orig", char), ORIG_DES_SIZE, origin);
						strcpy_s(VP(TDVO, TDVO->count - 1, "Dest", char), ORIG_DES_SIZE, dest);
						strcpy_s(VP(TDVO, TDVO->count - 1, "arrdep", char), 2, arrdep);
						strcpy_s(VP(TDVO, TDVO->count - 1, "OUT", char), 6, out);
						strcpy_s(VP(TDVO, TDVO->count - 1, "STD", char), 6, std);
						VV(TDVO, TDVO->count - 1, "Delay", int) = (int)delay * 60; // Delay is in minutes, convert to seconds
					}
				}
			}
		} else {
			str = NULL;
		}
	}

	// Sort VO
	vo_order(TDVO);

	D_CONTROL("TARMAC_DELAY_VO", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) TarmacDelayVO='%s'\n\n", cdwThreadId, vo_printstr(TDVO)));

	return(TDVO);
}

AIR* AirpFromGateFlights(struct InstanceData* id, const char* flightid)
{
	AIR **gate_airp = NULL;
	AIR *air = NULL;
	int i = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	gate_airp = GetGateAirP(id);

	// Find Aircraft in GATE Air
	for (i = 0; i < N_TRACK_ID; i++){
		if (!(air = gate_airp[i])){
			continue;
		}
		if (!strcmp(air->FltNum, flightid)){
			gate_airp[i] = NULL;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found Gate Airp for Asdex Track, FLTNUM<%s>.\n",
				cdwThreadId, flightid);
			break;
		}
		air = NULL;
	}
	return air;
}




void ProcessDMX(struct InstanceData* id, char *outbuf)
{
	char *str, *eolstr;
	char linebuf[256];
	int len, matches;
	char flightid[FLTNUM_SIZE];
	char orig_dest[ORIG_DES_SIZE];
	char asdi_dest[ORIG_DES_SIZE], origin[ORIG_DES_SIZE];
	int arrdep = -1;
	VO *DMXVO, *PrevVO;

	const DWORD cdwThreadId = GetCurrentThreadId();

	str = outbuf;
	if (strcasecmp(str, "DivertedAircraft")){
		DMXVO = (VO *)vo_create(0, NULL);
		vo_set(DMXVO, V_NAME, "DivertedVO", NULL);
		VOPropAdd(DMXVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
		VOPropAdd(DMXVO, "orig_dest", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
		VOPropAdd(DMXVO, "asdi_dest", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
		VOPropAdd(DMXVO, "origin", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
		vo_rm_rows(DMXVO, 0, DMXVO->count);
		vo_set(DMXVO, V_ORDER_COLS, "FltNum", "origin", NULL, NULL);

		while (str){
			if ((eolstr = strchr(str, '\n'))){
				len = eolstr - str;
				if (len >= 256){
					break;  // some problem with the data
				}
				strncpy_s(linebuf, _countof(linebuf), str, len);

				if (!strcasecmp(linebuf, "EOD")){
					break; // EOD
				}

				str = eolstr;
				str++; /* skip over eol char */

				matches = sscanf_s(linebuf, "%s\t%s\t%s\t%s", flightid, FLTNUM_SIZE,
					asdi_dest, ORIG_DES_SIZE, orig_dest, ORIG_DES_SIZE, origin, ORIG_DES_SIZE);

				if (matches == 4){
					D_CONTROL("DM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHTID '%s', ORIGIBAL_DEST '%s', DIVERTED_DEST '%s'\n", cdwThreadId,
						flightid, orig_dest, asdi_dest));

					vo_alloc_rows(DMXVO, 1);
					strcpy_s(VP(DMXVO, DMXVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
					strcpy_s(VP(DMXVO, DMXVO->count - 1, "orig_dest", char), ORIG_DES_SIZE, orig_dest);
					strcpy_s(VP(DMXVO, DMXVO->count - 1, "asdi_dest", char), ORIG_DES_SIZE, asdi_dest);
					strcpy_s(VP(DMXVO, DMXVO->count - 1, "origin", char), ORIG_DES_SIZE, origin);
				}
			} else {
				break;
			}
		}
		vo_order(DMXVO);

		EnterCriticalSection(&id->m_csEta);
		PrevVO = (VO*)id->m_pDMXVO;
		id->m_pDMXVO = DMXVO;
		LeaveCriticalSection(&id->m_csEta);

		// Release Old VO
		if (PrevVO){
			vo_rm_rows(PrevVO, 0, PrevVO->count);
			vo_free(PrevVO);
		}
	}
}

void ProcessGateFlights(struct InstanceData* id, AIR** airp, int feed)
{
	int i = 0, j = 0, k = 0;
	char *arpt, *flightid, *gate, *term;
	float lat, lng, ang;
	static VO* PrevInVO = NULL;
	static VO* PrevOutVO = NULL;
	VO *InVO;
	VO *OutVO;
	AIR **gate_airp;
	AIR *air, *air2;
	time_t cur;
	char cur_arpt[6] = { 'K' };

	const DWORD cdwThreadId = GetCurrentThreadId();
	gate_airp = GetGateAirP(id);

	strncpy_s(&cur_arpt[1], 5, id->m_strAsdexArpt, 3);
	StrUpper(cur_arpt);

	EnterCriticalSection(&id->m_csEta);
	InVO = (VO*)id->m_pGateInVO;
	OutVO = (VO*)id->m_pGateOutVO;

	// Process Gate In Messages
	if (InVO && PrevInVO != InVO)
	{
		for (i = 0; i < InVO->count; i++)
		{
			int bFound = FALSE;
			arpt = VP(InVO, i, "Arpt", char);
			flightid = VP(InVO, i, "FltNum", char);
			gate = VP(InVO, i, "Gate", char);
			term = VP(InVO, i, "Term", char);
			cur = VV(InVO, i, "Time", int);

			// Find Aircraft in feed Air
			for (j = 0; j < N_TRACK_ID && !bFound; j++){
				if (!(air = airp[j])){
					continue;
				}

				if (!strcmp(air->FltNum, flightid)){
					bFound = TRUE;
					// Found Flight ID in feed
					D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
						cdwThreadId, arpt, flightid, term, gate, cur));

					// If Gate is "NULL" we can't move aircraft to gate because we don't know where it belongs
					if (strcmp(gate, "null")){
						// Move feed Air* to Gate Air*, mark as In
						if (NULL == gate_airp[j]){
							gate_airp[j] = air;
							k = j;
						}else{
							// Find next open spot
							// Start with k = 1 (anytime we need to put in a new air struct)
							// because the selected index value of no selection is 0 and will not
							// draw large tag for aircraft at index 0;
							k = 1;
							while (k < N_TRACK_ID){
								if (NULL != gate_airp[k]){
									k++;
								}else{
									gate_airp[k] = air;
									break;
								}
							}
						}
						airp[j] = NULL;

						// Add required Gate Information
						strcpy_s(air->gate, GATE_SIZE, gate);
						if (GetAirportGateData(id, arpt, term, gate, flightid, &lat, &lng, &ang))
						{
							air->CurX = air->X = lng;
							air->CurY = air->Y = lat;
							air->PrevAngle = ang;
							air->utc = cur;
							air->utc_gatein = cur;
							air->trackid = k;
							strcpy_s(air->Destin, ORIG_DES_SIZE, cur_arpt);
							AddTrail(id, air, k, NULL, FALSE, MAX(MIN(GATE_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), GATE_TRACK_MODIFIER(MAX_GATE_TRACK_POINTS)), 3));
							D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Moved from %s[%d] to GATE airp[%d]: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
								cdwThreadId, g_arFeedTypes[feed], j, k, arpt, flightid, term, gate, cur));
						}else{
							// Remove Air* so aircraft is not drawn
							RemoveTrack(id, gate_airp, k, feed, FALSE);
							D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropped Gate airp[%d], gate info not found: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
								cdwThreadId, k, arpt, flightid, term, gate, cur));
						}

					}else{
						// Remove Air* so LKP is not drawn
						RemoveTrack(id, airp, j, feed, FALSE);
						D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropped %s airp[%d], no gate data provided: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
							cdwThreadId, g_arFeedTypes[feed], j, arpt, flightid, term, gate, cur));
					}
				}
			}
			if (!bFound){
				// Not in feed, still need to show parked aircraft (Possibly just started WT)
				if (GetAirportGateData(id, arpt, term, gate, flightid, &lat, &lng, &ang))
				{
					// Look to see if we already have it
					for (j = 0; j < N_TRACK_ID && !bFound; j++){
						if (!(air = gate_airp[j])){
							continue;
						}

						if (!strcmp(air->FltNum, flightid)){
							bFound = TRUE;
							air->CurX = air->X = lng;
							air->CurY = air->Y = lat;
							air->PrevAngle = ang;
							air->utc = cur;
							air->utc_gatein = cur;
							strcpy_s(air->Destin, ORIG_DES_SIZE, cur_arpt);
							strcpy_s(air->gate, GATE_SIZE, gate);
							AddTrail(id, air, j, NULL, FALSE, MAX(MIN(GATE_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), GATE_TRACK_MODIFIER(MAX_GATE_TRACK_POINTS)), 3));
							D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Used/Updated existing GATE airp[%d]: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
								cdwThreadId, j, arpt, flightid, term, gate, cur));

						}
					}

					// Last resort, create a new one
					if (!bFound){
						// Find next open spot
						k = 1;
						while (k < N_TRACK_ID){
							if (NULL != gate_airp[k]){
								k++;
							}else{
								break;
							}
						}
						air = GetAir(gate_airp, k); // creates the new struct for tracking
						strcpy_s(air->FltNum, FLTNUM_SIZE, flightid);
						air->CurX = air->X = lng;
						air->CurY = air->Y = lat;
						air->PrevAngle = ang;
						air->utc = cur;
						air->utc_gatein = cur;
						air->trackid = k;
						strcpy_s(air->Destin, ORIG_DES_SIZE, cur_arpt);
						strcpy_s(air->gate, GATE_SIZE, gate);
						AddTrail(id, air, k, NULL, FALSE, MAX(MIN(GATE_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), GATE_TRACK_MODIFIER(MAX_GATE_TRACK_POINTS)), 3));
						D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Created new GATE airp[%d]: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
							cdwThreadId, k, arpt, flightid, term, gate, cur));
					}
				}
			}
		}

		PrevInVO = InVO;
	}

	// Process Gate Out Messages
	if (OutVO && PrevOutVO != OutVO)
	{
		for (i = 0; i < OutVO->count; i++)
		{
			flightid = VP(OutVO, i, "FltNum", char);
			gate = VP(OutVO, i, "Gate", char);

			// If gate is null, this data is useless, ignore it.
			if (!strcmp(gate, "null")){
				vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Out Gate Message for FLTNUM<%s> is missing gate data, ignoring.\n",
					cdwThreadId, flightid);
				continue;
			}

			arpt = VP(OutVO, i, "Arpt", char);
			term = VP(OutVO, i, "Term", char);
			cur = VV(OutVO, i, "Time", int);

			// Find Aircraft in GATE Air
			for (j = 0; j < N_TRACK_ID; j++){
				if (!(air = gate_airp[j])){
					continue;
				}
				if (!strcmp(air->FltNum, flightid) /*&& !strcmp(air->Destin, cur_arpt)*/){
					break;
				}
				air = NULL;
			}

			// Find Aircraft in feed Air
			for (k = 0; k < N_TRACK_ID; k++){
				if (!(air2 = airp[k])){
					continue;
				}

				if (!strcmp(air2->FltNum, flightid)){
					// Found Flight ID in ASDEX
					D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found flight in %s tracks, ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
						cdwThreadId, g_arFeedTypes[feed], arpt, flightid, term, gate, cur));
					break;
				}
				air2 = NULL;
			}

			// If we are already receiving feed tracks, just make sure ORIG info is filled
			// We do not want to show the aircraft at the gate either
			if (air2){
				D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s found for : ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
					cdwThreadId, g_arFeedTypes[feed], arpt, flightid, term, gate, cur));
				if (!strlen(air2->Origin))
					strcpy_s(air2->Origin, ORIG_DES_SIZE, arpt);
				if (!strlen(air2->gate))
					strcpy_s(air2->gate, GATE_SIZE, gate);

				// If we have a gate airstruct remove it, no longer needed
				if (air){
					RemoveTrack(id, gate_airp, j, GATE, FALSE);
					D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Deleting GATE air, %s is tracking : ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
						cdwThreadId, g_arFeedTypes[feed], arpt, flightid, term, gate, cur));
				}
			}else if( !air ){
				// We don't have any airstructs so create one at the gate in first available position
				k = 1;
				while (k < N_TRACK_ID){
					if (NULL != gate_airp[k]){
						k++;
					}else{
						gate_airp[k] = air;
						break;
					}
				}
				if (GetAirportGateData(id, arpt, term, gate, flightid, &lat, &lng, &ang))
				{
					air = GetAir(gate_airp, k); // creates the new struct for tracking
					strcpy_s(air->FltNum, FLTNUM_SIZE, flightid);
					strcpy_s(air->gate, GATE_SIZE, gate);
					strcpy_s(air->Origin, ORIG_DES_SIZE, arpt);
					air->CurX = air->X = lng;
					air->CurY = air->Y = lat;
					air->PrevAngle = ang + 180.0f;
					air->utc = cur;
					air->utc_gateout = cur;
					air->trackid = k;
					AddTrail(id, air, k, NULL, FALSE, MAX(MIN(GATE_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), GATE_TRACK_MODIFIER(MAX_GATE_TRACK_POINTS)), 3));
					D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Adding Gate OUT Aircraft: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
						cdwThreadId, arpt, flightid, term, gate, cur));
				}else{
					// Remove Air* so aircraft is not drawn at all
					RemoveTrack(id, gate_airp, k, GATE, FALSE);
					D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropping Gate OUT Aircraft, gate not found: ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>.\n",
						cdwThreadId, arpt, flightid, term, gate, cur));
				}
			}
			// Do nothing if we have an air from gate_airp and not one from airp
			// this means we have already put the aircraft at the gate and are not yet
			// recieving asdex tracks
		}
		PrevOutVO = OutVO;
	}

	// Update Gate Airp with new TrackPoint
	for (i = 0; i < N_TRACK_ID; i++ ){
		if ( !(air = gate_airp[i]) ){
			// no tracks yet
			continue;
		}
		if (air->utc_gatein && ((air->utc - air->utc_gatein) > GATE_IN_TRACK_TIMEOUT)){
			D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropping Gate IN Aircraft; Gate Message Elapsed: FLTNUM<%s>, MESSAGE TIME<%d>, UTC TIME<%d>.\n",
				cdwThreadId, air->FltNum, air->utc_gatein, air->utc));
			RemoveTrack(id, gate_airp, i, GATE, FALSE);
			continue;
		}
		else if (air->utc_gateout && ((air->utc - air->utc_gateout) > GATE_OUT_TRACK_TIMEOUT)){
			D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropping Gate OUT Aircraft; Gate Message Elapsed: FLTNUM<%s>, MESSAGE TIME<%d>, UTC TIME<%d>.\n",
				cdwThreadId, air->FltNum, air->utc_gateout, air->utc));
			RemoveTrack(id, gate_airp, i, GATE, FALSE);
			continue;
		}
		air->utc = id->m_tPlotTime;
		air->TrackPtr[air->tcount - 1].utc = id->m_tPlotTime;		
	}
 
	LeaveCriticalSection(&id->m_csEta);
}







void GetDivertedDestination(struct InstanceData* id, char* flightid, char* dest){

	struct row_index *row_index;
	VO *DMVO = NULL;
	EnterCriticalSection(&id->m_csEta);
	DMVO = (VO*)id->m_pDMVO;
	if (DMVO && (row_index = vo_search(DMVO, "FltNum", flightid, NULL))){
		strcpy_s(dest, ORIG_DES_SIZE, VP(DMVO, row_index->rownum, "orig_dest", char));
		D_CONTROL("DM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Assigning diverted destination <%s> to flight <%s>\n",
			GetCurrentThreadId(), dest, flightid));
	}
	LeaveCriticalSection(&id->m_csEta);
}



void ProcessDMData(struct InstanceData* id, char *outbuf)
{
	char *str, *eolstr;
	char linebuf[256];
	int len, matches;
	char flightid[FLTNUM_SIZE];
	char orig_dest[ORIG_DES_SIZE];
	char asdi_dest[ORIG_DES_SIZE];
	int arrdep = -1;
	VO *DMVO, *PrevVO;

	const DWORD cdwThreadId = GetCurrentThreadId();

	str = outbuf;
	if (strcasecmp(str, "DivertedAircraft")){
		DMVO = (VO *)vo_create(0, NULL);
		vo_set(DMVO, V_NAME, "DivertedVO", NULL);
		VOPropAdd(DMVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
		VOPropAdd(DMVO, "orig_dest", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
		VOPropAdd(DMVO, "asdi_dest", NTBSTRINGBIND, ORIG_DES_SIZE, VO_NO_ROW);
		vo_rm_rows(DMVO, 0, DMVO->count);
		vo_set(DMVO, V_ORDER_COLS, "FltNum", NULL, NULL);

		while (str){
			if ((eolstr = strchr(str, '\n'))){
				len = eolstr - str;
				if (len > 30){
					break;  // some problem with the data
				}
				strncpy_s(linebuf, _countof(linebuf), str, len);

				if (!strcasecmp(linebuf, "EOD")){
					break; // EOD
				}

				str = eolstr;
				str++; /* skip over eol char */

				matches = sscanf_s(linebuf, "%s\t%s\t%s", flightid, FLTNUM_SIZE,
					orig_dest, ORIG_DES_SIZE, asdi_dest, ORIG_DES_SIZE);

				if (matches == 3){
					D_CONTROL("DM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FLIGHTID '%s', ORIGIBAL_DEST '%s', DIVERTED_DEST '%s'\n", cdwThreadId,
						flightid, orig_dest, asdi_dest));

					vo_alloc_rows(DMVO, 1);
					strcpy_s(VP(DMVO, DMVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
					strcpy_s(VP(DMVO, DMVO->count - 1, "orig_dest", char), ORIG_DES_SIZE, orig_dest);
					strcpy_s(VP(DMVO, DMVO->count - 1, "asdi_dest", char), ORIG_DES_SIZE, asdi_dest);
				}
			}
		}
		vo_order(DMVO);

		EnterCriticalSection(&id->m_csEta);
		PrevVO = (VO*)id->m_pDMVO;
		id->m_pDMVO = DMVO;
		LeaveCriticalSection(&id->m_csEta);

		// Release Old VO
		if (PrevVO){
			vo_rm_rows(PrevVO, 0, PrevVO->count);
			vo_free(PrevVO);
		}
	}
}



char *GetNxtField(char *recstr, char *tmpstr, int tmpsize, char delim, char **curstr)
{
	char *endstr;
	int len;

	if (!(endstr = strchr(recstr, delim))){
		return("");
	}
	len = endstr - recstr;

	if (len < tmpsize){
		strncpy_s(tmpstr, tmpsize, recstr, len);
		tmpstr[len] = '\0';
	}
	else {
		/* TRUNCATE */
		strncpy_s(tmpstr, tmpsize, recstr, _TRUNCATE);
	}

	recstr = endstr + 1;

	*curstr = recstr;
	return(tmpstr);
}


void FillFDOGateStatus(char *arpt, char *gate, VO *LFDO, char *gate_status, char *fdo_gatefieldname)
{
	int i;
	char *destin, *arr_gate;

	// find row in LFDO matching this arpt and gate

	for (i = 0; LFDO && i < LFDO->count; i++){
		destin = VP(LFDO, i, "Destin", char);  
		if (strcmp(destin, arpt)){
			// does not match, skip	
			continue;	
		}
		// arr_gate = VP(LFDO, i, "int_arr_gate", char);
		arr_gate = VP(LFDO, i, fdo_gatefieldname, char);
		STrimRight(arr_gate);
		if (strcmp(arr_gate, gate)){
			// does not match, skip	
			continue;
		} 
		// matches
		strncpy_s(VP(LFDO, i, "Assigned Gate Status", char), 32, gate_status, _TRUNCATE);
	}

}

void ProcessGateStatus(struct InstanceData* id, char *outbuf, VO *LFDO, char *fdo_gatefieldname)
{
	int row;
	char *str, *eolstr, *curstr;
	char linebuf[8192];
	char tmpbuf[8192];
	int len, loopcount;
	static char prev_arpt[ORIG_DES_SIZE] = { 0 };
	int arrdep = -1;
	int i = 0;
	char flightid[FLTNUM_SIZE], arpt[ORIG_DES_SIZE];
	char gate[GATE_SIZE], tail[N_TAIL_SIZE], gate_status[32];
	static int testflag = 0;
	static int debugstop = 1;
	time_t rowtime, intime, outtime;


	//
	// load data from, servers info global FDO  GFDO
	//

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "ProcessFDOData starting\n");

	const DWORD cdwThreadId = GetCurrentThreadId();

	row = 0;
	str = outbuf;
	//  rows from web service printf("arpt\tgate\tstatus\trowtime\tflightid\ttail\tintime\touttime\t\n");

	loopcount = 0;
	while (str && strlen(str) > 20 && loopcount++ < 50000){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > _countof(linebuf)){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}

			str = eolstr;
			str++; /* skip over eol char */

			if (strstr(linebuf, "arpt")){
				// skip header row linebuf = 0x136fef2c "arpt\tgate\tstatus\trowtime\tflightid\ttail\tintime\touttime\t\n"
				continue;
			}

			arpt[0] = gate[0] = gate_status[0] = flightid[0] = tail[0] = '\0';

			curstr = linebuf;
			strcpy_s(arpt, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(gate_status, 32, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			rowtime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			intime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			outtime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			FillFDOGateStatus(arpt, gate, LFDO, gate_status, fdo_gatefieldname);  // fill all rows that match this arpt and gate with this status

		}
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "entering critial section\n");

}

void GetGateStatus(struct InstanceData* id, VO *LFDO, char *fdo_gatefieldname)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char  urltime[VO_NAME_SIZE];
	static int firsttime = 1;
	time_t secs;
	int pflag = 0;
	struct timeb start_time, done_time;
	int len = 0, trycount = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();
	char *pwd, *usrname, *servername;
	extern int GetCurlFormGetResults_timeout(struct InstanceData* id, struct MemoryStruct *chunk, char *url, char *postfields, enum SecureMode eMode, int logflag, long curltimeout);

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	usrname = id->m_strUserName;

	pwd = "XXYY22"; // hardwired password since WT does not get passed pwd from javascript. Server will use this password to override for all users with permissions

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=FDOGateStatus&username=%s&pwd=%s", usrname, pwd);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);

	if (timeflag){ ftime(&start_time); }

	servername = GetPulseSrvr(id);
	servername = "https://www54.passur.com/fcgi/PulseTrack.fcg";  // for testing

	// get next server in list so we load balance amoung all servers
	// servername = GetNxtOrlandoPulseSrvr(id);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, servername, tmpstr);

	do {
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */

		if (!GetCurlFormGetResults_timeout(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE, 45L)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FDO data from %s%s, switching srvrs to %s and trying again.\n",
				cdwThreadId, servername, tmpstr, servername);
			// try again
		}
		else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, found %d bytes\n",
				chunk.size);
			break;
		}
	} while (trycount++ < 3);

	if (trycount >= 3){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FDO data from %s%s, giving up for now and returning\n",
			cdwThreadId, servername, tmpstr);
		return;
	}


	if (timeflag) {
		ftime(&done_time);
	}
	sprintf_s(tmpstr, TMPBUF_SIZE, "%g", uts_timediff(&start_time, &done_time));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, calling ProcessFDOData with %d bytes of data, time=%s\n", chunk.size, tmpstr);

	if (chunk.memory && chunk.size > 500){
		D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FDO DATA:'\n%s\n", cdwThreadId, chunk.memory));

		ProcessGateStatus(id, chunk.memory, LFDO, fdo_gatefieldname);

		free(chunk.memory);
	}
	else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No FDO data returned from server\n", cdwThreadId);
	}
}



void ProcessBasicFDOData(struct InstanceData* id, char *outbuf)
{
	int row;
	char *str, *eolstr, *testflight, *curstr;
	char linebuf[8192];
	char tmpbuf[8192];
	int len, loopcount;
	static char prev_arpt[ORIG_DES_SIZE] = { 0 };
	int arrdep = -1;
	int i = 0;
	VO *LFDO, *PrevInVO;
	char FltNum[FLTNUM_SIZE], Origin[ORIG_DES_SIZE], Destin[ORIG_DES_SIZE], actype[ACTYPE_SIZE], u_actype[ACTYPE_SIZE],
		arr_runway[RUNWAY_SIZE], arr_gate[GATE_SIZE], dep_gate[GATE_SIZE];
	char fltroute[GG_FLT_ROUTE_SIZE];
	char gate[GATE_SIZE], arr_rwy[7], tracon_rwy[7], acs[25], fps[25], edc_status[7], old_fid[9], sfzflag[25], rfzflag[25], tbfm_actype[13];
	time_t eta, ata, atd, std, etd, sta,
		tbfm_offtime, tbfm_ontime, tbfm_freezetime,
		
		first_msg_secs, rwy_freeze_secs, edc_time_secs, tbfm_etd_secs, sta_at_rwy_secs, eta_at_rwy_secs;
	static int testflag = 0;
	static int debugstop = 1;

	//
	// load data from, servers info global FDO  GFDO
	//

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "ProcessFDOData starting\n");

	const DWORD cdwThreadId = GetCurrentThreadId();

	row = 0;
	str = outbuf;

	LFDO = CrFDOVO();

	vo_rm_rows(LFDO, 0, LFDO->count);
	loopcount = 0;
	while (str && strlen(str) > 20 && loopcount++ < 50000){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > _countof(linebuf)){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}

			str = eolstr;
			str++; /* skip over eol char */

			if (strstr(linebuf, "flightid")){
				// skip header row linebuf = 0x136fef2c "flightid\torigin\tdestination\tactype\teta\tata\tstd\tetd\tatd\tsta\tarr_runway\tfltroute\t"
				continue;
			}

			FltNum[0] = Origin[0] = Destin[0] = actype[0] = fltroute[0] = arr_runway[0] = gate[0] = u_actype[0] =
				arr_gate[0] = dep_gate[0] = '\0';

			curstr = linebuf;
			strcpy_s(FltNum, FLTNUM_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			if (!strncmp(FltNum, "UAL", 3)){
				// test
				u_actype[0] = '\0';
			}

			strcpy_s(Origin, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(Destin, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(actype, ACTYPE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			eta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			ata = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			std = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			etd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			atd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			sta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(arr_runway, RUNWAY_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//outsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//offsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//onsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//insecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			//strcpy_s(arr_gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//strcpy_s(dep_gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			//u_sta_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//u_std_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//strcpy_s(u_actype, ACTYPE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			//cargo_door_clsd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//cargo_door_open = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//pax_door_clsd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//pax_door_open = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//bridge_on_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//crew_out_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//bridge_on_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			//brake_released = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			//brake_set = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			//acars_init = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(fltroute, GG_FLT_ROUTE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			tbfm_offtime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_ontime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_freezetime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
	
			// additional tbfm fields 
			first_msg_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(old_fid, 9, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(fps, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(acs, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(sfzflag, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(rfzflag, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			rwy_freeze_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(tbfm_actype, 13, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(tracon_rwy, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(arr_rwy, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(edc_status, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			edc_time_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_etd_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			sta_at_rwy_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			eta_at_rwy_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			

			// skip beacon only flights
			if (strlen(FltNum) == 4 && !isalpha(FltNum[0]) && !isalpha(FltNum[1]) && !isalpha(FltNum[2]) && !isalpha(FltNum[3])){
				// beacon only flight, skip
				continue;
			}

			vo_alloc_rows(LFDO, 1);

			strncpy_s(VP(LFDO, LFDO->count - 1, "FltNum", char), FLTNUM_SIZE, FltNum, _TRUNCATE);
			testflight = VP(LFDO, LFDO->count - 1, "FltNum", char);
			strncpy_s(VP(LFDO, LFDO->count - 1, "Origin", char), ORIG_DES_SIZE, Origin, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "Destin", char), ORIG_DES_SIZE, Destin, _TRUNCATE);
			//  get altitude from AirVO??  VV(LFDO, LFDO->count - 1, "altitude", int) = altitude;
			VV(LFDO, LFDO->count - 1, "eta", int) = eta;
			VV(LFDO, LFDO->count - 1, "ata", int) = ata;
			VV(LFDO, LFDO->count - 1, "std", int) = std;
			VV(LFDO, LFDO->count - 1, "etd", int) = etd;
			VV(LFDO, LFDO->count - 1, "atd", int) = atd;
			VV(LFDO, LFDO->count - 1, "sta", int) = sta;

			strncpy_s(VP(LFDO, LFDO->count - 1, "actype", char), ACTYPE_SIZE, actype, _TRUNCATE);


			//VV(LFDO, LFDO->count - 1, "outtime", int) = outsecs;
			//VV(LFDO, LFDO->count - 1, "offtime", int) = offsecs;
			//VV(LFDO, LFDO->count - 1, "ontime", int) = onsecs;
			//VV(LFDO, LFDO->count - 1, "intime", int) = insecs;

			VV(LFDO, LFDO->count - 1, "tbfm_offtime", int) = tbfm_offtime;
			VV(LFDO, LFDO->count - 1, "tbfm_ontime", int) = tbfm_ontime;
			VV(LFDO, LFDO->count - 1, "tbfm_freezetime", int) = tbfm_freezetime;

			VV(LFDO, LFDO->count - 1, "first_msg", int) = first_msg_secs;
			strncpy_s(VP(LFDO, LFDO->count - 1, "old_fid", char), 9, old_fid, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "fps", char), 25, fps, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "acs", char), 25, acs, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "sfzflag", char), 25, sfzflag, _TRUNCATE);

			strncpy_s(VP(LFDO, LFDO->count - 1, "rfzflag", char), 25, rfzflag, _TRUNCATE);
			VV(LFDO, LFDO->count - 1, "rwy_freeze", int) = rwy_freeze_secs;
			strncpy_s(VP(LFDO, LFDO->count - 1, "tbfm_actype", char), 13, tbfm_actype, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "tracon_rwy", char), 7, tracon_rwy, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "arr_rwy", char), 7, arr_rwy, _TRUNCATE);

			strncpy_s(VP(LFDO, LFDO->count - 1, "edc_status", char), 7, edc_status, _TRUNCATE);
			VV(LFDO, LFDO->count - 1, "edc_time", int) = edc_time_secs;
			VV(LFDO, LFDO->count - 1, "tbfm_etd", int) = tbfm_etd_secs;
			VV(LFDO, LFDO->count - 1, "sta_at_rwy", int) = sta_at_rwy_secs;
			VV(LFDO, LFDO->count - 1, "eta_at_rwy", int) = eta_at_rwy_secs;


			//VV(LFDO, LFDO->count - 1, "cargo_door_clsd", int) = cargo_door_clsd;
			//VV(LFDO, LFDO->count - 1, "cargo_door_open", int) = cargo_door_open;
			//VV(LFDO, LFDO->count - 1, "pax_door_clsd", int) = pax_door_clsd;
			//VV(LFDO, LFDO->count - 1, "pax_door_open", int) = pax_door_open;
			//VV(LFDO, LFDO->count - 1, "bridge_on_time", int) = bridge_on_time;
			//VV(LFDO, LFDO->count - 1, "crew_out_time", int) = crew_out_time;
			//VV(LFDO, LFDO->count - 1, "brake_released", int) = brake_released;
			//VV(LFDO, LFDO->count - 1, "brake_set", int) = brake_set;

			//strncpy_s(VP(LFDO, LFDO->count - 1, "dep_gate", char), GATE_SIZE, dep_gate, _TRUNCATE);
			//strncpy_s(VP(LFDO, LFDO->count - 1, "arr_gate", char), GATE_SIZE, arr_gate, _TRUNCATE);

			//VV(LFDO, LFDO->count - 1, "acars_init", int) = acars_init;



		}
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "entering critial section\n");

	// dont get gate status for BASIC users GetGateStatus(id, LFDO, "" );

	EnterCriticalSection(&id->m_csEta);
	PrevInVO = (VO*)id->GFDO;
	id->GFDO = LFDO;
	LeaveCriticalSection(&id->m_csEta);
	vo_free(PrevInVO);

}



void ProcessSysAlertsData(struct InstanceData* id, char *outbuf)
{
	int row;
	char *str, *eolstr, *curstr;
	char linebuf[8192];
	char tmpbuf[8192];
	char test_buff[APPNAME_SIZE];
	int len, loopcount;
	int i = 0;
	VO *LFDO, *PrevInVO;
	int seqnum=0;
	char appname[APPNAME_SIZE], username[USERNAME_SIZE], alertname[ALERTNAME_SIZE], priority[PRIORITY_SIZE], comments[COMMENTS_SIZE], alertsource[ALERTSOURCE_SIZE];
		//keyvalues[KEYVALUES_SIZE];
	time_t starttime, endtime;
	


	//
	// load data from, servers info global SA GSAVO
	//

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "ProcessSysAlertsData starting\n");

	const DWORD cdwThreadId = GetCurrentThreadId();

	row = 0;
	str = outbuf;

	LFDO = CrSAVO();

	vo_rm_rows(LFDO, 0, LFDO->count);
	loopcount = 0;
	while (str && strlen(str) > 20 && loopcount++ < 50000){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > _countof(linebuf)){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}

			str = eolstr;
			str++; /* skip over eol char */

			if (strstr(linebuf, "seqnum")){
				// skip header row linebuf = 0x136fef2c "seqnum\tappname\tusername\talertname\tpriority\tstarttime\tendtime\tcomments\tkeyvalues\t"
				continue;
			}

			appname[0] = username[0] = alertname[0] = priority[0] = comments[0] = alertsource[0] = '\0';
			//keyvalues[0] 
			

			curstr = linebuf;
			seqnum = atoi(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(appname, APPNAME_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(username, USERNAME_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(alertname, ALERTNAME_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(priority, PRIORITY_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			starttime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			endtime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(comments, COMMENTS_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(alertsource, ALERTSOURCE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
		//	strcpy_s(keyvalues, KEYVALUES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			
			vo_alloc_rows(LFDO, 1);

			VV(LFDO, LFDO->count - 1, "seqnum", int) = seqnum;
			strncpy_s(VP(LFDO, LFDO->count - 1, "appname", char), APPNAME_SIZE, appname, _TRUNCATE);
			strncpy_s(test_buff, APPNAME_SIZE, VP(LFDO, LFDO->count - 1, "appname", char), _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "username", char), USERNAME_SIZE, username, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "alertname", char), ALERTNAME_SIZE, alertname, _TRUNCATE);
			strncpy_s(test_buff, ALERTNAME_SIZE, VP(LFDO, LFDO->count - 1, "alertname", char), _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "priority", char), PRIORITY_SIZE, priority, _TRUNCATE);
			
			VV(LFDO, LFDO->count - 1, "starttime", int) = starttime;
			VV(LFDO, LFDO->count - 1, "endtime", int) = endtime;

			strncpy_s(VP(LFDO, LFDO->count - 1, "comments", char), COMMENTS_SIZE, comments, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "alertsource", char), ALERTSOURCE_SIZE, alertsource, _TRUNCATE);
			//strncpy_s(VP(LFDO, LFDO->count - 1, "keyvalues", char), KEYVALUES_SIZE, keyvalues, _TRUNCATE);

			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "appname=%s\n", VP(LFDO, LFDO->count - 1, "appname", char));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "username=%s\n", VP(LFDO, LFDO->count - 1, "username", char));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "alertname=%s\n", VP(LFDO, LFDO->count - 1, "alertname", char));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "priority=%s\n", VP(LFDO, LFDO->count - 1, "priority", char));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "starttime=%d\n", VP(LFDO, LFDO->count - 1, "starttime", int));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "endtime=%d\n", VP(LFDO, LFDO->count - 1, "endtime", int));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "comments=%s\n", VP(LFDO, LFDO->count - 1, "comments", char));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "alertsource=%s\n", VP(LFDO, LFDO->count - 1, "alertsource", char));
		//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "keyvalues=%s\n", VP(LFDO, LFDO->count - 1, "keyvalues", char));
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "------------------------------------------------------------");

		}
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "entering critial section\n");

	EnterCriticalSection(&id->m_csEta);
	PrevInVO = (VO*)id->GSA;
	id->GSA = LFDO;
	LeaveCriticalSection(&id->m_csEta);
	vo_free(PrevInVO);

//	FillSysAlertsFromGSA(id, SysAlertsGrid);


}




void ProcessUALFDOData(struct InstanceData* id, char *outbuf)
{
	int row;
	char *str, *eolstr, *testflight, *curstr;
	char linebuf[8192];
	char tmpbuf[8192];
	int len, loopcount;
	static char prev_arpt[ORIG_DES_SIZE] = { 0 };
	int arrdep = -1;
	int i = 0;
	VO *LFDO, *PrevInVO;
	char FltNum[FLTNUM_SIZE], Origin[ORIG_DES_SIZE], Destin[ORIG_DES_SIZE], actype[ACTYPE_SIZE], u_actype[ACTYPE_SIZE],
		arr_runway[RUNWAY_SIZE], arr_gate[GATE_SIZE], dep_gate[GATE_SIZE];
	char fltroute[GG_FLT_ROUTE_SIZE];
	char gate[GATE_SIZE], arr_rwy[7], tracon_rwy[7], acs[25], fps[25], edc_status[7], old_fid[9], sfzflag[25], rfzflag[25], tbfm_actype[13];;
	time_t eta, ata, atd, std, etd, sta, outsecs, offsecs, onsecs, insecs, 
		tbfm_offtime, tbfm_ontime, tbfm_freezetime, cargo_door_clsd, cargo_door_open, pax_door_clsd,
		pax_door_open, bridge_on_time, crew_out_time, brake_released, brake_set, acars_init, u_sta_secs, u_std_secs,
		first_msg_secs, rwy_freeze_secs, edc_time_secs, tbfm_etd_secs, sta_at_rwy_secs, eta_at_rwy_secs;
	static int testflag = 0;
	static int debugstop = 1;

	//
	// load data from, servers info global FDO  GFDO
	//

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "ProcessFDOData starting\n");

	const DWORD cdwThreadId = GetCurrentThreadId();

	row = 0;
	str = outbuf;

	LFDO = CrFDOVO();

	vo_rm_rows(LFDO, 0, LFDO->count);
	loopcount = 0;
	while (str && strlen(str) > 20 && loopcount++ < 50000){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > _countof(linebuf)){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}

			str = eolstr;
			str++; /* skip over eol char */

			if (strstr(linebuf, "flightid")){
				// skip header row linebuf = 0x136fef2c "flightid\torigin\tdestination\tactype\teta\tata\tstd\tetd\tatd\tsta\tarr_runway\tfltroute\t"
				continue;
			}

			FltNum[0] = Origin[0] = Destin[0] = actype[0] = fltroute[0] = arr_runway[0] = gate[0] = u_actype[0] =
				arr_gate[0] = dep_gate[0] = '\0';

			curstr = linebuf;
			strcpy_s(FltNum, FLTNUM_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			if (!strncmp(FltNum, "UAL", 3)){
				// test
				u_actype[0] = '\0';
			}

			strcpy_s(Origin, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(Destin, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(actype, ACTYPE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			eta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			ata = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			std = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			etd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			atd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			sta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(arr_runway, RUNWAY_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			outsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			offsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			onsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			insecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(arr_gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(dep_gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			u_sta_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			u_std_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(u_actype, ACTYPE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			cargo_door_clsd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			cargo_door_open = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			pax_door_clsd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			pax_door_open = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			bridge_on_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			crew_out_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			bridge_on_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			brake_released = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			brake_set = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			acars_init = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(fltroute, GG_FLT_ROUTE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			tbfm_offtime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_ontime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_freezetime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			// additional tbfm fields 
			first_msg_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(old_fid, 9, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(fps, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(acs, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(sfzflag, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(rfzflag, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			rwy_freeze_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(tbfm_actype, 13, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(tracon_rwy, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(arr_rwy, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(edc_status, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			edc_time_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_etd_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			sta_at_rwy_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			eta_at_rwy_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			// skip beacon only flights
			if (strlen(FltNum) == 4 && !isalpha(FltNum[0]) && !isalpha(FltNum[1]) && !isalpha(FltNum[2]) && !isalpha(FltNum[3])){
				// beacon only flight, skip
				continue;
			}

			vo_alloc_rows(LFDO, 1);

			strncpy_s(VP(LFDO, LFDO->count - 1, "FltNum", char), FLTNUM_SIZE, FltNum, _TRUNCATE);
			testflight = VP(LFDO, LFDO->count - 1, "FltNum", char);
			strncpy_s(VP(LFDO, LFDO->count - 1, "Origin", char), ORIG_DES_SIZE, Origin, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "Destin", char), ORIG_DES_SIZE, Destin, _TRUNCATE);
			//  get altitude from AirVO??  VV(LFDO, LFDO->count - 1, "altitude", int) = altitude;
			VV(LFDO, LFDO->count - 1, "eta", int) = eta;
			VV(LFDO, LFDO->count - 1, "ata", int) = ata;
			VV(LFDO, LFDO->count - 1, "std", int) = std;
			VV(LFDO, LFDO->count - 1, "etd", int) = etd;
			VV(LFDO, LFDO->count - 1, "atd", int) = atd;
			VV(LFDO, LFDO->count - 1, "sta", int) = sta;

			strncpy_s(VP(LFDO, LFDO->count - 1, "actype", char), ACTYPE_SIZE, actype, _TRUNCATE);


			VV(LFDO, LFDO->count - 1, "outtime", int) = outsecs;
			VV(LFDO, LFDO->count - 1, "offtime", int) = offsecs;
			VV(LFDO, LFDO->count - 1, "ontime", int) = onsecs;
			VV(LFDO, LFDO->count - 1, "intime", int) = insecs;

			VV(LFDO, LFDO->count - 1, "tbfm_offtime", int) = tbfm_offtime;
			VV(LFDO, LFDO->count - 1, "tbfm_ontime", int) = tbfm_ontime;
			VV(LFDO, LFDO->count - 1, "tbfm_freezetime", int) = tbfm_freezetime;

			VV(LFDO, LFDO->count - 1, "cargo_door_clsd", int) = cargo_door_clsd;
			VV(LFDO, LFDO->count - 1, "cargo_door_open", int) = cargo_door_open;
			VV(LFDO, LFDO->count - 1, "pax_door_clsd", int) = pax_door_clsd;
			VV(LFDO, LFDO->count - 1, "pax_door_open", int) = pax_door_open;
			VV(LFDO, LFDO->count - 1, "bridge_on_time", int) = bridge_on_time;
			VV(LFDO, LFDO->count - 1, "crew_out_time", int) = crew_out_time;
			VV(LFDO, LFDO->count - 1, "brake_released", int) = brake_released;
			VV(LFDO, LFDO->count - 1, "brake_set", int) = brake_set;

			strncpy_s(VP(LFDO, LFDO->count - 1, "dep_gate", char), GATE_SIZE, dep_gate, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "arr_gate", char), GATE_SIZE, arr_gate, _TRUNCATE);

			VV(LFDO, LFDO->count - 1, "acars_init", int) = acars_init;

			VV(LFDO, LFDO->count - 1, "first_msg", int) = first_msg_secs;
			strncpy_s(VP(LFDO, LFDO->count - 1, "old_fid", char), 9, old_fid, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "fps", char), 25, fps, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "acs", char), 25, acs, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "sfzflag", char), 25, sfzflag, _TRUNCATE);

			strncpy_s(VP(LFDO, LFDO->count - 1, "rfzflag", char), 25, rfzflag, _TRUNCATE);
			VV(LFDO, LFDO->count - 1, "rwy_freeze", int) = rwy_freeze_secs;
			strncpy_s(VP(LFDO, LFDO->count - 1, "tbfm_actype", char), 13, tbfm_actype, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "tracon_rwy", char), 7, tracon_rwy, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "arr_rwy", char), 7, arr_rwy, _TRUNCATE);

			strncpy_s(VP(LFDO, LFDO->count - 1, "edc_status", char), 7, edc_status, _TRUNCATE);
			VV(LFDO, LFDO->count - 1, "edc_time", int) = edc_time_secs;
			VV(LFDO, LFDO->count - 1, "tbfm_etd", int) = tbfm_etd_secs;
			VV(LFDO, LFDO->count - 1, "sta_at_rwy", int) = sta_at_rwy_secs;
			VV(LFDO, LFDO->count - 1, "eta_at_rwy", int) = eta_at_rwy_secs;

		}
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "entering critial section\n");


	GetGateStatus(id, LFDO, "arr_gate" );

	EnterCriticalSection(&id->m_csEta);
	PrevInVO = (VO*)id->GFDO;
	id->GFDO = LFDO;
	LeaveCriticalSection(&id->m_csEta);
	vo_free(PrevInVO);

}


void ProcessFDOData(struct InstanceData* id, char *outbuf)
{
	int row;
	char *str, *eolstr, *testflight, *curstr;
	char linebuf[8192];
	char tmpbuf[8192];
	int len, loopcount;
	static char prev_arpt[ORIG_DES_SIZE] = { 0 };
	int arrdep = -1;
	int i = 0;
	VO *LFDO, *PrevInVO;
	char FltNum[FLTNUM_SIZE], Origin[ORIG_DES_SIZE], Destin[ORIG_DES_SIZE], actype[ACTYPE_SIZE], d_actype[ACTYPE_SIZE], intdprtgate[GATE_SIZE],
		prevpubdprtgate[GATE_SIZE], arr_runway[RUNWAY_SIZE], prevpubarrgate[GATE_SIZE], previntdprtgate[GATE_SIZE], previntarrgate[GATE_SIZE],
		defaultdprtgateind[GATE_SIZE], int_arr_gate[GATE_SIZE], default_arr_gate_ind[GATE_SIZE], estdprtctrlgmttssrc[33], draggateid[17];
	char fltroute[GG_FLT_ROUTE_SIZE];
	char gate[GATE_SIZE], arr_rwy[7], tracon_rwy[7], acs[25], fps[25], edc_status[7], old_fid[9], sfzflag[25], rfzflag[25], tbfm_actype[13];
	time_t eta, ata, atd, std, etd, sta, outsecs, offsecs, onsecs, insecs, d_etasecs, d_sta, drag_off_secs, psgr_clseout_secs,
		arr_gate_time, dprt_gate_time, lst_upd_time, last_upd_time, tbfm_offtime, tbfm_ontime, tbfm_freezetime, estdprtctrlgmtts, brdngstrtdgmtts, readytodprtgmtts, onlinetsgmt, paxdrclsgmtts,
		first_msg_secs, rwy_freeze_secs, edc_time_secs, tbfm_etd_secs, sta_at_rwy_secs, eta_at_rwy_secs;
	static int testflag = 0;
	static int debugstop = 1;
	



	//
	// load data from, servers info global FDO  GFDO
	//

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "ProcessFDOData starting\n");

	const DWORD cdwThreadId = GetCurrentThreadId();

	row = 0;
	str = outbuf;

	LFDO = CrFDOVO();

	vo_rm_rows(LFDO, 0, LFDO->count);
	loopcount = 0;
	while (str && strlen(str) > 20 && loopcount++ < 50000){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > _countof(linebuf)){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}

			str = eolstr;
			str++; /* skip over eol char */

			if (strstr(linebuf, "flightid")){
				// skip header row linebuf = 0x136fef2c "flightid\torigin\tdestination\tactype\teta\tata\tstd\tetd\tatd\tsta\tarr_runway\tfltroute\t"
				continue;
			}

			FltNum[0] = Origin[0] = Destin[0] = actype[0] = fltroute[0] = arr_runway[0] = gate[0] = d_actype[0] = intdprtgate[0] = prevpubdprtgate[0] = '\0';

			/*
			matches = sscanf_s(linebuf,
			"%s\t%s\t%s\t%s\t"
			"%ld\t%ld\t%ld\t%ld\t"
			"%ld\t%ld\t%s\t"
			"%ld\t%ld\t%ld\t%ld\t"
			"%s\t%ld\t%ld\t%s\t"
			"%ld\t%ld\t%s\t%s\t%s\t",
			FltNum, FLTNUM_SIZE, Origin, ORIG_DES_SIZE, Destin, ORIG_DES_SIZE, actype, ACTYPE_SIZE,
			&eta, &ata, &std, &etd,
			&atd, &sta, arr_runway, RUNWAY_SIZE,
			&outsecs, &offsecs, &onsecs, &insecs,
			gate, GATE_SIZE, &d_etasecs, &d_sta, d_actype, ACTYPE_SIZE,
			&drag_off_secs, &psgr_clseout_secs, intdprtgate, GATE_SIZE, prevpubdprtgate, GATE_SIZE, fltroute, GG_FLT_ROUTE_SIZE );
			*/

			curstr = linebuf;
			strcpy_s(FltNum, FLTNUM_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(Origin, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(Destin, ORIG_DES_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(actype, ACTYPE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			eta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			ata = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			std = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			etd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			atd = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			sta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(arr_runway, RUNWAY_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			outsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			offsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			onsecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			insecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			d_etasecs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			d_sta = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(d_actype, ACTYPE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			drag_off_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			psgr_clseout_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(intdprtgate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(prevpubdprtgate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(prevpubarrgate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(previntdprtgate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(previntarrgate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(defaultdprtgateind, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(int_arr_gate, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			arr_gate_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			dprt_gate_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(default_arr_gate_ind, GATE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			lst_upd_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(fltroute, GG_FLT_ROUTE_SIZE, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			// last_upd_time is rowtime from ggflights table
			last_upd_time = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			tbfm_offtime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_ontime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_freezetime = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			// additional tbfm fields 
			first_msg_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(old_fid, 9, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(fps, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(acs, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(sfzflag, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(rfzflag, 25, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			rwy_freeze_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(tbfm_actype, 13, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(tracon_rwy, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(arr_rwy, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));

			strcpy_s(edc_status, 7, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			edc_time_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			tbfm_etd_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			sta_at_rwy_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			eta_at_rwy_secs = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));


			//12th oct 2016
			estdprtctrlgmtts = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(estdprtctrlgmttssrc, 33, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			brdngstrtdgmtts = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			paxdrclsgmtts = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			readytodprtgmtts = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			onlinetsgmt = atol(GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			strcpy_s(draggateid, 17, GetNxtField(curstr, tmpbuf, sizeof(tmpbuf) - 1, '\t', &curstr));
			
			
			//if (!strncasecmp(FltNum, "DAL", 3)){
			//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "flightid %s, estdprtctrlgmtts=%ld, \n", FltNum, estdprtctrlgmtts);
			//}

			// skip beacon only flights
			if (strlen(FltNum) == 4 && !isalpha(FltNum[0]) && !isalpha(FltNum[1]) && !isalpha(FltNum[2]) && !isalpha(FltNum[3])){
				// beacon only flight, skip
				continue;
			}

			vo_alloc_rows(LFDO, 1);

			strncpy_s(VP(LFDO, LFDO->count - 1, "FltNum", char), FLTNUM_SIZE, FltNum, _TRUNCATE);
			testflight = VP(LFDO, LFDO->count - 1, "FltNum", char);
			strncpy_s(VP(LFDO, LFDO->count - 1, "Origin", char), ORIG_DES_SIZE, Origin, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "Destin", char), ORIG_DES_SIZE, Destin, _TRUNCATE);
			//  get altitude from AirVO??  VV(LFDO, LFDO->count - 1, "altitude", int) = altitude;
			VV(LFDO, LFDO->count - 1, "eta", int) = eta;
			VV(LFDO, LFDO->count - 1, "ata", int) = ata;
			VV(LFDO, LFDO->count - 1, "std", int) = std;
			VV(LFDO, LFDO->count - 1, "etd", int) = etd;
			VV(LFDO, LFDO->count - 1, "atd", int) = atd;
			VV(LFDO, LFDO->count - 1, "sta", int) = sta;

			// get from AirVO VV(LFDO, LFDO->count - 1, "speed", int) = speed;
			strncpy_s(VP(LFDO, LFDO->count - 1, "actype", char), ACTYPE_SIZE, actype, _TRUNCATE);
			//strncpy_s(VP(LFDO, LFDO->count - 1, "gate", char), GATE_SIZE, gate, _TRUNCATE);

			VV(LFDO, LFDO->count - 1, "outtime", int) = outsecs;
			VV(LFDO, LFDO->count - 1, "offtime", int) = offsecs;
			VV(LFDO, LFDO->count - 1, "ontime", int) = onsecs;
			VV(LFDO, LFDO->count - 1, "intime", int) = insecs;
			//VV(LFDO, LFDO->count - 1, "d_sta", int) = d_sta;

			strncpy_s(VP(LFDO, LFDO->count - 1, "d_actype", char), ACTYPE_SIZE, d_actype, _TRUNCATE);

		//	VV(LFDO, LFDO->count - 1, "bestarrgmtts", int) = d_etasecs;
			//VV(LFDO, LFDO->count - 1, "drag_off", int) = drag_off_secs;
			VV(LFDO, LFDO->count - 1, "psgr_clseout", int) = psgr_clseout_secs;

			strncpy_s(VP(LFDO, LFDO->count - 1, "intdprtgate", char), GATE_SIZE, intdprtgate, _TRUNCATE);
		//	strncpy_s(VP(LFDO, LFDO->count - 1, "prevpubdprtgate", char), GATE_SIZE, prevpubdprtgate, _TRUNCATE);


		//	strncpy_s(VP(LFDO, LFDO->count - 1, "prevpubarrgate", char), GATE_SIZE, prevpubarrgate, _TRUNCATE);
		//	strncpy_s(VP(LFDO, LFDO->count - 1, "previntdprtgate", char), GATE_SIZE, previntdprtgate, _TRUNCATE);
		//	strncpy_s(VP(LFDO, LFDO->count - 1, "previntarrgate", char), GATE_SIZE, previntarrgate, _TRUNCATE);
		//	strncpy_s(VP(LFDO, LFDO->count - 1, "defaultdprtgateind", char), GATE_SIZE, defaultdprtgateind, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "int_arr_gate", char), GATE_SIZE, int_arr_gate, _TRUNCATE);

		//	VV(LFDO, LFDO->count - 1, "arr_gate_time", int) = arr_gate_time;
		//	VV(LFDO, LFDO->count - 1, "dprt_gate_time", int) = dprt_gate_time;

		//	strncpy_s(VP(LFDO, LFDO->count - 1, "default_arr_gate_ind", char), GATE_SIZE, default_arr_gate_ind, _TRUNCATE);
		//	VV(LFDO, LFDO->count - 1, "lst_upd_time", int) = lst_upd_time;

			VV(LFDO, LFDO->count - 1, "tbfm_offtime", int) = tbfm_offtime;
			VV(LFDO, LFDO->count - 1, "tbfm_ontime", int) = tbfm_ontime;
			VV(LFDO, LFDO->count - 1, "tbfm_freezetime", int) = tbfm_freezetime;

			VV(LFDO, LFDO->count - 1, "first_msg", int) = first_msg_secs;
			strncpy_s(VP(LFDO, LFDO->count - 1, "old_fid", char), 9, old_fid, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "fps", char), 25, fps, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "acs", char), 25, acs, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "sfzflag", char), 25, sfzflag, _TRUNCATE);

			strncpy_s(VP(LFDO, LFDO->count - 1, "rfzflag", char), 25, rfzflag, _TRUNCATE);
			VV(LFDO, LFDO->count - 1, "rwy_freeze", int) = rwy_freeze_secs;
			strncpy_s(VP(LFDO, LFDO->count - 1, "tbfm_actype", char), 13, tbfm_actype, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "tracon_rwy", char), 7, tracon_rwy, _TRUNCATE);
			strncpy_s(VP(LFDO, LFDO->count - 1, "arr_rwy", char), 7, arr_rwy, _TRUNCATE);

			strncpy_s(VP(LFDO, LFDO->count - 1, "edc_status", char), 7, edc_status, _TRUNCATE);
			VV(LFDO, LFDO->count - 1, "edc_time", int) = edc_time_secs;
			VV(LFDO, LFDO->count - 1, "tbfm_etd", int) = tbfm_etd_secs;
			VV(LFDO, LFDO->count - 1, "sta_at_rwy", int) = sta_at_rwy_secs;
			VV(LFDO, LFDO->count - 1, "eta_at_rwy", int) = eta_at_rwy_secs;


			//12th oct 2016
			VV(LFDO, LFDO->count - 1, "estdprtctrlgmtts", int)= estdprtctrlgmtts;
			strncpy_s(VP(LFDO, LFDO->count - 1, "estdprtctrlgmttssrc", char), 33, estdprtctrlgmttssrc, _TRUNCATE);			
			VV(LFDO, LFDO->count - 1, "brdngstrtdgmtts", int)=brdngstrtdgmtts;
			VV(LFDO, LFDO->count - 1, "paxdrclsgmtts", int)=paxdrclsgmtts;
			VV(LFDO, LFDO->count - 1, "readytodprtgmtts", int)=readytodprtgmtts;
			VV(LFDO, LFDO->count - 1, "onlinetsgmt", int)=onlinetsgmt;
			strncpy_s(VP(LFDO, LFDO->count - 1, "draggateid", char), 17, draggateid, _TRUNCATE);
			
			//if (!strncasecmp(FltNum, "DAL", 3)){
			//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "flightid %s, lfdo estdprtctrlgmtts=%ld, brdngstrtdgmtts=%ld estdprtctrlgmttssrc=%s\n", FltNum, VV(LFDO, LFDO->count - 1, "estdprtctrlgmtts", int) ,
			//		VV(LFDO, LFDO->count - 1, "brdngstrtdgmtts", int), VP(LFDO, LFDO->count - 1, "estdprtctrlgmttssrc", char) );
			//}

		}
	}

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "entering critial section\n");

	GetGateStatus(id, LFDO, "int_arr_gate" );

		//for (i = 0; i < LFDO->count; i++){
		//	if (!strncmp(VP(LFDO, i, "FltNum", char), "DAL", 3)){
		//		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "after gate status, FltNum '%s' estdprtctrlgmtts=%ld, brdngstrtdgmtts=%ld estdprtctrlgmttssrc=%s \n",
		//			VP(LFDO, i, "FltNum", char),
		//			VV(LFDO, i, "estdprtctrlgmtts", int),
		//			VV(LFDO, i, "brdngstrtdgmtts", int),
		//			VP(LFDO, i, "estdprtctrlgmttssrc", char));
		//	}
		//}
	



	EnterCriticalSection(&id->m_csEta);
	PrevInVO = (VO*)id->GFDO;
	id->GFDO = LFDO;
	LeaveCriticalSection(&id->m_csEta);
	vo_free(PrevInVO);

}





void ProcessGateData(struct InstanceData* id, char* arpt, char *outbuf)
{
	int row;
	char *str, *eolstr;
	char linebuf[256];
	int len, matches;
	char flightid[FLTNUM_SIZE];
	char gate[7];
	char term[7];
	char temp[15];
	static char prev_arpt[5] = { 0 };
	int arrdep = -1;
	int i = 0;
	const char* err1 = "TD, Could not find Arpt";
	const char* err2 = "TD, No Tarmac for Arpt";
	struct row_index *row_index;
	VO *GateProcessVO;
	VO *InVO;  // get a new one every time so the thread can create a new one w/o affecting existing one
	VO *OutVO;  // get a new one every time so the thread can create a new one w/o affecting existing one
	VO *PrevInVO;
	VO *PrevOutVO;
	time_t cur, now;
	struct tm t;

	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!id->m_pGateProcessVO){
		GateProcessVO = id->m_pGateProcessVO = (VO *)vo_create(0, NULL);
		vo_set(GateProcessVO, V_NAME, "GateProcessVO", NULL);
		VOPropAdd(GateProcessVO, "Line", NTBSTRINGBIND, 100, VO_NO_ROW);
		VOPropAdd(GateProcessVO, "Processed", INTBIND, -1, VO_NO_ROW);
		vo_rm_rows(GateProcessVO, 0, GateProcessVO->count);
		vo_set(GateProcessVO, V_ORDER_COLS, "Line", NULL, NULL);
	}else{
		GateProcessVO = id->m_pGateProcessVO;
		for (i = 0; i < GateProcessVO->count; i++){
			VV(GateProcessVO, i, "Processed", int) = 0; // Not Processed
		}
	}

	// If we change the airport, reset the processed list
	if (strcmp(arpt, prev_arpt)){
		strcpy_s(prev_arpt, 5, arpt);
		vo_rm_rows(GateProcessVO, 0, GateProcessVO->count);
	}


	now = cur = time(NULL);
	gmtime_s(&t, &cur);

	InVO = (VO *)vo_create(0, NULL);
	vo_set(InVO, V_NAME, "GateInVO", NULL);
	VOPropAdd(InVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(InVO, "Arpt", NTBSTRINGBIND, 5, VO_NO_ROW);
	VOPropAdd(InVO, "Time", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(InVO, "Term", NTBSTRINGBIND, 7, VO_NO_ROW);
	VOPropAdd(InVO, "Gate", NTBSTRINGBIND, 7, VO_NO_ROW);
	vo_rm_rows(InVO, 0, InVO->count);
	vo_set(InVO, V_ORDER_COLS, "FltNum", NULL, NULL);

	OutVO = (VO *)vo_create(0, NULL);
	vo_set(OutVO, V_NAME, "GateOutVO", NULL);
	VOPropAdd(OutVO, "FltNum", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
	VOPropAdd(OutVO, "Arpt", NTBSTRINGBIND, 5, VO_NO_ROW);
	VOPropAdd(OutVO, "Time", INTBIND, -1, VO_NO_ROW);
	VOPropAdd(OutVO, "Term", NTBSTRINGBIND, 7, VO_NO_ROW);
	VOPropAdd(OutVO, "Gate", NTBSTRINGBIND, 7, VO_NO_ROW);
	vo_rm_rows(OutVO, 0, OutVO->count);
	vo_set(OutVO, V_ORDER_COLS, "FltNum", NULL, NULL);


	row = 0;
	str = outbuf;
	while (str){
		if ((eolstr = strchr(str, '\n'))){
			len = eolstr - str;
			if (len > 30){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), str, len);

			if (!strcasecmp(linebuf, "EOD")){
				break; // EOD
			}
			if (!strncmp(linebuf, err1, strlen(err1)) || // Make sure we are not just getting error data back
				!strncmp(linebuf, err2, strlen(err2))){
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Gate data from %s <reason:%s>, switching srvrs to %s and trying again.\n",
					cdwThreadId, linebuf, GetPulseSrvr(id), GetNxtPulseSrvr(id));
				return;
			}
			str = eolstr;
			str++; /* skip over eol char */

			if (!strncmp(linebuf, "FLIGHTID", 8))
			{
				if (-1 == arrdep)
					arrdep = 0;
				else
					arrdep = 1;
				continue;
			}

			// Check if the data has been processed, do not add to Data VO's if it has
			if (row_index = (struct row_index *) vo_search(GateProcessVO, "Line", linebuf, NULL))
			{
				D_CONTROL("GATE_LINE_IGN", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GATE DATA <%s> IGNORED, Already Processed.\n", cdwThreadId, linebuf));
				VV(GateProcessVO, row_index->rownum, "Processed", int) = 1; // Processed
				continue;
			}else{
				vo_alloc_rows(GateProcessVO, 1);
				strcpy_s(VP(GateProcessVO, GateProcessVO->count - 1, "Line", char), 100, linebuf);
				VV(GateProcessVO, GateProcessVO->count - 1, "Processed", int) = 1;
				D_CONTROL("GATE_LINE_NEW", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) NEW GATE DATA <%s>\n", cdwThreadId, linebuf));
			}

			if (len > 3){  // skip over the EOD string
				if (!arrdep)
				{
					//Process Arrivals first
					//FLIGHTID INGATE TERM
					matches = sscanf_s(linebuf, "%s %d %s", flightid, FLTNUM_SIZE,
						&cur, temp, 14);

					if (matches == 3){
						D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) INGATE='%s, %s'\n", cdwThreadId, arpt, linebuf));

						if (!strcmp("N/A", temp)){
							strcpy_s(term, 7, "null");
							strcpy_s(gate, 7, "null");
						}else{
							char* p = strchr(temp, '/');
							if (p){
								memset(term, 0, 7 * sizeof(char));
								strncpy_s(term, 7, temp, strlen(temp) - strlen(p));
								p++;
								strcpy_s(gate, 7, p);
							}else{
								strcpy_s(term, 7, "null");
								strcpy_s(gate, 7, temp);
							}
						}

						// Filter out any gate in's for last 15 minutes
						if ((now - cur) < GATE_IN_TRACK_TIMEOUT)
						{
							vo_alloc_rows(InVO, 1);
							strcpy_s(VP(InVO, InVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
							strcpy_s(VP(InVO, InVO->count - 1, "Arpt", char), 5, arpt);
							VV(InVO, InVO->count - 1, "Time", int) = cur;
							strcpy_s(VP(InVO, InVO->count - 1, "Term", char), 7, term);
							strcpy_s(VP(InVO, InVO->count - 1, "Gate", char), 7, gate);
						}else{
							D_CONTROL("GATES", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropping GATEIN for ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>, time past current time.\n",
								cdwThreadId, arpt, flightid, term, gate, cur));
						}
					}
				}else{
					//Process Departures second
					//FLIGHTID OUTGATE TERM
					matches = sscanf_s(linebuf, "%s %d %s", flightid, FLTNUM_SIZE,
						&cur, temp, 14);

					if (matches == 3){
						D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) OUTGATE='%s, %s'\n	", cdwThreadId, arpt, linebuf));

						if (!strcmp("N/A", temp)){
							strcpy_s(term, 7, "null");
							strcpy_s(gate, 7, "null");
						}else{
							char* p = strchr(temp, '/');
							if (p){
								memset(term, 0, 7 * sizeof(char));
								strncpy_s(term, 7, temp, strlen(temp) - strlen(p));
								p++;
								strcpy_s(gate, 7, p);
							}else{
								strcpy_s(term, 7, "null");
								strcpy_s(gate, 7, temp);
							}
						}

						// Filter out any gate out's for last 10 minutes
						if ((now - cur) < GATE_OUT_TRACK_TIMEOUT)
						{
							vo_alloc_rows(OutVO, 1);
							strcpy_s(VP(OutVO, OutVO->count - 1, "FltNum", char), FLTNUM_SIZE, flightid);
							strcpy_s(VP(OutVO, OutVO->count - 1, "Arpt", char), 5, arpt);
							VV(OutVO, OutVO->count - 1, "Time", int) = cur;
							strcpy_s(VP(OutVO, OutVO->count - 1, "Term", char), 7, term);
							strcpy_s(VP(OutVO, OutVO->count - 1, "Gate", char), 7, gate);
						}else{
							D_CONTROL("GATES", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Dropping GATEOUT for ARPT<%s>, FLTNUM<%s>, TERM<%s>, GATE<%s>, TIME<%d>, time past current time.\n",
								cdwThreadId, arpt, flightid, term, gate, cur));
						}
					}
				}
			}
		} else {
			str = NULL;
		}
	}

	// Sort VO
	vo_order(InVO);
	vo_order(OutVO);

	D_CONTROL("INGATE_VO", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) InGateVO='%s'\n\n", cdwThreadId, vo_printstr(InVO)));
	D_CONTROL("OUTGATE_VO", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) OutGateVO='%s'\n\n", cdwThreadId, vo_printstr(OutVO)));


	EnterCriticalSection(&id->m_csEta);
	PrevInVO = (VO*)id->m_pGateInVO;
	id->m_pGateInVO = InVO;
	PrevOutVO = (VO*)id->m_pGateOutVO;
	id->m_pGateOutVO = OutVO;
	LeaveCriticalSection(&id->m_csEta);
	vo_free(PrevInVO);
	vo_free(PrevOutVO);

	for (i = 0; i < GateProcessVO->count; i++){
		if (!VV(GateProcessVO, i, "Processed", int)){
			vo_rm_row(GateProcessVO, i);
			i--;
		}
	}
	vo_order(GateProcessVO);
}


int GetPlannedArrDepVO(struct InstanceData* id, CURL* curl_handle)
{
	time_t secs;
	struct MemoryStruct chunk;
	int delaysecs;
	int replay_adjust_secs;
	int loopcount;
	int i, c, lastslash;
	int replay_status;
	long unziplen;
	char url[URL_SZ];
	char tmpstr[TMPBUF_SIZE];
	char tname[URL_SZ];
	char* str;
	char LatestAsdexcginame[256];
	char *outbufdef = NULL, *outbufarr = NULL;
	VO *PlannedDepVO = NULL, *PlannedArrVO = NULL, *PrevVO = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (!curl_handle) return FALSE;

	secs = time(0);
	replay_status = id->m_bReplayStatus;

	if (id->m_nDelaySecs){
		// we are in replay mode, use Plottime to retrieve next file
		if (id->m_tPlannedFileTime < id->m_tPlotTime){
			// file is behind, get the next file
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) file is behind, Gfiletime=%d plottime=%d\n",
				cdwThreadId, id->m_tPlannedFileTime, id->m_tPlotTime);
		} else if ( secs - id->m_tLastPlannedGetTime < 60 ){
			/* we already got it */
			return(SUCCEED);
		}
	} else if ( secs - id->m_tLastPlannedGetTime < 60 ){  
		/* we already got it */
		return(SUCCEED);
	}

	id->m_tLastPlannedGetTime = secs;

	loopcount = 0;
	do {
		id->m_strPlannedZipFilename[0] = '\0';
		if (id->m_nDelaySecs || !id->m_bClass1){
			if (!id->m_bClass1){
				delaysecs = MAX(id->m_nDelaySecs, 300);
			} else {
				delaysecs = id->m_nDelaySecs;
			}
			if (id->m_nDelaySecs && id->m_nReplaySpeed && delaystartsecs){
				replay_adjust_secs = (int)(id->m_tClientsTime - delaystartsecs) *  (id->m_nReplaySpeed - 1);
				delaysecs -= replay_adjust_secs;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) delaysecs reduced by %d\n", cdwThreadId, replay_adjust_secs);
			}
			if (delaysecs < 0 || (delaysecs < 300 && !id->m_bClass1)){
				// we already got it 
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) delaysecs =%d, in future, replay past current time\n",
					cdwThreadId, delaysecs);
				return(SUCCEED);
			}
			secs -= delaysecs;
			//NOTE: hard coded airport name to asdex - becuase we currently only have jfk ASDE-X data. 
			//      Once we support other airports we will need to modify scheme, maybe asdexJFK??
			sprintf_s(tmpstr, TMPBUF_SIZE, "arpt=%s&feed=%s&replay=%d", id->m_strAsdexArpt, "asdexetas", delaysecs);
		} else {
			//NOTE: hard coded airport name to asdex - becuase we currently only have jfk ASDE-X data. 
			//      Once we support other airports we will need to modify scheme, maybe asdexJFK??
			sprintf_s(tmpstr, TMPBUF_SIZE, "arpt=%s&feed=%s", id->m_strAsdexArpt, "asdexetas");
		}

		clear_chunk_memory(&chunk);

		setCurlTimeout(curl_handle, 4L);

		sprintf_s(LatestAsdexcginame, _countof(LatestAsdexcginame), "%s/cgi-bin/latest.cgi", GetAsdexSrvr(id));

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) LatestAsdexcginame <%s> tmpstr <%s>\n", cdwThreadId, LatestAsdexcginame, tmpstr);

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - LatestAsdexcginame <%s> tmpstr <%s>\n",
			cdwThreadId, LatestAsdexcginame, tmpstr);
		if (GetCurlFormGetResults_r(id, curl_handle, &chunk, LatestAsdexcginame, tmpstr, SM_HTTPS, TRUE) == FALSE) {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Call to GetCurlFormGetResults for url: <%s> failed, switching srvrs & trying again.\n",
				cdwThreadId, LatestAsdexcginame);

			/*---------------------------------------------------------------------*/
			/* Swithch to next ASDEX server                                        */
			/*---------------------------------------------------------------------*/

			GetNxtAsdexSrvr(id);
		}

		if (chunk.memory){
			strncpy_s(id->m_strPlannedZipFilename, 256, chunk.memory, _TRUNCATE);
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) strPlannedZipFilename <%s>\n", cdwThreadId, id->m_strPlannedZipFilename);
			free_chunk_memory(&chunk);
		} else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get latest.cgi, trying again\n", cdwThreadId);
		}
	} while (!strlen(id->m_strPlannedZipFilename) && ++loopcount < 5);
	if (loopcount >= 5) {
		return(FALSE);
	}

	clear_chunk_memory(&chunk);
	sprintf_s(url, URL_SZ, "%s/%s", GetAsdexSrvr(id), id->m_strPlannedZipFilename);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ASDEX url: <%s> PlannedZipFilename <%s>\n", cdwThreadId, url, id->m_strPlannedZipFilename);

	if (!strcmp(url, id->m_strPrevPlannedUrl)){
		/* we already got this file */
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Already got this file(%s), skipping\n", cdwThreadId, url);
		return(SUCCEED);
	}

	if (!strncmp(id->m_strUserName, "sm", 2)){  // take anything for now
		if ('\x0A' == url[strlen(url) - 1])url[strlen(url) - 1] = 0; // removes newline		
		_snprintf_s(id->m_strLatestPassurURL, URL_SZ, _TRUNCATE, "PLANNED: %s", url);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", cdwThreadId, id->m_strLatestPassurURL);
	}

	id->m_tPlannedFileTime = CalcPlannedFileTime(id, url);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlPage_r id <%x> url <%s>.\n", cdwThreadId, id, url);

	// Get Zip file data
	if (!GetCurlPage_r(id, curl_handle, &chunk, url, SM_HTTPS, 3, 4L)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Curl failed for <%s>\n", cdwThreadId, url);

		// 
		// Note server failure and get alternate if available
		//

		GetNxtAsdexSrvr(id);

		free_chunk_memory(&chunk);
		return(FALSE);
	}

	// Verify we received data
	if (!chunk.size || !chunk.memory){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Error, null chunk size\n", cdwThreadId);
		return(FALSE);
	}

	// Verify that the data is a zip file
	if (chunk.memory[0] != 'P' && chunk.memory[1] != 'K'){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Invalid downloaded compressed data file for %s\n", cdwThreadId, url);
		free_chunk_memory(&chunk);
		return (FALSE);
	}

	// Determine zip filename to extract
	str = id->m_strPlannedZipFilename;
	i = 0;
	lastslash = -1;
	while ((c = *str++) != '\0'){
		if (c == '/'){ lastslash = i; }
		i++;
	}
	if (lastslash == -1){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create zip filename\n", cdwThreadId);
		return(FALSE);
	}
	strncpy_s(tname, URL_SZ, &id->m_strPlannedZipFilename[lastslash + 1], 255);

	// Extract zip file into buffer
	if ((unziplen = imunzip(tname, chunk.memory, chunk.size, &outbufdef)) <= 0){
		if (unziplen == -2){
			strcpy_s(id->m_strPrevPlannedUrl, 256, url);
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Planned data available for %s\n", cdwThreadId, url);
		}else{
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) imunzip failed for %s\n", cdwThreadId, url);
		}
		free_chunk_memory(&chunk);
		return(FALSE);
	}

	free_chunk_memory(&chunk);

	strcpy_s(id->m_strPrevPlannedUrl, 256, url);

	D_CONTROL("RAWARRDEP", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s\n", cdwThreadId, outbufdef));

	// Split output buffers
	outbufarr = strstr(outbufdef, "EOD");

	// WARNING ---outbufarr and outbufdef can be null
	// Added Check for Valid Header in Buffer
	if (outbufdef){
		if (!strncmp("FLIGHTID", outbufdef, 8)){
			// Build VO's
			PlannedDepVO = ProcessPlannedDeps(outbufdef, id);
		}else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) outbufdef was INVALID, missing expected header <%s>\n", cdwThreadId, outbufdef);
		}
	}else{
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) outbufdef was NULL, url <%s>\n", cdwThreadId, url);
	}
	//
	// Check to make sure we have a pointer 
	//
	if (outbufarr) {
		outbufarr += 4;
		// Added Check for Valid Header in Buffer
		if (!strncmp("FLIGHTID", outbufarr, 8)){
			PlannedArrVO = ProcessPlannedArrs(outbufarr, id);
		}else{
			vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) outbufarr was INVALID, missing expected header <%s>\n", cdwThreadId, outbufarr);
		}
	} else {
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) outbufarr was NULL, url <%s>\n", cdwThreadId, url);
	}
	// Copy VO's 
	EnterCriticalSection(&id->m_csPlanned);
	// Check if replay status has changed since we started downloading
	if (replay_status == id->m_bReplayStatus)
	{
		// No change, copy into shared pointers
		if (PlannedDepVO)
		{
			PrevVO = (VO*)id->m_pPlannedDepVO;
			id->m_pPlannedDepVO = PlannedDepVO;
			if (PrevVO)
			{
				vo_free(PrevVO); // remove the prior data		
				PrevVO = NULL;
			}
		}

		if (PlannedArrVO)
		{
			PrevVO = (VO*)id->m_pPlannedArrVO;
			id->m_pPlannedArrVO = PlannedArrVO;
			if (PrevVO)
			{
				vo_free(PrevVO); // remove the prior data		
				PrevVO = NULL;
			}
		}
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Arrival and Departure VO's (re)created.\n", cdwThreadId);
	}else{
		// Change, just release ALL of them.
		if (id->m_pPlannedDepVO){
			vo_free(id->m_pPlannedDepVO);
			id->m_pPlannedDepVO = NULL;
		}
		if (id->m_pPlannedArrVO){
			vo_free(id->m_pPlannedArrVO);
			id->m_pPlannedArrVO = NULL;
		}
		if (PlannedDepVO){
			vo_free(PlannedDepVO);
			PlannedDepVO = NULL;
		}
		if (PlannedArrVO){
			vo_free(PlannedArrVO);
			PlannedArrVO = NULL;
		}

		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Arrival and Departure VO's ignored, replay status changed STATUS<EXP %d, CUR %d>.\n",
			cdwThreadId, replay_status, id->m_bReplayStatus);
	}
	LeaveCriticalSection(&id->m_csPlanned);

	free(outbufdef);

	return(SUCCEED);
}



void GetDMXVO(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	int pflag = 0;
	VO* DMXVO = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();
	char *servername;

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */


	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=RdDiversions");

	servername = GetPulseSrvr(id);
	// temp , get from test server
	servername = "https://www3.passur.com/fcgi/PulseTrack2.fcg";

	if (!GetCurlFormGetResults(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get ETA data from %s, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return;
	}

	if (chunk.memory){
		ProcessDMX(id, chunk.memory);
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No ETA data returned from server\n", cdwThreadId);
	}

}




VO *GetETAs(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char username[VO_NAME_SIZE], urltime[VO_NAME_SIZE];
	static int firsttime = 1;
	time_t secs;
	int pflag = 0;
	struct timeb start_time, done_time;
	VO* ETAVO = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	strcpy_s(username, VO_NAME_SIZE, id->m_strCurluser);
	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=RdETAs&arpt=%s&lastcmdtime=%s&username=%s&pwd=%s&pulse_arpt_code=%s&uselocaltime=1", id->m_sCurLayout.m_strPassurArpt,
		urltime, username, id->m_strCurlpwd, pulse_db_arpt);
	if (pflag){
		printf("GetETAs, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	}
	if (timeflag){ ftime(&start_time); }

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), tmpstr);

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get ETA data from %s, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return(NULL);
	}
	if (timeflag) {
		ftime(&done_time);
	}

	if (chunk.memory){
		ETAVO = ProcessETAs(chunk.memory);
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No ETA data returned from server\n", cdwThreadId);
	}

	return(ETAVO);
}




unsigned _stdcall FDOThread(PVOID pvoid)
{
	static int FDOThreadCount;
	struct InstanceData* id = (struct InstanceData*)pvoid;
	extern void GetFDOData(struct InstanceData* id);
	static int loop_wait_msecs = 120000; // two minutes
	static int first_time_wait_msecs = 1000;
	int waittime_msecs;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Created\n", GetCurrentThreadId(), id->m_nControlId, FDOThreadCount++);

	waittime_msecs = first_time_wait_msecs;
	while (WAIT_TIMEOUT == WaitForSingleObject(id->m_evShutdown, waittime_msecs)){ // load every 2 minutes
		GetFDOData(id);
		
		waittime_msecs = loop_wait_msecs;
	}
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Terminated\n", GetCurrentThreadId(), id->m_nControlId, FDOThreadCount++);
	_endthreadex(0);
	return 0;
}


/*unsigned _stdcall FDOThread(PVOID pvoid)
{
	static int FDOThreadCount;
	struct InstanceData* id = (struct InstanceData*)pvoid;
	extern void GetFDOData(struct InstanceData* id);
	static int loop_wait_msecs = 120000; // two minutes
	static int first_time_wait_msecs = 1000;
	int waittime_msecs;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Created\n", GetCurrentThreadId(), id->m_nControlId, FDOThreadCount++);

	waittime_msecs = first_time_wait_msecs;
	while (WAIT_TIMEOUT == WaitForSingleObject(id->m_evShutdown, waittime_msecs)){ // load every 2 minutes
		GetFDOData(id);
		
		waittime_msecs = loop_wait_msecs;
	}
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Terminated\n", GetCurrentThreadId(), id->m_nControlId, FDOThreadCount++);
	_endthreadex(0);
	return 0;
}*/


unsigned _stdcall SysAlertsThread(PVOID pvoid)
{
	static int SAThreadCount;
	struct InstanceData* id = (struct InstanceData*)pvoid;
	extern void GetSysAlertsData(struct InstanceData* id);
	static int loop_wait_msecs = 120000; // two minutes
	static int first_time_wait_msecs = 1000;
	int waittime_msecs;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Created\n", GetCurrentThreadId(), id->m_nControlId, SAThreadCount++);

	waittime_msecs = first_time_wait_msecs;
	while (WAIT_TIMEOUT == WaitForSingleObject(id->m_evShutdown, waittime_msecs)){ // load every 2 minutes
		GetSysAlertsData(id);

//		waittime_msecs = loop_wait_msecs;
		waittime_msecs = 1;
	}
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Terminated\n", GetCurrentThreadId(), id->m_nControlId, SAThreadCount++);
	_endthreadex(0);
	return 0;
}





StartFDOThread(struct InstanceData* id)
{
	static int FDOThreadStarted;

	if (!hFDOMutex){
		hFDOMutex = CreateMutex(NULL, FALSE, NULL);
	}


	if ((!FDOThreadStarted  && hFDOMutex) || id->m_bOnRefresh){
		RegisterThreadHandle(id, _beginthreadex(NULL, 0, FDOThread, id, 0, NULL), "FDOThread");
		FDOThreadStarted = TRUE;
	}


	// allow the thread to reload when it wants to
	ReleaseMutex(hFDOMutex);

}

StartSysAlertsThread(struct InstanceData* id)
{
	static int SysAlertsThreadStarted;

	if (!hSAMutex){
		hSAMutex = CreateMutex(NULL, FALSE, NULL);
	}


	if ((!SysAlertsThreadStarted  && hSAMutex) || id->m_bOnRefresh){
		RegisterThreadHandle(id, _beginthreadex(NULL, 0, SysAlertsThread, id, 0, NULL), "SysAlertsThread");
		SysAlertsThreadStarted = TRUE;
	}


	// allow the thread to reload when it wants to
	ReleaseMutex(hSAMutex);

}

int GetCurlFormGetResults_timeout(struct InstanceData* id, struct MemoryStruct *chunk, char *url, char *postfields, enum SecureMode eMode, int logflag, long curltimeout)
{
	CURL *curl_handle;
	int ret;

	curl_handle = GetCurlHandle(id, eMode);
	if (!curl_handle) {
		return(FALSE);
	}

	setCurlTimeout(curl_handle, curltimeout);
	ret = GetCurlFormGetResults_r(id, curl_handle, chunk, url, postfields, eMode, logflag);

	curl_easy_cleanup(curl_handle);

	return(ret);
}



void GetFDOData(struct InstanceData* id)
{
	struct MemoryStruct chunk, chunk2;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char  urltime[VO_NAME_SIZE];
	static int firsttime = 1;
	time_t secs;
	int pflag = 0;
	struct timeb start_time, done_time;
	int len = 0, trycount = 0, ret;
	const DWORD cdwThreadId = GetCurrentThreadId();
	char *pwd, *usrname, *servername, *airline;

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	usrname = id->m_strUserName;

	airline = "NONE";
	if (HavePermission(id, "FPES")){
		airline = "DAL";
	}
	else if (HavePermission(id, "UALDATA")){
		airline = "UAL";
	}

	pwd = "XXYY22"; // hardwired password since WT does not get passed pwd from javascript. Server will use this password to override for all users with permissions

	if (!strcmp(airline, "UAL")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=FDODataZipUAL&username=%s&pwd=%s", usrname, pwd);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	}
	else if (!strcmp(airline, "DAL")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=FDODataZip&username=%s&pwd=%s", usrname, pwd);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	}
	else {
		// airline = "NONE";
		sprintf_s(tmpstr, TMPBUF_SIZE, "Action=FDODataZipBasic&username=%s&pwd=%s", usrname, pwd);
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	}

	if (timeflag){ ftime(&start_time); }

	servername = GetPulseSrvr(id);
	//servername = "https://www54.passur.com/fcgi/PulseTrack.fcg";
	//servername = GetOrlandoPulseSrvr(id);
	
	// get next server in list so we load balance amoung all servers
	servername = GetNxtOrlandoPulseSrvr(id);
	servername = "https://www54.passur.com/fcgi/PulseTrack7.fcg";

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, servername, tmpstr);

	do {
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */

		if (!GetCurlFormGetResults_timeout(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE, 45L)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FDO data from %s%s, switching srvrs to %s and trying again.\n",
				cdwThreadId, servername, tmpstr, servername);
			// try again
		}
		else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, found %d bytes\n",
				chunk.size);
			break;
		}
	} while (trycount++ < 3);



#ifdef OLD_NO_TIMEOUT
	do {
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */
		if (!GetCurlFormGetResults(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FDO data from %s%s, switching srvrs to %s and trying again.\n",
				cdwThreadId, servername, tmpstr, servername);
			// try again
		}
		else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, found %d bytes\n",
				chunk.size);
			break;
		}
	} while (trycount++ < 3);
#endif

	if (trycount >= 3){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FDO data from %s%s, giving up for now and returning\n",
			cdwThreadId, servername, tmpstr);
		return;
	}


	if (timeflag) {
		ftime(&done_time);
	}
	sprintf_s(tmpstr, TMPBUF_SIZE, "%g", uts_timediff(&start_time, &done_time));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, calling ProcessFDOData with %d bytes of data, time=%s\n", chunk.size, tmpstr);

	if (chunk.memory && chunk.size > 500 ){
		D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FDO DATA:'\n%s\n", cdwThreadId, chunk.memory));

		if (chunk.memory) {
			// unzip from chunk2 into chunk
			chunk2 = chunk;
			chunk.memory = NULL;
			ret = unzip_chunk(id, &chunk2, &chunk);
			if (ret != SUCCEED) {
				if (chunk.memory) free(chunk.memory);
				chunk.memory = NULL;
			}
			free(chunk2.memory);
			chunk2.memory = NULL;
		}
		if (!strcmp(airline, "UAL")){
			ProcessUALFDOData(id, chunk.memory);
		}
		else if (!strcmp(airline, "DAL")){
			ProcessFDOData(id, chunk.memory);
		}
		else {
			ProcessBasicFDOData(id, chunk.memory);
		}

		free(chunk.memory);
	}
	else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No FDO data returned from server\n", cdwThreadId);
	}
}



void GetSysAlertsData(struct InstanceData* id)
{
	struct MemoryStruct chunk, chunk2;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char  urltime[VO_NAME_SIZE];
	static int firsttime = 1;
	time_t secs;
	int pflag = 0;
	struct timeb start_time, done_time;
	int len = 0, trycount = 0, ret;
	const DWORD cdwThreadId = GetCurrentThreadId();
	//char *pwd, *usrname,
	char *servername;

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	//usrname = id->m_strUserName;



	//wd = "XXYY22"; // hardwired password since WT does not get passed pwd from javascript. Server will use this password to override for all users with permissions

	
	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=SADataZip");
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetSysAlertsData, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime);
	

	if (timeflag){ ftime(&start_time); }

	//servername = GetPulseSrvr(id);
	servername = "https://www54.passur.com/fcgi/PulseTrack6.fcg";
	//servername = GetOrlandoPulseSrvr(id);

	// get next server in list so we load balance amoung all servers
	//servername = GetNxtOrlandoPulseSrvr(id);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, servername, tmpstr);

	do {
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */

		if (!GetCurlFormGetResults_timeout(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE, 45L)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get SysAlert data from %s%s, switching srvrs to %s and trying again.\n",
				cdwThreadId, servername, tmpstr, servername);
			// try again
		}
		else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetSysAlertsData, found %d bytes\n",
				chunk.size);
			break;
		}
	} while (trycount++ < 3);



#ifdef OLD_NO_TIMEOUT
	do {
		chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
		chunk.size = 0;    /* no data at this point */
		if (!GetCurlFormGetResults(id, &chunk, servername, tmpstr, SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get FDO data from %s%s, switching srvrs to %s and trying again.\n",
				cdwThreadId, servername, tmpstr, servername);
			// try again
		}
		else {
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetFDOData, found %d bytes\n",
				chunk.size);
			break;
		}
	} while (trycount++ < 3);
#endif

	if (trycount >= 3){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get SysAlerts data from %s%s, giving up for now and returning\n",
			cdwThreadId, servername, tmpstr);
		return;
	}


	if (timeflag) {
		ftime(&done_time);
	}
	sprintf_s(tmpstr, TMPBUF_SIZE, "%g", uts_timediff(&start_time, &done_time));
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetSysAlertsData, calling ProcessSData with %d bytes of data, time=%s\n", chunk.size, tmpstr);

	if (chunk.memory && chunk.size > 500){
		D_CONTROL("GetSysAlertsData", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) SA DATA:'\n%s\n", cdwThreadId, chunk.memory));

		if (chunk.memory) {
			// unzip from chunk2 into chunk
			chunk2 = chunk;
			chunk.memory = NULL;
			ret = unzip_chunk(id, &chunk2, &chunk);
			if (ret != SUCCEED) {
				if (chunk.memory) free(chunk.memory);
				chunk.memory = NULL;
			}
			free(chunk2.memory);
			chunk2.memory = NULL;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetSysAlertsData, uncompressed chunk %s\n",
				chunk.memory);
		}
		ProcessSysAlertsData(id, chunk.memory);
		free(chunk.memory);
	}
	else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Sys Alerts data returned from server\n", cdwThreadId);
	}
}


void GetGateData(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char username[VO_NAME_SIZE], urltime[VO_NAME_SIZE];
	char arpt[5] = { 0 };
	static int firsttime = 1;
	time_t secs;
	int pflag = 0;
	struct timeb start_time, done_time;
	int len = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	if (IS_D_CONTROL("TEST_GATES")){
		return; // Only draw Fake Gate Aircraft
	}

	strcpy_s(username, VO_NAME_SIZE, id->m_strCurluser);
	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	len = strlen(id->m_sCurLayout.m_strPassurArpt);
	if (!len)
		return;
	else if (len < 4)
		sprintf_s(arpt, 5, "K%s", id->m_sCurLayout.m_strPassurArpt);
	else
		strcpy_s(arpt, 5, id->m_sCurLayout.m_strPassurArpt);

	StrUpper(arpt);

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=GateData&arpt=%s&username=%s&pwd=%s", arpt,
		username, id->m_strCurlpwd);
	D_CONTROL("GATES", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "GetGate, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime));
	if (timeflag){ ftime(&start_time); }

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), tmpstr);

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Gate data from %s, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return;
	}
	if (timeflag) {
		ftime(&done_time);
	}

	if (chunk.memory){
		D_CONTROL("GATES_DNLD", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GATE DATA:'\n%s\n", cdwThreadId, chunk.memory));
		ProcessGateData(id, arpt, chunk.memory);
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Gate data returned from server\n", cdwThreadId);
	}
}

void GetDivertedAircraft(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();

	clear_chunk_memory(&chunk);
	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=DivertedAircraft");

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - Surf <%s> tmpstr <%s>.\n",
		cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

	if (!GetCurlFormGetResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Diverted Aircraft data from %s, switching srvrs to %s.\n",
			cdwThreadId, id->m_strHttpDBservername[id->m_nDBServerIndex], GetNxtSurfSrvr(id));
	}else if ( chunk.memory ){
		D_CONTROL("DM", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) DM DATA:'\n%s\n", cdwThreadId, chunk.memory));
		ProcessDMData(id, chunk.memory);
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Diverted Aircraft data returned from server\n", cdwThreadId);
	}
}


VO *GetTarmacDelays(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	char tmpstr[TMPBUF_SIZE];
	static char lastcmdtime[VO_NAME_SIZE];
	char username[VO_NAME_SIZE], urltime[VO_NAME_SIZE];
	char arpt[5] = { 0 };
	static int firsttime = 1;
	time_t secs;
	int pflag = 0;
	struct timeb start_time, done_time;
	VO* TDVO = NULL;
	int len = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	if (firsttime){
		secs = time(0);
		VOTimeFmt(lastcmdtime, secs, "%Y-%m-%d %H:%M:%S");
		firsttime = 0;
	}

	strcpy_s(username, VO_NAME_SIZE, id->m_strCurluser);
	memset(urltime, 0, VO_NAME_SIZE);
	urlencode(urltime, lastcmdtime, 0);

	len = strlen(id->m_sCurLayout.m_strPassurArpt);
	if (!len)
		return (NULL);
	else if (len < 4)
		sprintf_s(arpt, 5, "K%s", id->m_sCurLayout.m_strPassurArpt);
	else
		strcpy_s(arpt, 5, id->m_sCurLayout.m_strPassurArpt);

	StrUpper(arpt);

	sprintf_s(tmpstr, TMPBUF_SIZE, "Action=TarmacData&arpt=%s&username=%s&pwd=%s", arpt,
		username, id->m_strCurlpwd);
	D_CONTROL("TARMAC_DELAY", vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "GetTarmacDelays, tmpstr='%s', lastcmdtime='%s'\n", tmpstr, lastcmdtime));
	if (timeflag){ ftime(&start_time); }

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> tmpstr <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), tmpstr);

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), tmpstr, SM_HTTPS, TRUE)){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get TarmacDelay data from %s, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		return(NULL);
	}
	if (timeflag) {
		ftime(&done_time);
	}

	if (chunk.memory){
		TDVO = ProcessTDs(id, chunk.memory);
		free(chunk.memory);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No TarmacDelay data returned from server\n", cdwThreadId);
	}

	return(TDVO);
}



// Set true if you want a dialog box to request compression method
#define USE_AVI_COMP_DIALOG 0

// RecordVideo WT2.3
unsigned _stdcall RecordVideoThread(PVOID pvoid)
{
	int notDone = TRUE;
	struct InstanceData* id = (struct InstanceData*)pvoid;
	AVILIB * avip = &id->avilib;
	DWORD dwWait = WAIT_TIMEOUT;
	HANDLE arHandles[2] = { id->m_evRecVideoReset, id->m_evShutdown };
	const DWORD cdwThreadId = GetCurrentThreadId();
	time_t secs;
	struct tm tmTemp;
	BITMAPINFOHEADER * bihp = NULL;
	AVISTREAMINFOA strHdr;		// single stream info
	AVISTREAMINFOA * shp = &strHdr;
	AVICOMPRESSOPTIONS opts;
	AVICOMPRESSOPTIONS FAR * aopts[1] = { &opts };
	HRESULT hr;
	char errMsg[512];

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Record Video Thread Created\n",
		cdwThreadId, id->m_nControlId);

	memset(errMsg, 0, sizeof(errMsg));

	// Initialize the recording
	avip->m_dwRate = 1;				// Start with 1 fps

	// Init Bitmap Info Header 
	bihp = &avip->m_bih;
	bihp->biSize = sizeof(BITMAPINFOHEADER);
	bihp->biWidth = (avip->m_nVideoWidth / 4) * 4;
	bihp->biHeight = (avip->m_nVideoHeight / 4) * 4;
	bihp->biPlanes = 1;
	bihp->biBitCount = 24;
	bihp->biCompression = BI_RGB;
	bihp->biSizeImage = bihp->biWidth * bihp->biHeight * 4;
	bihp->biClrUsed = 0;
	bihp->biClrImportant = 0;

	// Open the file for recording
	secs = time(0);
	avip->m_RecStart = secs;        // Start time of the recording
	gmtime_s(&tmTemp, &secs);
	sprintf_s(avip->m_videoFileName, sizeof(avip->m_videoFileName) - 1,
		"%s\\video\\%s_%d%02d%02d_%02d%02d%02d.avi",
		id->m_strPassurOutPath, id->m_strUserName, tmTemp.tm_year + 1900,
		tmTemp.tm_mon + 1, tmTemp.tm_mday, tmTemp.tm_hour, tmTemp.tm_min,
		tmTemp.tm_sec);

	sprintf_s(errMsg, sizeof(errMsg) - 1, "RecordVideo: Success: %s", &avip->m_videoFileName[2]);

	// Init the AVI File engine
	AVIFileInit();

	// Open the file for writing
	hr = AVIFileOpen(&avip->m_pAVIFile, (LPCSTR)avip->m_videoFileName, OF_WRITE | OF_CREATE, NULL);

	if (hr == AVIERR_OK)
	{
		// Populate the video stream header
		memset(shp, 0, sizeof(strHdr));
		shp->fccType = streamtypeVIDEO;
		shp->fccHandler = 0;
		shp->dwScale = 1;				// 1 for video
		shp->dwRate = avip->m_dwRate;	// fps
		shp->dwSuggestedBufferSize = avip->m_bih.biSizeImage;
		SetRect(&shp->rcFrame, 0, 0, (int)avip->m_bih.biWidth, (int)avip->m_bih.biHeight);

		// Create the stream
		hr = AVIFileCreateStream(avip->m_pAVIFile, &avip->m_pStream, shp);

		if (hr == AVIERR_OK)
		{
			memset(&opts, 0, sizeof(opts));

			if (USE_AVI_COMP_DIALOG)
			{
				if (!AVISaveOptions(NULL, 0, 1, &avip->m_pStream, (LPAVICOMPRESSOPTIONS FAR *) &aopts))
				{
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
						"(0x%X):[%d] Record Video: User canceled Video options dialog box\n",
						cdwThreadId, id->m_nControlId);

					// Unable to fetch options
					AVISaveOptionsFree(1, (LPAVICOMPRESSOPTIONS FAR *) &aopts);
					hr = S_FALSE;
				}
			}
			else
			{
				// Set codec to Microsoft Video 1
				opts.fccHandler = mmioFOURCC('M', 'S', 'V', 'C');
				opts.dwQuality = 7500;
				opts.dwFlags = AVICOMPRESSF_VALID;
				hr = AVIERR_OK;
			}

			// Proceed if we have coded options selected
			if (hr == AVIERR_OK)
			{
				// Create a compressed stream using codec
				hr = AVIMakeCompressedStream(&avip->m_pStreamCompressed, avip->m_pStream, &opts, NULL);

				if (hr == AVIERR_OK)
				{
					// Set the stream format
					hr = AVIStreamSetFormat(avip->m_pStreamCompressed, 0, &avip->m_bih,
						avip->m_bih.biSize + avip->m_bih.biClrUsed * sizeof(RGBQUAD));

					if (hr == AVIERR_OK)
					{
						// Tell RenderScene() to start grabbing the video
						avip->m_bRecordVideo = TRUE;

						// Frame counter
						avip->m_lFrame = 0;

						// Record every second until a stop request.
						notDone = TRUE;
						do
						{
							dwWait = WaitForMultipleObjects(sizeof(arHandles) / sizeof(HANDLE), arHandles, FALSE, 1000);
							if (WAIT_TIMEOUT == dwWait)
							{
								// Check to see if we have started recording data yet
								if (avip->m_bVideoBufferReady)
								{
									// Write out next frame
									hr = AVIStreamWrite(
										avip->m_pStreamCompressed,	// stream pointer
										avip->m_lFrame,				// time of this frame
										1,							// number to write
										avip->m_pVideoBuffer,		// video buffer
										avip->m_bih.biSizeImage,	// size of frame
										AVIIF_KEYFRAME,
										NULL, NULL);

									if (hr != AVIERR_OK)
									{
										vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
											"(0x%X):[%d] Record Video: AVIStreamWrite Error:%ld\n",
											cdwThreadId, id->m_nControlId, hr);
										sprintf_s(errMsg, _countof(errMsg), "RecordVideo: Error: AVIStreamWrite Error %ld", hr);
										notDone = FALSE;
									}
									else
									{
										// Allow RenderScene() to fetch the next buffer 
										avip->m_bVideoBufferReady = FALSE;
									}

									avip->m_lFrame++;		// update frame counter

									// Stop recording if we reached the max record duration.
									if (avip->m_lRecDurSec > 0)
									{
										secs = time(0);
										if (secs >= (avip->m_RecStart + avip->m_lRecDurSec))
											notDone = FALSE;
									}
								}
							}

						} while (WAIT_TIMEOUT == dwWait && notDone == TRUE);

					}
					else
					{
						// AVI Compressed stream format setting failed
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
							"(0x%X):[%d] Record Video: AVIStreamSetFormat Error:%ld\n",
							cdwThreadId, id->m_nControlId, hr);
						sprintf_s(errMsg, _countof(errMsg), "RecordVideo: Error: AVIStreamSetFormat Error %ld", hr);
					}

					// Release the compressed stream
					if (avip->m_pStreamCompressed)
					{
						AVIStreamRelease(avip->m_pStreamCompressed);
						avip->m_pStreamCompressed = NULL;
					}
				}
				else
				{
					// Unable to make a compressed stream
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
						"(0x%X):[%d] Record Video: AVIMakeCompressedStream Error:%ld\n",
						cdwThreadId, id->m_nControlId, hr);
					sprintf_s(errMsg, _countof(errMsg), "RecordVideo: Error: AVIMakeCompressedStream Error %ld", hr);
				}

				// Did we popup a dialog to fetch the compress option
				if (USE_AVI_COMP_DIALOG)
				{
					// Release memory allocated by AVISaveOptions()
					hr = AVISaveOptionsFree(1, (LPAVICOMPRESSOPTIONS FAR *) &aopts);
					if (hr != AVIERR_OK)
					{
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
							"(0x%X):[%d] Record Video: Unable to free Save Options memory\n",
							cdwThreadId, id->m_nControlId);
					}
				}
			}

			// Release AVI streams
			if (avip->m_pStream)
			{
				AVIStreamRelease(avip->m_pStream);
				avip->m_pStream = NULL;
			}
		}
		else
		{
			// Stream creation failed
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X):[%d] Record Video: AVICreateStream Error:%ld\n",
				cdwThreadId, id->m_nControlId, hr);
			sprintf_s(errMsg, _countof(errMsg), "RecordVideo: Error: AVICreateStream Error %ld", hr);
		}

		// Close video file
		if (avip->m_pAVIFile)
		{
			AVIFileRelease(avip->m_pAVIFile);
			avip->m_pAVIFile = NULL;
		}
	}
	else
	{
		// Error opening AVI File
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X):[%d] Record Video: AVIFileOpen Error:%ld\n",
			cdwThreadId, id->m_nControlId, hr);
		sprintf_s(errMsg, _countof(errMsg), "RecordVideo: Error: AVIFileOpen Error %ld", hr);
	}

	// Close the AVI File engine
	AVIFileExit();

	// Notify the HTML layer that we are done and of any errors
	Callback2Javascript(id, errMsg);

	// Free the screen buffer
	if (avip->m_pVideoBuffer)
	{
		free(avip->m_pVideoBuffer);
		avip->m_pVideoBuffer = NULL;
	}

	// Stop recording button pressed (or simulated)
	avip->m_bRecordVideoButton = FALSE;

	// Exit request
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Record Video Thread Terminated\n", cdwThreadId, id->m_nControlId);
	_endthreadex(0);

	return 0;
}



void UpdateTarmacVO(struct InstanceData* id)
{
	int i;
	char *DataSource;
	MGLGRID *TarmacGrid = NULL;
	VO *DataAppVO;


	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	if (!DataAppGrid || !(DataAppVO = DataAppGrid->vo)) return;
	// find tarmac grids
	for (i = 0; i < DataAppVO->count; i++){
		DataSource = VP(DataAppVO, i, "DataSource", char);
		if (!strcmp(DataSource, "Tarmac")){
			TarmacGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
		}
	}

	if (!TarmacGrid){
		// no grid activated yet
		return;
	}
	TarmacGrid->vo = id->m_pTDVO;

	CrFilteredGrid(id, TarmacGrid);
	MGLSortFilteredGrid(TarmacGrid);

}


unsigned _stdcall ETAThread(PVOID pvoid)
{
	CURL* curl_handle = NULL;
	VO *PrevVO = NULL;
	struct InstanceData* id = (struct InstanceData*)pvoid;
	VO *ETAVO = NULL;
	VO *TDVO = NULL;
	DWORD dwWait = WAIT_TIMEOUT;
	HANDLE arHandles[2] = { id->m_evPlannedReset, id->m_evShutdown };
	const DWORD cdwThreadId = GetCurrentThreadId();
	static int bGateData = TRUE;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] ETA Thread Created\n", cdwThreadId, id->m_nControlId);

	// Dev & Test, allows us to turn of Gate Retrieval Data
	if( IS_D_CONTROL( "DISABLE_GATEDATA" ) )
		bGateData = FALSE;

	// MHM 14jan2011:  Increased timeout to 60 seconds (was 6)
	do
	{
		// query to get the data before entering critical area
		ETAVO = GetETAs(id);
		if (ETAVO)
		{
			EnterCriticalSection(&id->m_csEta);
			PrevVO = (VO*)id->m_pETAVO;
			id->m_pETAVO = ETAVO;
			LeaveCriticalSection(&id->m_csEta);
			vo_free(PrevVO); // remove the prior data		
			PrevVO = NULL;
		}

#ifdef ADD_TARMAC
		GetDMXVO(id);

		TDVO = GetTarmacDelays(id);

		if (TDVO)
		{
			EnterCriticalSection(&id->m_csEta);
			PrevVO = (VO*)id->m_pTDVO;
			id->m_pTDVO = TDVO;
			UpdateTarmacVO(id);  // give the vo info to the Tarmac Grid tool
			LeaveCriticalSection(&id->m_csEta);
			vo_free(PrevVO);
			PrevVO = NULL;
		}
#endif

		if( bGateData )
			GetGateData(id);

		// Build curl handle for getting Arrivals and Departure info
		if (!curl_handle) {
			curl_handle = GetCurlHandle(id, SM_HTTPS);
			if (!curl_handle)
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Calling GetCurlHandle() failed\n", cdwThreadId);
		}

		GetPlannedArrDepVO(id, curl_handle);

		GetDivertedAircraft(id);

		// Check for signal to restart or quit
		dwWait = WaitForMultipleObjects(sizeof(arHandles) / sizeof(HANDLE), arHandles, FALSE, 60000);
		if (WAIT_OBJECT_0 == dwWait){
			ResetEvent(id->m_evPlannedReset);
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) ETA Thread awoken for ResetTracks.\n", cdwThreadId);
		}
	} while (WAIT_TIMEOUT == dwWait || WAIT_OBJECT_0 == dwWait);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] ETA Thread Terminated\n", cdwThreadId, id->m_nControlId);
	_endthreadex(0);
	return 0;
}

void FAACurlXMLGet(struct InstanceData* id)
{
	int xmlsize = 0;
	struct MemoryStruct chunk;
	int trycount = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();


	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> STRING <%s>.\n",
		cdwThreadId, GetPulseSrvr(id), "Action=DelayAirportStatus");

	if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), "Action=DelayAirportStatus", SM_HTTPS, TRUE))	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Delay Airport Status data from %s, switching srvrs to %s and trying again.\n",
			cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));

	} else {
		if (chunk.memory){
			ProcessFAAXML(id, chunk.memory, chunk.size);
			free(chunk.memory);
			chunk.memory = NULL;
			return;
		} else {
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Delay Airports data returned from server\n", cdwThreadId);
		}
	}
}

unsigned _stdcall FAAThread(PVOID pvoid)
{
	static int FAAThreadCount;
	struct InstanceData* id = (struct InstanceData*)pvoid;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Created\n", GetCurrentThreadId(), id->m_nControlId, FAAThreadCount++);
	while (WAIT_TIMEOUT == WaitForSingleObject(id->m_evShutdown, 6000)){
		FAACurlXMLGet(id);
	}
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Thread %d Terminated\n", GetCurrentThreadId(), id->m_nControlId, FAAThreadCount++);
	_endthreadex(0);
	return 0;
}


VO *ProcessDelayArpts(struct InstanceData* id, char *membuf, int memsize)
{
	int matches, len;
	char linebuf[256];
	char *eolstr;
	char arptcode[256];
	char region[32];
	VO *DelayArptsVO = NULL;
	int i;


	while (membuf && memsize){
		if ((eolstr = strchr(membuf, '\n'))){
			len = eolstr - membuf;
			if (len > 31){
				break;  // some problem with the data
			}
			strncpy_s(linebuf, _countof(linebuf), membuf, len);
			linebuf[len] = '\0';

			membuf = eolstr;
			membuf++; /* skip over eol char */

			matches = sscanf_s(linebuf, "%s %s", arptcode, _countof(arptcode), region, _countof(region));
			if (matches == 2){
				if (!DelayArptsVO){
					DelayArptsVO = (VO *)vo_create(0, NULL);
					vo_set(DelayArptsVO, V_NAME, "DelayArptsVO", NULL);

					VOPropAdd(DelayArptsVO, "code", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					VOPropAdd(DelayArptsVO, "region", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
					VOPropAdd(DelayArptsVO, "colorcode", INTBIND, -1, VO_NO_ROW);
					VOPropAdd(DelayArptsVO, "StatusStr", VOIDBIND, -1, VO_NO_ROW);
					VOPropAdd(DelayArptsVO, "xpix", INTBIND, -1, VO_NO_ROW);
					VOPropAdd(DelayArptsVO, "ypix", INTBIND, -1, VO_NO_ROW);


					vo_rm_rows(DelayArptsVO, 0, DelayArptsVO->count);
				}
				vo_alloc_rows(DelayArptsVO, 1);

				strncpy_s(VP(DelayArptsVO, DelayArptsVO->count - 1, "code", char), ARPT_CODE_SIZE, arptcode, _TRUNCATE);
				strncpy_s(VP(DelayArptsVO, DelayArptsVO->count - 1, "region", char), ARPT_CODE_SIZE, region, _TRUNCATE);
			}
		} else {
			membuf = NULL;
		}
	}


	/* sort the array by code */
	vo_set(DelayArptsVO, V_ORDER_COLS, "code", NULL, NULL);
	vo_order(DelayArptsVO);

	if (IS_D_CONTROL("FAA_STATUS")){
		for (i = 0; DelayArptsVO && i < DelayArptsVO->count; i++){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) code[%d] =%s r=%s\n", GetCurrentThreadId(), i,
				VP(DelayArptsVO, i, "code", char), VP(DelayArptsVO, i, "region", char));
		}
	}

	return(DelayArptsVO);
}

VO *GetDelayArpts(struct InstanceData* id)
{
	struct MemoryStruct chunk;
	int trycount = 0;
	static int PrevTrackID;
	VO *DelayArpts = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	while (trycount++ < 3){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormGetResults - CurrentPulseServer <%s> STRING <%s>.\n",
			cdwThreadId, GetPulseSrvr(id), "Action=DelayAirports");

		if (!GetCurlFormGetResults(id, &chunk, GetPulseSrvr(id), "Action=DelayAirports", SM_HTTPS, TRUE)){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not get Delay Airport data from %s, switching srvrs to %s and trying again.\n",
				cdwThreadId, GetPulseSrvr(id), GetNxtPulseSrvr(id));
		} else {
			if (chunk.memory){
				DelayArpts = ProcessDelayArpts(id, chunk.memory, chunk.size);
				free(chunk.memory);
				chunk.memory = NULL;
				return(DelayArpts);
			} else {
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) No Delay Airports data returned from server\n", cdwThreadId);
			}
		}
	}

	return(NULL);
}

AdjustArpt(char *arpt, int *xpixelptr, int *ypixelptr)
{

	// need to move some close together airports so they don't overlap at larger distances

	if (!strcmp(arpt, "SJC")){
		// *xpixelptr -= 20;
		*ypixelptr -= 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "EWR")){
		*xpixelptr -= 15;
		// *ypixelptr -= 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "TEB")){
		*xpixelptr -= 10;
		*ypixelptr += 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "LGA")){
		*ypixelptr += 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "IAD")){
		// *xpixelptr -= 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "DCA")){
		*xpixelptr += 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "BWI")){
		// *xpixelptr += 10;
		*ypixelptr += 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "TPA")){
		// *xpixelptr += 10;
		// *ypixelptr += 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "MIA")){
		// *xpixelptr += 10;
		*ypixelptr -= 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "ORD")){
		// *xpixelptr -= 10;
		*ypixelptr += 5;
		return(TRUE);
	}


	return(FALSE);
}




AdjustArptLabel(char *arpt, int *xpixelptr, int *ypixelptr)
{

	if (!strcmp(arpt, "SJC")){
		*xpixelptr -= 30;
		*ypixelptr -= 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "EWR")){
		*xpixelptr -= 50;
		*ypixelptr -= 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "TEB")){
		*xpixelptr -= 40;
		*ypixelptr += 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "LGA")){
		//*xpixelptr += 10;
		*ypixelptr += 15;
		return(TRUE);
	}
	if (!strcmp(arpt, "IAD")){
		*xpixelptr -= 25;
		*ypixelptr -= 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "DCA")){
		*xpixelptr += 35;
		*ypixelptr -= 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "BWI")){
		*xpixelptr -= 30;
		*ypixelptr += 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "TPA")){
		*xpixelptr -= 30;
		// *ypixelptr += 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "MIA")){
		*xpixelptr -= 30;
		*ypixelptr -= 15;
		return(TRUE);
	}
	if (!strcmp(arpt, "JFK")){
		*xpixelptr += 10;
		*ypixelptr -= 10;
		return(TRUE);
	}
	if (!strcmp(arpt, "ORD")){
		*xpixelptr -= 35;
		// *ypixelptr -= 5;
		return(TRUE);
	}
	if (!strcmp(arpt, "PIT")){
		*xpixelptr -= 35;
		// *ypixelptr -= 5;
		return(TRUE);
	}



	return(FALSE);
}


void ProcessETAPassurTracks(struct InstanceData* id)
{
	int i, eta;
	char *flightid;
	VO* ETAVO = NULL;

	if (id->m_nDelaySecs){
		// if we are in replay mode, don't use current portal etas
		return;
	}

	if (TryEnterCriticalSection(&id->m_csEta)){
		ETAVO = (VO*)id->m_pETAVO;
		for (i = 0; ETAVO && i < ETAVO->count; i++){
			flightid = VP(ETAVO, i, "FltNum", char);
			// see if we already have this flight in passur

			if (flightid && strlen(flightid) &&
				-1 == GetIndex(id, id->m_pPassurIndexMap, flightid, 0, 0, PASSUR)){
				// found a flightid not in passur, probably already landed
				// check eta to see if it is close to landing
				eta = VV(ETAVO, i, "eta", int);
				if (eta - id->m_tPlotTime > 900){
					// aircraft not due for more than 15 minutes, so don't add
					continue;
				}

				AddIndex(id, id->m_pPassurIndexMap, flightid, 0, 0, -1, PASSUR);
			}
		}
		LeaveCriticalSection(&id->m_csEta);
	}
}





int MkASDDirs(struct InstanceData* id, char *PassurOutPath, int year, int month, int day, int hour)
{
	char dirname[256];
	const DWORD cdwThreadId = GetCurrentThreadId();

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s", PassurOutPath);
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
	}

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s\\data", PassurOutPath);
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
	}

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s\\data\\%s", PassurOutPath, "asd");
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
	}

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s\\data\\%s\\%d", PassurOutPath, "asd", year);
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
	}

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s\\data\\%s\\%d\\%d", PassurOutPath, "asd", year, month);
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
	}

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s\\data\\%s\\%d\\%d\\%d", PassurOutPath, "asd", year, month, day);
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
	}

	_snprintf_s(dirname, _countof(dirname), _TRUNCATE, "%s\\data\\%s\\%d\\%d\\%d\\%02d", PassurOutPath, "asd", year, month, day, hour);
	if (_mkdir(dirname) != 0)
	{
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not create directory '%s'\n", cdwThreadId, dirname);
		return(FALSE);
	}
	return(TRUE);
}


FILE *OpenASDOutFile(struct InstanceData* id, char *LastZipName)
{
	char txtname[256];
	char *str;
	int len;
	FILE *f;
	int year, month, day, hour;

	// directory format   C:\Documents and Settings\All Users\Documents\Passur\data\YYYY\MM\DD\HH\MMSS.txt

	str = &LastZipName[5];
	sscanf_s(str, "%d/%d/%d/%d/%s", &year, &month, &day, &hour, txtname, _countof(txtname));

	if ((str = strstr(txtname, ".zip"))){
		len = str - txtname;
		strcpy_s(&txtname[len], _countof(txtname), ".txt");
	}


	_snprintf_s(id->m_strASDSharedFilename, 256, _TRUNCATE, "%s\\data\\%s\\%d\\%d\\%d\\%d\\%s", id->m_strPassurOutPath, "asd", year, month, day, hour,
		txtname);

	if (fopen_s(&f, id->m_strASDSharedFilename, "wb")){
		// could not open, so make sure directories have been created

		MkASDDirs(id, id->m_strPassurOutPath, year, month, day, hour);

		if (fopen_s(&f, id->m_strASDSharedFilename, "wb")){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open '%s'\n", GetCurrentThreadId(), id->m_strASDSharedFilename);
			return(NULL);
		}
	}

	return(f);
}

int compareFlt(char **arg1, char **arg2)
{
	//char *str1, *str2;
	/* Compare all of both strings: */
	//str1 = *arg1;
	//str2 = *arg2;

	return _strcmpi(*arg1, *arg2);
}


int ADSBHasBeacon(struct InstanceData* id, int beacon)
{
	struct row_index *row_index;
	char tmpstr[5];

	// check all asdex values to see if we have a matching beacon


	_snprintf_s(tmpstr, 5, _TRUNCATE, "%04o", beacon);
	tmpstr[4] = '\0';

	if (id->m_pADSBBeaconVO && (row_index = (struct row_index *) vo_search(id->m_pADSBBeaconVO, "beaconstr", tmpstr, NULL))){
		return(TRUE);
	}

	return(FALSE);
}

int ASDEXHasBeacon(struct InstanceData* id, int beacon)
{
	struct row_index *row_index;
	char tmpstr[5];

	// check all asdex values to see if we have a matching beacon


	_snprintf_s(tmpstr, 5, _TRUNCATE, "%04o", beacon);
	tmpstr[4] = '\0';

	if (id->m_pASDEXBeaconVO && (row_index = (struct row_index *) vo_search(id->m_pASDEXBeaconVO, "beaconstr", tmpstr, NULL))){
		return(TRUE);
	}

	return(FALSE);
}




void FillDestOrigFix(struct InstanceData* id, int i, AIR** airp)
{
	AIR *air;
	struct row_index *row_index;
	char *fltnum_arr = NULL, *fltnum_dep = NULL;
	char *destin_dep = NULL, *orig_dep = NULL;
	char *destin_arr = NULL, *orig_arr = NULL;
	char *gate_arr = NULL, *gate_dep = NULL;
	char *runway_arr = NULL, *runway_dep = NULL;
	int outsecs_dep = -999, onsecs_arr = -999, etasecs_arr = -999, std_dep = -999, sta_arr = -999;
	int plotsecs;
	char *dfix = NULL, *afix = NULL;
	char outtimebuf[64], ontimebuf[64], etatimebuf[64];
	int use_arrivals;
	int found = FALSE;
	const DWORD cdwThreadId = GetCurrentThreadId();

	plotsecs = id->m_tPlotTime;
	// Exit function if the air pointer does not exist or the flight id is untraceable into the arr/dep VO's
	if (!(air = airp[i]) || !strcmp(air->FltNum, "UNKN") || !strcmp(air->FltNum, "ANON"))
	{
		return;
	}

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (1a) i <%d> airp <%x> air <%x>.\n", cdwThreadId, i, airp, air));

	if (id->m_pPlannedDepVO && (row_index = vo_search((VO*)id->m_pPlannedDepVO, "FltNum", (char *)air->FltNum, NULL))){
		found = TRUE;
		fltnum_dep = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "FltNum", char);
		destin_dep = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "Destin", char);
		orig_dep = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "Origin", char);
		dfix = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "DFix", char);
		outsecs_dep = VV((VO*)id->m_pPlannedDepVO, row_index->rownum, "outsecs", int);
		std_dep = VV((VO*)id->m_pPlannedDepVO, row_index->rownum, "stdsecs", int);
		gate_dep = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "gate", char);
		runway_dep = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "runway", char);
	}

	if (id->m_pPlannedArrVO && (row_index = vo_search((VO*)id->m_pPlannedArrVO, "FltNum", (char *)air->FltNum, NULL))){
		found = TRUE;
		fltnum_arr = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "FltNum", char);
		destin_arr = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "Destin", char);
		orig_arr = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "Origin", char);
		afix = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "AFix", char);
		onsecs_arr = VV((VO*)id->m_pPlannedArrVO, row_index->rownum, "onsecs", int);
		etasecs_arr = VV((VO*)id->m_pPlannedArrVO, row_index->rownum, "etasecs", int);
		sta_arr = VV((VO*)id->m_pPlannedArrVO, row_index->rownum, "stasecs", int);
		gate_arr = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "gate", char);
		runway_arr = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "runway", char);
	}

	if (!found){
		// Neither VO had data for this flight id, no need to process further.
		return;
	}

	VOTimeFmt(outtimebuf, outsecs_dep, "%Y-%m-%d %H:%M:%S");
	VOTimeFmt(ontimebuf, onsecs_arr, "%Y-%m-%d %H:%M:%S");
	VOTimeFmt(etatimebuf, etasecs_arr, "%Y-%m-%d %H:%M:%S");
	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (1b) outsecs_dep '%s' <%d> onsecs_arr '%s' <%d>. etasecs_arr '%s' <%d>\n",
		cdwThreadId, outtimebuf, outsecs_dep, ontimebuf, onsecs_arr, etatimebuf, etasecs_arr));
	if (abs(outsecs_dep - plotsecs) < abs(onsecs_arr - plotsecs)){
		D_CONTROL("FIL-TAG", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (1c) Departure time in future outsecs_dep <%d> onsecs_arr <%d>.\n", cdwThreadId, outsecs_dep, onsecs_arr));
	}

	if (etasecs_arr > 0 && plotsecs < (etasecs_arr + 1800)){
		use_arrivals = TRUE;
	} else if ( (outsecs_dep > 0 || onsecs_arr > 0 ) && (abs(outsecs_dep - plotsecs) < abs(onsecs_arr - plotsecs)) ){
		use_arrivals = FALSE;
	} else if ( (std_dep > 0 || sta_arr > 0 ) && (abs(std_dep - plotsecs) < abs(sta_arr - plotsecs))){
		use_arrivals = FALSE;  // closer to std_dep, so use dep info
	} else {
		use_arrivals = TRUE;
	}

	if (use_arrivals == FALSE){
		// OUT time closer, use departure information
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2a use departure information).\n", cdwThreadId));
		if (destin_dep && strlen(destin_dep) && strcmp(destin_dep, "null")) {
			strncpy_s(air->Destin, ORIG_DES_SIZE + 1, destin_dep, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile,
				__FUNCTION__, "(0x%X) (3a) air->FltNum <%s>, destin <%s>.\n", cdwThreadId, air->FltNum, destin_dep));
		}
		if (orig_dep && strlen(orig_dep) && strcmp(orig_dep, "null")) {
			strncpy_s(air->Origin, ORIG_DES_SIZE + 1, orig_dep, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3b) air->FltNum <%s>, orig <%s>.\n", cdwThreadId, air->FltNum, orig_dep));
		}
		if (dfix && strlen(dfix) && strcmp(dfix, "null")) {
			strncpy_s(air->DepartureFix, DEP_FIX_SIZE, dfix, _TRUNCATE);
			D_CONTROL("FIL-TAG",
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (4a) air->FltNum <%s>, fix <%s> \n", cdwThreadId, air->FltNum, dfix));
		}
		if (gate_dep && strlen(gate_dep) && strcmp(gate_dep, "null")) {
			strncpy_s(air->gate, GATE_SIZE + 1, gate_dep, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3c) air->FltNum <%s>, gate <%s>.\n", cdwThreadId, air->FltNum, gate_dep));
		}
		if (runway_dep && strlen(runway_dep) && strcmp(runway_dep, "null")) {
			strncpy_s(air->runway, RUNWAY_SIZE + 1, runway_dep, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3d) air->FltNum <%s>, runway <%s>.\n", cdwThreadId, air->FltNum, runway_dep));
		}
		if (std_dep && -1 != std_dep) {
			air->etd = std_dep;
		}

	}else{
		// use Arrival information since ON time is closer in time, OR both are missing
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2b use arrival info).\n", cdwThreadId));
		if (destin_arr && strlen(destin_arr) && strcmp(destin_arr, "null")) {
			strncpy_s(air->Destin, ORIG_DES_SIZE + 1, destin_arr, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile,
				__FUNCTION__, "(0x%X) (3c) air->FltNum <%s>, destin <%s>.\n", cdwThreadId, air->FltNum, destin_arr));
		}
		if (orig_arr && strlen(orig_arr) && strcmp(orig_arr, "null")) {
			strncpy_s(air->Origin, ORIG_DES_SIZE + 1, orig_arr, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3d) air->FltNum <%s>, orig <%s>.\n", cdwThreadId, air->FltNum, orig_arr));
		}
		if (plotsecs > (onsecs_arr + 1800)){
			D_CONTROL("FIL-TAG", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FltNum<%s,(%s)> ETA is greater than plotime + 30 minutes and no new ETD provided,"
				"origin and destination values may be incorrect\n", cdwThreadId, air->FltNum, fltnum_arr));
			D_CONTROL("FIL-TAG", vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) FltNum<%s>, Origin<%s>, Dest<%s>, ETA<%d>, ETD<%d>, PT<%d>\n",
				cdwThreadId, air->FltNum, air->Origin, air->Destin, onsecs_arr, outsecs_dep, plotsecs));
		}
		if (gate_arr && strlen(gate_arr) && strcmp(gate_arr, "null")) {
			strncpy_s(air->gate, GATE_SIZE + 1, gate_arr, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3c) air->FltNum <%s>, gate <%s>.\n", cdwThreadId, air->FltNum, gate_arr));
		}

		if (runway_arr && strlen(runway_arr) && strcmp(runway_arr, "null")) {
			strncpy_s(air->runway, RUNWAY_SIZE + 1, runway_arr, _TRUNCATE);
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (3d) air->FltNum <%s>, runway <%s>.\n", cdwThreadId, air->FltNum, runway_arr));
		}
	}

	if (afix && strlen(afix) && strcmp(afix, "null")) {
		strncpy_s(air->ArrivalFix, ARR_FIX_SIZE, afix, _TRUNCATE);
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (4b) air->FltNum <%s>, air->ArrivalFix <%s> \n", cdwThreadId, air->FltNum, afix));
	}

	if (onsecs_arr > 0){
		air->eta = onsecs_arr;
	}
}


void FillTarmacDelay(struct InstanceData* id, int i, AIR** airp)
{
	AIR *air;
	struct row_index *row_index;
	char *tail = NULL, *orig = NULL;
	char *dest = NULL, *arrdep = NULL;
	char *ata = NULL, *sta = NULL;
	char *out = NULL, *std = NULL;
	int outsecs_dep = -999, onsecs_arr = -999, etasecs_arr = -999, std_dep = -999, sta_arr = -999;
	int plotsecs;
	int elapse;
	int arrival = FALSE;
	char *dfix = NULL, *afix = NULL;
	//char outtimebuf[64], ontimebuf[64], etatimebuf[64];
	//int use_arrivals;
	const DWORD cdwThreadId = GetCurrentThreadId();

	plotsecs = id->m_tPlotTime;
	if (!(air = airp[i])){
		return;
	}

	// Always reset at the beginning:
	if (ALERT_TD_OTI == air->alert || ALERT_TD_OTO == air->alert)
	{
		air->alert = ALERT_NONE;
		air->alert_level = ALERT_LEVEL_NONE;
	}

	// Only Set TD if we are in a region on the airport.
	if (air->InRegion) {

		if (id->m_pTDVO && (row_index = vo_search((VO*)id->m_pTDVO, "FltNum", (char *)air->FltNum, NULL))){
			arrdep = VP((VO*)id->m_pTDVO, row_index->rownum, "arrdep", char);
			dest = VP((VO*)id->m_pTDVO, row_index->rownum, "Dest", char);
			orig = VP((VO*)id->m_pTDVO, row_index->rownum, "Orig", char);
			if (arrdep[0] == 'A'){
				arrival = TRUE;
				ata = VP((VO*)id->m_pTDVO, row_index->rownum, "ATA", char);
				sta = VP((VO*)id->m_pTDVO, row_index->rownum, "STA", char);
			}else{
				out = VP((VO*)id->m_pTDVO, row_index->rownum, "OUT", char);
				std = VP((VO*)id->m_pTDVO, row_index->rownum, "STD", char);
			}

			elapse = VV((VO*)id->m_pTDVO, row_index->rownum, "Delay", int);

			if (arrival){
				air->td_oti = elapse;
				if (elapse >= id->m_nTarmacDelayOTIRed) {
					air->alert = ALERT_TD_OTI;
					air->alert_level = ALERT_LEVEL_HIGH;
					D_CONTROL("TARMAC", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tarmac Delay for %s OTI RED Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapse));
				}else if( elapse >= id->m_nTarmacDelayOTIYellow ) {
					air->alert = ALERT_TD_OTI;
					air->alert_level = ALERT_LEVEL_MED;
					D_CONTROL("TARMAC", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tarmac Delay for %s OTI Yellow Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapse));
				}
			}else{
				air->td_oto = elapse;
				if (elapse >= id->m_nTarmacDelayOTORed) {
					air->alert = ALERT_TD_OTO;
					air->alert_level = ALERT_LEVEL_HIGH;
					D_CONTROL("TARMAC", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tarmac Delay for %s OTO RED Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapse));
				}else if( elapse >= id->m_nTarmacDelayOTOYellow ) {
					air->alert = ALERT_TD_OTO;
					air->alert_level = ALERT_LEVEL_MED;
					D_CONTROL("TARMAC", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Tarmac Delay for %s OTO Yellow Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapse));
				}
			}
		}
	}
}




void FillFix(struct InstanceData* id, int i, AIR** airp)
{
	AIR *air;
	struct row_index *row_index;
	int outsecs_dep = 0, onsecs_arr = 0, plotsecs;
	char *dfix = NULL, *afix = NULL;
	const DWORD cdwThreadId = GetCurrentThreadId();


	plotsecs = id->m_tPlotTime;
	if (!(air = airp[i])){
		return;
	}

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (1a) i <%d> airp <%x> air <%x>.\n", cdwThreadId, i, airp, air));

	if (id->m_pPlannedDepVO && (row_index = vo_search((VO*)id->m_pPlannedDepVO, "FltNum", (char *)air->FltNum, NULL))){
		dfix = VP((VO*)id->m_pPlannedDepVO, row_index->rownum, "DFix", char);
		outsecs_dep = VV((VO*)id->m_pPlannedDepVO, row_index->rownum, "outsecs", int);
	}

	if (id->m_pPlannedArrVO && (row_index = vo_search((VO*)id->m_pPlannedArrVO, "FltNum", (char *)air->FltNum, NULL))){
		afix = VP((VO*)id->m_pPlannedArrVO, row_index->rownum, "AFix", char);
		onsecs_arr = VV((VO*)id->m_pPlannedArrVO, row_index->rownum, "onsecs", int);
	}

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (1b) etasecs_dep <%d> etasecs_arr <%d>.\n", cdwThreadId, outsecs_dep, onsecs_arr));

	if (abs(outsecs_dep - plotsecs) < abs(onsecs_arr - plotsecs)){
		// use departure information
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2a).\n", cdwThreadId));
		if (dfix && strlen(dfix) && strcmp(dfix, "null")) {
			strncpy_s(air->DepartureFix, DEP_FIX_SIZE, dfix, _TRUNCATE);
			D_CONTROL("FIL-TAG",
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (4a) air->FltNum <%s>, fix <%s> \n", cdwThreadId, air->FltNum, dfix));
		}
	}

	if (afix && strlen(afix) && strcmp(afix, "null")) {
		strncpy_s(air->ArrivalFix, ARR_FIX_SIZE, afix, _TRUNCATE);
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (4b) air->FltNum <%s>, air->ArrivalFix <%s> \n", cdwThreadId, air->FltNum, afix));
	}
}

int FillADSBTags(struct InstanceData* id, AIR** airp)
{
	int aircount, i;
	time_t nowsecs = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", cdwThreadId, airp));

	aircount = N_ADSB_TRACK_ID;

	if (!id->m_sCurLayout.m_bShowADSBAircraft){
		// only process the data from the adsb feed if enabled
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (1a) airp <%x>.\n", cdwThreadId, airp));
		return(nowsecs);
	}

	if (TryEnterCriticalSection(&id->m_csPlanned)) {
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (2a) airp <%x>.\n", cdwThreadId, airp));
		if (id->m_pPlannedDepVO || id->m_pPlannedArrVO){
			// insert values into adsb structs
			for (i = 0; i < aircount; i++){
				FillDestOrigFix(id, i, airp);
				if (id->m_nTarmacDelayEnabled)
					FillTarmacDelay(id, i, airp);
				nowsecs = time(0);
			}
		}else{
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2b)Skipped Fill, No VO data.\n", cdwThreadId));
		}
		LeaveCriticalSection(&id->m_csPlanned);
	}else{
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2c)Skipped Fill, critical section locked.\n", cdwThreadId));
	}
	return(nowsecs);
}

int FillMLATTags(struct InstanceData* id, AIR** airp)
{
	int aircount, i;
	time_t nowsecs = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", cdwThreadId, airp));

	aircount = N_ADSB_TRACK_ID;

	if (!id->m_sCurLayout.m_bShowMLATAircraft){
		// only process the data from the mlat feed if enabled
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (1a) airp <%x>.\n", cdwThreadId, airp));
		return(nowsecs);
	}

	if (TryEnterCriticalSection(&id->m_csPlanned)) {
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (2a) airp <%x>.\n", cdwThreadId, airp));
		if (id->m_pPlannedDepVO || id->m_pPlannedArrVO){
			// insert values into mlat structs
			for (i = 0; i < aircount; i++){
				FillDestOrigFix(id, i, airp);
				if (id->m_nTarmacDelayEnabled)
					FillTarmacDelay(id, i, airp);
				nowsecs = time(0);
			}
		}else{
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2b)Skipped Fill, No VO data.\n", cdwThreadId));
		}
		LeaveCriticalSection(&id->m_csPlanned);
	}else{
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2c)Skipped Fill, critical section locked.\n", cdwThreadId));
	}
	return(nowsecs);
}

int FillASDEXTarmacDelayData(struct InstanceData* id, AIR** airp)
{
	int aircount, i;
	time_t nowsecs = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", cdwThreadId, airp));

	aircount = N_TRACK_ID;

	if (!id->m_sCurLayout.m_bShowASDEXAircraft){
		// only process the data from the asdex feed if enabled
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (1a) airp <%x>.\n", cdwThreadId, airp));
		return(nowsecs);
	}

	if (TryEnterCriticalSection(&id->m_csPlanned)) {
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (2a) airp <%x>.\n", cdwThreadId, airp));
		// insert values into asdex structs
		if (id->m_nTarmacDelayEnabled){
			for (i = 0; i < aircount; i++){
				FillTarmacDelay(id, i, airp);
			}
		}
		LeaveCriticalSection(&id->m_csPlanned);
	}else{
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2c)Skipped Fill, critical section locked.\n", cdwThreadId));
	}
	return(nowsecs);
}



int FillASDEXTags(struct InstanceData* id, AIR** airp)
{
	int aircount, i;
	time_t nowsecs = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", cdwThreadId, airp));

	aircount = N_PASSUR_TRACK_ID;

	if (!id->m_sCurLayout.m_bShowASDEXAircraft){
		// only process the data from the asdex feed if enabled
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (1a) airp <%x>.\n", cdwThreadId, airp));
		return(nowsecs);
	}

	if (TryEnterCriticalSection(&id->m_csPlanned)) {
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (2a) airp <%x>.\n", cdwThreadId, airp));
		if (id->m_pPlannedDepVO || id->m_pPlannedArrVO){
			// insert values into asdex structs
			for (i = 0; i < aircount; i++){
				FillDestOrigFix(id, i, airp);
				if (id->m_nTarmacDelayEnabled)
					FillTarmacDelay(id, i, airp);
				nowsecs = time(0);
			}
		}else{
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2b)Skipped Fill, No VO data.\n", cdwThreadId));
		}
		LeaveCriticalSection(&id->m_csPlanned);
	}else{
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2c)Skipped Fill, critical section locked.\n", cdwThreadId));
	}
	return(nowsecs);
}

int FillASDTags(struct InstanceData* id, AIR** airp)
{
	int aircount, i;
	time_t nowsecs = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) %x\n", cdwThreadId, airp));

	aircount = N_PASSUR_TRACK_ID;

	if (TryEnterCriticalSection(&id->m_csPlanned)){
		if (id->m_pPlannedDepVO || id->m_pPlannedArrVO){
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2a) airp <%x>.\n", cdwThreadId, airp));
			// insert values into asd structs
			for (i = 0; i < aircount; i++){
				FillFix(id, i, airp);
			}
			nowsecs = time(0);
		} else {
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2b) %x\n", cdwThreadId, airp));
		}

		LeaveCriticalSection(&id->m_csPlanned);
	} else {
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2c) airp <%x>.\n", cdwThreadId, airp));
	}
	return(nowsecs);
}

int FillPASSURTags(struct InstanceData* id, AIR** airp)
{
	int aircount, i;
	time_t nowsecs = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) %x\n", cdwThreadId, airp));

	aircount = N_PASSUR_TRACK_ID;

	if (TryEnterCriticalSection(&id->m_csPlanned)){
		if (id->m_pPlannedDepVO || id->m_pPlannedArrVO){
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2a) %x\n", cdwThreadId, airp));
			// insert values into asdex structs
			for (i = 0; i < aircount; i++){
				FillFix(id, i, airp);
			}
			nowsecs = time(0);
		} else {
			D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
				"(0x%X) (2b) %x\n", cdwThreadId, airp));
		}

		LeaveCriticalSection(&id->m_csPlanned);
	} else {
		D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
			"(0x%X) (2c) airp <%x>.\n", cdwThreadId, airp));
	}
	return(nowsecs);
}


void DrawADSBAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	//int tdiff, absdiff;
	static struct timeb PssrASDOverlap_time, cur_time;
	static int PassurOverlapTimeout = PASSUR_OVERLAP_TIMEOUT_START;
	int nowsecs;

	airp = GetADSBAirP(id);

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", GetCurrentThreadId(), airp));

	nowsecs = time(0);
	if (nowsecs - id->m_LastADSBFillTags > FILL_ADSB_TIME){
		id->m_LastADSBFillTags = FillADSBTags(id, airp);  // fill in orig/dest and other fields into ASDEX airp
	}

	aircount = N_ADSB_TRACK_ID;

	drawADSBAircraft(id, airp, FALSE);

	ftime(&cur_time);
	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails(id, airp, TRUE, id->m_tPlotTime, SAT_ADSB, ADSB_TRACK_MODIFIER(id->m_sCurLayout.m_dAdsbTrailCount));
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, ADSB_TRACK_MODIFIER(id->m_sCurLayout.m_dAdsbTrailCount), SAT_ADSB);
	}

	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_ADSB);
	}

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorADSB, FALSE, TCI_ADSB);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)black, TRUE, TCI_ADSB);
	}
}

void DrawAirAsiaAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	//int tdiff, absdiff;
	static struct timeb PssrASDOverlap_time, cur_time;
	static int PassurOverlapTimeout = PASSUR_OVERLAP_TIMEOUT_START;
	int nowsecs;

	airp = GetAirAsiaAirP(id);

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", GetCurrentThreadId(), airp));

	nowsecs = time(0);
	//if ( nowsecs - id->m_LastADSBFillTags > FILL_ADSB_TIME ){
	//	id->m_LastADSBFillTags = FillADSBTags(id, airp);  // fill in orig/dest and other fields into ASDEX airp
	//}

	aircount = N_AIRASIA_TRACK_ID;

	drawAirAsiaAircraft(id, airp, FALSE);

	ftime(&cur_time);
	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails( id, airp, TRUE, id->m_tPlotTime , SAT_AIRASIA, AIRASIA_TRACK_MODIFIER(id->m_sCurLayout.m_nAirAsiaTrailCount) );
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, AIRASIA_TRACK_MODIFIER(id->m_sCurLayout.m_nAirAsiaTrailCount), SAT_AIRASIA );
	}

	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_AIRASIA);
	}

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorAirAsia, FALSE, TCI_AIRASIA);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)black, TRUE, TCI_AIRASIA);
	}
}

void DrawMLATAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	//int tdiff, absdiff;
	static struct timeb PssrASDOverlap_time, cur_time;
	static int PassurOverlapTimeout = PASSUR_OVERLAP_TIMEOUT_START;
	int nowsecs;

	airp = GetMLATAirP(id);

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", GetCurrentThreadId(), airp));

	nowsecs = time(0);
	if (nowsecs - id->m_LastMLATFillTags > FILL_ADSB_TIME){
		id->m_LastMLATFillTags = FillMLATTags(id, airp);  // fill in orig/dest and other fields into MLAT airp
	}

	aircount = N_ADSB_TRACK_ID;

	drawMLATAircraft(id, airp, FALSE);

	ftime(&cur_time);
	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails(id, airp, TRUE, id->m_tPlotTime, SAT_MLAT, MLAT_TRACK_MODIFIER(id->m_sCurLayout.m_dMlatTrailCount));
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, MLAT_TRACK_MODIFIER(id->m_sCurLayout.m_dMlatTrailCount), SAT_MLAT);
	}

	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_MLAT);
	}

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorMLAT, FALSE, TCI_MLAT);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)black, TRUE, TCI_MLAT);
	}

	// Draw Last Known Position Rings
	drawLKPRings(id, airp, aircount, TCI_MLAT);
}

void DrawLMGVehicles(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	//int tdiff, absdiff;

	airp = GetLMGAirP(id);

	aircount = N_PASSUR_TRACK_ID;

	drawLMGVehicles( id, airp, FALSE);

	if ( id->m_sCurLayout.m_bShowTrails ){
		drawTrails( id, airp, TRUE, id->m_tPlotTime , SAT_ASDEX, ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount) );
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), SAT_ASDEX );
	}

	if ( id->m_sCurLayout.m_bShowSmallTags ){
		DrawFlightNums( id, airp, aircount, (GLfloat *) id->m_sCurLayout.m_glfLargeTagTextColorASDEX, FALSE, TCI_LMG );
	} else {
		// trailer only
		DrawFlightNums( id, airp, aircount, (GLfloat *) black, TRUE, TCI_LMG );
	}	
}

void DrawASDEXAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	//int tdiff, absdiff;
	static struct timeb PssrASDOverlap_time, cur_time;
	static int PassurOverlapTimeout = PASSUR_OVERLAP_TIMEOUT_START;
	int nowsecs;

	airp = GetASDEXAirP(id);

	D_CONTROL("FIL-TAG", vo_log_info(id->m_pfVoLogFile, __FUNCTION__,
		"(0x%X) (0) airp <%x>.\n", GetCurrentThreadId(), airp));

	nowsecs = time(0);
	if (nowsecs - id->m_LastASDEXFillTags > FILL_ASDEX_TIME){
		id->m_LastASDEXFillTags = FillASDEXTags(id, airp);  // fill in orig/dest and other fields into ASDEX airp
	}

	FillASDEXTarmacDelayData(id, airp);

	aircount = N_PASSUR_TRACK_ID;

	drawASDEXAircraft(id, airp, FALSE);

	ftime(&cur_time);
	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails(id, airp, TRUE, id->m_tPlotTime, SAT_ASDEX, ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount));
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, ASDEX_TRACK_MODIFIER(id->m_sCurLayout.m_dAsdexTrailCount), SAT_ASDEX);
	}

	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_ASDEX);
	}

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorASDEX, FALSE, TCI_ASDEX);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)black, TRUE, TCI_ASDEX);
	}

	// Draw Last Known Position Rings
	drawLKPRings(id, airp, aircount, TCI_ASDEX);

	DrawLMGVehicles(id);
}

void DrawGateAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;
	GLfloat* color = (GLfloat*)id->m_sCurLayout.m_glfLargeTagTextColorGate;
	int nFeedType = TCI_GATE;

	airp = GetGateAirP(id);
	aircount = N_TRACK_ID;

	drawGateAircraft(id, airp, FALSE);

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, color, FALSE, nFeedType);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)color, TRUE, nFeedType);
	}
}


void DrawNoiseAircraft(struct InstanceData* id)
{
	AIR **airp;
	int aircount;

	airp = GetNoiseAirP(id);

	aircount = N_NOISE_TRACK_ID;

	drawNoiseAircraft(id, airp, FALSE);

	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails(id, airp, TRUE, id->m_tPlotTime, SAT_NOISE, NOISE_TRACK_MODIFIER(id->m_sCurLayout.m_dNoiseTrailCount));
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, NOISE_TRACK_MODIFIER(id->m_sCurLayout.m_dNoiseTrailCount), SAT_NOISE);
	}

	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_NOISE);
	}

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorADSB, FALSE, TCI_NOISE);
	} else {
		DrawFlightNums(id, airp, aircount, (GLfloat *)black, TRUE, TCI_NOISE);
	}
}


DrawPassurAircraft(struct InstanceData* id, int passurindex)
{
	AIR **airp;
	int aircount;
	int nowsecs;

	airp = GetAirP(id, passurindex);

	D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) (0) %x, passurindex(%d)\n", GetCurrentThreadId(), airp, passurindex));

	nowsecs = time(0);


	if (nowsecs - id->m_LastPassurFillTags > FILL_PASSUR_TIME){
		// fill in orig/dest and other fields into airp
		id->m_LastPassurFillTags = FillPASSURTags(id, airp);
	}


	aircount = N_PASSUR_TRACK_ID;
	//drawAircraft( id, airp, FALSE, passurindex );
	//drawAircraft( id, airp, FALSE, 0 );

	if (id->m_sCurLayout.m_bShowPassurAircraft){
		drawAircraft(id, airp, FALSE, passurindex); // draw aircraft
	} else if ( PassurThreadStarted ) {
		drawAircraft(id, airp, TRUE, passurindex); // load data only
	}

	if (id->m_sCurLayout.m_bShowTrails){
		drawTrails(id, airp, TRUE, id->m_tPlotTime, SAT_PASSUR, PASSUR_TRACK_MODIFIER(id->m_sCurLayout.m_nPassurTrailCount));
		drawTrailLabels(id, airp, aircount, TRUE, id->m_tPlotTime, PASSUR_TRACK_MODIFIER(id->m_sCurLayout.m_nPassurTrailCount), SAT_PASSUR);
	}
	if (id->m_sCurLayout.m_bShowAircraftRings){
		drawAircraftRangeRings(id, airp, aircount, SAT_PASSUR);
	}

	if (id->m_sCurLayout.m_bShowSmallTags){
		DrawFlightNums(id, airp, aircount, (GLfloat *)id->m_sCurLayout.m_glfLargeTagTextColorPASSUR, FALSE, TCI_PASSUR);
	} else {
		// trailer only
		DrawFlightNums(id, airp, aircount, (GLfloat *)black, TRUE, TCI_PASSUR);
	}




}

DrawOverlayPanel(struct InstanceData* id, int xpixel, int ypixel, int xsize, int ysize, int blend_flag, int textureindex)
{

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Starting\n", GetCurrentThreadId());
	glPushMatrix();

	glColor3fv(white);
	/* use border as background of text */

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);

	/* solid with alpha masking */

	glEnable(GL_DEPTH_TEST);
	/* glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); */
	// glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	if (blend_flag){
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glEnable(GL_BLEND);
	}
	glDepthFunc(GL_LEQUAL);

	// glBindTexture( GL_TEXTURE_2D,  guitexture[4 + UseMapColors] );	// light map
	glBindTexture(GL_TEXTURE_2D, id->m_gluGuiTextures[textureindex]);
	//glBindTexture( GL_TEXTURE_2D,  guitexture[7] );
	DispTextureSize((float)xpixel, (float)ypixel, 0.0f, (float)xsize, (float)ysize);
	glPopMatrix();

	glBindTexture(GL_TEXTURE_2D, 0); // unbind the texture

	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);
	glLoadIdentity();

}


int ShowFAAPopup(struct InstanceData* id, VO *DelayArptsVO, int rownum)
{
	int xpixel, ypixel, i;
	char *str, *eolstr;
	int xsize = 250;
	int ysize = 100;
	char linebuf[32][64];
	int len, textrows, maxwidth;
	char tmpstr[TMPBUF_SIZE], errorbuf[80]; //TODO: for debug..
	static int count;
	SIZE size;

	if (!DelayArptsVO){
		return(FALSE);
	}
	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glColor3fv(darkpurple);



	if ((str = VV(DelayArptsVO, rownum, "StatusStr", char *)) && strlen(str)){
	} else {
		str = "General Arrival/Departures delays are\n15 minutes or less";
	}
	D_CONTROL("FAA_STATUS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) rownum=%d str='%s'\n", GetCurrentThreadId(), rownum, str));

	MGLGridText(id, statusgrid, 14, 0, "showpop");
	sprintf_s(tmpstr, TMPBUF_SIZE, "%d", count++);
	MGLGridText(id, statusgrid, 14, 1, tmpstr);


	textrows = 0;
	maxwidth = 0;

	while (str && strlen(str) && (eolstr = strchr(str, '\n')) && textrows < 32){
		len = eolstr - str;
		if (len >= 64){
			break;  // some problem with the data
		}
		strncpy_s(linebuf[textrows], 64, str, len);
		// find out how many pixels wide this string needs
		if (GetTextExtentPoint32(wglGetCurrentDC(), linebuf[textrows], len, &size) == 0){
			// function failed
			sprintf_s(errorbuf, _countof(errorbuf), "error is %s", GetLastErrorStr());
		} else {
			if (size.cx > maxwidth){
				maxwidth = size.cx;
			}
		}

		textrows++;
		str = eolstr;
		str++; /* skip over eol char */


	}
	if (*str != '\0' && textrows < 31){
		// last line

		len = strlen(str);
		if (len >= 64){
			// some problem with the data
		} else {
			strncpy_s(linebuf[textrows], 64, str, len);
			if (GetTextExtentPoint32(wglGetCurrentDC(), linebuf[textrows], len, &size) == 0){
				// function failed
				sprintf_s(errorbuf, _countof(errorbuf), "error is %s", GetLastErrorStr());
			} else {
				if (size.cx > maxwidth){
					maxwidth = size.cx;
				}
			}
			textrows++;
		}
	}


	xpixel = VV(DelayArptsVO, rownum, "xpix", int);
	ypixel = VV(DelayArptsVO, rownum, "ypix", int);

	ypixel += 20; // move box up and away a little so we can read the last line w/o moving cursor
	// ysize = (id->m_tmCustom.tmAscent * textrows) + 5;
	ysize = ((id->m_tmCustom.tmHeight + id->m_tmCustom.tmExternalLeading) * textrows) + 5;

	xsize = maxwidth + (OVERLAY_MARGIN * 2); // add in both left and right margins 
	if (xpixel < 0 || xpixel > id->m_nWidth ||
		ypixel < 0 || ypixel > id->m_nHeight){
		/* skip */
		ypixel = 0; // dummy for debugging
	} else {


		if (ypixel + ysize > (id->m_nHeight - GUI_BORDER_SIZE - GUIIconHeight)){
			ypixel -= (ypixel + ysize) - (id->m_nHeight - GUI_BORDER_SIZE - GUIIconHeight - 5);
			// must move x position also since we will now be over mouse location
			xpixel += 25;
		}
		if (xpixel + xsize > (id->m_nWidth - GUI_BORDER_SIZE)){
			xpixel -= (xpixel + xsize) - (id->m_nWidth - GUI_BORDER_SIZE - 5);
		}

		glRasterPos2i(xpixel, ypixel);

		DrawOverlayPanel(id, xpixel, ypixel, xsize, ysize, TRUE, 4 + UseMapColors);

		glBegin(GL_LINE_STRIP);
		//if ( id->m_sUserSettings.NoFillColor ){
		glColor3fv(white);
		//	} else {
		glColor3fv(black);
		//	}
		glVertex3i(xpixel - 1, ypixel - 1, 0);
		glVertex3i(xpixel - 1, ypixel + ysize, 0);
		glVertex3i(xpixel + xsize, ypixel + ysize, 0);
		glVertex3i(xpixel + xsize, ypixel - 1, 0);
		glVertex3i(xpixel - 1, ypixel - 1, 0);

		glEnd();


		/* move to point for top line of text */
		ypixel += (ysize - id->m_tmCustom.tmHeight);
		xpixel += OVERLAY_MARGIN; // x margin
		glRasterPos2i(xpixel, ypixel);

		if (UseMapColors >= 1){
			glColor3fv(blue);
		} else {
			glColor3fv(black);
		}
		glRasterPos2i(xpixel, ypixel);

		for (i = 0; i < textrows; i++){

			glPrintCustom(id, id->m_gluCustomBase, linebuf[i]);
			// move the cursor down
			ypixel -= id->m_tmCustom.tmHeight;
			glRasterPos2i(xpixel, ypixel);
		}


	}

	glFlush();
	glPopMatrix();

	glColor3fv(white);
	return(TRUE);
}


DrawFAAPopupTags(struct InstanceData* id)
{
	int i;
	int xmin, xmax, ymin, ymax;

	// see if the cursor is over a display & Mouse pointer has a value
	if (id->m_nMouseX || id->m_nMouseX) {
		// see if we are over a Status icon
		for (i = 0; DelayArptsVO && i < DelayArptsVO->count; i++){
			xmin = VV(DelayArptsVO, i, "xpix", int);
			ymin = VV(DelayArptsVO, i, "ypix", int);
			xmax = xmin + FAABallSize;
			ymax = ymin + FAABallSize;
			if (id->m_nMouseX >= xmin && id->m_nMouseX <= xmax && id->m_nMouseY >= ymin && id->m_nMouseY <= ymax){
				// overlaps , show popup
				D_CONTROL("FAA_STATUS", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Found rollover mouse x=%d y=%d, drawing airport status for airport<%s>.\n",
					GetCurrentThreadId(), id->m_nMouseX, id->m_nMouseY, VP(DelayArptsVO, i, "code", char)));
				ShowFAAPopup(id, DelayArptsVO, i);
				break;
			}
		}
	}


	//if ( i >= DelayArptsVO->count ){
	// xmin = VV(DelayArptsVO, 135, "xpix", int );
	// ymin = VV(DelayArptsVO, 135, "ypix", int );
	//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) did not use rollover mouse x=%d y=%d xmin=%d ymin=%d\n",
	//  GetCurrentThreadId(), id->m_nMouseX, id->m_nMouseY, xmin, ymin);
	//}


}

DrawFAAStatus(struct InstanceData* id)
{
	int i;
	double y, x, x2, y2;
	double deltax, realdelta;
	int xpixel, ypixel;
	int ShowRegionalAirports = FALSE;
	char *arpt;
	char *region;
	ARPT *Arpt;
	char pngfilename[256];
	static int FAAThreadStarted;
	int mutexstatus, colorcode;
	const DWORD cdwThreadId = GetCurrentThreadId();
	if (id->m_sCurLayout.m_dWorldXSize < 20.0){
		ShowRegionalAirports = TRUE;
	}

	if (!hFAAMutex){
		hFAAMutex = CreateMutex(NULL, FALSE, NULL);
	}


	if ((!FAAThreadStarted  && hFAAMutex) || id->m_bOnRefresh){
		RegisterThreadHandle(id, _beginthreadex(NULL, 0, FAAThread, id, 0, NULL), "FAAThread");
		FAAThreadStarted = TRUE;
	}


	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	// glColor3fv(green);
	// glColor3f(46.0/255.0, 134.0/255.0, 61.0/255.0 );
	// glColor3f(143.0/255.0, 188.0/255.0, 143.0/255.0 ); // dark sea green
	// glColor3f(85.0/255.0, 107.0/255.0, 47.0/255.0 ); // dark olive green
	glColor3f(0.0f / 255.0f, 100.0f / 255.0f, 0.0f / 255.0f); // dark green

	// first time must wait if FAAThread just started, but hereafter should usually not have to wait
	if ((mutexstatus = WaitForSingleObject(hFAAMutex, 0)) != WAIT_OBJECT_0){
		// the mutex is ready for and we have the signal and can use the FAA data
		return(FALSE);
	}

	if (!DelayArptsVO){
		if (!(DelayArptsVO = GetDelayArpts(id))){
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to process FAA Status, DelayArptsVO is NULL, GetDelayArpts Failed!\n", cdwThreadId);
			return(FALSE);
		}
	}
	for (i = 0; DelayArptsVO && i < DelayArptsVO->count; i++){

		arpt = VP(DelayArptsVO, i, "code", char);
		region = VP(DelayArptsVO, i, "region", char);

		if (*region == 'R' && !ShowRegionalAirports){
			continue;
		}
		if (!(Arpt = FindArptRow(id, arpt, MATCH_ALL))){
			// could not find arpt
			continue;
		}

		y = Arpt->lat;
		x = Arpt->lng;

		if (projflag){
			deltax = x - LngOrig;
			realdelta = deltax * cos(y * M_PI / 180.0);
			x = LngOrig + realdelta;
		}

		/* convert X and Y from world to pixel coordinates */
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		if (xpixel < GUI_BORDER_SIZE || xpixel >(id->m_nWidth - GUI_BORDER_SIZE - GUI_STRAIGHT_SIZE) ||
			ypixel < GUI_BORDER_SIZE || ypixel > id->m_nHeight - GUI_BORDER_SIZE - GUIIconHeight){
			continue;
		}

		// glRecti(xpixel, ypixel, xpixel+2, ypixel+2 );

		if ((!ShowRegionalAirports || id->m_sCurLayout.m_dWorldXSize > 10.0) && AdjustArptLabel(Arpt->icao, &xpixel, &ypixel)){
			// move to other side of dot to avoid nearby airport text
			glRasterPos2i(xpixel, ypixel);
			VV(DelayArptsVO, i, "xpix", int) = xpixel;
			VV(DelayArptsVO, i, "ypix", int) = ypixel;
		} else {
			glRasterPos2i(xpixel + 10, ypixel - 4);
			VV(DelayArptsVO, i, "xpix", int) = xpixel + 10;
			VV(DelayArptsVO, i, "ypix", int) = ypixel - 4;
		}
		// printString(Fixes[i].fixname);
		glPrintCustom(id, id->m_gluCustomBase, Arpt->icao);

	}


	glFlush();
	glPopMatrix();

	glColor3fv(white);

	// now draw all of the colored icons

	for (i = 0; DelayArptsVO && i < DelayArptsVO->count; i++){

		arpt = VP(DelayArptsVO, i, "code", char);
		region = VP(DelayArptsVO, i, "region", char);

		if (*region == 'R' && !ShowRegionalAirports){
			continue;
		}
		if (!(Arpt = FindArptRow(id, arpt, MATCH_ALL))){
			// could not find arpt
			continue;
		}

		y = Arpt->lat;
		x = Arpt->lng;

		if (projflag){
			deltax = x - LngOrig;
			realdelta = deltax * cos(y * M_PI / 180.0);
			x = LngOrig + realdelta;
		}
		/* convert X and Y from world to pixel coordinates */
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		if (!ShowRegionalAirports || id->m_sCurLayout.m_dWorldXSize > 10.0){
			AdjustArpt(Arpt->icao, &xpixel, &ypixel);
		}

		// move the dot so it centers on the original point
		xpixel -= 6;
		ypixel -= 6;
		if (xpixel < GUI_BORDER_SIZE || xpixel >(id->m_nWidth - GUI_BORDER_SIZE - GUI_STRAIGHT_SIZE) ||
			ypixel < GUI_BORDER_SIZE || ypixel > id->m_nHeight - GUI_BORDER_SIZE - GUIIconHeight){
			continue;
		}
		y = (((double)ypixel / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
		x = (((double)xpixel / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		VV(DelayArptsVO, i, "xpix", int) = xpixel;
		VV(DelayArptsVO, i, "ypix", int) = ypixel;

		xpixel += FAABallSize;  // move to opposite corner for the other endpoints of image
		ypixel += FAABallSize;
		if (xpixel < GUI_BORDER_SIZE || xpixel >(id->m_nWidth - GUI_BORDER_SIZE - GUI_STRAIGHT_SIZE) ||
			ypixel < GUI_BORDER_SIZE || ypixel > id->m_nHeight - GUI_BORDER_SIZE - GUIIconHeight){
			continue;
		}


		y2 = (((double)ypixel / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
		x2 = (((double)xpixel / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;


		//colorcode = (rand() % 6) + 1;
		//colorcode = FAA_RED;

		colorcode = VV(DelayArptsVO, i, "colorcode", int);
		switch (colorcode)
		{
		case FAA_GREEN:
			sprintf_s(pngfilename, _countof(pngfilename), "greensquare.png");
			break;
		case FAA_RED:
			sprintf_s(pngfilename, _countof(pngfilename), "redsquare.png");
			break;
		case FAA_BLACK:
			sprintf_s(pngfilename, _countof(pngfilename), "bluesquare.png");
			break;
		case FAA_ORANGE:
			sprintf_s(pngfilename, _countof(pngfilename), "orangesquare.png");
			break;
		case FAA_YELLOW:
			sprintf_s(pngfilename, _countof(pngfilename), "yellowsquare.png");
			break;
		default:
			sprintf_s(pngfilename, _countof(pngfilename), "greensquare.png");
			break;
		}

		DisplayCachedPNG(id, pngfilename, 16, (GLfloat)x, (GLfloat)x2, (GLfloat)y, (GLfloat)y2,
			(GLfloat)(x2 - x), (GLfloat)(y2 - y), GL_ONE_MINUS_SRC_ALPHA, ALPHA_MODE_NONE, TRUE);

	}

	// allow the thread to reload when it wants to
	ReleaseMutex(hFAAMutex);

	return(TRUE);
}



int drawfixes(struct InstanceData* id, FIX *Fixes, int fixcount, GLfloat *fixfillcolor, GLuint fontbase)
{
	int i;
	double y, x;
	int xpixel, ypixel;
	static int pflag = 0;
	double deltax, realdelta;

	if (!g_bFixesLoaded){
		return(FALSE);
	}

	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);
	
	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);

	RotateView(id, id->m_nWidth, 0, id->m_nHeight, 0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glColor3fv(darkpurple);

	for (i = 0; i < fixcount; i++){

		y = Fixes[i].lat;
		x = Fixes[i].lng;


		if (projflag){
			deltax = x - LngOrig;
			realdelta = deltax * cos(y * M_PI / 180.0);
			x = LngOrig + realdelta;
		}

		/* convert X and Y from world to pixel coordinates */
		ypixel = (int)rint((y - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((x - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		if (xpixel < 0 || xpixel > id->m_nWidth ||
			ypixel < 0 || ypixel > id->m_nHeight){
			continue;
		}

		glRecti(xpixel, ypixel, xpixel + 2, ypixel + 2);

		if (id->m_sCurLayout.m_dWorldXSize < 4.0){
			glColor3fv(fixfillcolor);
			glRasterPos2i(xpixel + 4, ypixel);
			// printString(Fixes[i].fixname);
			glPrintCustom(id, fontbase, Fixes[i].fixname);
			glColor3fv(darkpurple);
		}
	}

	glFlush();
	glPopMatrix();

	glColor3fv(white);
	return(TRUE);

}

int drawairways(struct InstanceData* id)
{
	int i;
	double y, x;
	double deltax, realdelta;
	char prevname[6];
	char name1[6];

	prevname[0] = '\0';

	if (!g_bAirwaysLoaded){
		return (FALSE);
	}

	glPushMatrix();
	glLoadIdentity();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax, 0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);

	glColor3fv(darkpurple);

	for (i = 0; i < g_nAirwayCount; i++){

		y = g_pAirways[i].lat;
		x = g_pAirways[i].lng;

		if (projflag){
			deltax = x - LngOrig;
			realdelta = deltax * cos(y * M_PI / 180.0);
			x = LngOrig + realdelta;
		}


		sprintf_s(name1, _countof(name1), "%.4s%c", g_pAirways[i].name, g_pAirways[i].type);

		if (strcmp(prevname, name1)){
			// new airway
			if (strlen(prevname)){
				glEnd();
			}
			strncpy_s(prevname, _countof(prevname), name1, _TRUNCATE);
			glBegin(GL_LINE_STRIP);
		}
		glVertex3f((float)x, (float)y, 0.0f);
	}
	glEnd();

	glFlush();
	glPopMatrix();

	glColor3fv(white);
	return(TRUE);

}



int pnpoly(int nvert, float *vertx, float *verty, float testx, float testy)
{
	int i, j, c = 0;

	/* test for inside or outside of polygon. Uses Jordan curve Theorem. Casts Ray semi infinite direction. */

	for (i = 0, j = nvert - 1; i < nvert; j = i++) {
		if (((verty[i]>testy) != (verty[j] > testy)) &&
			(testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))
			c = !c;
	}
	return c;
}



void FreeRegions(struct InstanceData* id)
{
	int i;
	PREGION *reg;

	// get rid of previous regions from another airport
	for (i = 0; i < id->m_nRegions; i++){
		reg = id->m_pRegions[i];
		free(reg->vertx);
		free(reg->verty);
		free(reg);
	}
	if (id->m_pRegions){
		free(id->m_pRegions);
		id->m_pRegions = NULL;
	}
	id->m_nRegions = 0; // clear it out

}




char *InRegion(struct InstanceData* id, float x, float y, int *regionnum)
{
	PREGION **Region;

	int i, nvert;
	float *vertx, *verty;

	if (!(Region = CreateRegionStructs(id))){
		return(NULL);
	}

	for (i = *regionnum; i < id->m_nRegions; i++){

		vertx = Region[i]->vertx;
		verty = Region[i]->verty;
		nvert = Region[i]->nvert;

		if (pnpoly(nvert, vertx, verty, x, y)){
			*regionnum = i + 1;
			return(Region[i]->name);
		}
	}
	return(NULL);

}



void BuildRegionJSON(struct InstanceData* id, VO *ROIDataVO, struct MemoryStruct* m)
{
	struct json_object* jobj = NULL;
	struct json_object* jarr = NULL;
	char* data = NULL;
	char* region = NULL;
	char* arpt = NULL;
	const char* jstr = NULL;
	VO* voROI = NULL;
	int i = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();

	// Create json array
	jarr = json_object_new_array();

	if (jarr){
		// Loop through all Regions and add to array
		for (i = 0; ROIDataVO && i < ROIDataVO->count; i++){
			arpt = VP(ROIDataVO, i, "arpt", char);
			// Adjust arpt code (skip first 'K' of 'KJFK')
			if (strlen(arpt) == 4 && arpt[0] == 'K') arpt++;
			// Region must match airport
			if (!strcasecmp(id->m_sCurLayout.m_strPassurArpt, arpt)){
				// Only Add new region names, hopefully duplicate names are never out of sequence
				if (!region || strcmp(region, VP(ROIDataVO, i, "Region", char))){
					region = VP(ROIDataVO, i, "Region", char);
					json_object_array_add(jarr, json_object_new_string(region));
					json_object_array_add(jarr, json_object_new_string(VP(ROIDataVO, i, "flightid", char)));
				}
			}
		}
		// Create json parent object
		jobj = json_object_new_object();
		if (jobj){
			// Add airport to object
			json_object_object_add(jobj, "arpt", json_object_new_string(id->m_sCurLayout.m_strPassurArpt));
			// Add array to object and get json string
			json_object_object_add(jobj, "regions", jarr);
			jstr = json_object_to_json_string(jobj);

			// Convert to curl escaped text for return
			data = curl_escape(jstr, strlen(jstr));
			if (data){
				// Add data to memory struct
				clear_chunk_memory(m);
				m->size = strlen(data) + 1;
				m->memory = (char*)calloc(m->size, sizeof(char*));
				strcat_s(m->memory, m->size, data);

				// Release curl escaped data
				curl_free(data);
			}else
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to escape json string!\n", cdwThreadId);

			// Release entire json object
			json_object_put(jobj);
		}else{
			// Release json array if object could not be created
			json_object_put(jarr);
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to create json object!\n", cdwThreadId);
		}
	}else
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to create json array!\n", cdwThreadId);
}


void BuildRegionsJSON(struct InstanceData* id, VO *ROIDataVO)
{
	char *RegStr = NULL;
	int i;
	char tmpstr[4096];
	char stime[256], etime[256], elapsedtime[256];
	int startsecs, endsecs, elapsed;
	char *activestr;
	const DWORD cdwThreadId = GetCurrentThreadId();

	for (i = 0; ROIDataVO && i < ROIDataVO->count; i++){
		startsecs = VV(ROIDataVO, i, "starttime", int);
		endsecs = VV(ROIDataVO, i, "endtime", int);
		elapsed = VV(ROIDataVO, i, "elapsed", int);

		if (id->m_sUserSettings.TimeDisplayLocal)
		{
			VOTimeFmt(stime, startsecs, "%H:%M:%S");
			if (endsecs){
				VOTimeFmt(etime, endsecs, "%H:%M:%S");
			} else {
				etime[0] = '\0';
			}
		}else{
			VOGMTime(stime, startsecs, "%H:%M:%S");
			if (endsecs){
				VOGMTime(etime, endsecs, "%H:%M:%S");
			} else {
				etime[0] = '\0';
			}
		}

		if (elapsed > 3600){
			_snprintf_s(elapsedtime, sizeof(elapsedtime), _TRUNCATE, "%02d:%02d:%02d", elapsed / 3600, (elapsed % 3600) / 60, elapsed % 60);
			// VOTimeFmt(elapsedtime, elapsed, "%H:%M:%S" );
		} else {
			//VOTimeFmt(elapsedtime, elapsed, "%M:%S" );
			_snprintf_s(elapsedtime, sizeof(elapsedtime), _TRUNCATE, "%02d:%02d", elapsed / 60, elapsed % 60);
		}
		if ( VV( ROIDataVO, i, "Active", char ) ){ activestr = "Y"; } else {activestr = "N"; }

		if (RegStr){
			// another region to add
			_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE,
				",\n\t{\"uniqueid\": \"%s%d\",\"action\": \"%s\",\"region\": \"%s\",\"flightid\": \"%s\",\"start\": \"%s\",\"end\": \"%s\",\"elapsed\": \"%s\","
				"\"arrdep\": \"%s\",\"fix\": \"%s\",\"active\": \"%s\"\t}",
				VP(ROIDataVO, i, "uniqueid", char), VV(ROIDataVO, i, "starttime", int), VP(ROIDataVO, i, "action", char),
				VP(ROIDataVO, i, "Region", char), VP(ROIDataVO, i, "flightid", char), stime, etime, elapsedtime,
				VP(ROIDataVO, i, "arrdep", char), VP(ROIDataVO, i, "fix", char), activestr);

			RegStr = strcat_alloc(RegStr, tmpstr);
		} else {
			// first region   
			//  example: \"region\": \"TWY B\",\"flightid\": \"DAL99\",\"start\": \"10:11\",\"end\": \"10:20\",\"elapsed\": \"10:00\",\"fix\":\"name\",\"active\": \"N\"},"
			RegStr = str_falloc("{\n");
			// strcpy( RegStr, "{\n" );
			sprintf_s(tmpstr, _countof(tmpstr), "\t\"arpt\": \"%s\", \n ", id->m_sCurLayout.m_strPassurArpt);
			RegStr = strcat_alloc(RegStr, tmpstr);

			// Add replay status into data string
			if (REPLAY_STATUS_STOPPED != id->m_bReplayStatus){
				RegStr = strcat_alloc(RegStr, "\t\"replay\":1, \n");
			}else{
				RegStr = strcat_alloc(RegStr, "\t\"replay\":0, \n");
			}
			if (id->m_sUserSettings.TimeDisplayLocal){
				RegStr = strcat_alloc(RegStr, "\t\"local\":1, \n");
			}else{
				RegStr = strcat_alloc(RegStr, "\t\"local\":0, \n");
			}
			RegStr = strcat_alloc(RegStr, "\t\"data\": [\n");

			_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE,
				"\t{\"uniqueid\": \"%s%d\",\"action\": \"%s\",\"region\": \"%s\",\"flightid\": \"%s\",\"start\": \"%s\",\"end\": \"%s\","
				"\"elapsed\": \"%s\",\"arrdep\": \"%s\",\"fix\": \"%s\",\"active\": \"%s\"\t}",
				VP(ROIDataVO, i, "uniqueid", char), VV(ROIDataVO, i, "starttime", int), VP(ROIDataVO, i, "action", char),
				VP(ROIDataVO, i, "Region", char), VP(ROIDataVO, i, "flightid", char), stime, etime, elapsedtime,
				VP(ROIDataVO, i, "arrdep", char), VP(ROIDataVO, i, "fix", char), activestr);

			RegStr = strcat_alloc(RegStr, tmpstr);
		}
	}


	if (!ROIDataVO || !ROIDataVO->count){
		// no regions, give "empty" json 
		RegStr = str_falloc("{\n");
		sprintf_s(tmpstr, _countof(tmpstr), "\t\"arpt\": \"%s\", \n ", id->m_sCurLayout.m_strPassurArpt);
		RegStr = strcat_alloc(RegStr, tmpstr);
		RegStr = strcat_alloc(RegStr, "\t\"data\": [ ]\n");
		RegStr = strcat_alloc(RegStr, "} \n");
	} else {
		// terminator
		if (RegStr)
			RegStr = strcat_alloc(RegStr, "\n\t]\n}\n");
	}

	if (RegStr){
		if (id->m_pGRegions){
			free(id->m_pGRegions);
			id->m_pGRegions = NULL;
		}
		id->m_pGRegions = RegStr;
		D_CONTROL("REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X): Current Regions <%d:%s>\n", cdwThreadId, strlen(id->m_pGRegions), id->m_pGRegions));
	}
}


void minmaxroi(struct InstanceData* id, int rownum, char *FltNum, char *region, int *minrow, int *maxrow)
{
	int vcount, row;

	row = rownum;
	while (rownum >= 0 && !strcmp(VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char), FltNum) &&
		!strcmp(VP((VO*)(id->m_pROIDataVO), rownum, "Region", char), region)){
		rownum--;
	}
	*minrow = rownum + 1;

	rownum = row; // original start location

	vcount = ((VO*)(id->m_pROIDataVO))->count;
	while (rownum < vcount && !strcmp(VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char), FltNum) &&
		!strcmp(VP((VO*)(id->m_pROIDataVO), rownum, "Region", char), region)){
		rownum++;
	}
	*maxrow = rownum - 1;
}



//   VO *CrFilteredGrid( MGLGRID *parentgrid )
// pseudo coded for row filtering


/* another algorithm to try is Rick's  see his email on 1 oct 2013:

The only other way I can think of is if you can keep your data rows sorted by column, and also sort the filter lists. Then you could step through both lists 'in order' to compare them. Does that make sense? If you have to sort every time it would probably be worse.

rows
col1  col2      filter1    filter 2
A     1             B             1
A     2             D
A     3             E
B     1             F
B     2             G
B     3
D    1
D    2
D    3



if column1 is less than the current filter1 value, skip the row.
If column1 matches the filter value, check column2 (or keep the row if no more filter columns).
If column1 is greater than filter1, go to next filter value and check again (if no more filter values, skip remaining rows)
*/

// PURPOSE: Check if there is a VO with Active Region Data from the Download and Merge it into the CalcRegions VO
void MergeRegions(struct InstanceData* id)
{
	int i = 0;
	int rownum = 0;
	struct row_index *row_index;
	const DWORD cdwThreadId = GetCurrentThreadId();
	VO* ROIDataVO = (VO*)id->m_pROIDataVO;
	char tmptimebuf[65] = { 0 };
	char uniqueid[60] = { 0 };

	// This section Handles Pre-Loading of Region Data from the Historical Download
	if (TryEnterCriticalSection(&id->m_csROIHist)){
		// Pull Historical Active VO to process
		VO* ROIActive = (VO*)id->m_pROINewActiveVO;
		id->m_pROINewActiveVO = NULL;

		LeaveCriticalSection(&id->m_csROIHist);

		// Copy From Historical Active VO to Current Processing VO
		if (ROIActive){
			D_CONTROL("HIST_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Historical Count <%d>, Current Count <%d>\n",
				cdwThreadId, ROIActive->count, ROIDataVO->count));

			for (i = 0; i < ROIActive->count; i++){
				// If Data already exists, copy into existing row, otherwise add row
				sprintf_s(uniqueid, _countof(uniqueid), "%s%s", VP(ROIActive, i, "flightid", char), VP(ROIActive, i, "Region", char));
				CleanString(uniqueid);
				if (ROIDataVO->count && (row_index = vo_search(ROIDataVO, "uniqueid", uniqueid))){
					// Updating Existing Row
					int starttime = 0;
					int elapsed = 0;
					rownum = row_index->rownum;
					//strncpy_s( VP(ROIDataVO, rownum, "arpt", char), 5, VP(ROIActive, i, "arpt", char), _TRUNCATE );
					strncpy_s(VP(ROIDataVO, rownum, "fix", char), 5, VP(ROIActive, i, "fix", char), _TRUNCATE);
					starttime = VV(ROIDataVO, rownum, "starttime", int) = VV(ROIActive, i, "starttime", int);
					elapsed = id->m_tPlotTime - starttime;
					// Enable copying of the elapsed time for this region
					VV(ROIDataVO, rownum, "elapsed", int) = elapsed;
					strncpy_s(VP(ROIDataVO, rownum, "arrdep", char), 2, VP(ROIActive, i, "arrdep", char), _TRUNCATE);
					D_CONTROL("MERGE_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Historical to Active ROI Update: %s, %s, %s, %s, e=%d\n",
						cdwThreadId, VP(ROIDataVO, rownum, "Region", char),
						VP(ROIDataVO, rownum, "flightid", char), VP(ROIDataVO, rownum, "arpt", char),
						VOTimeFmt(tmptimebuf, VV(ROIDataVO, rownum, "starttime", int), "%Y-%m-%d %H:%M:%S"), elapsed));
				}else{
					// Adding New Row
					int elapsed = 0;
					int starttime = 0;
					vo_alloc_rows(ROIDataVO, 1);
					strncpy_s(VP(ROIDataVO, ROIDataVO->count - 1, "uniqueid", char), 60, VP(ROIActive, i, "uniqueid", char), _TRUNCATE);
					strncpy_s(VP(ROIDataVO, ROIDataVO->count - 1, "Region", char), 33, VP(ROIActive, i, "Region", char), _TRUNCATE);
					strncpy_s(VP(ROIDataVO, ROIDataVO->count - 1, "flightid", char), 9, VP(ROIActive, i, "flightid", char), _TRUNCATE);
					strncpy_s(VP(ROIDataVO, ROIDataVO->count - 1, "arpt", char), 5, VP(ROIActive, i, "arpt", char), _TRUNCATE);
					strncpy_s(VP(ROIDataVO, ROIDataVO->count - 1, "fix", char), 5, VP(ROIActive, i, "fix", char), _TRUNCATE);
					starttime = VV(ROIDataVO, ROIDataVO->count - 1, "starttime", int) = VV(ROIActive, i, "starttime", int);
					elapsed = id->m_tPlotTime - starttime;
					VV(ROIDataVO, ROIDataVO->count - 1, "elapsed", int) = elapsed;// VV(ROIActive, i, "elapsed", int);
					strncpy_s(VP(ROIDataVO, ROIDataVO->count - 1, "arrdep", char), 2, VP(ROIActive, i, "arrdep", char), _TRUNCATE);
					VV(ROIDataVO, ROIDataVO->count - 1, "lasttime", int) = VV(ROIActive, i, "lasttime", int);
					VV(ROIDataVO, ROIDataVO->count - 1, "Active", int) = VV(ROIActive, i, "Active", int);
					D_CONTROL("MERGE_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Historical to Active ROI: %s, %s, %s, %s, e=%d\n",
						cdwThreadId, VP(ROIDataVO, ROIDataVO->count - 1, "Region", char),
						VP(ROIDataVO, ROIDataVO->count - 1, "flightid", char), VP(ROIDataVO, ROIDataVO->count - 1, "arpt", char),
						VOTimeFmt(tmptimebuf, VV(ROIDataVO, ROIDataVO->count - 1, "starttime", int), "%Y-%m-%d %H:%M:%S"), elapsed));
				}
			}
			vo_rm_rows(ROIActive, 0, ROIActive->count);
			vo_free(ROIActive);
		}
	}

}



void CpyRegionDataROI(struct InstanceData* id, MGLGRID *ROIGrid)
{


	// since we need both HistRegions and Current Data, merge them into this grid

	// if there is no more historical data, then just use the id->m_pROIDataVO

	if (!HistROIVO || !HistROIVO->count){
		ROIGrid->vo = id->m_pROIDataVO;
	}


}




void AddHistRegions(struct InstanceData* id, MGLGRID *ROIGrid)
{



}



void ClearOldHistRegions(MGLGRID *ROIGrid)
{



}

void updateFGBG(struct InstanceData* id, MGLGRID *RoiGrid)
{
	//RoiGrid->vo->row_index[1].fg=MGLColorHex2Int("529EFD");




}


void UpdateROIGridVO(struct InstanceData* id)
{
	MGLGRID *ROIGrid = NULL;
	int i;
	char *DataSource;
	VO *DataAppVO;
	time_t nowsecs = time(0);
	static time_t lastfilledsecs;
	static time_t lastcalcwidthssecs;


	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	MGLGRID* SecondTabGrid = (MGLGRID*)id->SecondTabGrid;

	id->DataAppGrid = DataAppGrid;
	// if first time, or time expired between fills
	if (!lastfilledsecs || nowsecs - lastfilledsecs > 30 || SecondTabGrid->updateroi==1){
		lastfilledsecs = nowsecs;
	} else {
		// skip
		return;
	}
	// the opengl grid is a combination of the current roigrid and HistoricalROI data
	for (i = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && i < DataAppVO->count; i++){
		DataSource = VP(DataAppVO, i, "DataSource", char);
		if (!strcmp(DataSource, "ROI")){
			ROIGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
			if (!ROIGrid->vo){
				ROIGrid->vo = CreateRegionVO(id, "OpenglROI");
				if (SecondTabGrid)
				{
					if (SecondTabGrid->childgrid)
					{
						if (SecondTabGrid->childgrid->ActionsGrid)
						{
							MGLFillParametersGrid(SecondTabGrid->childgrid->ActionsGrid, SecondTabGrid->childgrid->CurActionNum, id);
							//	MGLFillParametersColsVO(SecondTabGrid->childgrid);
							FillAvailableColsVO(id, SecondTabGrid->childgrid);
						}
					}
				}
			}
			else {

			}
			CpyRegionDataROI(id, ROIGrid);
			AddHistRegions(id, ROIGrid);
			ClearOldHistRegions(ROIGrid); // clear out rows older than one hour ?? 
			updateFGBG(id, ROIGrid);
			// if this grid has filters or row alerts, then create the filtered vo
			if (ROIGrid && OpenglGrid){
				id->m_nRegionTimeoutDelay = 3600;
				//// creates ROIGrid->filteredvo
				MGLSetlabelNamesFromVO(ROIGrid);
				CrFilteredGrid(id, ROIGrid);
				MGLSortFilteredGrid(ROIGrid);
			} else {
				id->m_nRegionTimeoutDelay = 120;
			}
			if (!lastcalcwidthssecs || nowsecs - lastcalcwidthssecs > 60){
				lastcalcwidthssecs = nowsecs;
				CalcColWidths(id, ROIGrid);
			}
		}
	}

	SecondTabGrid->aircraftcolor_change_MLAT = 1;
	SecondTabGrid->aircraftcolor_change_ASDEX = 1;
	SecondTabGrid->aircraftcolor_change_Noise = 1;
	SecondTabGrid->aircraftcolor_change_Gate = 1;
	SecondTabGrid->aircraftcolor_change_ASD = 1;
	SecondTabGrid->aircraftcolor_change = 1;
	SecondTabGrid->updateroi = 0;
}


void CalcRegions(struct InstanceData* id/*, AIR **airp*/)
{
	AIR *air;
	AIR **airp;
	int i, tcount, rownum, elapsed, rcount, j;
	PTRACK *trackarr;
	float x, y;
	time_t sutc;
	//	time_t lasttime;
	char *region, *regarpt, *pssrarpt;
	char arpt[5], destination[5];
	char arrdep[2] = { 0 };
	struct MemoryStruct chunk;
	int regionnum;  // allow multiple regions, so keep track to start looking for next region
	const DWORD cdwThreadId = GetCurrentThreadId();
	struct row_index *row_index;
	int minrow, maxrow, new_rownum_reorder;
	static int pflag = FALSE, lastgridup = 0;
	char *flightid;
	static char testflightid[10];
	char tmptimebuf[64], tmptimebuf2[64];
	char uniqueid[60] = { 0 };
	time_t endtime = 0, nowsecs;
	VO* ROIDataVO = NULL;
	static int debug = 0;


	// struct row_index *row_index;
	// VO *QVO;

	// find out if asdex tracks are in a region of interest ROI
	clear_chunk_memory(&chunk);

	if (!id->m_pROIDataVO){
		id->m_pROIDataVO = (VO *)vo_create(0, NULL);
		vo_set(id->m_pROIDataVO, V_NAME, "ROIDataVO", NULL);
		VOPropAdd(id->m_pROIDataVO, "uniqueid", NTBSTRINGBIND, 60, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "Region", NTBSTRINGBIND, 33, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "flightid", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "arpt", NTBSTRINGBIND, ARPT_CODE_SIZE, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "starttime", INTBIND, -1, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "endtime", INTBIND, -1, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "lasttime", INTBIND, -1, VO_NO_ROW);  // track when last track point found in order to delete dead tracks
		VOPropAdd(id->m_pROIDataVO, "elapsed", INTBIND, -1, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "arrdep", NTBSTRINGBIND, 2, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "Active", INTBIND, -1, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "fix", NTBSTRINGBIND, DEP_FIX_SIZE, VO_NO_ROW);
		VOPropAdd(id->m_pROIDataVO, "action", NTBSTRINGBIND, FLTNUM_SIZE, VO_NO_ROW); // Used to track when we insert/update or delete rows.
		vo_rm_rows(id->m_pROIDataVO, 0, ((VO*)(id->m_pROIDataVO))->count);

		vo_set(id->m_pROIDataVO, V_ORDER_COLS, "uniqueid", "flightid", "Region", NULL, NULL);
	}
	ROIDataVO = (VO*)id->m_pROIDataVO;

	//  fill in the ROIDataVO, and then create json using a routine ala GetRegionList function????

	pssrarpt = id->m_sCurLayout.m_strPassurArpt;
	// Set Region Airport to PASSUR Airport if empty
	if (0 == strlen(id->m_strRegionArpt)){
		strcpy_s(id->m_strRegionArpt, 6, id->m_sCurLayout.m_strPassurArpt);
		StrUpper(id->m_strRegionArpt);
	}
	regarpt = id->m_strRegionArpt;



	if (strlen(regarpt) && !strcasecmp(regarpt, pssrarpt)){
		// did not change airports, set all rows inactive so we know if we left a region
		for (i = 0; i < ((VO*)(id->m_pROIDataVO))->count; i++){
			VV((VO*)(id->m_pROIDataVO), i, "Active", int) = 0;  // inactivate, assume no longer in list
			if (!VV((VO*)(id->m_pROIDataVO), i, "endtime", int)){
				flightid = VP((VO*)(id->m_pROIDataVO), i, "flightid", char);

				if (!strcmp(flightid, testflightid)){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s , setting endtime = '%s'\n",
						cdwThreadId, testflightid, VOTimeFmt(tmptimebuf, VV((VO*)(id->m_pROIDataVO), i, "lasttime", int), "%Y-%m-%d %H:%M:%S"));
				}
				VV((VO*)(id->m_pROIDataVO), i, "endtime", int) =
					VV((VO*)(id->m_pROIDataVO), i, "lasttime", int); // assume it ended. If active, we will fill endtime=0 below
			}
		}
	} else {		
		// clear out data also
		if (id->m_pROIDataVO){
			vo_rm_rows(id->m_pROIDataVO, 0, ((VO*)(id->m_pROIDataVO))->count);
		}
	}

	// This section Handles Pre-Loading of Active Region Data from the Historical Download
	MergeRegions(id);

	if (!debug)
		D_CONTROL("HIST_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CalcRegionsVO='%s'\n\n", cdwThreadId, vo_printstr(id->m_pROIDataVO)));

	for (j = 0; j < 4; j++ ){
		int bContinue = FALSE;
		switch(j){
			// ADSB
			case 0: bContinue = !id->m_sCurLayout.m_bShowADSBAircraft;
					airp = GetADSBAirP(id);
				break;
			// ASDEX
			case 1: bContinue = !id->m_sCurLayout.m_bShowASDEXAircraft;
					airp = GetASDEXAirP(id);
				break;
			// MLAT
			case 2: bContinue = !id->m_sCurLayout.m_bShowMLATAircraft;
					airp = GetMLATAirP(id);
				break;
			//	GATE
			case 3: bContinue = !(id->m_sCurLayout.m_bShowASDEXAircraft || id->m_sCurLayout.m_bShowMLATAircraft);
					airp = GetGateAirP(id);
				break;
		}
		if(bContinue) continue;

	for (i = 0; i < N_TRACK_ID; i++){
		if (!(air = airp[i])){
			continue;
		}
		// see if latest point is inside a ROI
		if (!(trackarr = air->TrackPtr)){
			/* no tracks yet */
			continue;
		}

		//@@@mct Ignore Ground Vehicles in Region Info???
		if (air->vehicle){
			continue;
		}
		tcount = air->tcount;

		// filter out UNKN flights. we have to figure out if they will be part of ROI
		if (!strncasecmp(air->FltNum, "UNKN", 4) || !strncasecmp(air->FltNum, "MISC", 4)){
			continue;
		}
		x = trackarr[tcount - 1].x;  // get latest point
		y = trackarr[tcount - 1].y;
		sutc = trackarr[tcount - 1].utc;

		//  mhm test 18mar2014 make larger if ( id->m_tPlotTime - sutc > 5 ){
		if (id->m_tPlotTime - sutc > 60){
			// we should have already processed this point
			// try to speed things up by skipping this so we don't reprocess the same point over and over
			continue;
		}
		regionnum = 0;
		air->InRegion = FALSE;
		air->OnRwy = FALSE;

		// Clear Alerts To Start because we only do alerts inside airport regions
		if (ALERT_RG_OTO == air->alert || ALERT_RG_OTI == air->alert){
			air->alert = ALERT_NONE;
			air->alert_level = ALERT_LEVEL_NONE;
		}

		// Clear Status of aircraft being in MLAT region
		air->InMlatRegion = FALSE;
		
		while ((region = InRegion(id, x, y, &regionnum))){
			// find prior row in ROIDataVO

			rcount = ((VO*)(id->m_pROIDataVO))->count;
			sprintf_s(uniqueid, _countof(uniqueid), "%s%s", air->FltNum, region);
			CleanString(uniqueid);

			//  we must process all matching rows
			//if ( (row_index = vo_multisearch((VO*)(id->m_pROIDataVO), "flightid", (char *) air->FltNum, "Region", region, NULL )) ){
			if ((row_index = vo_search((VO*)(id->m_pROIDataVO), "uniqueid", uniqueid))){
				// matches, but make sure row is not an old one from arrival leg
				rownum = row_index->rownum;

				minmaxroi(id, rownum, air->FltNum, region, &minrow, &maxrow);
				for (rownum = minrow; rownum <= maxrow; rownum++){

					// sanity check for bad rows where flightid does not match
					if (strcmp(air->FltNum, VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char))){
						// bad match
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s min/max rownum flightid not matching with %s\n",
							cdwThreadId, air->FltNum, VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char));
						continue;
					}

					if (id->m_tPlotTime - VV((VO*)(id->m_pROIDataVO), rownum, "lasttime", int) > id->m_nMaxRegionSecs){
						// this row already ended, so do not change it so it does not combine arrival and departure legs
						vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s plot(%d)-lasttime(%d) > MAX_REGION_SECS(%d), not matching\n",
							cdwThreadId, air->FltNum, id->m_tPlotTime, VV((VO*)(id->m_pROIDataVO), rownum, "lasttime", int), id->m_nMaxRegionSecs);
						continue;
					} else {
						// found a match, rownum points to correct row
						break;
					}
				}
				if (rownum > maxrow){
					// no rows matched
					rownum = rcount;
				}
			} else {
				// no matches, so create a new row
				rownum = rcount;
			}

			new_rownum_reorder = 0;
			if (rownum < rcount){
				// existing rownum
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "action", char), FLTNUM_SIZE, "update");
			} else {				
				//  do not allocate a new row if it is too old
				if (id->m_tPlotTime - sutc > id->m_nMaxRegionSecs){
					// do not add this row to avoid adding one every cycle. this data is old
					//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "%s skipping old data plot=%d sutc=%d\n",
					//				air->FltNum, id->m_tPlotTime, sutc  );
					continue;  // go to next region
				}

				vo_alloc_rows(id->m_pROIDataVO, 1);
				rownum = ((VO*)(id->m_pROIDataVO))->count - 1;
				//if ( rownum > 500 ){
				//	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "%s too many rows, rownum=%d\n", air->FltNum, rownum );
				//}
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "uniqueid", char), 60, uniqueid);
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "Region", char), 33, region);
				VV((VO*)(id->m_pROIDataVO), rownum, "starttime", int) = sutc;
				VV((VO*)(id->m_pROIDataVO), rownum, "lasttime", int) = sutc;
				if (!strcmp(air->FltNum, testflightid)){
					// debug
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s found in region %s, , new lasttime='%s' x=%1.6f y=%1.6f\n",
						cdwThreadId, air->FltNum, region, VOTimeFmt(tmptimebuf, sutc, "%Y-%m-%d %H:%M:%S"), x, y);
				}
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "arpt", char), ARPT_CODE_SIZE, id->m_sCurLayout.m_strPassurArpt);
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char), FLTNUM_SIZE, air->FltNum);
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "action", char), FLTNUM_SIZE, "insert");

				D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s adding ROI region %s, sutc=%d, plottime=%d rownum=%d\n",
					cdwThreadId, air->FltNum, region, sutc, id->m_tPlotTime, rownum));
				new_rownum_reorder = 1;
				// we are no longer sorting since we must check all rows vo_order( id->m_pROIDataVO );  // must resort after adding row
				// vo_order( id->m_pROIDataVO );
			}

			// update the ROIDataVO with this new data
			// sanity check for bad rows where flightid does not match
			if (strcmp(air->FltNum, VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char))){
				// bad match
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s flightid not matching with %s, rcount=%d rownum=%d\n",
					cdwThreadId, air->FltNum, VP((VO*)(id->m_pROIDataVO), rownum, "flightid", char), rcount, rownum);
				continue;
			}


			strncpy_s(air->Region, REGION_SIZE, region, sizeof(air->Region));
			air->InRegion = TRUE;
			strncpy_s(arpt, 5, id->m_sCurLayout.m_strPassurArpt, _TRUNCATE);
			StrUpper(arpt);
			strncpy_s(destination, 5, air->Destin, _TRUNCATE);
			if (strlen(destination) == 4){
				memmove(destination, &destination[1], 3);
				destination[3] = '\0';
			}

			strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "fix", char), DEP_FIX_SIZE, "");
			if (strlen(destination) && !strcmp(arpt, destination)){
				// destination matches, aircraft is arriving
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "arrdep", char), 2, "A");
			} else if ( strlen( destination ) ){
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "arrdep", char), 2, "D");
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "fix", char), DEP_FIX_SIZE, air->DepartureFix);
			} else {
				strcpy_s(VP((VO*)(id->m_pROIDataVO), rownum, "arrdep", char), 2, "U");  // unknown
			}

			VV((VO*)(id->m_pROIDataVO), rownum, "lasttime", int) = sutc;
			VV((VO*)(id->m_pROIDataVO), rownum, "Active", int) = 1; // activate current region as IN

			elapsed = id->m_tPlotTime - VV((VO*)(id->m_pROIDataVO), rownum, "starttime", int);
			if (elapsed < 0) elapsed = 0;
			VV((VO*)(id->m_pROIDataVO), rownum, "elapsed", int) = elapsed;
			VV((VO*)(id->m_pROIDataVO), rownum, "endtime", int) = 0; // has not ended

			// sanity check
			if (sutc < VV((VO*)(id->m_pROIDataVO), rownum, "starttime", int)){
				D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s starttime > current point %s, sutc=%d, start=%d plottime=%d rownum=%d\n",
					cdwThreadId, air->FltNum, region, sutc, VV((VO*)(id->m_pROIDataVO), rownum, "starttime", int), id->m_tPlotTime, rownum));
			}
			if (new_rownum_reorder){
				vo_order(id->m_pROIDataVO);
			}

			// Check and Update Region Alert OTO
			endtime = VV((VO*)(id->m_pROIDataVO), rownum, "endtime", int);
			strcpy_s(arrdep, 2, VP((VO*)(id->m_pROIDataVO), rownum, "arrdep", char));
			if (!strcasecmp(region, "Out") && !strcmp(arrdep, "D") && !endtime)
			{
				air->rg_oto = elapsed;
				if (id->m_nRegionAlertEnabled){
					if (elapsed > id->m_nRegionOTORed){
						if (ALERT_NONE == air->alert){
							air->alert = ALERT_RG_OTO;
							air->alert_level = ALERT_LEVEL_HIGH;
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region %s OTO RED Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapsed);
						}
					}else if ( elapsed > id->m_nRegionOTOYellow ){
						if (ALERT_NONE == air->alert){
							air->alert = ALERT_RG_OTO;
							air->alert_level = ALERT_LEVEL_MED;
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region %s OTO YELLOW Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapsed);
						}
					}
				}

			} else if ( !strcasecmp(region, "On") && !strcmp(arrdep, "A") && !endtime ){
				air->rg_oti = elapsed;
				if (id->m_nRegionAlertEnabled){
					if (elapsed > id->m_nRegionOTIRed){
						if (ALERT_NONE == air->alert){
							air->alert = ALERT_RG_OTI;
							air->alert_level = ALERT_LEVEL_HIGH;
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region %s OTI RED Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapsed);
						}
					}else if ( elapsed > id->m_nRegionOTIYellow ){
						if (ALERT_NONE == air->alert){
							air->alert = ALERT_RG_OTI;
							air->alert_level = ALERT_LEVEL_MED;
							vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Region %s OTI YELLOW Alert with elapsed(%d)\n", cdwThreadId, air->FltNum, elapsed);
						}
					}
				}
			}else if ( !strcasecmp(region, "MVNT") && !endtime){
				air->tt = elapsed;
			}
			if ( !strcasecmp(region, "MLAT") && !endtime){
				air->InMlatRegion = TRUE;
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Flight <%s, %d> in MLAT defined region\n",  cdwThreadId, air->FltNum, air->trackid);
			}
			if ( !strcasecmp(region, "RWY") && !endtime){
				air->OnRwy = TRUE;
			}

		}  // end of regions while loop

		//vo_order( id->m_pROIDataVO );		
	}

	} // End Processing all AIRP's

	// go through all Regions and timeout old flights
	for (i = 0; i < ((VO*)(id->m_pROIDataVO))->count && i >= 0; i++){
		// for debugging
		flightid = VP((VO*)(id->m_pROIDataVO), i, "flightid", char);

		if (!strcmp(flightid, testflightid)){
			// debug
			//vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "%s found it\n", flightid );
			if (VV((VO*)(id->m_pROIDataVO), i, "Active", int) == 0){
				//  no longer in this region
				// this should not be needed
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s endtime='%s'  lasttime='%s'\n",
					cdwThreadId, flightid,
					VOTimeFmt(tmptimebuf2, VV((VO*)(id->m_pROIDataVO), i, "endtime", int), "%Y-%m-%d %H:%M:%S"),
					VOTimeFmt(tmptimebuf, VV((VO*)(id->m_pROIDataVO), i, "lasttime", int), "%Y-%m-%d %H:%M:%S"));

				if (VV((VO*)(id->m_pROIDataVO), i, "endtime", int) != VV((VO*)(id->m_pROIDataVO), i, "lasttime", int)){
					VV((VO*)(id->m_pROIDataVO), i, "endtime", int) =
						VV((VO*)(id->m_pROIDataVO), i, "lasttime", int); // it ended. 
				}
			}
		}
		if (!VV((VO*)(id->m_pROIDataVO), i, "endtime", int)){
			// region has NOT ended yet
			// if we have not received a track point for 15 minutes, set endtime of ROI
			if (id->m_tPlotTime - VV((VO*)(id->m_pROIDataVO), i, "lasttime", int) > id->m_nMaxRegionTimeout){
				VV((VO*)(id->m_pROIDataVO), i, "endtime", int) = VV((VO*)(id->m_pROIDataVO), i, "lasttime", int);
				D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s plot - lasttime > ROI_TRACK_TIMEOUT(%d secs), end=lasttime\n",
					cdwThreadId, VP((VO*)(id->m_pROIDataVO), i, "flightid", char), id->m_nMaxRegionTimeout));
				// update elapsed to match endtime
				elapsed = VV((VO*)(id->m_pROIDataVO), i, "endtime", int) - VV((VO*)(id->m_pROIDataVO), i, "starttime", int);
				VV((VO*)(id->m_pROIDataVO), i, "elapsed", int) = elapsed;

				// sanity check and find some bad rows
				if (elapsed < 0){
					vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s flight TIMEOUT, elapsed is less than zero, end=%d start=%d plottime=%d\n",
						cdwThreadId,
						VP((VO*)(id->m_pROIDataVO), i, "flightid", char),
						VV((VO*)(id->m_pROIDataVO), i, "endtime", int),
						VV((VO*)(id->m_pROIDataVO), i, "starttime", int),
						id->m_tPlotTime);
				}
			}
		} else {
			// region has ended, calc elapsed
			elapsed = VV((VO*)(id->m_pROIDataVO), i, "endtime", int) - VV((VO*)(id->m_pROIDataVO), i, "starttime", int);
			VV((VO*)(id->m_pROIDataVO), i, "elapsed", int) = elapsed;

			// sanity check and find some bad rows
			if (elapsed < 0){
			}

			// get rid of ended rows (moves them to Background thread)
			if (id->m_tPlotTime - VV((VO*)(id->m_pROIDataVO), i, "lasttime", int) > id->m_nRegionTimeoutDelay){
				// Marking old row for delete, keeping for an extra 30 secs.
				//strcpy_s( VP((VO*)(id->m_pROIDataVO), i, "action", char ), FLTNUM_SIZE, "update" );
				//if ( id->m_tPlotTime - VV((VO*)(id->m_pROIDataVO), i, "lasttime", int ) > (id->m_nRegionTimeoutDelay + 30) ){
				// This section Handles Pre-Loading of Region Data from the Historical Download
				if (TryEnterCriticalSection(&id->m_csROIHist)){
					// Pull Historical Active VO to process
					char tmptimebuf2[64] = { 0 };
					VO* ROIHist = NULL;
					if (!id->m_pROINewHistVO){
						id->m_pROINewHistVO = (VO*)CreateRegionVO(id, "ROINewHistVO");
					}
					ROIHist = (VO*)id->m_pROINewHistVO;
					// Add Row To NewHist and Delete
					vo_alloc_rows(ROIHist, 1);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "uniqueid", char), 60, VP(ROIDataVO, i, "uniqueid", char), _TRUNCATE);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "Region", char), 33, VP(ROIDataVO, i, "Region", char), _TRUNCATE);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "flightid", char), FLTNUM_SIZE, VP(ROIDataVO, i, "flightid", char), _TRUNCATE);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "arpt", char), 5, VP(ROIDataVO, i, "arpt", char), _TRUNCATE);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "fix", char), 5, VP(ROIDataVO, i, "fix", char), _TRUNCATE);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "action", char), FLTNUM_SIZE, VP(ROIDataVO, i, "action", char), _TRUNCATE);
					VV(ROIHist, ROIHist->count - 1, "starttime", int) = VV(ROIDataVO, i, "starttime", int);
					VV(ROIHist, ROIHist->count - 1, "endtime", int) = VV(ROIDataVO, i, "endtime", int);
					VV(ROIHist, ROIHist->count - 1, "elapsed", int) = VV(ROIDataVO, i, "elapsed", int);
					strncpy_s(VP(ROIHist, ROIHist->count - 1, "arrdep", char), 2, VP(ROIDataVO, i, "arrdep", char), _TRUNCATE);
					VV(ROIHist, ROIHist->count - 1, "lasttime", int) = VV(ROIDataVO, i, "lasttime", int);
					VV(ROIHist, ROIHist->count - 1, "Active", int) = VV(ROIDataVO, i, "Active", int);
					D_CONTROL("HIST_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Active to Historical ROI: %s:%s:%s, ST:%s, ET:%s\n",
						cdwThreadId,
						VP(ROIHist, ROIHist->count - 1, "arpt", char),
						VP(ROIHist, ROIHist->count - 1, "Region", char),
						VP(ROIHist, ROIHist->count - 1, "flightid", char),
						VOTimeFmt(tmptimebuf, VV(ROIHist, ROIHist->count - 1, "starttime", int), "%Y-%m-%d %H:%M:%S"),
						VOTimeFmt(tmptimebuf2, VV(ROIHist, ROIHist->count - 1, "endtime", int), "%Y-%m-%d %H:%M:%S")));

					// remove row so they do not stay on forever
					D_CONTROL(__FUNCTION__, vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) %s removing OLD row end=%d start=%d plottime=%d\n",
						cdwThreadId,
						VP(ROIDataVO, i, "flightid", char),
						VV(ROIDataVO, i, "endtime", int),
						VV(ROIDataVO, i, "starttime", int),
						id->m_tPlotTime));
					vo_rm_row(ROIDataVO, i);
					i--;
					LeaveCriticalSection(&id->m_csROIHist);
				}

				// no need to reorder since we deleted and remain rows should be OK ----   vo_order( id->m_pROIDataVO );
				vo_order(ROIDataVO);
				//}
			}


		}
		if (strlen(testflightid) && !strcmp(flightid, testflightid)){

			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "%s found TEST FLIGHT, end=%d start=%d plottime=%d reg=%s last=%d elapsed=%d\n",
				VP((VO*)(id->m_pROIDataVO), i, "flightid", char),
				VV((VO*)(id->m_pROIDataVO), i, "endtime", int),
				VV((VO*)(id->m_pROIDataVO), i, "starttime", int),
				id->m_tPlotTime,
				VP((VO*)(id->m_pROIDataVO), i, "Region", char),
				VV((VO*)(id->m_pROIDataVO), i, "lasttime", int),
				VV((VO*)(id->m_pROIDataVO), i, "elapsed", int));
		}
	}
	if (!debug)
		D_CONTROL("HIST_REGION_DATA", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CalcRegionsVO='%s'\n\n", cdwThreadId, vo_printstr(id->m_pROIDataVO)));
	BuildRegionsJSON(id, id->m_pROIDataVO);




	if (OpenglGrid){
		nowsecs = time(0);
		if (!lastgridup || nowsecs - lastgridup > 5){
			UpdateROIGridVO(id);
			lastgridup = nowsecs;
		}
	}

	debug = 1;
}





int drawEditPolys(struct InstanceData* id)
{
	points *np;

	if (!editpoly){
		return(FALSE);
	}

	glPushMatrix();
	glLoadIdentity();

	glColor3f(1.0f, 1.0f, 1.0f); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_dWidth, 0, id->m_dHeight, 0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);


	glColor4f(1.0f, 0.0f, 0.0f, 0.5f); /* fill polys with red */

	// make the polygon transparent so that the user can continue drawing polygon 
	// even if non-convex poly is not filled properly yet
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	if (!editlist && editpoly){
		editlist = CreateTessPoly(editpoly);
	}

	glCallList(editlist);


	// draw line around polys to make them more visible
	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	glBegin(GL_LINE_LOOP);

	for (np = editpoly->ppoints; np; np = np->np){
		glVertex3f((float)np->vt[0], (float)np->vt[1], 0.0f);
	}
	// go back and connect to first point
	if ((np = editpoly->ppoints)){
		glVertex3f((float)np->vt[0], (float)np->vt[1], 0.0f);
	}
	glEnd();

	glFlush();

	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0f, 1.0f, 1.0f);
	return(TRUE);
}


void ResetADTCriticalSections(struct InstanceData* id)
{
	// Check PASSUR Data Thread CS
	if (TryEnterCriticalSection(&id->m_csPassurSync))
		LeaveCriticalSection(&id->m_csPassurSync);
	else{
		// Reset if we could not lock it
		DeleteCriticalSection(&id->m_csPassurSync);
		InitializeCriticalSection(&id->m_csPassurSync);
	}

	// Check ASDE-X Data Thread CS
	if (TryEnterCriticalSection(&id->m_csASDEXSync))
		LeaveCriticalSection(&id->m_csASDEXSync);
	else{
		// Reset if we could not lock it
		DeleteCriticalSection(&id->m_csASDEXSync);
		InitializeCriticalSection(&id->m_csASDEXSync);
	}

	// Check ASDI Data Thread CS
	if (TryEnterCriticalSection(&id->m_csASDSync))
		LeaveCriticalSection(&id->m_csASDSync);
	else{
		// Reset if we could not lock it
		DeleteCriticalSection(&id->m_csASDSync);
		InitializeCriticalSection(&id->m_csASDSync);
	}
}




drawHistoricalTimes(struct InstanceData* id)
{
	VO *HistoricalTrackVO, *HistoricalHdrVO;
	int i, trk, len;
	double x2, y2;
	int pflag = 0, selindex;
	static int testsmoothflag = 0;
	char *fromto, *str;
	char arptbuf[5];

	// char src_radar[12];
	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glColor3fv(darkpurple);



	for (i = 0, selindex = 0; HisVO && i < HisVO->count; i++){
		/* draw a line between all of the points */
		// see if the track is in the list box and selected
		if (BlockSelectedBuffer[selindex] != i){
			// not selected
			continue;
		}
		selindex++;

		// HistoricalTrackVO = HistoricalTracksVO[i];
		HistoricalTrackVO = VV(HisVO, i, "HTrackVO", void *);
		HistoricalHdrVO = VV(HisVO, i, "HHdrVO", void *);

		fromto = VP(HistoricalHdrVO, 0, "fromto", char);

		// get rid of K if leading part of from to
		if ((str = strstr(fromto, "-"))){
			len = str - fromto;
			if (len <= 4){
				strncpy_s(arptbuf, sizeof(arptbuf), fromto, 4);
				arptbuf[4] = '\0';
				if (arptbuf[0] == 'K'){
					memcpy(arptbuf, &arptbuf[1], 3);
					arptbuf[3] = '\0';
				}
			}
		} else {
			arptbuf[0] = '\0';
		}

		if (HistoricalTrackVO == BestVO){
			glColor3fv(blue); // selected flight
		} else if ( !strncasecmp( arptbuf, ReplayArpt, 3) ){
			// departure matches replay airport
			glColor3fv(red);
		} else {
			// arrival
			glColor3fv(green);
		}


		for (trk = 0; HistoricalTrackVO && trk < HistoricalTrackVO->count; trk++){
			// if ( !tcheck || airplottime >= endutc){
			x2 = VV(HistoricalTrackVO, trk, "X", double);
			y2 = VV(HistoricalTrackVO, trk, "Y", double);

			// get rid of obviously bad tracks, like 0,0
			if (fabs(x2) < 1.0 && fabs(y2) < 1.0){
				// bad track

			} else {
				// glVertex3f( (float) x2, (float) y2, 0.0f );
				drawTrailLabel(id, x2, y2, VV(HistoricalTrackVO, trk, "utc", int));
			}



		}
		// glEnd();
	}

	glFlush();



	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}




drawHistoricalTracks(struct InstanceData* id)
{
	VO *HistoricalTrackVO, *HistoricalHdrVO;
	int i, trk, len;
	double x2, y2;
	int pflag = 0, selindex;
	static int testsmoothflag = 0;
	char *fromto, *str;
	char arptbuf[5];

	// char src_radar[12];

	glPushMatrix();
	glLoadIdentity();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	RotateView(id, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin,
		id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);


	for (i = 0, selindex = 0; HisVO && i < HisVO->count; i++){
		/* draw a line between all of the points */
		// see if the track is in the list box and selected
		if (BlockSelectedBuffer[selindex] != i){
			// not selected
			continue;
		}
		selindex++;

		// HistoricalTrackVO = HistoricalTracksVO[i];
		HistoricalTrackVO = VV(HisVO, i, "HTrackVO", void *);
		HistoricalHdrVO = VV(HisVO, i, "HHdrVO", void *);

		fromto = VP(HistoricalHdrVO, 0, "fromto", char);

		// get rid of K if leading part of from to
		if ((str = strstr(fromto, "-"))){
			len = str - fromto;
			if (len <= 4){
				strncpy_s(arptbuf, sizeof(arptbuf), fromto, 4);
				arptbuf[4] = '\0';
				if (arptbuf[0] == 'K'){
					memcpy(arptbuf, &arptbuf[1], 3);
					arptbuf[3] = '\0';
				}
			}
		} else {
			arptbuf[0] = '\0';
		}

		if (HistoricalTrackVO == BestVO){
			glColor3fv(blue); // selected flight
		} else if ( !strncasecmp( arptbuf, ReplayArpt, 3) ){
			// departure matches replay airport
			glColor3fv(red);
		} else {
			// arrival
			glColor3fv(green);
		}

		glBegin(GL_LINE_STRIP);
		for (trk = 0; HistoricalTrackVO && trk < HistoricalTrackVO->count; trk++){
			// if ( !tcheck || airplottime >= endutc){
			x2 = VV(HistoricalTrackVO, trk, "X", double);
			y2 = VV(HistoricalTrackVO, trk, "Y", double);

			// get rid of obviously bad tracks, like 0,0
			if (fabs(x2) < 1.0 && fabs(y2) < 1.0){
				// bad track

			} else {
				glVertex3f((float)x2, (float)y2, 0.0f);
			}



		}
		glEnd();
	}

	glFlush();



	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}


void UpdateFDOGrid(struct InstanceData* id)
{
	int i;
	MGLGRID *FDOGrid;
	time_t nowsecs;
	static time_t LastFDOFillSecs;
	char *DataSource;

	// we will have to do this for every ROIGrid, but for now just find the first one ........
	if ((nowsecs = time(0)) - LastFDOFillSecs < 30) return;

	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	for (i = 0, FDOGrid = NULL; DataAppGrid && DataAppGrid->vo && i < DataAppGrid->vo->count; i++){
		DataSource = VP(DataAppGrid->vo, i, "DataSource", char);
		if (!strcmp(DataSource, "FDO")){
			FDOGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
			if (FDOGrid && FDOGrid->vo && FDOGrid->parent_w->visible == TRUE){
				if (FDOGrid->UpdateCB){
					FDOGrid->UpdateCB(id, FDOGrid);
				}
				LastFDOFillSecs = nowsecs;
			}
			else if (FDOGrid && FDOGrid->vo && FDOGrid->active_icon == 2){
					if (FDOGrid->UpdateCB){
						FDOGrid->UpdateCB(id, FDOGrid);
					}
					LastFDOFillSecs = nowsecs;					
				}
		}
	}
}

void UpdateSAGrid(struct InstanceData* id)
{
	int i;
	MGLGRID *SAGrid;
	time_t nowsecs;
	static time_t LastSAFillSecs;
	char *DataSource;

	// we will have to do this for every ROIGrid, but for now just find the first one ........
	if ((nowsecs = time(0)) - LastSAFillSecs < 30) return;

	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	for (i = 0, SAGrid = NULL; DataAppGrid && DataAppGrid->vo && i < DataAppGrid->vo->count; i++){
		DataSource = VP(DataAppGrid->vo, i, "DataSource", char);
		if (!strcmp(DataSource, "SysAlerts")){
			SAGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
			if (SAGrid && SAGrid->vo && SAGrid->parent_w->visible == TRUE){
				if (SAGrid->UpdateSACB){
					SAGrid->UpdateSACB(id, SAGrid);
				}
				LastSAFillSecs = nowsecs;
			}
			else if (SAGrid && SAGrid->vo && SAGrid->active_icon == 3){
				if (SAGrid->UpdateSACB){
					SAGrid->UpdateSACB(id, SAGrid);
				}
				LastSAFillSecs = nowsecs;
			}
		}
	}
}




/* function to reset our viewport after a window resize */
int ResizeWindowPicinPic(struct InstanceData* id, int xstart, int ystart, int width, int height)
{
	/* Height / width ratio */
	GLfloat ratio;
	double CurrentYSize, CurrentXSize;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (width == 0 || height == 0){
		// window was closed, do nothing
		return(TRUE);
	}

	wglMakeCurrent(id->m_hDC, id->m_hRCActive);

	id->m_dWidth = width;
	id->m_dHeight = height;
	id->m_nWidth = width;
	id->m_nHeight = height;

	id->m_nViewPortYOrig = 0;
	id->m_nViewPortXOrig = 0;
	id->m_nViewPortWidth = id->m_nWidth;
	id->m_nViewPortHeight = id->m_nHeight;

	/* Protect against a divide by zero */
	if (height == 0)
		height = 1;

	ratio = (GLfloat)width / (GLfloat)height;

	D_CONTROL("ResizeWindow", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) width=%d height=%d ratio=%g\n", cdwThreadId, width, height, ratio));

	/* change to the projection matrix and set our viewing volume. */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	glOrtho(0.0f, width, 0.0f, height, 0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	/* void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
	/ Defines a pixel rectangle in the window into which the final image is mapped. The (x, y) parameter specifies the lower-left corner
	/ of the viewport, and width and height are the size of the viewport rectangle. By default, the initial viewport values are
	/ (0, 0, winWidth, winHeight), where winWidth and winHeight are the size of the window. */

	/* Setup our viewport. */
	glViewport(xstart, ystart, (GLsizei)width, (GLsizei)height);
	D_CONTROL("ResizeWindow", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Setting GLViewport(%d, %d, %d, %d)\n", cdwThreadId, id->m_nControlId, 0, 0, width, height));

	D_CONTROL("ResizeWindow", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Current Values: WorldXmax=%g WorldXmin=%g WorldXSize=%g WorldYmax=%g WorldYmin=%g WorldYSize=%g\n",
		cdwThreadId, id->m_dWorldXmax, id->m_dWorldXmin, id->m_dWorldXSize, id->m_dWorldYmax, id->m_dWorldYmin, id->m_dWorldYSize));

	/* make World Coordinates match aspect ratio of screen */
	if (id->m_dWorldXSize > id->m_dWorldYSize){
		CurrentYSize = id->m_dWorldYSize;
		id->m_dWorldYSize = (id->m_dWorldXSize / ratio);
		id->m_dWorldYmax = id->m_dWorldYmin + id->m_dWorldYSize;
	}
	else {
		CurrentXSize = id->m_dWorldXSize;
		id->m_dWorldXSize = (id->m_dWorldYSize * ratio);
		id->m_dWorldXmax = id->m_dWorldXmin + id->m_dWorldXSize;
	}

	D_CONTROL("ResizeWindow", vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New Values: WorldXmax=%g WorldXmin=%g WorldXSize=%g WorldYmax=%g WorldYmin=%g WorldYSize=%g\n",
		cdwThreadId, id->m_dWorldXmax, id->m_dWorldXmin, id->m_dWorldXSize, id->m_dWorldYmax, id->m_dWorldYmin, id->m_dWorldYSize));

	return(TRUE);
}



drawPicBox(struct InstanceData* id)
{
	// draw border around Pic in Pic 

	// drawbox();

	glLoadIdentity();

	glColor3f(1.0f, 1.0f, 1.0f); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);


	glLineWidth(8);
	glBegin(GL_LINE_STRIP);
	glColor3f(1.0, 0.0, 0.0);

	glVertex3f(0.0f, 0.0f, 0.0f);
	glVertex3f(300.0f, 0.0f, 0.0f);
	glVertex3f(300.0f, 300.0f, 0.0f);
	glVertex3f(0.0f, 300.0f, 0.0f);
	glVertex3f(0.0f, 0.0f, 0.0f);

	glEnd();
	glLineWidth(1);
}



drawPicBoxOLD(struct InstanceData* id)
{
	// draw border around Pic in Pic 

	// drawbox();

	glLoadIdentity();

	glColor3f(1.0f, 1.0f, 1.0f); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);


	glLineWidth(5);
	glBegin(GL_LINE_STRIP);
	glColor3f(1.0, 0.0, 0.0);
	glVertex3f((float)id->m_sCurLayout.m_dWorldXmin, (float)id->m_sCurLayout.m_dWorldYmin, 0.0f);
	glVertex3f((float)id->m_sCurLayout.m_dWorldXmax, (float)id->m_sCurLayout.m_dWorldYmin, 0.0f);
	glVertex3f((float)id->m_sCurLayout.m_dWorldXmax, (float)id->m_sCurLayout.m_dWorldYmax, 0.0f);
	glVertex3f((float)id->m_sCurLayout.m_dWorldXmin, (float)id->m_sCurLayout.m_dWorldYmax, 0.0f);
	glVertex3f((float)id->m_sCurLayout.m_dWorldXmin, (float)id->m_sCurLayout.m_dWorldYmin, 0.0f);

	glEnd();
	glLineWidth(1);
}



// Called to draw scene
void RenderScenePicInPic(struct InstanceData* id)
{
	double fps;
	static char tmpstr[256];
	struct timeb start_time, done_time;
	static time_t start_fps, end_fps, nowsecs;
	static int loopcount = 0;
	double saveWorldXmin, saveWorldXmax, saveWorldYmin, saveWorldYmax;
	int saveWidth, saveHeight;

	// static VO *AirVO;
	int nVO = 0;
	int wx;
	const DWORD cdwThreadId = GetCurrentThreadId();
	//VO *ColorgateAircraftVO=NULL;

	saveWorldXmin = id->m_sCurLayout.m_dWorldXmin;
	saveWorldXmax = id->m_sCurLayout.m_dWorldXmax;
	saveWorldYmin = id->m_sCurLayout.m_dWorldYmin;
	saveWorldYmax = id->m_sCurLayout.m_dWorldYmax;
	saveWidth = id->m_nWidth;
	saveHeight = id->m_nHeight;


	ResizeWindowPicinPic(id, 100, 100, 300, 300);

	/* renderscene already cleared window
	// Clear the window
	GL_ASSERT(glClear(GL_COLOR_BUFFER_BIT));
	if (id->m_sCurLayout.m_bShowWorldMap){
	GL_ASSERT(glClearColor(id->m_sCurLayout.m_glfWaterFillColor[0], id->m_sCurLayout.m_glfWaterFillColor[1], id->m_sCurLayout.m_glfWaterFillColor[2], 0.0f));
	// glClearColor(0.0f, 0.0f, 1.0f, 0.0f);
	}
	else {
	GL_ASSERT(glClearColor(0.0f, 0.0f, 0.0f, 0.0f));
	}
	*/


	// glClearColor(0.0f, 0.0f, 1.0f, 1.0f );
	glLoadIdentity();
	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	//glOrtho((GLfloat) 0, (GLfloat) STRAT_XSIZE,
	// (GLfloat) 0, (GLfloat) STRAT_YSIZE, 0.0f, 1.0f);
	{
		char strDebug[200] = { 0 };
		sprintf_s(strDebug, _countof(strDebug), "WorldXmin:%f, WorldXmax:%f, WorldYmin:%f, WorldYmax:%f",
			id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax);
		TIME_TRACE_DBG(strDebug);
	}

	// change the coordinates of smaller window
	id->m_sCurLayout.m_dWorldXmin = -84.45;
	id->m_sCurLayout.m_dWorldXmax = -84.40;
	id->m_sCurLayout.m_dWorldYmin = 33.61;
	id->m_sCurLayout.m_dWorldYmax = 33.65;
	id->m_dWorldYSize = (id->m_dWorldYmax - id->m_dWorldYmin);
	id->m_dWorldXSize = (id->m_dWorldXmax - id->m_dWorldXmin);


	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	// DrawSatMapLayer(1, "jfksq", -73.81, 40.615, -73.749, 40.676 );

	if (id->m_sCurLayout.m_bShowWorldMap){
		TIME_TRACE_DBG("START - ShowWorldMap");
		fillBinaryTriangles(id);
		fillLakes(id);
		TIME_TRACE_DBG("END - ShowWorldMap");
	}



	if (id->m_sCurLayout.m_bShowWorldBorders){
		TIME_TRACE_DBG("START - ShowWorldBorders");
		drawBorders(id);
		TIME_TRACE_DBG("END - ShowWorldBorders");
	}

	if (id->m_sCurLayout.m_bShowRunways){
		TIME_TRACE_DBG("START - ShowRunways");
		DrawRunways(id);
		TIME_TRACE_DBG("END - ShowRunways");
	}


	if (ShowHiResMap){
		TIME_TRACE_DBG("START - ShowHiResMap");
		DrawHiResMap(id);
		TIME_TRACE_DBG("END - ShowHiResMap");
	}

	if (id->m_sCurLayout.m_bShowWeather){
		// Must be in live mode to see weather
		if (id->m_nDelaySecs == 0){
			TIME_TRACE_DBG("START - drawWX");
			for (wx = 0; wx < NActiveRadars; wx++){
				drawWx(id, wx);
			}
			TIME_TRACE_DBG("END - drawWX");
		}
	}

	if (id->m_sCurLayout.m_bShowAirportRings){
		TIME_TRACE_DBG("START - drawAirportRings");
		drawAirportRings(id);
		TIME_TRACE_DBG("END - drawAirportRings");
	}

	// DrawSatMap(0, "jfkgeo", -73.82094497, 40.64583812, -73.78516804, 40.67050178);
	// DrawSatMap(1, "jfk03789201", -73.78516804, 40.64583812, -73.7493911, 40.67050178);
	TIME_TRACE_DBG("START - drawBox");
	drawBox(id);
	TIME_TRACE_DBG("END - drawBox");

	/* not needed for Pic in Pic
	if (showlatlongs){
	TIME_TRACE_DBG("START - ShowLatLong");
	lng = (((double)id->m_nMouseX / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
	lat = (((double)id->m_nMouseY / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
	sprintf_s(tmpstr, _countof(tmpstr), "x=%d y=%d lat=%g long=%g Wxmin=%g wxmax=%g wymin=%g wymax=%g\n",
	id->m_nBoxX1, id->m_nBoxY1, lat, lng, id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax);
	DrawGLText(id, 20, 60, tmpstr, (GLfloat *)white, FALSE);
	TIME_TRACE_DBG("START - ShowLatLong");
	}

	if (id->m_bShowDepGates){
	TIME_TRACE_DBG("START - ShowDepGates");
	DrawDepartureGates(id);
	TIME_TRACE_DBG("END - ShowDepGates");
	}
	*/

	//if (SecondTabGrid)
	//{
	//	if (SecondTabGrid->childgrid)
	//	{
	//		if (SecondTabGrid->childgrid->filteredvo){
	//			if (SecondTabGrid->icon_set == 1)
	//			{
	//				if (!ColorgateAircraftVO)
	//				{
	//					ColorgateAircraftVO = (VO *)vo_create(0, NULL);
	//					vo_set(ColorgateAircraftVO, V_NAME, "ColorAircraft", NULL);
	//					VOPropAdd(ColorgateAircraftVO, "FltNum", NTBSTRINGBIND, 256, VO_NO_ROW);
	//					VOPropAdd(ColorgateAircraftVO, "ColorVO", INTBIND, 64, VO_NO_ROW);
	//					vo_alloc_row(ColorgateAircraftVO, 1);

	//				}
	//				create_gateaircraftcolors(id);
	//			}
	//		}
	//	}
	//}

	if (id->m_sCurLayout.m_bShowFltPlan){
		TIME_TRACE_DBG("START - DisplayFltPlan");
		DisplayFltPlan(id);
		TIME_TRACE_DBG("END - DisplayFltPlan");
	}


	// Do NOT Move this after Drawing aircraft routines (DrawASDEXAircraft, DrawPassurAircraft or drawASDAircraft)
	// Initializes Grids to prevent tags over aircraft.
	if (id->m_sCurLayout.m_bShowLargeTags){
		TIME_TRACE_DBG("START - ShowLargeTags");
		InitRollGrids(id);
		TIME_TRACE_DBG("END - ShowLargeTags");
	}

	if (id->m_sCurLayout.m_bShowNoiseAircraft || SAT_NOISE == id->m_nSelectedAircraftType){

		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawNoiseProcess");
			NoiseProcess(id);
			TIME_TRACE_DBG("END - DrawNoiseProcess");
		}

		TIME_TRACE_DBG("START - DrawNoiseAircraft");
		DrawNoiseAircraft(id);
		TIME_TRACE_DBG("END - DrawNoiseAircraft");
	}

	if (id->m_sCurLayout.m_bShowADSBAircraft || SAT_ADSB == id->m_nSelectedAircraftType){

		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawADSBProcess");
			ADSBProcess(id);
			TIME_TRACE_DBG("END - DrawADSBProcess");
		}

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus) {
			TIME_TRACE_DBG("START - ProcessGateFlights ADSB");
			ProcessGateFlights(id, GetADSBAirP(id), ADSB);
			TIME_TRACE_DBG("END - ProcessGateFlights ADSB");
		}

		TIME_TRACE_DBG("START - DrawADSBAircraft");
		DrawADSBAircraft(id);
		TIME_TRACE_DBG("END - DrawADSBAircraft");
	}

#ifdef AIR_ASIA_BUILD
	if (id->m_sCurLayout.m_bShowAirAsiaAircraft || SAT_AIRASIA == id->m_nSelectedAircraftType){

		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawAirAsiaProcess");
			AirAsiaProcess(id);
			TIME_TRACE_DBG("END - DrawAirAsiaProcess");
		}

		TIME_TRACE_DBG("START - DrawAirAsiaAircraft");
		DrawAirAsiaAircraft(id);
		TIME_TRACE_DBG("END - DrawAirAsiaAircraft");
	}
#endif//AIR_ASIA_BUILD
	TIME_TRACE_DBG("START - ASDEX");
	if (id->m_sCurLayout.m_bShowASDEXAircraft || SAT_ASDEX == id->m_nSelectedAircraftType){
		TIME_TRACE_DBG("START - ASDEXProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			ASDEXProcess(id);
		}
		TIME_TRACE_DBG("END - ASDEXProcess");

		// Process Gate for ASDEX, before Drawing Either
		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus)
		{
			TIME_TRACE_DBG("START - ProcessGateFlights ASDEX");
			ProcessGateFlights(id, GetASDEXAirP(id), ASDEX);
			TIME_TRACE_DBG("END - ProcessGateFlights ASDEX");
		}

		// Must lock ROI CritSect for all access to ROI VO's
		EnterCriticalSection(&id->m_csROI);
		if (id->m_pROIColors) {
			// Draw Region of Interest if there are colors
			DrawROI(id);
		}
		TIME_TRACE_DBG("START - drawEditPolys ASDEX");
		drawEditPolys(id);
		TIME_TRACE_DBG("END - drawEditPolys ASDEX");
		//TIME_TRACE_DBG("START - CalcRegions ASDEX");
		//ftime(&start_time);
		//if (CalcRegionsFlag){  // enable debug mode switch
		//	CalcRegions(id, GetASDEXAirP(id));
		//}
		//ftime(&done_time);
		//sprintf_s(tmpstr, 256, "%g", uts_timediff(&start_time, &done_time));
		//TIME_TRACE_DBG("END - CalcRegions ASDEX");
		LeaveCriticalSection(&id->m_csROI);


		if (id->m_sCurLayout.m_dWorldXSize < 10.0) {
			TIME_TRACE_DBG("START - DrawASDEXAircraft");
			if (!HisVO || !HisVO->count){
				DrawASDEXAircraft(id);
			}
			TIME_TRACE_DBG("END - DrawASDEXAircraft");
		}
	}
	TIME_TRACE_DBG("END - ASDEX");

	TIME_TRACE_DBG("START - MLAT");
	if (id->m_sCurLayout.m_bShowMLATAircraft || SAT_MLAT == id->m_nSelectedAircraftType){

		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawMLATProcess");
			MLATProcess(id);
			TIME_TRACE_DBG("END - DrawMLATProcess");
		}

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus)
		{
			TIME_TRACE_DBG("START - ProcessGateFlights MLAT");
			ProcessGateFlights(id, GetMLATAirP(id), MLAT);
			TIME_TRACE_DBG("END - ProcessGateFlights MLAT");
		}

		// Must lock ROI CritSect for all access to ROI VO's
		EnterCriticalSection(&id->m_csROI);
		if (id->m_pROIColors) {
			// Draw Region of Interest if there are colors
			DrawROI(id);
		}

		TIME_TRACE_DBG("START - drawEditPolys MLAT");
		drawEditPolys(id);
		TIME_TRACE_DBG("END - drawEditPolys MLAT");
		TIME_TRACE_DBG("START - CalcRegions MLAT");
		ftime(&start_time);
		if (CalcRegionsFlag){  // enable debug mode switch
			CalcRegions(id/*, GetMLATAirP(id)*/);
		}
		ftime(&done_time);
		sprintf_s(tmpstr, 256, "%g", uts_timediff(&start_time, &done_time));
		TIME_TRACE_DBG("END - CalcRegions MLAT");
		LeaveCriticalSection(&id->m_csROI);

		if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT ) {
			TIME_TRACE_DBG("START - DrawMLATAircraft");
			DrawMLATAircraft(id);
			TIME_TRACE_DBG("END - DrawMLATAircraft");
		}
	}
	TIME_TRACE_DBG("START - MLAT");

	if (id->m_sCurLayout.m_bShowPassurAircraft || SAT_PASSUR == id->m_nSelectedAircraftType) {

		TIME_TRACE_DBG("START - PassurProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
			PassurProcess(id, 0);
		TIME_TRACE_DBG("END - PassurProcess");

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus)
		{
			TIME_TRACE_DBG("START - ProcessGateFlights PASSUR");
			ProcessGateFlights(id, GetAirP(id, 0), PASSUR);
			TIME_TRACE_DBG("END - ProcessGateFlights PASSUR");
		}


		TIME_TRACE_DBG("START - DrawPassurAircraft");
		if (!HisVO || !HisVO->count){
			DrawPassurAircraft(id, 0);
		}
		TIME_TRACE_DBG("END - DrawPassurAircraft");
	}

	if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT) {
		
		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus) {
			TIME_TRACE_DBG("START - DrawGateAircraft MLAT");
			DrawGateAircraft(id);
			TIME_TRACE_DBG("END - DrawGateAircraft MLAT");
		}
	}

	ProcessETAPassurTracks(id);

	EnterCriticalSection(&id->m_csBlock);
	if (!ProcessingBlocks){
		if (HisVO && HisVO->count > 0){
			if (ProcessLoadFlag == TRUE){
				ProcessBlockGUI(id);
				ProcessLoadFlag = FALSE;
			}
			drawHistoricalTracks(id);
			if (id->m_sCurLayout.m_bShowTrailTimes){
				drawHistoricalTimes(id);
			}
		}
	}
	LeaveCriticalSection(&id->m_csBlock);

	if (id->m_sCurLayout.m_bShowASDAircraft || SAT_ASDI == id->m_nSelectedAircraftType){
		TIME_TRACE_DBG("START - GetASDZipsProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
			ASDZipsProcess(id);  // process asd data
		TIME_TRACE_DBG("END - GetASDZipsProcess");

		TIME_TRACE_DBG("START - DrawASDAircraft");
		if (!HisVO || !HisVO->count){
			drawASDAircraft(id);
		}
		TIME_TRACE_DBG("END - DrawASDAircraft");
	}
	else {
		TIME_TRACE_DBG("START - ASDZipsProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
			ASDZipsProcess(id);  // continue to process asd information
		TIME_TRACE_DBG("END - ASDZipsProcess");
	}

	TIME_TRACE_DBG("START - DrawMeasure");
	DrawMeasure(id);
	TIME_TRACE_DBG("END - DrawMeasure");

	TIME_TRACE_DBG("START - DrawRollovers");
	if (!HisVO || !HisVO->count){
		DrawRollovers(id);  // draw largetags large tags
	}
	TIME_TRACE_DBG("END - DrawRollovers");


	drawPicBox(id);



	//if ( id->m_sCurLayout.m_bShowTrailTimes ){
	if (id->m_sCurLayout.m_bShowCompression){
		TIME_TRACE_DBG("START - DrawCompression");
		DrawCompression(id);
		TIME_TRACE_DBG("END - DrawCompression");
	}
	 
	// Draw Airport status after aircraft icons.
	if (id->m_sCurLayout.m_bShowFAAStatus){
		//check if LoadInternationalAirports has been called already
		TIME_TRACE_DBG("START - ShowFAAStatus");
		DrawFAAStatus(id);
		DrawFAAPopupTags(id);
		TIME_TRACE_DBG("END - ShowFAAStatus");
	}

	// not needed picinpic  StartFDOThread(id);


	TIME_TRACE_DBG("START - DrawSelectedPolyText");
	DrawSelectedPolyText(id);
	TIME_TRACE_DBG("END - DrawSelectedPolyText");

	// Added to show plottime when non aircraft are visible.
	if (!id->m_sCurLayout.m_bShowPassurAircraft &&
		!id->m_sCurLayout.m_bShowASDAircraft &&
		!id->m_sCurLayout.m_bShowASDEXAircraft){
		Updplottime(id);
	}

	// Moved Embedded GUI to end of Render for top visibility
	TIME_TRACE_DBG("START - DrawGUI");
	// GUI is created from CreateGUI function


	/* not needed pic in pic
	if (OpenglGrid){
	SetGridGLMode(id);
	MGLDrawGUI(id);
	}
	TIME_TRACE_DBG("END - DrawGUI");

	DrawPlotTime(id);
	*/

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	loopcount++;
	end_fps = time(0);
	if (end_fps - start_fps > 30){
		fps = (double)loopcount / (double)(end_fps - start_fps);
		loopcount = 0;
		start_fps = end_fps;
	}

	/* not needed pic in pic
	if (DataAppGrid && DataAppGrid->vo){
	UpdateFDOGrid(id);
	}
	*/



	id->m_bOnRefresh = FALSE;
	gframecount++;
	TIME_TRACE_DBG("END(3) - RenderScene");



	id->m_nWidth = saveWidth;
	id->m_nHeight = saveHeight;
	id->m_sCurLayout.m_dWorldXmin = saveWorldXmin;
	id->m_sCurLayout.m_dWorldXmax = saveWorldXmax;
	id->m_sCurLayout.m_dWorldYmin = saveWorldYmin;
	id->m_sCurLayout.m_dWorldYmax = saveWorldYmax;
	id->m_dWorldYSize = (id->m_dWorldYmax - id->m_dWorldYmin);
	id->m_dWorldXSize = (id->m_dWorldXmax - id->m_dWorldXmin);

	ResizeWindowPicinPic(id, 0, 0, id->m_nWidth, id->m_nHeight);
	// resizeWindow(id, id->m_nWidth, id->m_nHeight);

	return;  // enough for now

}

//void *createairstruct(struct InstanceData* id)
//{
//
//	int i,t,j,k,activecount, count, co,check;
//	AIR **airASDEX, **airMLAT,**airGate, **airNoise, **airP, **airASD, *air_buff, *air;
//	AIR *airbuffer[2 * N_PASSUR_TRACK_ID];
//	char *FltNum, *Region, *Flightnum, *Destination;
//	co = 0;
//	air_buff = &co;
//	//airbuffer = &air_buff;
//	int count1 = 0;
//	int count2 = 0;
//	MGLGRID *ROIGrid = NULL;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	count = 0;
//	vo_rm_rows(ColorAircraftVO, 0, ColorAircraftVO->count);
//
//	airASDEX = GetASDEXAirP(id);	
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){		
//		if (air = airASDEX[i]){
//			airbuffer[count] = airASDEX[i];			
//			//*airbuffer++;
//			count++;
//			
//	}
//	}
//
//	check = count;
//	airMLAT = GetMLATAirP(id);
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		if (air = airMLAT[i]){
//			airbuffer[count] = airMLAT[i];
//			//*airbuffer++;
//			count++;
//		}
//	}
//
//	check = count;
//	airGate = GetGateAirP(id);
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		if (air = airGate[i]){
//			airbuffer[count] = airGate[i];
//			//*airbuffer++;
//			count++;
//		}
//	}
//
//	check = count;
//	airNoise = GetASDAirP(id);
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		if (air = airNoise[i]){
//			airbuffer[count] = airNoise[i];
//			//*airbuffer++;
//			count++;
//		}
//	}
//
//	check = count;
//	airP= GetAirP(id, 0); 
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		if (air = airP[i]){
//			airbuffer[count] = airP[i];
//			//airbuffer++;
//			count++;
//		}
//	}
//
//	check = count;
//	airASD = GetASDAirP(id);
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		if (air = airASD[i]){
//			airbuffer[count] = airASD[i];
//			//*airbuffer++;
//			count++;
//		}
//	}
//	
//	check = count;
//	airbuffer[0];
//	for (i = 0, activecount = 0; i < count; i++){		
//	t1:		if (air = airbuffer[i]){
//		for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//		{
//			DataSource = VP(DataAppVO, t, "DataSource", char);
//			if (!strcmp(DataSource, "ROI")){
//				ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (ROIGrid->icon_set == 1)
//				{
//					if (ROIGrid->filteredvo){
//						for (k = 0; k < ROIGrid->filteredvo->count; k++){
//							FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "FltNum", char);
//							Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "Region", char);
//							co = 0;
//							count1 = 0;
//							count2 = 0;
//							while (FltNum[co] != '\0'){
//								count1++;
//								co++;
//							}
//
//							co = 0;
//
//							while (Region[co] != '\0'){
//								if (Region[co] == '-'){
//									count2--;
//								}
//								if (Region[co] == ' ')
//								{
//									count2--;
//								}
//
//								count2++;
//								co++;
//							}
//
//
//							Flightnum = (char *)malloc(count1 - count2 + 2);
//
//							for (j = 0; j < (count1 - count2 + 1); j++)
//								Flightnum[j] = 0;
//
//							for (j = 0; j < (count1 - count2); j++)
//							{
//								Flightnum[j] = FltNum[j];
//
//							}
//
//							Flightnum[count1 - count2 + 1] = '\0';
//							if (strcmp(Flightnum, air->FltNum) == 0)
//							{
//								if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
//								{
//									vo_alloc_rows(ColorAircraftVO, 1);
//									strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//									strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//									VV(ColorAircraftVO, ColorAircraftVO->count - 1, "ColorVO", int) = ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
//								}
//
//							}
//							free(Flightnum);
//
//						}
//					}
//				}
//			}
//
//			else if (!strcmp(DataSource, "FDO")){
//				FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (FDOGrid->icon_set == 1)
//				{
//					if (FDOGrid->filteredvo){
//						for (j = 0; j < FDOGrid->filteredvo->count; j++){
//							FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "FltNum", char);
//							Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "Destin", char);
//							if (air->FltNum)
//							{
//								if (strcmp(FltNum, air->FltNum) == 0)
//								{
//									if (strcmp(Destination, air->Destin) == 0)
//									{
//										if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//										{
//											vo_alloc_rows(ColorAircraftVO, 1);
//											strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//											strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//											VV(ColorAircraftVO, ColorAircraftVO->count - 1, "ColorVO", int) = FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//											break;
//										}
//									}
//
//
//								}
//
//							}
//						}
//
//					}
//				}
//			}
//
//		}
//	}
//
//
//
//	}
//	return check;
//}

//void *create_ASDEXaircraftcolors(struct InstanceData* id){
//	
//	int i,activecount;
//	AIR *air;
//	int j, t,k;
//	char *FltNum, *Region, *Flightnum, *Destination;
//	int count1 = 0;
//	int count2 = 0;
//	int count;
//	int co;
//	AIR **airp;
//	int aircount;	
//	int check;
//
//
//	MGLGRID *ROIGrid = NULL;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	airp = GetASDEXAirP(id);
//	vo_rm_rows(ColorASDEXAircraftVO, 0, ColorASDEXAircraftVO->count);
//	
//
//	for (i = 0, activecount = 0;  i < N_PASSUR_TRACK_ID; i++){
//		count = N_PASSUR_TRACK_ID;
//t1:		if (air = airp[i]){
//			for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//			{
//				DataSource = VP(DataAppVO, t, "DataSource", char);
//				if (!strcmp(DataSource, "ROI")){
//					ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//					if (ROIGrid->icon_set == 1)
//					{
//						if (ROIGrid->filteredvo){
//							for (k = 0; k < ROIGrid->filteredvo->count; k++){
//								FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "FltNum", char);
//								Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "Region", char);
//								co = 0;
//								count1 = 0;
//								count2 = 0;
//								while (FltNum[co] != '\0'){
//									count1++;
//									co++;
//								}
//
//								co = 0;
//
//								while (Region[co] != '\0'){
//									if (Region[co] == '-'){
//										count2--;
//									}
//									if (Region[co] == ' ')
//									{
//										count2--;
//									}
//
//									count2++;
//									co++;
//								}
//
//
//								Flightnum = (char *)malloc(count1 - count2 + 2);
//
//								for (j = 0; j < (count1 - count2 + 1); j++)
//									Flightnum[j] = 0;
//
//								for (j = 0; j < (count1 - count2); j++)
//								{
//									Flightnum[j] = FltNum[j];
//
//								}
//
//								Flightnum[count1 - count2 + 1] = '\0';
//								if (strcmp(Flightnum, air->FltNum) == 0)
//								{
//									if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
//									{
//										vo_alloc_rows(ColorASDEXAircraftVO, 1);
//										strncpy_s(VP(ColorASDEXAircraftVO, ColorASDEXAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//										strncpy_s(VP(ColorASDEXAircraftVO, ColorASDEXAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//										VV(ColorASDEXAircraftVO, ColorASDEXAircraftVO->count - 1, "ColorVO", int) = ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
//									}
//									
//								}
//								free(Flightnum);
//
//							}
//						}
//					}
//				}
//
//				else if (!strcmp(DataSource, "FDO")){
//					FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//					if (FDOGrid->icon_set == 1)
//					{
//						if (FDOGrid->filteredvo){
//							for (j = 0; j < FDOGrid->filteredvo->count; j++){
//								FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "FltNum", char);
//								Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "Destin", char);
//								if (air->FltNum)
//								{
//									if (strcmp(FltNum, air->FltNum) == 0)
//									{
//										if (strcmp(Destination, air->Destin) == 0)
//										{
//											if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//											{
//												vo_alloc_rows(ColorASDEXAircraftVO, 1);
//												strncpy_s(VP(ColorASDEXAircraftVO, ColorASDEXAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//												strncpy_s(VP(ColorASDEXAircraftVO, ColorASDEXAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//												VV(ColorASDEXAircraftVO, ColorASDEXAircraftVO->count - 1, "ColorVO", int) = FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//												break;
//											}
//										}
//
//
//									}
//
//								}
//							}
//
//						}
//					}
//				}
//
//			}
//		}
//
//
//
//	}
//
//	check = 100;
//	
//}


//void *create_MLATaircraftcolors(struct InstanceData* id){
//
//	int i, activecount;
//	AIR *air;
//	int j, t, k;
//	char *FltNum, *Region, *Flightnum, *Destination;
//	int count1 = 0;
//	int count2 = 0;
//	int count;
//	int co;
//	AIR **airp;
//	int aircount;	
//	int check;
//
//
//	MGLGRID *ROIGrid = NULL;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	airp = GetMLATAirP(id);
//	vo_rm_rows(ColorMLATAircraftVO, 0, ColorMLATAircraftVO->count);
//
//
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		count = N_PASSUR_TRACK_ID;
//	t1:		if (air = airp[i]){
//		for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//		{
//			DataSource = VP(DataAppVO, t, "DataSource", char);
//			if (!strcmp(DataSource, "ROI")){
//				ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (ROIGrid->icon_set == 1)
//				{
//					if (ROIGrid->filteredvo){
//						for (k = 0; k < ROIGrid->filteredvo->count; k++){
//							FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "FltNum", char);
//							Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "Region", char);
//							co = 0;
//							count1 = 0;
//							count2 = 0;
//							while (FltNum[co] != '\0'){
//								count1++;
//								co++;
//							}
//
//							co = 0;
//
//							while (Region[co] != '\0'){
//								if (Region[co] == '-'){
//									count2--;
//								}
//								if (Region[co] == ' ')
//								{
//									count2--;
//								}
//
//								count2++;
//								co++;
//							}
//
//
//							Flightnum = (char *)malloc(count1 - count2 + 2);
//
//							for (j = 0; j < (count1 - count2 + 1); j++)
//								Flightnum[j] = 0;
//
//							for (j = 0; j < (count1 - count2); j++)
//							{
//								Flightnum[j] = FltNum[j];
//
//							}
//
//							Flightnum[count1 - count2 + 1] = '\0';
//							if (strcmp(Flightnum, air->FltNum) == 0)
//							{
//								if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
//								{
//									vo_alloc_rows(ColorMLATAircraftVO, 1);
//									strncpy_s(VP(ColorMLATAircraftVO, ColorMLATAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//									strncpy_s(VP(ColorMLATAircraftVO, ColorMLATAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//									VV(ColorMLATAircraftVO, ColorMLATAircraftVO->count - 1, "ColorVO", int) = ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
//								}
//
//							}
//							free(Flightnum);
//
//						}
//					}
//				}
//			}
//
//			else if (!strcmp(DataSource, "FDO")){
//				FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (FDOGrid->icon_set == 1)
//				{
//					if (FDOGrid->filteredvo){
//						for (j = 0; j < FDOGrid->filteredvo->count; j++){
//							FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "FltNum", char);
//							Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "Destin", char);
//							if (air->FltNum)
//							{
//								if (strcmp(FltNum, air->FltNum) == 0)
//								{
//									if (strcmp(Destination, air->Destin) == 0)
//									{
//										if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//										{
//											vo_alloc_rows(ColorMLATAircraftVO, 1);
//											strncpy_s(VP(ColorMLATAircraftVO, ColorMLATAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//											strncpy_s(VP(ColorMLATAircraftVO, ColorMLATAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//											VV(ColorMLATAircraftVO, ColorMLATAircraftVO->count - 1, "ColorVO", int) = FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//											break;
//										}
//									}
//
//
//								}
//
//							}
//						}
//
//					}
//				}
//			}
//
//		}
//	}
//
//
//
//	}
//
//	check = 100;
//
//}

//void *create_Gateaircraftcolors(struct InstanceData* id){
//
//	int i, activecount;
//	AIR *air;
//	int j, t, k;
//	char *FltNum, *Region, *Flightnum, *Destination;
//	int count1 = 0;
//	int count2 = 0;
//	int count;
//	int co;
//	AIR **airp;
//	int aircount;
//	int check;
//
//
//	MGLGRID *ROIGrid = NULL;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	airp = GetGateAirP(id);
//	vo_rm_rows(ColorGateAircraftVO, 0, ColorGateAircraftVO->count);
//
//
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		count = N_PASSUR_TRACK_ID;
//	t1:		if (air = airp[i]){
//		for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//		{
//			DataSource = VP(DataAppVO, t, "DataSource", char);
//			if (!strcmp(DataSource, "ROI")){
//				ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (ROIGrid->icon_set == 1)
//				{
//					if (ROIGrid->filteredvo){
//						for (k = 0; k < ROIGrid->filteredvo->count; k++){
//							FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "FltNum", char);
//							Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "Region", char);
//							co = 0;
//							count1 = 0;
//							count2 = 0;
//							while (FltNum[co] != '\0'){
//								count1++;
//								co++;
//							}
//
//							co = 0;
//
//							while (Region[co] != '\0'){
//								if (Region[co] == '-'){
//									count2--;
//								}
//								if (Region[co] == ' ')
//								{
//									count2--;
//								}
//
//								count2++;
//								co++;
//							}
//
//
//							Flightnum = (char *)malloc(count1 - count2 + 2);
//
//							for (j = 0; j < (count1 - count2 + 1); j++)
//								Flightnum[j] = 0;
//
//							for (j = 0; j < (count1 - count2); j++)
//							{
//								Flightnum[j] = FltNum[j];
//
//							}
//
//							Flightnum[count1 - count2 + 1] = '\0';
//							if (strcmp(Flightnum, air->FltNum) == 0)
//							{
//								if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
//								{
//									vo_alloc_rows(ColorGateAircraftVO, 1);
//									strncpy_s(VP(ColorGateAircraftVO, ColorGateAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//									strncpy_s(VP(ColorGateAircraftVO, ColorGateAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//									VV(ColorGateAircraftVO, ColorGateAircraftVO->count - 1, "ColorVO", int) = ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
//								}
//
//							}
//							free(Flightnum);
//
//						}
//					}
//				}
//			}
//
//			else if (!strcmp(DataSource, "FDO")){
//				FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (FDOGrid->icon_set == 1)
//				{
//					if (FDOGrid->filteredvo){
//						for (j = 0; j < FDOGrid->filteredvo->count; j++){
//							FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "FltNum", char);
//							Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "Destin", char);
//							if (air->FltNum)
//							{
//								if (strcmp(FltNum, air->FltNum) == 0)
//								{
//									if (strcmp(Destination, air->Destin) == 0)
//									{
//										if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//										{
//											vo_alloc_rows(ColorGateAircraftVO, 1);
//											strncpy_s(VP(ColorGateAircraftVO, ColorGateAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//											strncpy_s(VP(ColorGateAircraftVO, ColorGateAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//											VV(ColorGateAircraftVO, ColorGateAircraftVO->count - 1, "ColorVO", int) = FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//											break;
//										}
//									}
//
//
//								}
//
//							}
//						}
//
//					}
//				}
//			}
//
//		}
//	}
//
//
//
//	}
//
//	check = 100;
//
//}

//void *create_Noiseaircraftcolors(struct InstanceData* id){
//
//	int i, activecount;
//	AIR *air;
//	int j, t, k;
//	char *FltNum, *Region, *Flightnum, *Destination;
//	int count1 = 0;
//	int count2 = 0;
//	int count;
//	int co;
//	AIR **airp;
//	int aircount;
//	int check;
//
//
//	MGLGRID *ROIGrid = NULL;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	//airp = GetNoiseAirP(id);
//	airp = GetASDAirP(id);
//	vo_rm_rows(ColorNoiseAircraftVO, 0, ColorNoiseAircraftVO->count);
//
//
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		count = N_PASSUR_TRACK_ID;
//	t1:		if (air = airp[i]){
//		for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//		{
//			DataSource = VP(DataAppVO, t, "DataSource", char);
//			if (!strcmp(DataSource, "ROI")){
//				ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (ROIGrid->icon_set == 1)
//				{
//					if (ROIGrid->filteredvo){
//						for (k = 0; k < ROIGrid->filteredvo->count; k++){
//							FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "FltNum", char);
//							Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "Region", char);
//							co = 0;
//							count1 = 0;
//							count2 = 0;
//							while (FltNum[co] != '\0'){
//								count1++;
//								co++;
//							}
//
//							co = 0;
//
//							while (Region[co] != '\0'){
//								if (Region[co] == '-'){
//									count2--;
//								}
//								if (Region[co] == ' ')
//								{
//									count2--;
//								}
//
//								count2++;
//								co++;
//							}
//
//
//							Flightnum = (char *)malloc(count1 - count2 + 2);
//
//							for (j = 0; j < (count1 - count2 + 1); j++)
//								Flightnum[j] = 0;
//
//							for (j = 0; j < (count1 - count2); j++)
//							{
//								Flightnum[j] = FltNum[j];
//
//							}
//
//							Flightnum[count1 - count2 + 1] = '\0';
//							if (strcmp(Flightnum, air->FltNum) == 0)
//							{
//								if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
//								{
//									vo_alloc_rows(ColorNoiseAircraftVO, 1);
//									strncpy_s(VP(ColorNoiseAircraftVO, ColorNoiseAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//									strncpy_s(VP(ColorNoiseAircraftVO, ColorNoiseAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//									VV(ColorNoiseAircraftVO, ColorNoiseAircraftVO->count - 1, "ColorVO", int) = ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
//								}
//
//							}
//							free(Flightnum);
//
//						}
//					}
//				}
//			}
//
//			else if (!strcmp(DataSource, "FDO")){
//				FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (FDOGrid->icon_set == 1)
//				{
//					if (FDOGrid->filteredvo){
//						for (j = 0; j < FDOGrid->filteredvo->count; j++){
//							FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "FltNum", char);
//							Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "Destin", char);
//							if (air->FltNum)
//							{
//								if (strcmp(FltNum, air->FltNum) == 0)
//								{
//									if (strcmp(Destination, air->Destin) == 0)
//									{
//										if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//										{
//											vo_alloc_rows(ColorNoiseAircraftVO, 1);
//											strncpy_s(VP(ColorNoiseAircraftVO, ColorNoiseAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//											strncpy_s(VP(ColorNoiseAircraftVO, ColorNoiseAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//											VV(ColorNoiseAircraftVO, ColorNoiseAircraftVO->count - 1, "ColorVO", int) = FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//											break;
//										}
//									}
//
//
//								}
//
//							}
//						}
//
//					}
//				}
//			}
//
//		}
//	}
//
//
//
//	}
//
//	check = 100;
//
//}
//void *create_aircraftcolors(struct InstanceData* id){
//
//	int i, activecount;
//	AIR *air;
//	int j, t, k;
//	char *FltNum, *Region, *Flightnum, *Destination;
//	int count1 = 0;
//	int count2 = 0;
//	int count;
//	int co;
//	AIR **airp;
//	int aircount;
//	int check;
//
//
//	MGLGRID *ROIGrid = NULL;
//	MGLGRID *FDOGrid = NULL;
//	char *DataSource;
//	VO *DataAppVO;
//
//	airp = GetAirP(id,0);
//	vo_rm_rows(ColorAircraftVO, 0, ColorAircraftVO->count);
//
//
//	for (i = 0, activecount = 0; i < N_PASSUR_TRACK_ID; i++){
//		count = N_PASSUR_TRACK_ID;
//	t1:		if (air = airp[i]){
//		for (t = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && t < DataAppVO->count; t++)
//		{
//			DataSource = VP(DataAppVO, t, "DataSource", char);
//			if (!strcmp(DataSource, "ROI")){
//				ROIGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (ROIGrid->icon_set == 1)
//				{
//					if (ROIGrid->filteredvo){
//						for (k = 0; k < ROIGrid->filteredvo->count; k++){
//							FltNum = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "FltNum", char);
//							Region = VP(ROIGrid->filteredvo, ROIGrid->filteredvo->row_index[k].rownum, "Region", char);
//							co = 0;
//							count1 = 0;
//							count2 = 0;
//							while (FltNum[co] != '\0'){
//								count1++;
//								co++;
//							}
//
//							co = 0;
//
//							while (Region[co] != '\0'){
//								if (Region[co] == '-'){
//									count2--;
//								}
//								if (Region[co] == ' ')
//								{
//									count2--;
//								}
//
//								count2++;
//								co++;
//							}
//
//
//							Flightnum = (char *)malloc(count1 - count2 + 2);
//
//							for (j = 0; j < (count1 - count2 + 1); j++)
//								Flightnum[j] = 0;
//
//							for (j = 0; j < (count1 - count2); j++)
//							{
//								Flightnum[j] = FltNum[j];
//
//							}
//
//							Flightnum[count1 - count2 + 1] = '\0';
//							if (strcmp(Flightnum, air->FltNum) == 0)
//							{
//								if ((ROIGrid->active_icon == 1) || (ROIGrid->active_icon == 2))
//								{
//									vo_alloc_rows(ColorAircraftVO, 1);
//									strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//									strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//									VV(ColorAircraftVO, ColorAircraftVO->count - 1, "ColorVO", int) = ROIGrid->AlertsColorGrid->IconColorGrid->icon_color;
//								}
//
//							}
//							free(Flightnum);
//
//						}
//					}
//				}
//			}
//
//			else if (!strcmp(DataSource, "FDO")){
//				FDOGrid = VV(DataAppGrid->vo, t, "gridptr", void *);
//				if (FDOGrid->icon_set == 1)
//				{
//					if (FDOGrid->filteredvo){
//						for (j = 0; j < FDOGrid->filteredvo->count; j++){
//							FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "FltNum", char);
//							Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[j].rownum, "Destin", char);
//							if (air->FltNum)
//							{
//								if (strcmp(FltNum, air->FltNum) == 0)
//								{
//									if (strcmp(Destination, air->Destin) == 0)
//									{
//										if ((FDOGrid->active_icon == 1) || (FDOGrid->active_icon == 2))
//										{
//											vo_alloc_rows(ColorAircraftVO, 1);
//											strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "FltNum", char), FLTNUM_SIZE, air->FltNum, _TRUNCATE);
//											strncpy_s(VP(ColorAircraftVO, ColorAircraftVO->count - 1, "Destin", char), FLTNUM_SIZE, air->Destin, _TRUNCATE);
//											VV(ColorAircraftVO, ColorAircraftVO->count - 1, "ColorVO", int) = FDOGrid->AlertsColorGrid->IconColorGrid->icon_color;
//											break;
//										}
//									}
//
//
//								}
//
//							}
//						}
//
//					}
//				}
//			}
//
//		}
//	}
//
//
//
//	}
//
//	check = 100;
//
//}
// Called to draw scene
void RenderScene(struct InstanceData* id)
{
	double lat, lng, fps;
	static char tmpstr[256];
	struct timeb start_time, done_time;
	static time_t start_fps, end_fps, nowsecs;
	static int loopcount = 0;

	static int PicInPic = 0;
	

	
	//MGLGRID *FDOGrid;	
	static time_t LastFDOFillSecs;
	static time_t LastSAFillSecs;
//	char *DataSource;

	static VO *LastGFDO = NULL;
	static VO *LastGSA =  NULL;

	//VO *ColorgateAircraftVO = NULL;

	// static VO *AirVO;
	int nVO = 0;
	int wx;
	const DWORD cdwThreadId = GetCurrentThreadId();

	

	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	if (!start_fps){
		start_fps = time(0);
	}
	TIME_TRACE_DBG("START - RenderScene");
	if (!id->m_bInitialized || !id->m_bBasicGraphicsLoaded) {
		DrawSplashScreen(id);
		id->m_tAirDataBeatTime = time(0);
		TIME_TRACE_DBG("END(1) - RenderScene");
		return;
	}
	if (id->m_bOnRefresh){
		// Reset Some Textures which may not get accessed immediately
		memset(id->m_gluGuiTextures, 0, sizeof(GLuint) * N_GUI_IMAGES);
	}
	// Kick off ETA Thread here
	if (!id->m_bEtaThread || id->m_bOnRefresh){
		RegisterThreadHandle(id, _beginthreadex(NULL, 0, ETAThread, id, 0, NULL), "ETAThread");
		id->m_bEtaThread = TRUE;
	}


	// Clear the window
	GL_ASSERT(glClear(GL_COLOR_BUFFER_BIT));
	if (id->m_sCurLayout.m_bShowWorldMap){
		GL_ASSERT(glClearColor(id->m_sCurLayout.m_glfWaterFillColor[0], id->m_sCurLayout.m_glfWaterFillColor[1], id->m_sCurLayout.m_glfWaterFillColor[2], 0.0f));
		// glClearColor(0.0f, 0.0f, 1.0f, 0.0f);
	} else {
		GL_ASSERT(glClearColor(0.0f, 0.0f, 0.0f, 0.0f));
	}

	// glClearColor(0.0f, 0.0f, 1.0f, 1.0f );
	glLoadIdentity();
	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	//glOrtho((GLfloat) 0, (GLfloat) STRAT_XSIZE,
	// (GLfloat) 0, (GLfloat) STRAT_YSIZE, 0.0f, 1.0f);
	{
		char strDebug[200] = { 0 };
		sprintf_s(strDebug, _countof(strDebug), "WorldXmin:%f, WorldXmax:%f, WorldYmin:%f, WorldYmax:%f",
			id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax);
		TIME_TRACE_DBG(strDebug);
	}
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	// DrawSatMapLayer(1, "jfksq", -73.81, 40.615, -73.749, 40.676 );

	if (id->m_sCurLayout.m_bShowWorldMap){
		TIME_TRACE_DBG("START - ShowWorldMap");
		fillBinaryTriangles(id);
		fillLakes(id);
		TIME_TRACE_DBG("END - ShowWorldMap");
	}
	if (id->m_sCurLayout.m_bShowWorldBorders){
		TIME_TRACE_DBG("START - ShowWorldBorders");
		drawBorders(id);
		TIME_TRACE_DBG("END - ShowWorldBorders");
	}

	// DrawPolys( PolyList );


	//TODO: Remove Function and Code once Accepted
	// Old Method, Using Enhanced Shapefiles in DrawHiResMap
	//DrawSctVectors();

#ifdef OLD_WAY_CANT_USE_LISTS_SINCE_WE_NEED_TO_CHANGE_SOME_COLORS_OR_RECREATE_LISTS
	if ( !Constructionlist ){
		//this routine just creates a gllist for display, it does not create poly structures to store info!!!
		Constructionlist = CreatePolyGLList( shapefilename, GL_LINE_STRIP );
	}
	if ( Constructionlist ){
		glColor3fv(red);
		glCallList( Constructionlist );
	}
#endif



	// add entity number to polylist, so that we can change colors based on status
	if (id->m_bShowRoads){
		TIME_TRACE_DBG("START - ShowRoads");
		DrawRoads(id);
		TIME_TRACE_DBG("END - ShowRoads");
	}

	if (id->m_sCurLayout.m_bShowRunways){
		TIME_TRACE_DBG("START - ShowRunways");
		DrawRunways(id);
		TIME_TRACE_DBG("END - ShowRunways");
	}

	// ShowConstructionPopup( ConstructionPolyList );


	if (ShowHiResMap){
		TIME_TRACE_DBG("START - ShowHiResMap");
		DrawHiResMap(id);
		TIME_TRACE_DBG("END - ShowHiResMap");
	}

	//@@@MCT Temporarily Removed
	//if (id->m_sCurLayout.m_nROISLabel && id->m_sCurLayout.m_dWorldXSize < 0.06){
	//	TIME_TRACE_DBG("START - DrawROILabels");
	//	DrawROILabels(id);
	//	TIME_TRACE_DBG("END - DrawROILabels");
	//}


	if (id->m_sCurLayout.m_bShowWeather){
		// Must be in live mode to see weather
		if (id->m_nDelaySecs == 0){
			TIME_TRACE_DBG("START - drawWX");
			for (wx = 0; wx < NActiveRadars; wx++){
				drawWx(id, wx);
			}
			TIME_TRACE_DBG("END - drawWX");
		}
	}

	if (id->m_sCurLayout.m_bShowAirportRings){
		TIME_TRACE_DBG("START - drawAirportRings");
		drawAirportRings(id);
		TIME_TRACE_DBG("END - drawAirportRings");
	}

	// DrawSatMap(0, "jfkgeo", -73.82094497, 40.64583812, -73.78516804, 40.67050178);
	// DrawSatMap(1, "jfk03789201", -73.78516804, 40.64583812, -73.7493911, 40.67050178);
	TIME_TRACE_DBG("START - drawBox");
	drawBox(id);
	TIME_TRACE_DBG("END - drawBox");


	if (showlatlongs){
		TIME_TRACE_DBG("START - ShowLatLong");
		lng = (((double)id->m_nMouseX / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		lat = (((double)id->m_nMouseY / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
		sprintf_s(tmpstr, _countof(tmpstr), "x=%d y=%d lat=%g long=%g Wxmin=%g wxmax=%g wymin=%g wymax=%g\n",
			id->m_nBoxX1, id->m_nBoxY1, lat, lng, id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax);
		DrawGLText(id, 20, 60, tmpstr, (GLfloat *)white, id->m_gluCustomBase, FALSE); 
		TIME_TRACE_DBG("START - ShowLatLong");
	}

	if (id->m_bShowDepGates){
		TIME_TRACE_DBG("START - ShowDepGates");
		DrawDepartureGates(id);
		TIME_TRACE_DBG("END - ShowDepGates");
	}

	if (id->m_dwAirDataCurrBeat != id->m_dwAirDataLastBeat){
		id->m_dwAirDataLastBeat = id->m_dwAirDataCurrBeat;
		id->m_tAirDataBeatTime = time(0);
	}else{
		time_t tNow = time(0);
		if ((tNow - id->m_tAirDataBeatTime) > 60){
			// Force Terminate Thread, and Restart
			vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) AircraftDataThread heart beat failed, restarting!\n", cdwThreadId);
			if (TerminateThread((HANDLE)id->m_hAirDataThread, 1)){
				UnregisterThreadHandle(id, id->m_hAirDataThread);
				CloseHandle((HANDLE)id->m_hAirDataThread);
				ResetADTCriticalSections(id);
			}else{
				vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unable to forcefully terminate AircraftDataThread\n", cdwThreadId);
			}
			id->m_dwAirDataLastBeat = (DWORD)(-1);
			id->m_tAirDataBeatTime = tNow;
			id->m_hAirDataThread = _beginthreadex(NULL, 0, AircraftDataThread, id, 0, NULL);
			RegisterThreadHandle(id, id->m_hAirDataThread, "AircraftDataThread");
		}
	}
	if (id->m_bResetTracks || id->m_bOnRefresh)
	{
		// This code only executes for replays and refresh
		// It signals the data thread to terminate and only calls ResetTracks once completed
		// It avoid a data thread still downloading data when we want to only have new tracks.
		DWORD dResult = WAIT_OBJECT_0;

		if (id->m_bOnRefresh) {
			id->m_hAirDataThread = 0;
		}

		if (0 != id->m_hAirDataThread) {
			dResult = WaitForSingleObject(id->m_evAirDrawReset, 1);
		}
		if (dResult == WAIT_OBJECT_0){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Resetting tracks.\n", cdwThreadId);
			ResetEvent(id->m_evAirDrawReset);
			ResetTracks(id, id->m_bResetASDTracks);
			if (0 == id->m_hAirDataThread) {
				id->m_hAirDataThread = _beginthreadex(NULL, 0, AircraftDataThread, id, 0, NULL);
				RegisterThreadHandle(id, id->m_hAirDataThread, "AircraftDataThread");
			}
			id->m_bResetTracks = FALSE;
			id->m_bResetASDTracks = FALSE;
		}else{
			// Draw GUI
			MGLDrawGUI(id);
			// Don't draw any aircraft until we get new data
			glFlush();
			/* reset the color to white so textures will appear */
			glColor3f(1.0, 1.0, 1.0);
			TIME_TRACE_DBG("END(2) - RenderScene");
			return;
		}
	}
	
	

	if (id->m_sCurLayout.m_dWorldXSize < 0.06){
		TIME_TRACE_DBG("START - GateLabels");
		DrawGateLabels(id);
		TIME_TRACE_DBG("END - GateLabels");
	}


	if (id->m_sCurLayout.m_bShowFixesH){
		TIME_TRACE_DBG("START - HighFixes");
		drawfixes(id, g_pFixesHigh, g_nFixCountHigh, id->m_sCurLayout.m_glfFixHighFillColor, id->m_arFonts[id->m_sCurLayout.m_nFixesHFontIndex].m_glListBase);
		TIME_TRACE_DBG("END - HighFixes");
	}
	if (id->m_sCurLayout.m_bShowFixesL){
		TIME_TRACE_DBG("START - LowFixes");
		drawfixes(id, g_pFixesLow, g_nFixCountLow, id->m_sCurLayout.m_glfFixLowFillColor, id->m_arFonts[id->m_sCurLayout.m_nFixesLFontIndex].m_glListBase);
		TIME_TRACE_DBG("END - LowFixes");
	}
	if (id->m_sCurLayout.m_bShowFixesT){
		TIME_TRACE_DBG("START - TerminalFixes");
		drawfixes(id, g_pFixesTerm, g_nFixCountTerm, id->m_sCurLayout.m_glfFixTermFillColor, id->m_arFonts[id->m_sCurLayout.m_nFixesTFontIndex].m_glListBase);
		TIME_TRACE_DBG("END - TerminalFixes");
	}

	if (id->m_bShowAirways){
		TIME_TRACE_DBG("START - ShowAirways");
		drawairways(id);
		TIME_TRACE_DBG("END - ShowAirways");
	}

	if (id->m_sCurLayout.m_bShowFltPlan){
		TIME_TRACE_DBG("START - DisplayFltPlan");
		DisplayFltPlan(id);
		TIME_TRACE_DBG("END - DisplayFltPlan");
	}

	TIME_TRACE_DBG("START - ShowARTCC");
	DrawARTCCs(id);
	TIME_TRACE_DBG("END - ShowARTCC");

	TIME_TRACE_DBG("START - ShowSIDS");
	DrawSids(id);
	TIME_TRACE_DBG("END - ShowSIDS");

	TIME_TRACE_DBG("START - ShowSTARS");
	DrawStars(id);
	TIME_TRACE_DBG("END - ShowSTARS");


	if (GScreenDebug && strlen(ScreenComment)){
		TIME_TRACE_DBG("START - ScreenComment");
		DrawGLText(id, 20, 600, ScreenComment, (GLfloat *)white, id->m_gluCustomBase, FALSE);
		TIME_TRACE_DBG("END - ScreenComment");
	}

	// Do NOT Move this after Drawing aircraft routines (DrawASDEXAircraft, DrawPassurAircraft or drawASDAircraft)
	// Initializes Grids to prevent tags over aircraft.
	if (id->m_sCurLayout.m_bShowLargeTags){
		TIME_TRACE_DBG("START - ShowLargeTags");
		InitRollGrids(id);
		TIME_TRACE_DBG("END - ShowLargeTags");
	}

	if (id->m_sCurLayout.m_bShowNoiseAircraft || SAT_NOISE == id->m_nSelectedAircraftType){

		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawNoiseProcess");
			NoiseProcess(id);
			TIME_TRACE_DBG("END - DrawNoiseProcess");
		}

		TIME_TRACE_DBG("START - DrawNoiseAircraft");
		DrawNoiseAircraft(id);
		TIME_TRACE_DBG("END - DrawNoiseAircraft");
	}

	if (id->m_sCurLayout.m_bShowADSBAircraft || SAT_ADSB == id->m_nSelectedAircraftType){

		
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawADSBProcess");
			ADSBProcess(id);
			TIME_TRACE_DBG("END - DrawADSBProcess");
		}

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus) {
			TIME_TRACE_DBG("START - ProcessGateFlights ADSB");
			ProcessGateFlights(id, GetADSBAirP(id), ADSB);
			TIME_TRACE_DBG("END - ProcessGateFlights ADSB");
		}

		TIME_TRACE_DBG("START - DrawADSBAircraft");
		DrawADSBAircraft(id);
		TIME_TRACE_DBG("END - DrawADSBAircraft");
	}

	if(id->m_sCurLayout.m_bShowAirAsiaAircraft || SAT_AIRASIA == id->m_nSelectedAircraftType){

		if(REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawAirAsiaProcess");
			AirAsiaProcess(id);
			TIME_TRACE_DBG("END - DrawAirAsiaProcess");
		}

		TIME_TRACE_DBG("START - DrawAirAsiaAircraft");
		DrawAirAsiaAircraft(id);
		TIME_TRACE_DBG("END - DrawAirAsiaAircraft");
	}

	TIME_TRACE_DBG("START - ASDEX");
	if (id->m_sCurLayout.m_bShowASDEXAircraft || SAT_ASDEX == id->m_nSelectedAircraftType){
		TIME_TRACE_DBG("START - ASDEXProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			ASDEXProcess(id);
		}
		TIME_TRACE_DBG("START - ASDEXProcess");

		// Process Gate for ASDEX, before Drawing Either
		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus)
		{
			TIME_TRACE_DBG("START - ProcessGateFlights ASDEX");
			ProcessGateFlights(id, GetASDEXAirP(id), ASDEX);
			TIME_TRACE_DBG("END - ProcessGateFlights ASDEX");
		}

		// Must lock ROI CritSect for all access to ROI VO's
		EnterCriticalSection(&id->m_csROI);
		if (id->m_pROIColors) {
			// Draw Region of Interest if there are colors
			TIME_TRACE_DBG("START - DrawROI");
			DrawROI(id);
			TIME_TRACE_DBG("END - DrawROI");
		}
		TIME_TRACE_DBG("START - drawEditPolys ASDEX");
		drawEditPolys(id);
		TIME_TRACE_DBG("END - drawEditPolys ASDEX");
		LeaveCriticalSection(&id->m_csROI);

		if (id->m_sCurLayout.m_dWorldXSize < 200.0) {
			TIME_TRACE_DBG("START - DrawASDEXAircraft");
			if (!HisVO || !HisVO->count){
				DrawASDEXAircraft(id);
			}
			TIME_TRACE_DBG("END - DrawASDEXAircraft");			
		}
	}
	TIME_TRACE_DBG("END - ASDEX");

	TIME_TRACE_DBG("START - MLAT");
	if (id->m_sCurLayout.m_bShowMLATAircraft || SAT_MLAT == id->m_nSelectedAircraftType){
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus){
			TIME_TRACE_DBG("START - DrawMLATProcess");
			MLATProcess(id);
			TIME_TRACE_DBG("END - DrawMLATProcess");
		}

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus)
		{
			TIME_TRACE_DBG("START - ProcessGateFlights MLAT");
			ProcessGateFlights(id, GetMLATAirP(id), MLAT);
			TIME_TRACE_DBG("END - ProcessGateFlights MLAT");
		}

		// Must lock ROI CritSect for all access to ROI VO's
		EnterCriticalSection(&id->m_csROI);
		if (id->m_pROIColors) {
			// Draw Region of Interest if there are colors
			TIME_TRACE_DBG("START - DrawROI");
			DrawROI(id);
			TIME_TRACE_DBG("END - DrawROI");
		}

		TIME_TRACE_DBG("START - drawEditPolys MLAT");
		drawEditPolys(id);
		TIME_TRACE_DBG("END - drawEditPolys MLAT");
		LeaveCriticalSection(&id->m_csROI);

		TIME_TRACE_DBG("START - DrawMLATAircraft");
		DrawMLATAircraft(id);
		TIME_TRACE_DBG("END - DrawMLATAircraft");		
	}
	TIME_TRACE_DBG("END - MLAT");

	// Have Moved all of the CalcRegions calls to here, single call to handle all
	// - data processing of the Regions, original algorithm does not support multiple calls
	// - it will mark any region rows as ended if they are not processed in the call
	TIME_TRACE_DBG("START - CalcRegions");
	ftime( &start_time );
	if ( CalcRegionsFlag ){  // enable debug mode switch
		CalcRegions(id/*, GetMLATAirP(id)*/);
	}
	ftime( &done_time );
	sprintf_s(tmpstr, 256, "%g", uts_timediff(&start_time, &done_time ));
	TIME_TRACE_DBG("END - CalcRegions");
		
	if (id->m_sCurLayout.m_bShowPassurAircraft || SAT_PASSUR == id->m_nSelectedAircraftType) {
		TIME_TRACE_DBG("START - PassurProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
			PassurProcess(id, 0);
		TIME_TRACE_DBG("END - PassurProcess");

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus)
		{
			TIME_TRACE_DBG("START - ProcessGateFlights PASSUR");
			ProcessGateFlights(id, GetAirP(id, 0), PASSUR);
			TIME_TRACE_DBG("END - ProcessGateFlights PASSUR");
		}


		TIME_TRACE_DBG("START - DrawPassurAircraft");
		if (!HisVO || !HisVO->count){
			DrawPassurAircraft(id, 0);
		}
		TIME_TRACE_DBG("END - DrawPassurAircraft");
	}

	// Draw Gate Aircraft
	if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT) {

		if (REPLAY_STATUS_STOPPED == id->m_bReplayStatus) {
			TIME_TRACE_DBG("START - DrawGateAircraft MLAT");
			DrawGateAircraft(id);
			TIME_TRACE_DBG("END - DrawGateAircraft MLAT");
		}
	}

	TIME_TRACE_DBG("START - ProcessETAPassurTracks");
	ProcessETAPassurTracks(id);
	TIME_TRACE_DBG("END - ProcessETAPassurTracks");

	EnterCriticalSection(&id->m_csBlock);
	TIME_TRACE_DBG("START - ProcessingBlocks");
	if (!ProcessingBlocks){
		if (HisVO && HisVO->count > 0){
			if (ProcessLoadFlag == TRUE){
				ProcessBlockGUI(id);
				ProcessLoadFlag = FALSE;
			}
			drawHistoricalTracks(id);
			if (id->m_sCurLayout.m_bShowTrailTimes){
				drawHistoricalTimes(id);
			}
		}
	}
	TIME_TRACE_DBG("END - ProcessingBlocks");
	LeaveCriticalSection(&id->m_csBlock);

	if (id->m_sCurLayout.m_bShowASDAircraft || SAT_ASDI == id->m_nSelectedAircraftType){
		TIME_TRACE_DBG("START - GetASDZipsProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
			ASDZipsProcess(id);  // process asd data
		TIME_TRACE_DBG("END - GetASDZipsProcess");

		TIME_TRACE_DBG("START - DrawASDAircraft");
		if (!HisVO || !HisVO->count){
			drawASDAircraft(id);
		}
		TIME_TRACE_DBG("END - DrawASDAircraft");
	} else {
		TIME_TRACE_DBG("START - ASDZipsProcess");
		if (REPLAY_STATUS_PAUSED != id->m_bReplayStatus)
			ASDZipsProcess(id);  // continue to process asd information
		TIME_TRACE_DBG("END - ASDZipsProcess");
	}

	TIME_TRACE_DBG("START - DrawMeasure");
	DrawMeasure(id);
	TIME_TRACE_DBG("END - DrawMeasure");

	TIME_TRACE_DBG("START - DrawRollovers");
	if (!HisVO || !HisVO->count){
		DrawRollovers(id);  // draw largetags large tags
	}
	TIME_TRACE_DBG("END - DrawRollovers");

	//if ( id->m_sCurLayout.m_bShowTrailTimes ){
	if (id->m_sCurLayout.m_bShowCompression){
		TIME_TRACE_DBG("START - DrawCompression");
		DrawCompression(id);
		TIME_TRACE_DBG("END - DrawCompression");
	}

	// Draw Airport status after aircraft icons.
	if (id->m_sCurLayout.m_bShowFAAStatus){
		//check if LoadInternationalAirports has been called already
		TIME_TRACE_DBG("START - ShowFAAStatus");
		DrawFAAStatus(id);
		DrawFAAPopupTags(id);
		TIME_TRACE_DBG("END - ShowFAAStatus");
	}

	TIME_TRACE_DBG("START - StartFDOThread");
	StartFDOThread(id);
	TIME_TRACE_DBG("END - StartFDOThread");
	
	TIME_TRACE_DBG("START - StartSysAlertsThread");
	StartSysAlertsThread(id);
	TIME_TRACE_DBG("END - StartSysAlertsThread");


	TIME_TRACE_DBG("START - DrawSelectedPolyText");
	DrawSelectedPolyText(id);
	TIME_TRACE_DBG("END - DrawSelectedPolyText");

	// Added to show plottime when non aircraft are visible.
	if (!id->m_sCurLayout.m_bShowPassurAircraft &&
		!id->m_sCurLayout.m_bShowASDAircraft &&
		!id->m_sCurLayout.m_bShowASDEXAircraft){
		Updplottime(id);
	}

	// Moved Embedded GUI to end of Render for top visibility
	TIME_TRACE_DBG("START - DrawGUI");
	// GUI is created from CreateGUI function
	gui* oglgui = (gui*)id->m_poglgui;

	if (!oglgui){
		oglgui = CreateGUI(id);
		id->m_poglgui = oglgui;
	}
	if (OpenglGrid){
		SetGridGLMode(id);
		MGLDrawGUI(id);
	}
	TIME_TRACE_DBG("END - DrawGUI");

	DrawPlotTime(id);

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	loopcount++;
	end_fps = time(0);

	if (end_fps - start_fps > 30){
		fps = (double)loopcount / (double)(end_fps - start_fps);
		loopcount = 0;
		start_fps = end_fps;
	}
	nowsecs = time(0);
	if (end_fps - start_fps > 10){
		if (DataAppGrid)
		{
		//	if (end_fps - start_fps > 10)
			//{
#ifdef TOO_SLOW
			if (nowsecs - LastFDOFillSecs > 500){
				for (i = 0, FDOGrid = NULL; DataAppGrid && DataAppGrid->vo && i < DataAppGrid->vo->count; i++)
				{
					DataSource = VP(DataAppGrid->vo, i, "DataSource", char);
					if (!strcmp(DataSource, "FDO")){
						FDOGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
						if (FDOGrid && FDOGrid->vo && FDOGrid->parent_w->visible == TRUE){
							CrFilteredGrid(id, FDOGrid);
							LastFDOFillSecs = nowsecs;
						}
					}
				}
			}
#endif

			//}
		}
		fps = (double)loopcount / (double)(end_fps - start_fps);
		loopcount = 0;
		start_fps = end_fps;
	}

	if (TryEnterCriticalSection(&id->m_csEta)){
		TIME_TRACE_DBG("START - UpdateFDOGrid");
		if (DataAppGrid && DataAppGrid->vo && (id->GFDO != LastGFDO) ){
			UpdateFDOGrid(id);
			LastGFDO = id->GFDO;
		} 
		TIME_TRACE_DBG("END - UpdateFDOGrid");

		TIME_TRACE_DBG("START - UpdateSAGrid");
		if (DataAppGrid && DataAppGrid->vo && (id->GSA != LastGSA)){
			UpdateSAGrid(id);
			LastGSA = id->GSA;
		}
		TIME_TRACE_DBG("END - UpdateSAGrid");
		LeaveCriticalSection(&id->m_csEta);
	}


	// RecordVideo: WT2.3 Save video frame if recording is active
	if (id->avilib.m_bRecordVideo == TRUE)
	{
		if (id->avilib.m_pVideoBuffer != NULL)
		{
			// Stop recording if the video buffer size differs from the current OpenGL size.
			// Send a stop request event and exit.
			if ((id->m_nWidth / 4) * 4 != id->avilib.m_nVideoWidth ||
				(id->m_nHeight / 4) * 4 != id->avilib.m_nVideoHeight)
			{
				// Send a stop recording event request
				SetEvent(id->m_evRecVideoReset);
				id->avilib.m_sError = "Recording stopped due to a screen size change.";
			}
			else
			{
				if (id->avilib.m_bVideoBufferReady == FALSE)
				{
					// Copy the buffer
					glReadPixels(0, 0, id->avilib.m_nVideoWidth, id->avilib.m_nVideoHeight, GL_BGR_EXT,
						GL_UNSIGNED_BYTE, id->avilib.m_pVideoBuffer);

					// Buffer is now ready to save
					id->avilib.m_bVideoBufferReady = TRUE;
				}
			}
		}
	}


	id->m_bOnRefresh = FALSE;
	gframecount++;
	TIME_TRACE_DBG("END(3) - RenderScene");

	if (PicInPic){
		RenderScenePicInPic(id);
	}

}





int CkBorderEvent(struct InstanceData* id, int b, int m, int x, int y)
{

	if (!id->m_bShowBorder){
		return(FALSE);
	}

	return(TRUE);
}

void ReadPixelVal(struct InstanceData* id)
{
	char tmpstr[TMPBUF_SIZE];
	GLenum   format = GL_RGBA;
	unsigned char* pdata;
	int bpp = 4;


	pdata = malloc(4);

	// read from front buffer
	glReadBuffer(GL_FRONT);

	// read pixel data
	glReadPixels(id->m_nMouseX, id->m_nMouseY, 1, 1, format, GL_UNSIGNED_BYTE, pdata);


	sprintf_s(tmpstr, TMPBUF_SIZE, "r=%d g=%d b=%d a=%d", pdata[0], pdata[1], pdata[2], pdata[3]);
	MGLGridText(id, statusgrid, 8, 0, "rgba");
	MGLGridText(id, statusgrid, 8, 1, tmpstr);

	free(pdata);


	glReadBuffer(GL_BACK);
}



void CkGmap(struct InstanceData* id)
{
	static double PrevXmin, PrevYmin, PrevXmax, PrevYmax;

	if (Gmapimage){
		MyScreenMessage = "Recalculating Screen...";
		ResetGmap = TRUE;
	} else {
		ForceRefresh = TRUE;
	}


	if (PrevXmin != id->m_sCurLayout.m_dWorldXmin ||
		PrevYmin != id->m_sCurLayout.m_dWorldYmin ||
		PrevXmax != id->m_sCurLayout.m_dWorldXmax ||
		PrevYmax != id->m_sCurLayout.m_dWorldYmax){
		//glDeleteLists(trianglelist, 1);
		//trianglelist = 0;
		PrevXmin = id->m_sCurLayout.m_dWorldXmin;
		PrevYmin = id->m_sCurLayout.m_dWorldYmin;
		PrevXmax = id->m_sCurLayout.m_dWorldXmax;
		PrevYmax = id->m_sCurLayout.m_dWorldYmax;
	}
}



double DisPoint2Line(double x1, double y1, double x2, double y2, double x0, double y0)
{
	double m, b, A, B, C, dst;

	// find distance from a point to a line
	m = (y2 - y1) / (x2 - x1);
	// use one point (x1,y1) to find b  (b=y - mx)
	b = -(m * x1) + y1;

	A = (y1 - y2);
	B = (x2 - x1);
	C = (x1*y2) - (x2 * y1);

	// d = abs( (x1*A + y1*B + c ) / sqrt (A^2 * B^2) )
	dst = fabs((x0 * A + y0 * B + C) / sqrt(A * A + B * B));

	return(dst);

}


void DistanceFromLine(double cx, double cy, double ax, double ay,
	double bx, double by, double *distanceSegment,
	double *distanceLine)
{

	//
	// find the distance from the point (cx,cy) to the line
	// determined by the points (ax,ay) and (bx,by)
	//
	// distanceSegment = distance from the point to the line segment
	// distanceLine = distance from the point to the line (assuming
	//					infinite extent in both directions
	//

	/*

	Subject 1.02: How do I find the distance from a point to a line?


	Let the point be C (Cx,Cy) and the line be AB (Ax,Ay) to (Bx,By).
	Let P be the point of perpendicular projection of C on AB.  The parameter
	r, which indicates P's position along AB, is computed by the dot product
	of AC and AB divided by the square of the length of AB:

	(1)     AC dot AB
	r = ---------
	||AB||^2

	r has the following meaning:

	r=0      P = A
	r=1      P = B
	r<0      P is on the backward extension of AB
	r>1      P is on the forward extension of AB
	0<r<1    P is interior to AB

	The length of a line segment in d dimensions, AB is computed by:

	L = sqrt( (Bx-Ax)^2 + (By-Ay)^2 + ... + (Bd-Ad)^2)

	so in 2D:

	L = sqrt( (Bx-Ax)^2 + (By-Ay)^2 )

	and the dot product of two vectors in d dimensions, U dot V is computed:

	D = (Ux * Vx) + (Uy * Vy) + ... + (Ud * Vd)

	so in 2D:

	D = (Ux * Vx) + (Uy * Vy)

	So (1) expands to:

	(Cx-Ax)(Bx-Ax) + (Cy-Ay)(By-Ay)
	r = -------------------------------
	L^2

	The point P can then be found:

	Px = Ax + r(Bx-Ax)
	Py = Ay + r(By-Ay)

	And the distance from A to P = r*L.

	Use another parameter s to indicate the location along PC, with the
	following meaning:
	s<0      C is left of AB
	s>0      C is right of AB
	s=0      C is on AB

	Compute s as follows:

	(Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
	s = -----------------------------
	L^2


	Then the distance from C to P = |s|*L.

	*/

	double xx, yy;
	double r_numerator = (cx - ax)*(bx - ax) + (cy - ay)*(by - ay);
	double r_denomenator = (bx - ax)*(bx - ax) + (by - ay)*(by - ay);
	double r = r_numerator / r_denomenator;
	//
	double px = ax + r*(bx - ax);
	double py = ay + r*(by - ay);
	//     
	double s = ((ay - cy)*(bx - ax) - (ax - cx)*(by - ay)) / r_denomenator;

	*distanceLine = fabs(s)*sqrt(r_denomenator);

	//
	// (xx,yy) is the point on the lineSegment closest to (cx,cy)
	//
	xx = px;
	yy = py;

	if ((r >= 0) && (r <= 1))
	{
		*distanceSegment = *distanceLine;
	}
	else
	{

		double dist1 = (cx - ax)*(cx - ax) + (cy - ay)*(cy - ay);
		double dist2 = (cx - bx)*(cx - bx) + (cy - by)*(cy - by);
		if (dist1 < dist2)
		{
			xx = ax;
			yy = ay;
			*distanceSegment = sqrt(dist1);
		}
		else
		{
			xx = bx;
			yy = by;
			*distanceSegment = sqrt(dist2);
		}
	}

	return;
}



int HandlePolyMouse(int b, int m, int x, int y)
{
	points *np, *newp, *lastnp;

	/* only capture down events */
	if (m == 1){
		/* mouse down event */
	} else {
		return(FALSE);
	}

	/* see if the value is in range of any gui panels */
	if (!editpoly){
		editpoly = (poly *)vo_malloc(sizeof(poly));
	}

	// find last point
	for (np = editpoly->ppoints, lastnp = NULL; np; np = np->np){
		lastnp = np;
	}
	newp = (points *)vo_malloc(sizeof(points));
	if (lastnp){
		lastnp->np = newp;
	} else {
		editpoly->ppoints = newp;
	}
	newp->vt[0] = x;
	newp->vt[1] = y;

	if (editlist){
		glDeleteLists(editlist, 1);
		editlist = 0;
	}

	return(TRUE);
}




int IsGuiMouseEvent(struct InstanceData* id, int b, int m, int x, int y, int s)
{
	
	widgets *w;
	gui *oglgui;
	gui *xgui;
	/* only capture down events */
	if (m == 1){
		/* mouse down event */
	} else {
		return(FALSE);
	}

	
	oglgui = (gui*)id->m_poglgui;
	/* see if the value is in range of any gui panels */
	if (!oglgui){
		return(FALSE);
	}
	for (xgui = oglgui; xgui; xgui = xgui->np){

		for (w = xgui->widgets; w; w = w->np){
			// see if in range of this widget
			if (w->wgt_mouse_cb){
				if (x >= (xgui->gregion.x1 + w->gregion.x1) && x <= (xgui->gregion.x1 + w->gregion.x2) &&
					y >= (xgui->gregion.y1 + w->gregion.y1) && y <= (xgui->gregion.y1 + w->gregion.y2)){
					// Only do work if s is set
					if (s)
						(w->wgt_mouse_cb)(id, w, x, y, xgui);
					return(TRUE);
				}
			}
		}
	}

	id->m_poglgui = oglgui;
	return(FALSE);
}



void myRmouse(struct InstanceData* id, int b, int m, int x, int y)
{
	char tmpstr[256];

	if (id->m_nMode == MODE_POLY){
		// stop adding to the polygon, and save it somewhere
		id->m_nMode = MODE_NONE;
		sprintf_s(tmpstr, _countof(tmpstr), "myRmouse set GMode = MODE_POLY\n");
		OutputDebugString(tmpstr);
	} else if (id->m_nMode == MODE_NONE){
		// first right click
		// just starting
		id->m_nMeasureX1 = x;
		measure_y1 = id->m_nHeight - y;
		id->m_nMode = MODE_MEASURE;
		measure_x2 = -1;
		measure_y2 = -1;
		sprintf_s(tmpstr, _countof(tmpstr), "first right click measure+x=%d y=%d\n", id->m_nMeasureX1, measure_y1);
		OutputDebugString(tmpstr);
	} else {
		// second point, make measurement stay
		measure_x2 = x;
		measure_y2 = id->m_nHeight - y;
		id->m_nMode = MODE_NONE;
		sprintf_s(tmpstr, _countof(tmpstr), "second meassure_x2=%d y2=%d\n", measure_x2, measure_y2);
		OutputDebugString(tmpstr);
	}

}



void FindTrailPoint(struct InstanceData* id, AIR **airp, int AI, int x, int y, AIR ***bestairp, int *bestindex, double *bestdis, int *bestIsTrail)
{
	PTRACK *trackarr = NULL;
	AIR *air;
	double lat, lng, dis, dy, dx;
	int ypixel, xpixel, tcount, i;

	// see if point is close to mouse location. Check last 20 points in trail


	if (!(air = airp[AI])){
		return;
	}
	if (!(trackarr = air->TrackPtr)){
		/* no tracks yet */
		return;
	}

	// start at last track and move backward
	tcount = air->tcount;
	for (i = tcount - 1; i > tcount - 20 && i >= 0; i--){
		lng = trackarr[i].x;
		lat = trackarr[i].y;

		/* convert X and Y from world to pixel coordinates */
		ypixel = (int)rint((lat - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((lng - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		dy = y - ypixel;
		dx = x - xpixel;
		dis = sqrt((dx * dx) + (dy * dy));

		if (dis < *bestdis){
			*bestairp = airp;
			*bestindex = AI;
			*bestdis = dis;
			*bestIsTrail = TRUE;
			//GScreenDebug = TRUE;
			//sprintf(ScreenComment, "%s dis=%g x=%d y=%d , xp=%d yp=%d", air->FltNum, dis, x, y, xpixel, ypixel );
		}
	}
}


int FindClosestAircraft(struct InstanceData* id, AIR **airp, int x, int y, AIR ***bestairp, int *bestindex, double *bestdis, int *bestIsTrail, int nFeedType, int ntracks)
{
	double dx, dy, dis, lat, lng;
	int ypixel, xpixel;
	int i;
	int found = FALSE;
	AIR *air;

	for (i = 0; i < ntracks; i++){
		/* calculate closest distance to this point */
		if (!(air = airp[i])){
			continue;
		}
		if (!air->TrackPtr){
			/* no tracks yet */
			continue;
		}
		if (air->IsTracked){// && !((air->IsTracked & TBF_ASDEX || air->IsTracked & TBF_MLAT) && id->m_sCurLayout.m_dWorldXSize > ASDEX_DRAW_LIMIT)){
			/* Tracked aircraft should not be selected */
			continue;
		}
		/* don't select filtered aircraft */
		if (ASDEX == nFeedType && !UseASDEXFilters){
			// ignore filters for asdex if !UseASDEXFilters 
		} else {
			if (!air->vehicle && filtermatch(id, air) < 0){
				if (ASDEX != nFeedType)
					continue;
			}
		}

		if ((!id->m_nVehicles && air->vehicle) || (2 == id->m_nVehicles && air->vehicle && !air->VInfoPtr))
			continue;

		/* convert X and Y from world to pixel coordinates */
		lat = air->Y;
		lng = air->X;
		ypixel = (int)rint((lat - id->m_sCurLayout.m_dWorldYmin) / id->m_sCurLayout.m_dWorldYSize * id->m_nHeight);
		xpixel = (int)rint((lng - id->m_sCurLayout.m_dWorldXmin) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);

		dy = y - ypixel;
		dx = x - xpixel;
		dis = sqrt((dx * dx) + (dy * dy));

		if (dis < *bestdis){
			*bestairp = airp;
			*bestindex = i;
			*bestdis = dis;
			*bestIsTrail = FALSE;
			found = TRUE;
		}

		if (id->m_sCurLayout.m_bShowTrailTimes){
			// see if user is clicking near a track point, and if so, display time, speed , altitude if this point is the closest
			// to make this run faster we should have make sure the aircraft in on the current users screen
			if (PixOnScreen(id, xpixel, ypixel)){
				// FindTrailPoint( id, airp, i, x, id->m_nHeight - y , bestairp, bestindex, bestdis, bestIsTrail );
				FindTrailPoint(id, airp, i, x, y, bestairp, bestindex, bestdis, bestIsTrail);
			}
		}

	}
	return found;
}


AIR **ClosestAircraft(struct InstanceData* id, int x, int y, int *bestindex, double *bestdis, int *bestIsTrail)
{
	AIR **airp;
	AIR **bestairp = NULL;

	// Display priority order when more than one overlay is switched
	// on is: ADS-B ASDE-X, Passur, then asdi.
	if (id->m_sCurLayout.m_bShowADSBAircraft){
		airp = GetADSBAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, ADSB, N_ADSB_TRACK_ID))
			id->m_nSelectedAircraftType = SAT_ADSB;
	}

	if (id->m_sCurLayout.m_bShowASDEXAircraft && (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT)){
		airp = GetGateAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, GATE, N_GATE_TRACK_ID)){
			id->m_nSelectedAircraftType = SAT_GATE;
		}

		airp = GetLMGAirP(id);
		if(FindClosestAircraft( id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, LMG, N_TRACK_ID ))
			id->m_nSelectedAircraftType = SAT_LMG;

		airp = GetASDEXAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, ASDEX, N_ASDEX_TRACK_ID))
			id->m_nSelectedAircraftType = SAT_ASDEX;
	}

	if (id->m_sCurLayout.m_bShowMLATAircraft && (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT)){
		airp = GetGateAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, GATE, N_GATE_TRACK_ID)){
			id->m_nSelectedAircraftType = SAT_GATE;
		}
		airp = GetMLATAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, MLAT, N_MLAT_TRACK_ID))
			id->m_nSelectedAircraftType = SAT_MLAT;
	}

	if (id->m_sCurLayout.m_bShowPassurAircraft){
		if (id->m_sCurLayout.m_dWorldXSize < ASDEX_DRAW_LIMIT) {
			airp = GetGateAirP(id);
			if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, GATE, N_GATE_TRACK_ID)) {
				id->m_nSelectedAircraftType = SAT_GATE;
			}
		}
		airp = GetAirP(id, 0);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, PASSUR, N_PASSUR_TRACK_ID))
			id->m_nSelectedAircraftType = SAT_PASSUR;
	}

	if (id->m_sCurLayout.m_bShowASDAircraft){
		airp = GetASDAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, ASDI, N_ASDI_TRACK_ID))
			id->m_nSelectedAircraftType = SAT_ASDI;
	}

	if (id->m_sCurLayout.m_bShowNoiseAircraft){
		airp = GetNoiseAirP(id);
		if (FindClosestAircraft(id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, NOISE, N_NOISE_TRACK_ID))
			id->m_nSelectedAircraftType = SAT_NOISE;
	}

	if ( id->m_sCurLayout.m_bShowAirAsiaAircraft ){
		airp = GetAirAsiaAirP(id);
		if(FindClosestAircraft( id, airp, x, y, &bestairp, bestindex, bestdis, bestIsTrail, AIRASIA, N_AIRASIA_TRACK_ID ))
			id->m_nSelectedAircraftType = SAT_AIRASIA;
	}

	return(bestairp);
}


void ColorFDORow(struct InstanceData* id, char *SelectedFltNum, char *SelectedDestination )
{
	int i;
	VO *DataAppVO;
	char *DataSource;
	MGLGRID *ROIGrid, *FDOGrid;
	


	//Setting void pointers to MGLGRID struct
	MGLGRID* DataAppGrid = (MGLGRID*)id->DataAppGrid;
	id->DataAppGrid = DataAppGrid;
	for (i = 0; DataAppGrid && (DataAppVO = DataAppGrid->vo) && i < DataAppVO->count; i++){
		DataSource = VP(DataAppVO, i, "DataSource", char);
		if (!strcmp(DataSource, "ROI")){
			ROIGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
			if (strcmp(ROIGrid->Flightnum, SelectedFltNum) != 0)
			{
				strcpy_s(ROIGrid->Flightnum, 20, SelectedFltNum);
				CrFilteredGrid(id, ROIGrid);
			}
			strcpy_s(ROIGrid->Flightnum, 20, SelectedFltNum);
			ROIGrid->mm = 3;
		}
		else if (!strcmp(DataSource, "FDO"))
		{
			FDOGrid = VV(DataAppGrid->vo, i, "gridptr", void *);
			if (FDOGrid->filteredvo){
				//for (voindex = 0; voindex < FDOGrid->filteredvo->count; voindex++){
				//	FltNum = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[voindex].rownum, "FltNum", char);
				//	Destination = VP(FDOGrid->filteredvo, FDOGrid->filteredvo->row_index[voindex].rownum, "Destin", char);
				//	if (!strcmp(FltNum, SelectedFltNum) && !strcmp(Destination, SelectedDestination)){
				//		strcpy_s(FDOGrid->Flightnum, 20, SelectedFltNum);
				//		FDOGrid->filteredvo->row_index[voindex].fg = MGLColorHex2Int("FF0000");
				//	}
				//}
				// even if not found, it may get set later, so update
				strcpy_s(FDOGrid->Flightnum, 20, SelectedFltNum);
				CrFilteredGrid(id, FDOGrid);
			}
		}

	}


}


int FindAircraft(struct InstanceData* id, int x, int y)
{
	AIR **airp;
	int AI = 0;
	double bestdis = 9.0e30;
	char tmpstr[TMPBUF_SIZE];
	AIR *air;
	int bestIsTrail = FALSE; // if True, then the best point is a trail point , not an aircraft

	// user clicked mouse, look for closest aircraft within 50 pixels
	if ((airp = ClosestAircraft(id, x, y, &AI, &bestdis, &bestIsTrail)) && bestdis < 50.0){
		id->m_pSelectedAirP = airp;
		if ((air = airp[AI])){
			id->m_pSelectedAircraft = air->FltNum;
			id->m_nSelectedTrackID = air->trackid;
			id->m_nSelectedAirIndex = AI;
			id->m_nSelectedIsTrail = bestIsTrail;
			Callback2Javascript(id, "UpdateSelected:");
			/// ShowLastKnown = 0;  // erase the tags on last known aircraft
			ForceRefresh = TRUE;
			if (ShowStatusWin){
				MGLGridText(id, statusgrid, 0, 0, "selected");
				MGLGridText(id, statusgrid, 0, 1, air->FltNum);
				MGLGridText(id, statusgrid, 1, 0, "s index");
				sprintf_s(tmpstr, TMPBUF_SIZE, "%d", id->m_nSelectedAirIndex);
				MGLGridText(id, statusgrid, 1, 1, tmpstr);
			}
			// color any FDO with this 
			// better place to call ColorVorow_iconselected
			ColorFDORow(id, id->m_pSelectedAircraft, air->Destin);
			//coloraircraft(id, id->m_pSelectedAircraft, air->Destin);
			 
		}
		return(TRUE);
	} else {
		ClearSelectedAircraft(id);
	}
	return(FALSE);
}

void DeleteRegion(struct InstanceData* id, char *regionname)
{
	struct MemoryStruct chunk;
	char tmpstr[25000];
	char *data;

	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */


	sprintf_s(tmpstr, _countof(tmpstr), "Action=DeleteRegion&regionname=%s&user=%s&arpt=%s",
		regionname, id->m_strUserName, id->m_sCurLayout.m_strPassurArpt);
	data = curl_escape(tmpstr, strlen(tmpstr));

	strncpy_s(tmpstr, _countof(tmpstr), data, _TRUNCATE);

	// don't escape = or &
	StrSubs(tmpstr, "%3D", "=", TMPBUF_SIZE);
	// StrSubs(tmpstr, "%20", "", TMPBUF_SIZE );
	StrSubs(tmpstr, "%26", "&", TMPBUF_SIZE);


	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
		GetCurrentThreadId(), id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

	if (!GetCurlFormPostResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) failed to delete region <%s>.\n",
			GetCurrentThreadId(), regionname);
		GetNxtSurfSrvr(id);
	}

	curl_free(data);

	if (chunk.memory){
		free(chunk.memory);
	}

	// Signal background thread to reload the ROI's so we can load newly created region.
	id->m_bROILoaded = FALSE;
}



void SaveRegion(struct InstanceData* id, char *regionname)
{
	struct MemoryStruct chunk;
	char tmpstr[25000];
	wchar_t wszBuffer[1000] = { 0 };
	size_t sCount = 0;
	points *np;
	char polystr[20000];
	int count;
	double lng, lat;


	chunk.memory = NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	// save the polygon values
	polystr[0] = '\0';
	if (!editpoly){
		// no polygons
		return;
	} else {
		for (np = editpoly->ppoints, count = 0; np; np = np->np, count++){
			// gluTessVertex(tobj, np->vt, np->vt );
			// convert to world coordinates
			lng = (((double)np->vt[0] / id->m_dWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
			lat = (((double)np->vt[1] / id->m_dHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

			_snprintf_s(tmpstr, _countof(tmpstr), _TRUNCATE, "&x=%0.6f&y=%0.6f", lng, lat);
			strncat_s(polystr, _countof(polystr), tmpstr, __min(strlen(tmpstr), sizeof(polystr) - strlen(polystr)));

		}
	}


	sprintf_s(tmpstr, _countof(tmpstr), "Action=SaveRegion&regionname=%s&user=%s&arpt=%s%s",
		regionname, id->m_strUserName, id->m_sCurLayout.m_strPassurArpt, polystr);
	StrSubs(tmpstr, "%3D", "=", TMPBUF_SIZE);
	// StrSubs(tmpstr, "%20", "", TMPBUF_SIZE );
	StrSubs(tmpstr, "%26", "&", TMPBUF_SIZE);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) CURL / GetCurlFormPostResults - id->m_strHttpDBservername <%s> tmpstr <%s>.\n",
		GetCurrentThreadId(), id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr);

	if (!GetCurlFormPostResults(id, &chunk, id->m_strHttpDBservername[id->m_nDBServerIndex], tmpstr, SM_HTTPS, TRUE)){
		vo_log_warning(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) failed to save region <%s>.\n",
			GetCurrentThreadId(), regionname);
		GetNxtSurfSrvr(id);
	}

	if (chunk.memory){
		free(chunk.memory);
	}

	// Signal background thread to reload the ROI's so we can load newly created region.
	id->m_bROILoaded = FALSE;
}


void CalcHistoricalBlockTimes(VO *HistoricalHdrVO, int BestVOCount)
{
	VO *HistoricalTrackVO;
	time_t startsecs, endsecs;


	// parse through tracks and get start and end times
	if (!HisVO){
		return;
	}

	// HistoricalTrackVO = HistoricalTracksVO[BestVOCount];
	HistoricalTrackVO = VV(HisVO, BestVOCount, "HTrackVO", void *);

	if (HistoricalTrackVO && HistoricalTrackVO->count){
		startsecs = VV(HistoricalTrackVO, 0, "utc", int);
		endsecs = VV(HistoricalTrackVO, HistoricalTrackVO->count - 1, "utc", int);
		VV(HistoricalHdrVO, 0, "startsecs", int) = startsecs;
		VV(HistoricalHdrVO, 0, "endsecs", int) = endsecs;
	}

}



int CkHistoricalTracks(struct InstanceData* id, int butval, int mbutton, int x, int y)
{
	double lng, lat, mindis, x1, y1, x2, y2, dst;
	int i, trk, selindex;
	VO *HistoricalTrackVO, *HistoricalHdrVO;
	double distanceSegment, distanceLine;
	char starttimebuf[256], endtimebuf[256];
	char tmpstr[TMPBUF_SIZE];
	double pixsize;


	lng = (((double)x / id->m_nWidth) *
		(id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
	lat = (((double)y / id->m_nHeight) *
		(id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

	pixsize = fabs((double)id->m_sCurLayout.m_dWorldXSize / id->m_nWidth);

	mindis = 9.9e9;
	// find closest track
	// use routine from IsLine()

	BestVO = NULL;
	if (id->m_hDlgBlockReplayDialog){
		SetDlgItemText(id->m_hDlgBlockReplayDialog, IDC_FLIGHTID, "");
	}
	for (i = 0, selindex = 0; HisVO && i < HisVO->count; i++){
		/* draw a line between all of the points */

		HistoricalTrackVO = VV(HisVO, i, "HTrackVO", void *);

		if (BlockSelectedBuffer[selindex] != i){
			// not selected
			continue;
		}
		selindex++;

		for (trk = 0; HistoricalTrackVO && trk < HistoricalTrackVO->count - 1; trk++){
			// if ( !tcheck || airplottime >= endutc){
			x1 = VV(HistoricalTrackVO, trk, "X", double);
			y1 = VV(HistoricalTrackVO, trk, "Y", double);
			x2 = VV(HistoricalTrackVO, trk + 1, "X", double);
			y2 = VV(HistoricalTrackVO, trk + 1, "Y", double);

			DistanceFromLine(lng, lat, x1, y1, x2, y2, &distanceSegment, &distanceLine);
			dst = distanceSegment;
			// if closest point and within 20 pixels of user clicked location
			if (dst < mindis && dst < (pixsize * 20.0)){
				BestVO = HistoricalTrackVO;
				BestVOCount = i;
				mindis = dst;
			}
		}
	}

	if (BestVO && HisVO && BestVOCount < HisVO->count){
		// this track will be drawn in red

		HistoricalHdrVO = VV(HisVO, BestVOCount, "HHdrVO", void *);;

		if (HistoricalHdrVO && HistoricalHdrVO->count){

			CalcHistoricalBlockTimes(HistoricalHdrVO, BestVOCount);
			VOTimeFmt(starttimebuf, VV(HistoricalHdrVO, 0, "startsecs", int), "%Y-%m-%d %H:%M:%S");
			VOTimeFmt(endtimebuf, VV(HistoricalHdrVO, 0, "endsecs", int), "%Y-%m-%d %H:%M:%S");

			sprintf_s(tmpstr, sizeof(tmpstr), "%s %s %s %s\n%s to %s\n",
				VP(HistoricalHdrVO, 0, "flightid", char),
				VP(HistoricalHdrVO, 0, "src_radar", char),
				VP(HistoricalHdrVO, 0, "fromto", char),
				VP(HistoricalHdrVO, 0, "actype", char),
				starttimebuf, endtimebuf);

			// ShowMyMessage2(tmpstr, 50 );
			// set string value in Block Window
			if (id->m_hDlgBlockReplayDialog){
				SetDlgItemText(id->m_hDlgBlockReplayDialog, IDC_FLIGHTID, VP(HistoricalHdrVO, 0, "flightid", char));
				SetDlgItemText(id->m_hDlgBlockReplayDialog, IDC_BLOCK_MESSAGE, tmpstr);
			}
		}
	}

	return(TRUE);
}


void mymouse(struct InstanceData* id, int b, int m, int x, int y)
{
	double lng1, lng2, lat1, lat2, dval, xlen, ylen;
	double newylen, newxlen;
	double xmove;
	static int testpoly = 1;

	//printf("b=%d m=%d x=%d y=%d Box=%d m=%d\n", b,m,x,y, Box, m);

	/* GUI y values must be flipped from SDL, since opengl
	has y = 0 is at bottom of screen */

	if (MGLIsGuiMouseEvent(id, b, m, x, id->m_nHeight - y)){
		/* handled by a gui panel */
		return;
	}

#ifdef OLDWAY
	if ( IsGuiMouseEvent(id, b, m, x, id->m_nHeight - y, 1 ) ){
		/* handled by a gui panel */
		return;
	}
#endif

	if (testpoly){
		// set using P key by user id->m_nMode g_nMode = MODE_POLY;

		// sprintf(tmpstr, "Hi");
		// ShowMyMessage2(tmpstr, 12);
	}

	if (id->m_nMode == MODE_POLY){
		if (HandlePolyMouse(b, m, x, id->m_nHeight - y)){
			/* mouse processed by poly editor */
			return;
		}
	}


	if (m == 1){
		/* mouse down event */
		id->m_nBox = TRUE;
		id->m_dPrevX1 = (((double)id->m_nBoxX1 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		id->m_dPrevY1 = (((double)id->m_nBoxY1 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

		id->m_nBoxX1 = x;
		id->m_nBoxX2 = x;
		id->m_nBoxY1 = id->m_nHeight - y;
		id->m_nBoxY2 = id->m_nHeight - y;
		ForceRefresh = TRUE;

		ReadPixelVal(id);

		id->m_nMeasureX1 = -1; // left mouse disables measure mode
		id->m_strHeader[0] = '\0';

	} else if ( id->m_nBox == TRUE && abs(id->m_nBoxX2 - id->m_nBoxX1) > 20  ){
		// MOUSE is UP
		/* just ended a drag operation */

		/* convert into lat and lon */

		/* make sure 2nd coordinate is largest */
		if (id->m_nBoxY1 > id->m_nBoxY2){
			dval = id->m_nBoxY2;
			id->m_nBoxY2 = id->m_nBoxY1;
			id->m_nBoxY1 = (int)dval;
		}
		if (id->m_nBoxX1 > id->m_nBoxX2){
			dval = id->m_nBoxX2;
			id->m_nBoxX2 = id->m_nBoxX1;
			id->m_nBoxX1 = (int)dval;
		}

		xlen = id->m_nBoxX2 - id->m_nBoxX1;
		ylen = id->m_nBoxY2 - id->m_nBoxY1;


		newylen = (xlen * id->m_nHeight) / id->m_nWidth;
		xmove = 0;
		if (newylen < ylen){
			// must increase redraw box
			newxlen = (ylen * id->m_nWidth) / id->m_nHeight;
			// recenter in x direction
			xmove = fabs(newxlen - xlen) / 2.0;
			xlen = newxlen;
		} else {
			ylen = newylen;
		}

		id->m_nBoxX1 -= (int)xmove; // adjust center to compensate for large xsize

		id->m_nBoxX2 = id->m_nBoxX1 + (int)xlen;
		id->m_nBoxY1 = id->m_nBoxY2 - (int)ylen;

		lng1 = (((double)id->m_nBoxX1 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		lng2 = (((double)id->m_nBoxX2 / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
		lat1 = (((double)id->m_nBoxY1 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;
		lat2 = (((double)id->m_nBoxY2 / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

		if (fabs(lng2 - lng1) < 0.001 || fabs(lat2 - lat1) < 0.001){
			// too small, ignore 
		} else {
			id->m_sCurLayout.m_dWorldXmin = lng1;
			id->m_sCurLayout.m_dWorldXmax = lng2;
			id->m_sCurLayout.m_dWorldYmin = lat1;
			id->m_sCurLayout.m_dWorldYmax = lat2;
			id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
			id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
		}

		//printf("\nchanging World xmin=%g xmax=%g ymin=%g ymax=%g\n",
		//   WorldXmin, WorldXmax, WorldYmin, WorldYmax );
		id->m_nBox = FALSE;
		id->m_nBoxCount = 0;
		id->m_bClearScreen = TRUE;
		CkGmap(id);
	} else if ( id->m_nBox == TRUE ) {
		// MOUSE is UP
		id->m_nBox = FALSE;
		id->m_nBoxCount = 0;
		/* if mouse is up and we did not draw a box, then get selected map feature */
		//		FindFeature( x, id->m_nHeight - y );

		/* find aircraft closest to these screen coordinates */
		if (0.0f != id->m_glfRotateAngle){
			RotateScreenPoint(id, id->m_nWidth / 2, id->m_nHeight / 2, &x, &y);
		}
		FindAircraft(id, x, id->m_nHeight - y);


		if (HisVO && HisVO->count > 0){
			CkHistoricalTracks(id, b, m, x, id->m_nHeight - y);
		}

	} else if ( id->m_nBox == FALSE ){

	}

}



// Change viewing volume and viewport.  Called when window is resized
void GridWinChangeSize(GLsizei w, GLsizei h)
{
	GLfloat nRange = 100.0f;

	// Prevent a divide by zero
	if (h == 0)
		h = 1;

	// Set Viewport to window dimensions
	glViewport(0, 0, w, h);

	// Reset coordinate system
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0.0, w, 0.0, h, 0.0, 1.0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
}





// Change viewing volume and viewport.  Called when window is resized
void FIDSWinChangeSize(GLsizei w, GLsizei h)
{
	GLfloat nRange = 100.0f;

	// Prevent a divide by zero
	if (h == 0)
		h = 1;

	// Set Viewport to window dimensions
	glViewport(0, 0, w, h);

	// Reset coordinate system
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0.0, w, 0.0, h, 0.0, 1.0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
}


void MoveAngle(struct InstanceData* id, double dDirection)
{
	double xrange = id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin;
	double yrange = id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin;
	double ratio = yrange / xrange;
	double dRadians = (dDirection - id->m_glfRotateAngle) * PI / 180.0f;

	xrange = xrange * cos(dRadians) * 0.05;
	yrange = yrange * sin(dRadians) * 0.05;

	id->m_sCurLayout.m_dWorldYmin -= yrange;
	id->m_sCurLayout.m_dWorldYmax -= yrange;

	id->m_sCurLayout.m_dWorldXmin -= xrange * ratio;
	id->m_sCurLayout.m_dWorldXmax -= xrange * ratio;

	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);

	id->m_bClearScreen = TRUE;
}


void MoveUp(struct InstanceData* id)
{
	double yrange;

	yrange = id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin;
	id->m_sCurLayout.m_dWorldYmin += yrange * 0.05;
	id->m_sCurLayout.m_dWorldYmax += yrange * 0.05;
	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
	/* printf("\nchanging World xmin=%g xmax=%g ymin=%g ymax=%g\n",
	WorldXmin, WorldXmax, WorldYmin, WorldYmax ); */
	id->m_bClearScreen = TRUE;

	// CkGmap(id);

}



void MoveDown(struct InstanceData* id)
{
	double yrange;

	yrange = id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin;
	id->m_sCurLayout.m_dWorldYmin -= yrange * 0.05;
	id->m_sCurLayout.m_dWorldYmax -= yrange * 0.05;
	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
	/* printf("\nchanging World xmin=%g xmax=%g ymin=%g ymax=%g\n",
	WorldXmin, WorldXmax, WorldYmin, WorldYmax ); */
	id->m_bClearScreen = TRUE;
	//CkGmap(id);

}

int ZoomIn(struct InstanceData* id, POINT* pt)
{
	double xrange, yrange;

	// Adjust over Point

	xrange = id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin;
	yrange = id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin;

	if (pt){
		RECT Rect;
		POINT c;
		int cnt;
		GetClientRect(id->m_hMainWnd, &Rect);
		c.x = (Rect.right - Rect.left) / 2;
		c.y = (Rect.bottom - Rect.top) / 2;
		// Move Left or Right
		if (c.x > pt->x){
			cnt = (int)ceil((((c.x - pt->x) / (double)id->m_nWidth) / 0.05));
			while (cnt-- > 0)
				MoveLeft(id);
		}else{
			cnt = (int)ceil((((pt->x - c.x) / (double)id->m_nWidth) / 0.05));
			while (cnt-- > 0)
				MoveRight(id);
		}

		// Move Up or Down
		if (c.y > pt->y){
			cnt = (int)ceil((((c.y - pt->y) / (double)id->m_nHeight) / 0.05));
			while (cnt-- > 0)
				MoveUp(id);
		}else{
			cnt = (int)ceil((((pt->y - c.y) / (double)id->m_nHeight) / 0.05));
			while (cnt-- > 0)
				MoveDown(id);
		}
	}

	/* zoom in 20 % */
	if (xrange > 0.001 && yrange > 0.001){
		id->m_sCurLayout.m_dWorldXmin += xrange * 0.2;
		id->m_sCurLayout.m_dWorldYmin += yrange * 0.2;
		id->m_sCurLayout.m_dWorldXmax -= xrange * 0.2;
		id->m_sCurLayout.m_dWorldYmax -= yrange * 0.2;
		id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
		id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
		/* printf("\nchanging AllPolys xmin=%g xmax=%g ymin=%g ymax=%g\n",
		WorldXmin, WorldXmax, WorldYmin, WorldYmax ); */
		id->m_bClearScreen = TRUE;
		//CkGmap(id);
	}
	return(TRUE);
}


int ZoomOut(struct InstanceData* id)
{
	double xrange, yrange;

	xrange = id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin;
	yrange = id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin;
	/* zoom in 20 % */
	if (xrange < 500.0 && yrange < 400.0){
		id->m_sCurLayout.m_dWorldXmin -= xrange * 0.2;
		id->m_sCurLayout.m_dWorldYmin -= yrange * 0.2;
		id->m_sCurLayout.m_dWorldXmax += xrange * 0.2;
		id->m_sCurLayout.m_dWorldYmax += yrange * 0.2;
		id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
		id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
		/* printf("\nchanging AllPolys xmin=%g xmax=%g ymin=%g ymax=%g\n",
		WorldXmin, WorldXmax, WorldYmin, WorldYmax ); */

		// For ASDEX/MLAT tracks only, if we zoom out beyond visible threshold, 
		// clear current selected aircraft (it will not be drawn anyway).
		if (id->m_sCurLayout.m_bShowASDEXAircraft &&
			SAT_ASDEX == id->m_nSelectedAircraftType &&
			id->m_sCurLayout.m_dWorldXSize > 1.5){
			ClearSelectedAircraft(id);
		}

		if (id->m_sCurLayout.m_bShowMLATAircraft &&
			SAT_MLAT == id->m_nSelectedAircraftType &&
			id->m_sCurLayout.m_dWorldXSize > 1.5){
			ClearSelectedAircraft(id);
		}

		if( id->m_nVehicles && 
			SAT_LMG == id->m_nSelectedAircraftType &&
			id->m_sCurLayout.m_dWorldXSize > 1.5 ){
				ClearSelectedAircraft(id);
		}

		id->m_bClearScreen = TRUE;
		//CkGmap(id);
	}
	return(TRUE);
}



int LoadShapefile(struct InstanceData* id, char *shapefilename, int polyflag, double red, double green, double blue,
	double LatLonSizeFilter, double PolyTolerance, int innerflag,
	int MinVertices, int exclusion_filter, int ptype)
{
	SHPHandle	hSHP;
	int nShapeType, nEntities, i, iPart, polycount = 0, pointcount = 0;
	const char 	*pszPlus;
	double adfMinBound[4], adfMaxBound[4];
	poly *newpoly = NULL;
	points *np;
	polylist *nextpoly;
	char tmpstr[TMPBUF_SIZE];
	float lng, lat, prevlng = 999.999f, prevlat = 999.999f;
	float xmin, xmax, ymin, ymax, deltalng, realdelta;
	static int pflag = 0;
	int StartNewPoly;

	xmax = -9.9E20f;
	xmin = 9.9E20f;
	ymax = -9.9E20f;
	ymin = 9.9E20f;
	/* -------------------------------------------------------------------- */
	/*      Open the passed shapefile.                                      */
	/* -------------------------------------------------------------------- */
	hSHP = SHPOpen(shapefilename, "rb");

	if (AllPolys){
		nextpoly = AllPolys->lastpoly;
	}

	if (hSHP == NULL)
	{
		//printf( "Unable to open:%s\n", shapefilename );
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) unable to open shapefile '%s'\n", GetCurrentThreadId(), shapefilename);
		return(FALSE);
	}

	//printf("loadshapefile='%s'\n", shapefilename );
	/* for non-us shapefiles */
	/* PolyTolerance = 0.001; */

	//printf("PolyTolerance=%g\n", PolyTolerance );


	/* -------------------------------------------------------------------- */
	/*      Print out the file bounds.                                      */
	/* -------------------------------------------------------------------- */
	SHPGetInfo(hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound);

	/* printf( "Shapefile Type: %s   # of Shapes: %d\n\n",
	SHPTypeName( nShapeType ), nEntities ); */

	/* printf( "File Bounds: (%12.3f,%12.3f,%g,%g)\n"
	"         to  (%12.3f,%12.3f,%g,%g)\n",
	adfMinBound[0],
	adfMinBound[1],
	adfMinBound[2],
	adfMinBound[3],
	adfMaxBound[0],
	adfMaxBound[1],
	adfMaxBound[2],
	adfMaxBound[3] ); */

	/* -------------------------------------------------------------------- */
	/*	Skim over the list of shapes, printing all the vertices.	*/
	/* -------------------------------------------------------------------- */
	for (i = 0; i < nEntities; i++)
	{
		int		j;
		SHPObject	*psShape;

		psShape = SHPReadObject(hSHP, i);

		/* printf( "\nShape:%d (%s)  nVertices=%d, nParts=%d\n"
		"  Bounds:(%12.3f,%12.3f, %g, %g)\n"
		"      to (%12.3f,%12.3f, %g, %g)\n",
		i, SHPTypeName(psShape->nSHPType),
		psShape->nVertices, psShape->nParts,
		psShape->dfXMin, psShape->dfYMin,
		psShape->dfZMin, psShape->dfMMin,
		psShape->dfXMax, psShape->dfYMax,
		psShape->dfZMax, psShape->dfMMax ); */


		if (psShape->nSHPType == SHPT_POLYGON ||
			psShape->nSHPType == SHPT_POLYGONZ || psShape->nSHPType == SHPT_ARC){

			/* get rid of top polygons in canadian wasteland */
			// if ( psShape->dfYMax > 68.0 ){

			if (psShape->dfYMin > 72.0){
				continue;
			}


			StartNewPoly = 1;
			for (j = 0, iPart = 1; j < psShape->nVertices; j++){
				const char	*pszPartType = "";

				if (j == 0 && psShape->nParts > 0)
					pszPartType = SHPPartTypeName(psShape->panPartType[0]);

				if (iPart < psShape->nParts
					&& psShape->panPartStart[iPart] == j){
					pszPartType = SHPPartTypeName(psShape->panPartType[iPart]);

					if (!innerflag){
						/* IGNORE INNER POLYGONS??? */
						break;
					}
					StartNewPoly = 1;
					iPart++;
					pszPlus = "+";
					} else {
					pszPlus = " ";
				}

				if (StartNewPoly){
					if (newpoly){
						/* close out prev poly */
						pointcount += newpoly->count;

						newpoly->xmin = xmin;
						newpoly->ymin = ymin;
						newpoly->xmax = xmax;
						newpoly->ymax = ymax;
						newpoly->width = newpoly->xmax - newpoly->xmin;
						newpoly->height = newpoly->ymax - newpoly->ymin;

						if (newpoly->xmin < AllPolys->xmin) AllPolys->xmin = newpoly->xmin;
						if (newpoly->ymin < AllPolys->ymin) AllPolys->ymin = newpoly->ymin;
						if (newpoly->xmax > AllPolys->xmax) AllPolys->xmax = newpoly->xmax;
						if (newpoly->ymax > AllPolys->ymax) AllPolys->ymax = newpoly->ymax;
						AllPolys->width = AllPolys->xmax - AllPolys->xmin;
						AllPolys->height = AllPolys->ymax - AllPolys->ymin;

					}

					StartNewPoly = FALSE;
					newpoly = (poly *)vo_malloc(sizeof(poly));
					newpoly->polyflag = polyflag;
					xmax = -9.9E20f;
					xmin = 9.9E20f;
					ymax = -9.9E20f;
					ymin = 9.9E20f;

					sprintf_s(tmpstr, TMPBUF_SIZE, "%s poly%d", shapefilename, polycount++);
					newpoly->polyname = str_falloc(tmpstr);

					newpoly->red = red;
					newpoly->green = green;
					newpoly->blue = blue;
					newpoly->ptype = ptype;
					if (pflag){
						printf("\nShape:%d (%s)  nVertices=%d, nParts=%d\n"
							"  Bounds:(%12.3f,%12.3f, %g, %g)\n"
							"      to (%12.3f,%12.3f, %g, %g)\n",
							i, SHPTypeName(psShape->nSHPType),
							psShape->nVertices, psShape->nParts,
							psShape->dfXMin, psShape->dfYMin,
							psShape->dfZMin, psShape->dfMMin,
							psShape->dfXMax, psShape->dfYMax,
							psShape->dfZMax, psShape->dfMMax);
					}
					if (!AllPolys){
						AllPolys = (polylist *)vo_malloc(sizeof(polylist));
						AllPolys->poly = newpoly;
						AllPolys->xmax = -9.9E20f;
						AllPolys->ymax = -9.9E20f;
						AllPolys->xmin = 9.9E20f;
						AllPolys->ymin = 9.9E20f;
						nextpoly = AllPolys;
						AllPolys->lastpoly = AllPolys;
						} else {
						nextpoly->np = (polylist *)vo_malloc(sizeof(polylist));
						nextpoly = nextpoly->np;
						nextpoly->poly = newpoly;
						AllPolys->lastpoly = nextpoly;
					}
				}

				lng = (float)psShape->padfX[j];
				lat = (float)psShape->padfY[j];

				if (projflag){
					/* convert to equal area projection centered at
					98.0W and 40N */
					/* get distance from central point */
					deltalng = lng - (float)LngOrig;
					realdelta = deltalng * (float)cos(lat * M_PI / 180.0);
					lng = (float)LngOrig + realdelta;
				}

				if (fabs(lng - prevlng) < PolyTolerance && fabs(lat - prevlat) < PolyTolerance){
					/* same as previous point, skip this one */
					continue;
				}
				prevlng = lng;
				prevlat = lat;

				if (!newpoly->ppoints){
					/* first poly */
					newpoly->ppoints = (points *)vo_malloc(sizeof(points));
					np = newpoly->ppoints;
					} else {
					np->np = (points *)vo_malloc(sizeof(points));
					np = np->np;
				}
				np->vt[0] = lng;
				np->vt[1] = lat;
				np->vt[2] = 0.0;
				// np->x = lng;
				// np->y = lat;
				if (lng > xmax) xmax = lng;
				if (lng < xmin) xmin = lng;
				if (lat > ymax) ymax = lat;
				if (lat < ymin) ymin = lat;
				newpoly->count++;
			}
			pointcount += newpoly->count;

			newpoly->xmin = xmin;
			newpoly->ymin = ymin;
			newpoly->xmax = xmax;
			newpoly->ymax = ymax;
			newpoly->width = newpoly->xmax - newpoly->xmin;
			newpoly->height = newpoly->ymax - newpoly->ymin;

			if (newpoly->xmin < AllPolys->xmin) AllPolys->xmin = newpoly->xmin;
			if (newpoly->ymin < AllPolys->ymin) AllPolys->ymin = newpoly->ymin;
			if (newpoly->xmax > AllPolys->xmax) AllPolys->xmax = newpoly->xmax;
			if (newpoly->ymax > AllPolys->ymax) AllPolys->ymax = newpoly->ymax;
			AllPolys->width = AllPolys->xmax - AllPolys->xmin;
			AllPolys->height = AllPolys->ymax - AllPolys->ymin;

		}
		SHPDestroyObject(psShape);
	}

	SHPClose(hSHP);

#ifdef USE_DBMALLOC
	malloc_dump(2);
#endif

	return(SUCCEED);
}





void printString(char *s)
{
	glPushAttrib(GL_LIST_BIT);
	glListBase(fontOffset);
	glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *)s);
	glPopAttrib();
}




GLubyte *LoadPNGMap(char *filename)
{
	gdImagePtr im;
	FILE *in;
	int row, col, startrow, endrow, startcol, endcol, maprow, mapcol;
	unsigned int c;
	int alpha, pflag = 0;
	char tmpstr[TMPBUF_SIZE];
	GLubyte *mapimage = NULL;
	float colscale, rowscale;
	unsigned char redval, greenval, blueval;
	int index;

	if (fopen_s(&in, filename, "rb")){
		sprintf_s(tmpstr, TMPBUF_SIZE, "Could not open file %s", filename);
		// MessageBox(MainWin, tmpstr,"GetAirplaneImage",MB_OK);
		return(NULL);
	}

	im = gdImageCreateFromPng(in);
	fclose(in);
	/* ... Use the image ... */

	ARows = CUSTOM_MAP_IMAGE_SIZE;
	ACols = CUSTOM_MAP_IMAGE_SIZE;
	mapimage = (GLubyte *)calloc(1, ARows * ACols * 4);
	colscale = (float)im->sx / ACols;
	rowscale = (float)im->sy / ARows;


	// inc_col_count = 1.0f  / colscale;
	// inc_row_count = 1.0f / rowscale;
	for (row = 0; row < im->sy; row++){
		for (col = 0; col < im->sx; col++){

			c = gdImageGetPixel(im, col, row);

			if (c < 0 || c > 255){
				alpha = 0;
				redval = greenval = blueval = 0;
			} else {
				alpha = im->blue[c] + im->green[c] + im->red[c];
				if (alpha > 255) alpha = 255;
				if (alpha > 0){
					redval = 0; // test
				}
				redval = im->red[c];
				greenval = im->green[c];
				blueval = im->blue[c];
			}

			startrow = (int)(row / rowscale);
			endrow = (int)((row + 1) / rowscale);
			startcol = (int)(col / colscale);
			endcol = (int)((col + 1) / colscale);


			for (maprow = startrow; maprow < endrow; maprow++){
				for (mapcol = startcol; mapcol < endcol; mapcol++){
					index = (maprow * ACols * 4) + (mapcol * 4);
					mapimage[index] = redval;
					mapimage[index + 1] = greenval;
					mapimage[index + 2] = blueval;
					mapimage[index + 3] = 255;
				}
			}

		}
	}

	gdImageDestroy(im);

	return(mapimage);

}




DisplayPNG(struct InstanceData* id, MAPLL *Mapcurnode, char *filename, GLfloat x1, GLfloat x2, GLfloat y1, GLfloat y2)
{
	int map_square_pixels = 0;
	GLubyte *mapimage;

	mapimage = LoadPNGMap(filename);

	glGenTextures(1, &Mapcurnode->maptexture);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Generated %s Texture: %d.\n", GetCurrentThreadId(), filename, Mapcurnode->maptexture);

	glBindTexture(GL_TEXTURE_2D, Mapcurnode->maptexture);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, CUSTOM_MAP_IMAGE_SIZE, CUSTOM_MAP_IMAGE_SIZE, 0, GL_RGBA,
		GL_UNSIGNED_BYTE, mapimage);
	if (map_square_pixels){
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	} else {
		/* Linear Filtering */
		/* produces a smoothed image, more accurate and realistic? */
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	}
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);


	free(mapimage);
	mapimage = NULL;

}



drawCustomMap(struct InstanceData* id, GLuint maptexture, GLfloat xloc, GLfloat yloc, GLfloat XSize, GLfloat YSize)
{
	static VO *AirVO, *DataVO;
	GLfloat params[4], overlap;

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);
	glBindTexture(GL_TEXTURE_2D, maptexture);

	/* solid with alpha masking */
	glEnable(GL_DEPTH_TEST);

	glDepthFunc(GL_LEQUAL);
	// glDepthFunc(GL_EQUAL);

	glPushMatrix();
	glLoadIdentity();


	// glTranslatef( (GLfloat) -140.0f,  (GLfloat) -10.0f, (GLfloat) trans[2] );
	glTranslatef((GLfloat)xloc, (GLfloat)yloc, (GLfloat)trans[2]);

	//params[0] = WxIntensity;
	//params[1] = WxIntensity;
	//params[2] = WxIntensity;
	params[0] = 1.0f;
	params[1] = 1.0f;
	params[2] = 1.0f;
	params[3] = 1.0f;

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
	//glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
	//glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

	glEnable(GL_TEXTURE_2D);
	glColor4f(MapIntensity, MapIntensity, MapIntensity, 1.0f);
	//glColor4f(0.0f, 0.0f, 0.0f, 1.0f);

	overlap = 0.0;
	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat)YSize + overlap, 0.0);
	glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)XSize + overlap, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)XSize + overlap, (GLfloat)YSize + overlap, 0.0);

	glEnd();

	glFlush();

	glPopMatrix();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
	return(SUCCEED);
}







/* function to reset our viewport after a window resize */
int resizeWindow(struct InstanceData* id, int width, int height)

{
	/* Height / width ratio */
	GLfloat ratio;
	double CurrentYSize, CurrentXSize;
	int pflag = 0;
	int buffer_y;
	const DWORD cdwThreadId = GetCurrentThreadId();

	if (width == 0 || height == 0){
		// window was closed, do nothing
		return(TRUE);
	}
	gui* oglgui = (gui*)id->m_poglgui;
	buffer_y = id->m_nHeight;
	
	wglMakeCurrent(id->m_hDC, id->m_hRCActive);

	id->m_dWidth = width;
	id->m_dHeight = height;
	id->m_nWidth = width;
	id->m_nHeight = height;

	id->m_nViewPortYOrig = 0;
	id->m_nViewPortXOrig = 0;
	id->m_nViewPortWidth = id->m_nWidth;
	id->m_nViewPortHeight = id->m_nHeight;

	/* Protect against a divide by zero */
	if (height == 0)
		height = 1;

	ratio = (GLfloat)width / (GLfloat)height;

	if (pflag) {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) width=%d height=%d ratio=%g\n",
			cdwThreadId, width, height, ratio);
	}

	/* change to the projection matrix and set our viewing volume. */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	glOrtho(0.0f, width, 0.0f, height, 0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	/* void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
	/ Defines a pixel rectangle in the window into which the final image is mapped. The (x, y) parameter specifies the lower-left corner
	/ of the viewport, and width and height are the size of the viewport rectangle. By default, the initial viewport values are
	/ (0, 0, winWidth, winHeight), where winWidth and winHeight are the size of the window. */

	/* Setup our viewport. */
	glViewport(0, 0, (GLsizei)width, (GLsizei)height);
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X):[%d] Setting GLViewport(%d, %d, %d, %d)\n", cdwThreadId, id->m_nControlId, 0, 0, width, height);

	if (pflag) {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Current Values: WorldXmax=%g WorldXmin=%g WorldXSize=%g WorldYmax=%g WorldYmin=%g WorldYSize=%g\n",
			cdwThreadId, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXSize, id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYSize);
	}

	/* make World Coordinates match aspect ratio of screen */
	if (id->m_sCurLayout.m_dWorldXSize > id->m_sCurLayout.m_dWorldYSize){
		CurrentYSize = id->m_sCurLayout.m_dWorldYSize;
		id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldXSize / ratio);
		id->m_sCurLayout.m_dWorldYmax = id->m_sCurLayout.m_dWorldYmin + id->m_sCurLayout.m_dWorldYSize;
	} else {
		CurrentXSize = id->m_sCurLayout.m_dWorldXSize;
		id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldYSize * ratio);
		id->m_sCurLayout.m_dWorldXmax = id->m_sCurLayout.m_dWorldXmin + id->m_sCurLayout.m_dWorldXSize;
	}

	if (pflag) {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) New Values: WorldXmax=%g WorldXmin=%g WorldXSize=%g WorldYmax=%g WorldYmin=%g WorldYSize=%g\n",
			cdwThreadId, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXSize, id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYSize);
	}

	// if window was redraw, we must reset gui's that are tied to GHeight, id->m_nWidth
	ResizeGUI(id, oglgui,buffer_y);
	id->m_poglgui = oglgui;
	return(TRUE);
}


void CALLBACK combineCallback(GLdouble coords[3], GLdouble *vertex_data[4],
	GLfloat weight[4], GLdouble **dataOut)
{

	GLdouble *vertex;

	vertex = (GLdouble *)malloc(3 * sizeof(GLdouble));
	vertex[0] = coords[0];
	vertex[1] = coords[1];
	vertex[2] = coords[2];

	*dataOut = vertex;
}

void CALLBACK combineCallbackORIG(GLdouble coords[3], GLdouble *vertex_data[4],
	GLfloat weight[4], GLdouble **dataOut)
{

	GLdouble *vertex;
	int i;


	vertex = (GLdouble *)malloc(6 * sizeof(GLdouble));
	vertex[0] = coords[0];
	vertex[1] = coords[1];
	vertex[2] = coords[2];

	for (i = 3; i < 6; i++){
		vertex[i] = weight[0] * vertex_data[0][i]
			+ weight[1] * vertex_data[1][i]
			+ weight[2] * vertex_data[2][i]
			+ weight[3] * vertex_data[3][i];
	}

	*dataOut = vertex;
}





drawPolys(struct InstanceData* id, int fill_type, GLenum mode, char *codestr)
{
	int pc;
	polylist *nextpoly;
	poly *newpoly;
	int clippolys = FALSE;  // the clipping check takes longer than just letting opengl do it, though not thorougly tested



	for (pc = 0, nextpoly = AllPolys; nextpoly; nextpoly = nextpoly->np, pc++){
		newpoly = nextpoly->poly;

		if (newpoly->showflag && (!clippolys || IsInRange(id, newpoly))){
			if (strstr(newpoly->polyname, "runway")){
				continue;
			}
			if (fill_type == LAKES_ONLY && !strstr(newpoly->polyname, "LAKES")){
				continue;
			}
			if (!strstr("ALL", codestr) && !strstr(newpoly->polyname, codestr)) {
				continue;  // not the file we are looking for
			}
			glColor3f((float)newpoly->red, (float)newpoly->green, (float)newpoly->blue);
			// glColor3f((float) polyred[i], (GLfloat) polygreen[i], (GLfloat) polyblue[i]);
			glCallList(newpoly->polylistcount);
		} else {
			// skipping
		}
	}


}


savecolorvertex(struct InstanceData* id, int size, int *countptr, GLfloat *buffer, char *code)
{
	int i;
	GLfloat fval[7];
	double lng, lat;

	for (i = 0; i < 7; i++){
		fval[i] = buffer[size - (*countptr)];
		(*countptr)--;
	}

	lng = (((double)fval[0] / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
	lat = (((double)fval[1] / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) \t%g %g %g %g %g %g %g\n",
		GetCurrentThreadId(), fval[0], fval[1], fval[2], fval[3], fval[4], fval[5], fval[6]);

	fprintf(savemapfile, "%g %g %s\n", lng, lat, code);

}




saveTess(struct InstanceData* id, int size, GLfloat *buffer, char *code)
{
	int i, pcount;
	GLint count;
	GLfloat token;
	const DWORD cdwThreadId = GetCurrentThreadId();

	count = size;


	while (count){
		token = buffer[size - count]; count--;

		if (token == GL_PASS_THROUGH_TOKEN){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GL_PASS_THROUGH_TOKEN= %g\n", cdwThreadId, buffer[size - count]);
			fprintf(savemapfile, "GL_PASS_THROUGH_TOKEN= %g\n", buffer[size - count]);
			count--;
		} else if ( token == GL_POINT_TOKEN ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GL_POINT_TOKEN\n", cdwThreadId);
			savecolorvertex(id, size, &count, buffer, code);
		} else if ( token == GL_LINE_TOKEN ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GL_LINE_TOKEN\n", cdwThreadId);
			savecolorvertex(id, size, &count, buffer, code);
			savecolorvertex(id, size, &count, buffer, code);
		} else if ( token == GL_LINE_RESET_TOKEN ){
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GL_LINE_RESET_TOKEN\n", cdwThreadId);
			savecolorvertex(id, size, &count, buffer, code);
			savecolorvertex(id, size, &count, buffer, code);
		} else if ( token == GL_POLYGON_TOKEN ){
			pcount = (int)buffer[size - count];
			count--;
			vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) GL_POLYGON_TOKEN count=%d\n", cdwThreadId, pcount);
			fprintf(savemapfile, "GL_POLYGON_TOKEN count=%d\n", pcount);
			for (i = 0; i < pcount; i++){
				savecolorvertex(id, size, &count, buffer, code);
			}
		}




	}

}


void DrawRasterString(struct InstanceData* id, int x, int y, GLfloat *fgcolor, char *textstr)
{
	glPushMatrix();
	glDisable(GL_DITHER);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glShadeModel(GL_FLAT);

	glLoadIdentity();

	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(trans[0], trans[1], trans[2]);
	glLineWidth(1);

	glColor3fv(fgcolor);

	glRasterPos2i(x, y);
	printString(textstr);
	glColor3fv(white);

	glFlush();
	glPopMatrix();

}



DrawTextureString(struct InstanceData* id, int x, int y, int pixheight, GLfloat *fgcolor, char *textstr)
{
	char *str;
	int width, ascent, descent;
	GLfloat fx, fy, XScale, YScale;
	static int loaded;

	glPushMatrix();
	glColor3f(1.0, 1.0, 1.0); /* white line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0, id->m_nWidth, 0, id->m_nHeight, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);

#ifdef OLDWAY
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_BLEND);
	glEnable(GL_ALPHA_TEST);
	glAlphaFunc(GL_GEQUAL, 0.2);
#endif

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	if (!loaded){
		txfEstablishTexture(id, txf, 0, GL_TRUE);
		loaded = TRUE;
	}
	str = textstr;

	txfGetStringMetrics(txf, str, strlen(str),
		&width, &ascent, &descent);

	glColor3fv(fgcolor);
	fx = (GLfloat)x;
	fy = (GLfloat)y;

	glTranslatef(fx, fy, trans[2]);
	glDisable(GL_DEPTH_TEST);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);


	XScale = ((float)pixheight / ascent);
	YScale = ((float)pixheight / ascent);

	glScalef(XScale, YScale, 1.0);
	txfRenderFancyString(txf, str, strlen(str));


	glPopMatrix();
}



int PixOnScreen(struct InstanceData* id, int xpixel, int ypixel)
{
	if(0.0f != id->m_glfRotateAngle){
		RotateScreenPoint(id, id->m_nWidth/2, id->m_nHeight/2, &xpixel, &ypixel);
	}

	if (xpixel < 0 || xpixel > id->m_nWidth ||
		ypixel < 0 || ypixel > id->m_nHeight){
		return(FALSE);
	}
	return(TRUE);
}



void DrawPoly(struct InstanceData* id, poly *BestPoly)
{
	GLfloat x, y;
	poly *newpoly;
	points *np;
	int count, totcount = 0;
	GLfloat xplotmin = 9.9E20f, xplotmax = -9.9E20f, yplotmin = 9.9E20f, yplotmax = -9.9E20f;

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
	glPushMatrix();
	glLoadIdentity();

	glColor3f(0.0, 0.0, 0.0); /* line */

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	glTranslatef(trans[0], trans[1], trans[2]);
	/* glTranslatef(0.0, 0.0, 0.0 ); */
	glLineWidth(1);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);


	newpoly = BestPoly;
	glBegin(GL_LINE_STRIP);
	glColor3f(1.0, 0.0, 0.0);
	for (np = newpoly->ppoints, count = 0; np; np = np->np, count++){
		/* printf("polyid='%s', point[%d] x=%1.9f, y=%1.9f\n", newpoly->polyname, count, np->x, np->y ); */
		//x = (float) np->x;
		//y = (float) np->y;
		x = (float)np->vt[0];
		y = (float)np->vt[1];

		glVertex3f(x, y, 0.0);
	}
	glEnd();
	glFlush();


	glPopMatrix();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);
}


DrawClosestPoly(struct InstanceData* id)
{
	int pc;
	polylist *nextpoly;
	poly *newpoly = NULL;
	static poly *BestPoly = NULL;
	static int pcbest;
	double dx, dy, dis, mindis = 9.0e30, lat, lng, x, y;
	points *np;
	static int prevmousex, prevmousey;
	char tmpstr[TMPBUF_SIZE];

	if (BestPoly && prevmousex == id->m_nMouseX && prevmousey == id->m_nMouseY){
		/* already found closest */
		DrawPoly(id, BestPoly);
	}

	for (pc = 0, nextpoly = AllPolys; nextpoly; nextpoly = nextpoly->np, pc++){
		newpoly = nextpoly->poly;
		/* draw a line between all of the points */

		for (np = newpoly->ppoints; np; np = np->np){
			/* printf("polyid='%s', point[%d] x=%1.9f, y=%1.9f\n", newpoly->polyname, count, np->x, np->y ); */
			//x = (float) np->x;
			//y = (float) np->y;
			x = (float)np->vt[0];
			y = (float)np->vt[1];

			lng = (((double)id->m_nMouseX / id->m_nWidth) * (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin)) + id->m_sCurLayout.m_dWorldXmin;
			lat = (((double)id->m_nMouseY / id->m_nHeight) * (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin)) + id->m_sCurLayout.m_dWorldYmin;

			dy = y - lat;
			dx = x - lng;
			dis = sqrt((dx * dx) + (dy * dy));

			if (dis < mindis){
				mindis = dis;
				BestPoly = newpoly;
				pcbest = pc;
			}
		}

	}

	if (BestPoly){
		/* draw the selected polygon in red */
		DrawPoly(id, BestPoly);
		MGLGridText(id, statusgrid, 22, 0, "polyname");
		sprintf_s(tmpstr, TMPBUF_SIZE, "%s, count=%d", BestPoly->polyname, BestPoly->count);
		MGLGridText(id, statusgrid, 22, 1, tmpstr);
	}


}



void drawImage(struct InstanceData* id, GLbyte *mapimage, GLfloat xloc, GLfloat yloc)
{
	double XSize, YSize;
	GLfloat xmapscale, ymapscale;
	double xmove, ymove;
	int UseMove = FALSE;
	int newxpixels, xmapsize, ymapsize;

	glLoadIdentity();
	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	XSize = 40.0;
	YSize = 50.0;

	xmove = 0.0;
	ymove = 0.0;
	yloc = (GLfloat)(yloc + YSize);
	if (xloc < id->m_sCurLayout.m_dWorldXmin){
		// if the initial position is outside the view volume, then the entire image will be clipped
		xmove = xloc - id->m_sCurLayout.m_dWorldXmin;
		newxpixels = (int)rint((id->m_sCurLayout.m_dWorldXmin - xloc) / id->m_sCurLayout.m_dWorldXSize * id->m_nWidth);
		xloc = (GLfloat)id->m_sCurLayout.m_dWorldXmin;

		UseMove = TRUE;
	}
	if (yloc > id->m_sCurLayout.m_dWorldYmax){
		ymove = id->m_sCurLayout.m_dWorldYmax - yloc;
		yloc = (GLfloat)id->m_sCurLayout.m_dWorldYmax;
		UseMove = TRUE;
	}

	xmapsize = MAP_IMAGE_SIZE;
	ymapsize = MAP_IMAGE_SIZE;
	if (UseMove){
		glPixelStorei(GL_PACK_SKIP_PIXELS, newxpixels);
		glPixelStorei(GL_PACK_ROW_LENGTH, MAP_IMAGE_SIZE - newxpixels);

		xmapsize = MAP_IMAGE_SIZE - newxpixels;
		glPixelStorei(GL_PACK_SKIP_ROWS, 0);
	}

	glRasterPos2f(xloc, yloc);



	xmapscale = (GLfloat)((XSize * id->m_nWidth) / (id->m_sCurLayout.m_dWorldXSize * xmapsize));
	ymapscale = (GLfloat)((YSize * id->m_nHeight) / (id->m_sCurLayout.m_dWorldYSize * MAP_IMAGE_SIZE));

	glPixelZoom(xmapscale, -ymapscale);

	glDrawPixels(MAP_IMAGE_SIZE, MAP_IMAGE_SIZE, GL_RGBA, GL_UNSIGNED_BYTE, mapimage);

	glFlush();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

}



int RectanglesOverlap(double ax1, double ay1, double ax2, double ay2,
	double bx1, double by1, double bx2, double by2)
{


	if (ay2 < by1){
		return(0);
	}

	if (ay1 > by2){
		return(0);
	}

	if (ax2 < bx1){
		return(0);
	}

	if (ax1 > bx2){
		return(0);
	}

	return(1);

}



void DispTexImage(struct InstanceData* id, GLubyte *demimage, GLfloat longitude, GLfloat latitude, GLfloat XSize, GLfloat YSize)
{
	GLfloat end_long, end_lat;
	int pflag = 0;


	/* find out what part of this image is in the main image map */

	end_long = longitude + XSize;
	end_lat = latitude + YSize;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) long=%g latitude=%g end_long=%g end_lat=%g",
			GetCurrentThreadId(), longitude, latitude, end_long, end_lat);
	}





}




void AddImageOLD(struct InstanceData* id, GLubyte *mapimage, GLubyte *demimage, GLfloat longitude, GLfloat latitude, int src_map_image_size)
{
	GLfloat end_long, end_lat, lat, lng, xpixsize_dest, ypixsize_dest;
	int y, x, xpix_src, ypix_src, sourceindex, index;
	GLfloat XSize, YSize;
	int sourcesize, mapsize;
	int pflag = 0;
	const DWORD cdwThreadId = GetCurrentThreadId();


	XSize = 40.0;
	YSize = 50.0;


	/* find out what part of this image is in the main image map */

	end_long = longitude + XSize;
	end_lat = latitude + YSize;

	if (pflag){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) long=%g latitude=%g end_long=%g end_lat=%g",
			cdwThreadId, longitude, latitude, end_long, end_lat);
	}

	if (RectanglesOverlap(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldYmax,
		longitude, latitude, end_long, end_lat)){
		// overlaps
	} else {
		// does not intersect, so skip this pane
		return;
	}

	xpixsize_dest = (GLfloat)(id->m_sCurLayout.m_dWorldXSize / id->m_nWidth);
	ypixsize_dest = (GLfloat)(id->m_sCurLayout.m_dWorldYSize / id->m_nHeight);


	sourcesize = src_map_image_size * src_map_image_size * 4;
	mapsize = id->m_nWidth * id->m_nHeight * 4;

	// go through each pixel in the output image mapimage[][], and place appropriate value from dem source demimage

	for (y = 0; y < id->m_nHeight; y++){

		lat = (GLfloat)(id->m_sCurLayout.m_dWorldYmin + (y * ypixsize_dest));

		if (lat < latitude){
			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) before y range of source lat=%g end_lat=%g startlatitude=%g\n",
					cdwThreadId, lat, end_lat, latitude);
			}
			// not in y range of the source image yet
			continue;
		}

		if (lat >= end_lat){
			if (pflag){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) beyond y range of source lat=%g end_lat=%g startlatitude=%g\n",
					cdwThreadId, lat, end_lat, latitude);
			}
			break; // beyond y range of source
		}

		for (x = 0; x < id->m_nWidth; x++){
			lng = (GLfloat)(id->m_sCurLayout.m_dWorldXmin + (x * xpixsize_dest));

			if (lng < longitude){
				// long not in range of source yet
				continue;
			}
			if (lng >= end_long){
				break;
			}

			xpix_src = (int)rint(((lng - longitude) / XSize) * src_map_image_size);
			ypix_src = (int)rint(((lat - latitude) / YSize)  * src_map_image_size);

			if (xpix_src < 0 || ypix_src < 0) continue;

			sourceindex = ((src_map_image_size - ypix_src - 1) * src_map_image_size * 4) + (xpix_src * 4);
			if (sourceindex < 0 || sourceindex > sourcesize){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad sourceindex=%d\n", cdwThreadId, sourceindex);
				break;
			}
			index = (y * id->m_nWidth * 4) + (x * 4);
			if (index < 0 || index > mapsize - 3){
				if (pflag) vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) bad index=%d\n", cdwThreadId, index);
				continue;
			}
			mapimage[index] = demimage[sourceindex];
			mapimage[index + 1] = demimage[sourceindex + 1];
			mapimage[index + 2] = demimage[sourceindex + 2];
			mapimage[index + 3] = demimage[sourceindex + 3]; // alpha

			if (pflag  && y % 10 == 0){
				vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) map[%d][%d] src[%d][%d] (i=%d) si=%d lat=%g lng=%g r=%d g=%d b=%d a=%d\n",
					cdwThreadId, y, x, xpix_src, ypix_src, index, sourceindex,
					lat, lng, mapimage[index], mapimage[index + 1], mapimage[index + 2], mapimage[index + 3]);
			}

		}
	}


}





drawTerrainImage(struct InstanceData* id, GLubyte *mapimage)
{

	glLoadIdentity();
	glColor3f(1.0f, 1.0f, 1.0f); /* white line */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);


	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_EQUAL);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();


	glRasterPos2f((GLfloat)id->m_sCurLayout.m_dWorldXmin, (GLfloat)id->m_sCurLayout.m_dWorldYmin);

	glPixelZoom(1.0, 1.0);
	glDrawPixels((GLsizei)id->m_nWidth, (GLsizei)id->m_nHeight, (GLenum)GL_RGBA, (GLenum)GL_UNSIGNED_BYTE,
		(const GLvoid *)mapimage);

	glFlush();

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

}



QueryOpenGL()
{

	int redbits, greenbits, bluebits, alphabits;
	GLboolean b;

	glGetIntegerv(GL_RED_BITS, &redbits);
	glGetIntegerv(GL_GREEN_BITS, &greenbits);
	glGetIntegerv(GL_BLUE_BITS, &bluebits);
	glGetIntegerv(GL_ALPHA_BITS, &alphabits);

	glGetBooleanv(GL_DOUBLEBUFFER, &b);

}




drawMap(struct InstanceData* id, GLuint maptexture, GLfloat xloc, GLfloat yloc)
{
	// static VO *AirVO, *DataVO;
	double XSize, YSize;
	GLfloat params[4], overlap;

	/* reset the color to white so textures will appear */
	glColor3f(1.0, 1.0, 1.0);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	/* glortho (left, right, bottom , top, near, far ) */
	/* glOrtho(0.0f, w, 0.0f, h, 0.0f, 1.0f); */
	glOrtho(id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldXmax,
		id->m_sCurLayout.m_dWorldYmin, id->m_sCurLayout.m_dWorldYmax,
		0.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glEnable(GL_TEXTURE_2D);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPEAT);
	glBindTexture(GL_TEXTURE_2D, maptexture);

	/* solid with alpha masking */
	glEnable(GL_DEPTH_TEST);


	// glDepthFunc(GL_LEQUAL);
	// glDepthFunc(GL_NOTEQUAL);
	glDepthFunc(GL_EQUAL);
	// glDepthFunc(GL_GREATER);


	glPushMatrix();
	glLoadIdentity();


	// glTranslatef( (GLfloat) -140.0f,  (GLfloat) -10.0f, (GLfloat) trans[2] );
	glTranslatef((GLfloat)xloc, (GLfloat)yloc, (GLfloat)trans[2]);


	XSize = 40.0;
	YSize = 50.0;

	//params[0] = WxIntensity;
	//params[1] = WxIntensity;
	//params[2] = WxIntensity;


	//QueryOpenGL();

	params[0] = 1.0f;
	params[1] = 1.0f;
	params[2] = 1.0f;
	params[3] = 1.0f;

	glEnable(GL_BLEND);
	// glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	//glBlendColor(0.0f, 0.0f, 0.0f, 0.0f);

	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	// test code

	//glEnable( GL_ALPHA_TEST );
	//glAlphaFunc( GL_GREATER, 0.8f );
	// end test code


	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND);
	//glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
	//glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, params);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

	glEnable(GL_TEXTURE_2D);
	glColor4f(MapIntensity, MapIntensity, MapIntensity, 1.0f);
	//glColor4f(0.0f, 0.0f, 0.0f, 1.0f);

	overlap = 0.0;
	glBegin(GL_QUADS);
	glTexCoord2f(0.0f, 0.0f); glVertex3f((GLfloat) 0.0f, (GLfloat)YSize + overlap, 0.0);
	glTexCoord2f(0.0f, 1.0f); glVertex3f((GLfloat) 0.0f, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 1.0f); glVertex3f((GLfloat)XSize + overlap, (GLfloat) 0.0, 0.0);
	glTexCoord2f(1.0f, 0.0f); glVertex3f((GLfloat)XSize + overlap, (GLfloat)YSize + overlap, 0.0);

	glEnd();

	glFlush();

	glPopMatrix();

	glDisable(GL_TEXTURE_ENV);
	glDisable(GL_TEXTURE_2D);
	glDisable(GL_ALPHA_TEST);
	glEnable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
	return(SUCCEED);
}


GLubyte *LoadZipImage(struct InstanceData* id, char *zipfilename, int saveprev)
{
	struct _stat buf;
	int result;
	int zipbufsize, nbytes;
	char *zipbuf = NULL;
	FILE *zipfile;
	const DWORD cdwThreadId = GetCurrentThreadId();
	static char prevzipfilename[128];
	static char *outbufptr;

	if (saveprev){
		if (!strcmp(zipfilename, prevzipfilename)){
			return(outbufptr);
		}


		strncpy_s(prevzipfilename, _countof(prevzipfilename), zipfilename, 127);
		prevzipfilename[127] = '\0';

		if (outbufptr){
			free(outbufptr);
			outbufptr = NULL;
		}
	}

	if (fopen_s(&zipfile, zipfilename, "rb")){
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open %s\n", cdwThreadId, zipfilename);
		return(NULL);
	}

	result = _stat(zipfilename, &buf);
	zipbufsize = buf.st_size;
	zipbuf = malloc(zipbufsize);

	if (!(nbytes = fread(zipbuf, 1, zipbufsize, zipfile))){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Empty file found\n", cdwThreadId);
		return(NULL);
	}

	fclose(zipfile);

	if ((nbytes = imunzip(zipfilename, zipbuf, zipbufsize, &outbufptr)) <= 0){
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) failed\n", cdwThreadId);
		return(NULL);
	}

	free(zipbuf);

	return(outbufptr);

}




int SaveImage(struct InstanceData* id, GLubyte *mapimage, int nbytes, char *filename)
{

	FILE *f;
	int cnt;

	if (!filename || !nbytes){
		return(FALSE);
	}

	if (!fopen_s(&f, filename, "wb")){
		cnt = fwrite(mapimage, 1, nbytes, f);
	} else {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Could not open %s for writing\n", GetCurrentThreadId(), filename);
	}
	fclose(f);

	return(TRUE);
}



void ImgChangeColorAlpha(GLubyte *mapimage, int ncols, int nrows, int r, int g, int b, int alpha,
	int bg_red, int bg_green, int bg_blue)
{
	int npixels, i, index;

	npixels = ncols * nrows;

	for (i = 0; i < npixels; i++){
		index = i * 4;
		if (mapimage[index] == r &&
			mapimage[index + 1] == g &&
			mapimage[index + 2] == b)
		{
			// matches target color
			mapimage[index + 3] = alpha;
			mapimage[index] = bg_red;  // even if alpha is zero, these colors will still be used in linear filter
			mapimage[index + 1] = bg_green;
			mapimage[index + 2] = bg_blue;
		}
	}


}

MoveCmd(struct InstanceData* id, char *linebuf)
{
	char *str;
	int i, c;
	char cmdbuf[64];

	str = &linebuf[9];

	i = 0;
	while ((c = *str++) != '\0' && c != '\n'){
		cmdbuf[i++] = c;
	}
	cmdbuf[i] = '\0';

	if (!strcasecmp(cmdbuf, "N")){
		MoveUp(id);
	} else if ( !strcasecmp(cmdbuf, "S") ){
		MoveDown(id);
	} else if ( !strcasecmp(cmdbuf, "E") ){
		MoveRight(id);
	} else if ( !strcasecmp(cmdbuf, "W") ){
		MoveLeft(id);
	} else if ( !strcasecmp(cmdbuf, "NW") ){
		MoveUp(id);
		MoveLeft(id);
	} else if ( !strcasecmp(cmdbuf, "SW") ){
		MoveDown(id);
		MoveLeft(id);
	} else if ( !strcasecmp(cmdbuf, "NE") ){
		MoveUp(id);
		MoveRight(id);
	} else if ( !strcasecmp(cmdbuf, "SE") ){
		MoveDown(id);
		MoveRight(id);
	} else {
		vo_log_error(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Unrecognized command '%d'\n",
			GetCurrentThreadId(), linebuf);
	}

}


void ResizeWorld(struct InstanceData* id, double x, double y, double NewXSize)
{
	double xlen, ylen;
	/* Only more the window if the x,y value is not on the screen currently */
	/* Move the window view so that x, y, is at the center of the FOV */

	/* zoom in on selected area */
	/* calculate new ranges to make x, y the center */

	xlen = NewXSize;

	ylen = (xlen * id->m_nHeight) / id->m_nWidth;

	id->m_sCurLayout.m_dWorldYmin = y - (ylen / 2.0);
	id->m_sCurLayout.m_dWorldYmax = y + (ylen / 2.0);

	id->m_sCurLayout.m_dWorldXmin = x - (xlen / 2.0);
	id->m_sCurLayout.m_dWorldXmax = x + (xlen / 2.0);

	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);

	id->m_bClearScreen = TRUE;
	// CkGmap(id);
}



void TranslateView(struct InstanceData* id, float x, float y)
{

	/* Only more the window if the x,y value is not on the screen currently */
	/* Move the window view so that x, y, is at the center of the FOV */

	if (x >= id->m_sCurLayout.m_dWorldXmin && x <= id->m_sCurLayout.m_dWorldXmax && y >= id->m_sCurLayout.m_dWorldYmin && y <= id->m_sCurLayout.m_dWorldYmax){
		// already on the screen
		return;
	}

	/* calculate new ranges to make x, y the center */

	id->m_sCurLayout.m_dWorldXmin = x - (id->m_sCurLayout.m_dWorldXSize / 2.0);
	id->m_sCurLayout.m_dWorldXmax = id->m_sCurLayout.m_dWorldXmin + id->m_sCurLayout.m_dWorldXSize;


	id->m_sCurLayout.m_dWorldYmin = y - (id->m_sCurLayout.m_dWorldYSize / 2.0);
	id->m_sCurLayout.m_dWorldYmax = id->m_sCurLayout.m_dWorldYmin + id->m_sCurLayout.m_dWorldYSize;

	id->m_bClearScreen = TRUE;
	// CkGmap(id);
}




/*
* Convert a surface into one suitable as an OpenGL texture;
* in RGBA format if want_alpha is nonzero, or in RGB format otherwise.
*
* The surface may have a colourkey, which is then translated to an alpha
* channel if RGBA is desired.
*
* Return the resulting texture, or NULL on error. The original surface is
* always freed.
*/
#ifdef USE_SDL
SDL_Surface *conv_surf_gl(SDL_Surface *s, int want_alpha)
{
	Uint32 rmask, gmask, bmask, amask;
	SDL_Surface *conv;
	int bpp = want_alpha ? 32 : 24;

	/* SDL interprets each pixel as a 24 or 32-bit number, so our
	masks must depend on the endianness (byte order) of the
	machine. */
#if SDL_BYTEORDER == SDL_BIG_ENDIAN
	rmask = 0xff000000 >> (32 - bpp);
	gmask = 0x00ff0000 >> (32 - bpp);
	bmask = 0x0000ff00 >> (32 - bpp);
	amask = 0x000000ff >> (32 - bpp);
#else
	rmask = 0x000000ff;
	gmask = 0x0000ff00;
	bmask = 0x00ff0000;
	amask = want_alpha ? 0xff000000 : 0;
#endif

	/* check if the surface happens to be in the right format */
	if(s->format->BitsPerPixel == bpp
		&& s->format->Rmask == rmask
		&& s->format->Gmask == gmask
		&& s->format->Bmask == bmask
		&& s->format->Amask == amask
		&& !(s->flags & SDL_SRCCOLORKEY)) {
		/* no conversion needed */
		return s;
	}

	/* wrong format, conversion necessary */

	/* SDL surfaces are created with lines padded to start at 32-bit boundaries
	which suits OpenGL well (as long as GL_UNPACK_ALIGNMENT remains
	unchanged from its initial value of 4) */
	conv = SDL_CreateRGBSurface(SDL_SWSURFACE, s->w, s->h, bpp,
		rmask, gmask, bmask, amask);
	if(!conv) {
		SDL_FreeSurface(conv);
		return NULL;
	}

	if(want_alpha) {
		/* SDL sets the SDL_SRCALPHA flag on all surfaces with an
		alpha channel. We need to clear that flag for the copy,
		since SDL would attempt to alpha-blend our image otherwise */
		SDL_SetAlpha(s, 0, 255);
	}

	/*
	* Do the conversion. If the source surface has a colourkey, then it
	* will be used in the blit. We use the fact that newly created software
	* surfaces are zero-filled, so the pixels not blitted will remain
	* transparent.
	*/
	if(SDL_BlitSurface(s, NULL, conv, NULL) < 0) {
		/* blit error */
		SDL_FreeSurface(conv);
		conv = NULL;
	}
	SDL_FreeSurface(s);

	return conv;
}

#endif

/*
* A sample use of conv_surf_gl():
*
* Load an image from a file, and convert it to RGB or RGBA format,
* depending on the image.
*
* Return the resulting surface, or NULL on error
*/
#ifdef USE_SDL
SDL_Surface *load_gl_texture(char *file)
{
	SDL_Surface *s = IMG_Load(file);


	/* s = IMG_Load("C:/cygwin/home/matt/lga512x512.gif"); */
	/* s = IMG_Load("C:\\cygwin\\home\\matt\\lga512x512.gif"); */

	if(!s)
		return NULL;
	return conv_surf_gl(s, s->format->Amask || (s->flags & SDL_SRCCOLORKEY));
}
#endif




DefCreateFont(struct InstanceData* id)
{
	/* txf = txfLoadFont("default.txf"); */

	/* txf = txfLoadFont("adobe-courier-bold.txf"); */
	/* txf = txfLoadFont("courier18.txf"); */
	/* txf = txfLoadFont("adobe-times-medium.txf"); */
	/* txf = txfLoadFont("courier24-normal.txf"); */
	/* txf = txfLoadFont("adobenewcentury-bold-r-normal24.txf"); */
	const char filename[] = "adobe-helvetica-bold-240Large.txf";
	char fontfile[TMPBUF_SIZE];
	const DWORD cdwThreadId = GetCurrentThreadId();
	sprintf_s(fontfile, TMPBUF_SIZE, "%s%s", id->m_strFontDir, filename);
	if (!GetLocalFile(id, id->m_strFontDir, filename, id->m_strHttpFontPath, SM_HTTPS))
	{
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Problem accessing %s\n", cdwThreadId, fontfile);
		return (FALSE);
	}
	txf = txfLoadFont(fontfile);

	if (txf == NULL) {
		vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) Problem loading %s, %s\n", cdwThreadId, fontfile, txfErrorString());
		return (FALSE);
	}

	glMatrixMode(GL_MODELVIEW);
	glEnable(GL_TEXTURE_2D);
	glEnable(GL_DEPTH_TEST);
	glDisable(GL_BLEND);
	glEnable(GL_ALPHA_TEST);
	glAlphaFunc(GL_GEQUAL, 0.5);
#ifdef OLDWAY
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
#endif
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	txfEstablishTexture(id, txf, 0, GL_TRUE);

	return (TRUE);
}





void MoveLeft(struct InstanceData* id)
{
	double xrange;

	xrange = id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin;
	id->m_sCurLayout.m_dWorldXmin -= xrange * 0.05;
	id->m_sCurLayout.m_dWorldXmax -= xrange * 0.05;
	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
	/* printf("\nchanging World xmin=%g xmax=%g ymin=%g ymax=%g\n",
	WorldXmin, WorldXmax, WorldYmin, WorldYmax ); */
	id->m_bClearScreen = TRUE;

	// CkGmap(id);

}



void MoveRight(struct InstanceData* id)
{
	double xrange;


	xrange = id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin;
	id->m_sCurLayout.m_dWorldXmin += xrange * 0.05;
	id->m_sCurLayout.m_dWorldXmax += xrange * 0.05;
	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);
	/* printf("\nchanging World xmin=%g xmax=%g ymin=%g ymax=%g\n",
	WorldXmin, WorldXmax, WorldYmin, WorldYmax ); */
	id->m_bClearScreen = TRUE;

	// CkGmap(id);

}




void PrevWorldCoordinates(struct InstanceData* id)
{
	const DWORD cdwThreadId = GetCurrentThreadId();
	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) PrevWorldIndex=%d LastWorldIndex=%d\n", cdwThreadId, PrevWorldIndex, LastWorldIndex);

	PrevWorldIndex--;
	if (PrevWorldIndex < 0){
		PrevWorldIndex = LastWorldIndex - 1;  // go back one from last location
	}
	if (PrevWorldIndex < 0 || PrevWorldIndex >= NUM_PREV_LOCATIONS){
		ShowMyMessage("No previous locations saved", 3);
		return;
	}
	id->m_sCurLayout.m_dWorldXmax = PrevWorldXmax[PrevWorldIndex];
	id->m_sCurLayout.m_dWorldXmin = PrevWorldXmin[PrevWorldIndex];
	id->m_sCurLayout.m_dWorldYmax = PrevWorldYmax[PrevWorldIndex];
	id->m_sCurLayout.m_dWorldYmin = PrevWorldYmin[PrevWorldIndex];

	id->m_sCurLayout.m_dWorldYSize = (id->m_sCurLayout.m_dWorldYmax - id->m_sCurLayout.m_dWorldYmin);
	id->m_sCurLayout.m_dWorldXSize = (id->m_sCurLayout.m_dWorldXmax - id->m_sCurLayout.m_dWorldXmin);

	vo_log_info(id->m_pfVoLogFile, __FUNCTION__, "(0x%X) PrevWorldIndex=%d WorldXmax=%g WorldXmin=%g WorldYmax=%g WorldYmin=%g\n",
		cdwThreadId, PrevWorldIndex, id->m_sCurLayout.m_dWorldXmax, id->m_sCurLayout.m_dWorldXmin, id->m_sCurLayout.m_dWorldYmax, id->m_sCurLayout.m_dWorldYmin);
	id->m_bClearScreen = TRUE;
	ForceRefresh = TRUE;

	//if ( Gmapimage ){
	//  free( Gmapimage );
	//  Gmapimage = NULL;
	//}

}


int check_exist_file(filename)
const char* filename;
{
	FILE* ftestexist;
	int ret = 1;
	fopen_s(&ftestexist, filename, "rb");
	if (ftestexist == NULL)
		ret = 0;
	else
		fclose(ftestexist);
	return ret;
}
